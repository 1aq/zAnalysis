{ Fast KDTree Double Type support                                                }
{ ****************************************************************************** }
{ * fast KDTree Support,writen by QQ 600585@qq.com                             * }
{ * https://github.com/PassByYou888/CoreCipher                                 * }
{ * https://github.com/PassByYou888/ZServer4D                                  * }
{ * https://github.com/PassByYou888/zExpression                                * }
{ * https://github.com/PassByYou888/zTranslate                                 * }
{ * https://github.com/PassByYou888/zSound                                     * }
{ * https://github.com/PassByYou888/zAnalysis                                  * }
{ ****************************************************************************** }

unit FastKDTreeE;

interface

uses CoreClasses, KM;

{$I zDefine.inc}

{$IFDEF FPC}
{$DEFINE DEBUG}
{$ENDIF FPC}

const

  // extended float: KDTree
  KDT1DE_Axis = 1;
  KDT2DE_Axis = 2;
  KDT3DE_Axis = 3;
  KDT4DE_Axis = 4;
  KDT5DE_Axis = 5;
  KDT6DE_Axis = 6;
  KDT7DE_Axis = 7;
  KDT8DE_Axis = 8;
  KDT9DE_Axis = 9;
  KDT10DE_Axis = 10;
  KDT11DE_Axis = 11;
  KDT12DE_Axis = 12;
  KDT13DE_Axis = 13;
  KDT14DE_Axis = 14;
  KDT15DE_Axis = 15;
  KDT16DE_Axis = 16;
  KDT17DE_Axis = 17;
  KDT18DE_Axis = 18;
  KDT19DE_Axis = 19;
  KDT20DE_Axis = 20;
  KDT21DE_Axis = 21;
  KDT22DE_Axis = 22;
  KDT23DE_Axis = 23;
  KDT24DE_Axis = 24;
  KDT25DE_Axis = 25;
  KDT26DE_Axis = 26;
  KDT27DE_Axis = 27;
  KDT28DE_Axis = 28;
  KDT29DE_Axis = 29;
  KDT30DE_Axis = 30;
  KDT31DE_Axis = 31;
  KDT32DE_Axis = 32;
  KDT33DE_Axis = 33;
  KDT34DE_Axis = 34;
  KDT35DE_Axis = 35;
  KDT36DE_Axis = 36;
  KDT37DE_Axis = 37;
  KDT38DE_Axis = 38;
  KDT39DE_Axis = 39;
  KDT40DE_Axis = 40;
  KDT41DE_Axis = 41;
  KDT42DE_Axis = 42;
  KDT43DE_Axis = 43;
  KDT44DE_Axis = 44;
  KDT45DE_Axis = 45;
  KDT46DE_Axis = 46;
  KDT47DE_Axis = 47;
  KDT48DE_Axis = 48;
  KDT49DE_Axis = 49;
  KDT50DE_Axis = 50;
  KDT51DE_Axis = 51;
  KDT52DE_Axis = 52;
  KDT53DE_Axis = 53;
  KDT54DE_Axis = 54;
  KDT55DE_Axis = 55;
  KDT56DE_Axis = 56;
  KDT57DE_Axis = 57;
  KDT58DE_Axis = 58;
  KDT59DE_Axis = 59;
  KDT60DE_Axis = 60;
  KDT61DE_Axis = 61;
  KDT62DE_Axis = 62;
  KDT63DE_Axis = 63;
  KDT64DE_Axis = 64;
  KDT65DE_Axis = 65;
  KDT66DE_Axis = 66;
  KDT67DE_Axis = 67;
  KDT68DE_Axis = 68;
  KDT69DE_Axis = 69;
  KDT70DE_Axis = 70;
  KDT71DE_Axis = 71;
  KDT72DE_Axis = 72;
  KDT84DE_Axis = 84;
  KDT96DE_Axis = 96;
  KDT128DE_Axis = 128;
  KDT140DE_Axis = 140;
  KDT160DE_Axis = 160;
  KDT196DE_Axis = 196;
  KDT256DE_Axis = 256;
  KDT272DE_Axis = 272;
  KDT288DE_Axis = 288;
  KDT372DE_Axis = 372;
  KDT512DE_Axis = 512;
  KDT576DE_Axis = 576;
  KDT768DE_Axis = 768;
  KDT1024DE_Axis = 1024;
  KDT1040DE_Axis = 1040;
  KDT1056DE_Axis = 1056;
  KDT1536DE_Axis = 1536;
  KDT1920DE_Axis = 1920;
  KDT1980DE_Axis = 1980;
  KDT2048DE_Axis = 2048;
  KDT3072DE_Axis = 3072;
  KDT3088DE_Axis = 3088;
  KDT3104DE_Axis = 3104;
  KDT4096DE_Axis = 4096;
  KDT8192DE_Axis = 8192;

type

  // extended float: KDTree
  TKDT1DE = class; TKDT1DE_VecType = Extended; // 1D
  TKDT2DE = class; TKDT2DE_VecType = Extended; // 2D
  TKDT3DE = class; TKDT3DE_VecType = Extended; // 3D
  TKDT4DE = class; TKDT4DE_VecType = Extended; // 4D
  TKDT5DE = class; TKDT5DE_VecType = Extended; // 5D
  TKDT6DE = class; TKDT6DE_VecType = Extended; // 6D
  TKDT7DE = class; TKDT7DE_VecType = Extended; // 7D
  TKDT8DE = class; TKDT8DE_VecType = Extended; // 8D
  TKDT9DE = class; TKDT9DE_VecType = Extended; // 9D
  TKDT10DE = class; TKDT10DE_VecType = Extended; // 10D
  TKDT11DE = class; TKDT11DE_VecType = Extended; // 11D
  TKDT12DE = class; TKDT12DE_VecType = Extended; // 12D
  TKDT13DE = class; TKDT13DE_VecType = Extended; // 13D
  TKDT14DE = class; TKDT14DE_VecType = Extended; // 14D
  TKDT15DE = class; TKDT15DE_VecType = Extended; // 15D
  TKDT16DE = class; TKDT16DE_VecType = Extended; // 16D
  TKDT17DE = class; TKDT17DE_VecType = Extended; // 17D
  TKDT18DE = class; TKDT18DE_VecType = Extended; // 18D
  TKDT19DE = class; TKDT19DE_VecType = Extended; // 19D
  TKDT20DE = class; TKDT20DE_VecType = Extended; // 20D
  TKDT21DE = class; TKDT21DE_VecType = Extended; // 21D
  TKDT22DE = class; TKDT22DE_VecType = Extended; // 22D
  TKDT23DE = class; TKDT23DE_VecType = Extended; // 23D
  TKDT24DE = class; TKDT24DE_VecType = Extended; // 24D
  TKDT25DE = class; TKDT25DE_VecType = Extended; // 25D
  TKDT26DE = class; TKDT26DE_VecType = Extended; // 26D
  TKDT27DE = class; TKDT27DE_VecType = Extended; // 27D
  TKDT28DE = class; TKDT28DE_VecType = Extended; // 28D
  TKDT29DE = class; TKDT29DE_VecType = Extended; // 29D
  TKDT30DE = class; TKDT30DE_VecType = Extended; // 30D
  TKDT31DE = class; TKDT31DE_VecType = Extended; // 31D
  TKDT32DE = class; TKDT32DE_VecType = Extended; // 32D
  TKDT33DE = class; TKDT33DE_VecType = Extended; // 33D
  TKDT34DE = class; TKDT34DE_VecType = Extended; // 34D
  TKDT35DE = class; TKDT35DE_VecType = Extended; // 35D
  TKDT36DE = class; TKDT36DE_VecType = Extended; // 36D
  TKDT37DE = class; TKDT37DE_VecType = Extended; // 37D
  TKDT38DE = class; TKDT38DE_VecType = Extended; // 38D
  TKDT39DE = class; TKDT39DE_VecType = Extended; // 39D
  TKDT40DE = class; TKDT40DE_VecType = Extended; // 40D
  TKDT41DE = class; TKDT41DE_VecType = Extended; // 41D
  TKDT42DE = class; TKDT42DE_VecType = Extended; // 42D
  TKDT43DE = class; TKDT43DE_VecType = Extended; // 43D
  TKDT44DE = class; TKDT44DE_VecType = Extended; // 44D
  TKDT45DE = class; TKDT45DE_VecType = Extended; // 45D
  TKDT46DE = class; TKDT46DE_VecType = Extended; // 46D
  TKDT47DE = class; TKDT47DE_VecType = Extended; // 47D
  TKDT48DE = class; TKDT48DE_VecType = Extended; // 48D
  TKDT49DE = class; TKDT49DE_VecType = Extended; // 49D
  TKDT50DE = class; TKDT50DE_VecType = Extended; // 50D
  TKDT51DE = class; TKDT51DE_VecType = Extended; // 51D
  TKDT52DE = class; TKDT52DE_VecType = Extended; // 52D
  TKDT53DE = class; TKDT53DE_VecType = Extended; // 53D
  TKDT54DE = class; TKDT54DE_VecType = Extended; // 54D
  TKDT55DE = class; TKDT55DE_VecType = Extended; // 55D
  TKDT56DE = class; TKDT56DE_VecType = Extended; // 56D
  TKDT57DE = class; TKDT57DE_VecType = Extended; // 57D
  TKDT58DE = class; TKDT58DE_VecType = Extended; // 58D
  TKDT59DE = class; TKDT59DE_VecType = Extended; // 59D
  TKDT60DE = class; TKDT60DE_VecType = Extended; // 60D
  TKDT61DE = class; TKDT61DE_VecType = Extended; // 61D
  TKDT62DE = class; TKDT62DE_VecType = Extended; // 62D
  TKDT63DE = class; TKDT63DE_VecType = Extended; // 63D
  TKDT64DE = class; TKDT64DE_VecType = Extended; // 64D
  TKDT65DE = class; TKDT65DE_VecType = Extended; // 65D
  TKDT66DE = class; TKDT66DE_VecType = Extended; // 66D
  TKDT67DE = class; TKDT67DE_VecType = Extended; // 67D
  TKDT68DE = class; TKDT68DE_VecType = Extended; // 68D
  TKDT69DE = class; TKDT69DE_VecType = Extended; // 69D
  TKDT70DE = class; TKDT70DE_VecType = Extended; // 70D
  TKDT71DE = class; TKDT71DE_VecType = Extended; // 71D
  TKDT72DE = class; TKDT72DE_VecType = Extended; // 72D
  TKDT84DE = class; TKDT84DE_VecType = Extended; // 84D
  TKDT96DE = class; TKDT96DE_VecType = Extended; // 96D
  TKDT128DE = class; TKDT128DE_VecType = Extended; // 128D
  TKDT140DE = class; TKDT140DE_VecType = Extended; // 140D
  TKDT160DE = class; TKDT160DE_VecType = Extended; // 160D
  TKDT196DE = class; TKDT196DE_VecType = Extended; // 196D
  TKDT256DE = class; TKDT256DE_VecType = Extended; // 256D
  TKDT272DE = class; TKDT272DE_VecType = Extended; // 272D
  TKDT288DE = class; TKDT288DE_VecType = Extended; // 288D
  TKDT372DE = class; TKDT372DE_VecType = Extended; // 372D
  TKDT512DE = class; TKDT512DE_VecType = Extended; // 512D
  TKDT576DE = class; TKDT576DE_VecType = Extended; // 576D
  TKDT768DE = class; TKDT768DE_VecType = Extended; // 768D
  TKDT1024DE = class; TKDT1024DE_VecType = Extended; // 1024D
  TKDT1040DE = class; TKDT1040DE_VecType = Extended; // 1040D
  TKDT1056DE = class; TKDT1056DE_VecType = Extended; // 1056D
  TKDT1536DE = class; TKDT1536DE_VecType = Extended; // 1536D
  TKDT1920DE = class; TKDT1920DE_VecType = Extended; // 1920D
  TKDT1980DE = class; TKDT1980DE_VecType = Extended; // 1980D
  TKDT2048DE = class; TKDT2048DE_VecType = Extended; // 2048D
  TKDT3072DE = class; TKDT3072DE_VecType = Extended; // 3072D
  TKDT3088DE = class; TKDT3088DE_VecType = Extended; // 3088D
  TKDT3104DE = class; TKDT3104DE_VecType = Extended; // 3104D
  TKDT4096DE = class; TKDT4096DE_VecType = Extended; // 4096D
  TKDT8192DE = class; TKDT8192DE_VecType = Extended; // 8192D





  // extended float: KDTree


  TKDT1DE = class(TCoreClassObject)
  public type
    // code split
    TKDT1DE_Vec = array [0 .. KDT1DE_Axis - 1] of TKDT1DE_VecType;
    PKDT1DE_Vec = ^TKDT1DE_Vec;

    TKDT1DE_DynamicVecBuffer = packed array of TKDT1DE_Vec;
    PKDT1DE_DynamicVecBuffer = ^TKDT1DE_DynamicVecBuffer;

    TKDT1DE_Source = packed record
      Buff: TKDT1DE_Vec;
      index: Int64;
    end;

    PKDT1DE_Source       = ^TKDT1DE_Source;
    TKDT1DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT1DE_Source) - 1] of PKDT1DE_Source;
    PKDT1DE_SourceBuffer = ^TKDT1DE_SourceBuffer;

    TKDT1DEyanmicSourceBuffer = packed array of PKDT1DE_Source;
    PKDT1DEyanmicSourceBuffer = ^TKDT1DEyanmicSourceBuffer;

    TKDT1DEyanmicStoreBuffer = packed array of TKDT1DE_Source;
    PKDT1DEyanmicStoreBuffer = ^TKDT1DEyanmicStoreBuffer;

    PKDT1DE_Node = ^TKDT1DE_Node;

    TKDT1DE_Node = packed record
      Parent, Right, Left: PKDT1DE_Node;
      vec: PKDT1DE_Source;
    end;

    TKDT1DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1DE_Source; const Data: Pointer);
    TKDT1DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1DEyanmicStoreBuffer;
    KDBuff     : TKDT1DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT1DE_Node;
    TestBuff   : TKDT1DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DE_Node;
    function GetData(const index: NativeInt): PKDT1DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DE_Node; overload;
    function Search(const Buff: TKDT1DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DE_Node; overload;
    function Search(const Buff: TKDT1DE_Vec; var SearchedDistanceMin: Double): PKDT1DE_Node; overload;
    function Search(const Buff: TKDT1DE_Vec): PKDT1DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1DE_DynamicVecBuffer; var OutBuff: TKDT1DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1DE_Node);
    procedure PrintBuffer;

    class function KDT1DEVec(const s: string): TKDT1DE_Vec; overload;
    class function KDT1DEVec(const v: TKDT1DE_Vec): string; overload;
    class function KDT1DEPow(const v: TKDT1DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1DEDistance(const v1, v2: TKDT1DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT2DE = class(TCoreClassObject)
  public type
    // code split
    TKDT2DE_Vec = array [0 .. KDT2DE_Axis - 1] of TKDT2DE_VecType;
    PKDT2DE_Vec = ^TKDT2DE_Vec;

    TKDT2DE_DynamicVecBuffer = packed array of TKDT2DE_Vec;
    PKDT2DE_DynamicVecBuffer = ^TKDT2DE_DynamicVecBuffer;

    TKDT2DE_Source = packed record
      Buff: TKDT2DE_Vec;
      index: Int64;
    end;

    PKDT2DE_Source       = ^TKDT2DE_Source;
    TKDT2DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT2DE_Source) - 1] of PKDT2DE_Source;
    PKDT2DE_SourceBuffer = ^TKDT2DE_SourceBuffer;

    TKDT2DEyanmicSourceBuffer = packed array of PKDT2DE_Source;
    PKDT2DEyanmicSourceBuffer = ^TKDT2DEyanmicSourceBuffer;

    TKDT2DEyanmicStoreBuffer = packed array of TKDT2DE_Source;
    PKDT2DEyanmicStoreBuffer = ^TKDT2DEyanmicStoreBuffer;

    PKDT2DE_Node = ^TKDT2DE_Node;

    TKDT2DE_Node = packed record
      Parent, Right, Left: PKDT2DE_Node;
      vec: PKDT2DE_Source;
    end;

    TKDT2DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT2DE_Source; const Data: Pointer);
    TKDT2DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT2DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT2DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT2DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT2DEyanmicStoreBuffer;
    KDBuff     : TKDT2DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT2DE_Node;
    TestBuff   : TKDT2DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DE_Node;
    function GetData(const index: NativeInt): PKDT2DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT2DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DE_Node; overload;
    function Search(const Buff: TKDT2DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DE_Node; overload;
    function Search(const Buff: TKDT2DE_Vec; var SearchedDistanceMin: Double): PKDT2DE_Node; overload;
    function Search(const Buff: TKDT2DE_Vec): PKDT2DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2DE_DynamicVecBuffer; var OutBuff: TKDT2DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT2DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT2DE_Node);
    procedure PrintBuffer;

    class function KDT2DEVec(const s: string): TKDT2DE_Vec; overload;
    class function KDT2DEVec(const v: TKDT2DE_Vec): string; overload;
    class function KDT2DEPow(const v: TKDT2DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT2DEDistance(const v1, v2: TKDT2DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT3DE = class(TCoreClassObject)
  public type
    // code split
    TKDT3DE_Vec = array [0 .. KDT3DE_Axis - 1] of TKDT3DE_VecType;
    PKDT3DE_Vec = ^TKDT3DE_Vec;

    TKDT3DE_DynamicVecBuffer = packed array of TKDT3DE_Vec;
    PKDT3DE_DynamicVecBuffer = ^TKDT3DE_DynamicVecBuffer;

    TKDT3DE_Source = packed record
      Buff: TKDT3DE_Vec;
      index: Int64;
    end;

    PKDT3DE_Source       = ^TKDT3DE_Source;
    TKDT3DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT3DE_Source) - 1] of PKDT3DE_Source;
    PKDT3DE_SourceBuffer = ^TKDT3DE_SourceBuffer;

    TKDT3DEyanmicSourceBuffer = packed array of PKDT3DE_Source;
    PKDT3DEyanmicSourceBuffer = ^TKDT3DEyanmicSourceBuffer;

    TKDT3DEyanmicStoreBuffer = packed array of TKDT3DE_Source;
    PKDT3DEyanmicStoreBuffer = ^TKDT3DEyanmicStoreBuffer;

    PKDT3DE_Node = ^TKDT3DE_Node;

    TKDT3DE_Node = packed record
      Parent, Right, Left: PKDT3DE_Node;
      vec: PKDT3DE_Source;
    end;

    TKDT3DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3DE_Source; const Data: Pointer);
    TKDT3DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT3DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT3DEyanmicStoreBuffer;
    KDBuff     : TKDT3DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT3DE_Node;
    TestBuff   : TKDT3DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DE_Node;
    function GetData(const index: NativeInt): PKDT3DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT3DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DE_Node; overload;
    function Search(const Buff: TKDT3DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DE_Node; overload;
    function Search(const Buff: TKDT3DE_Vec; var SearchedDistanceMin: Double): PKDT3DE_Node; overload;
    function Search(const Buff: TKDT3DE_Vec): PKDT3DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3DE_DynamicVecBuffer; var OutBuff: TKDT3DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT3DE_Node);
    procedure PrintBuffer;

    class function KDT3DEVec(const s: string): TKDT3DE_Vec; overload;
    class function KDT3DEVec(const v: TKDT3DE_Vec): string; overload;
    class function KDT3DEPow(const v: TKDT3DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3DEDistance(const v1, v2: TKDT3DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT4DE = class(TCoreClassObject)
  public type
    // code split
    TKDT4DE_Vec = array [0 .. KDT4DE_Axis - 1] of TKDT4DE_VecType;
    PKDT4DE_Vec = ^TKDT4DE_Vec;

    TKDT4DE_DynamicVecBuffer = packed array of TKDT4DE_Vec;
    PKDT4DE_DynamicVecBuffer = ^TKDT4DE_DynamicVecBuffer;

    TKDT4DE_Source = packed record
      Buff: TKDT4DE_Vec;
      index: Int64;
    end;

    PKDT4DE_Source       = ^TKDT4DE_Source;
    TKDT4DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT4DE_Source) - 1] of PKDT4DE_Source;
    PKDT4DE_SourceBuffer = ^TKDT4DE_SourceBuffer;

    TKDT4DEyanmicSourceBuffer = packed array of PKDT4DE_Source;
    PKDT4DEyanmicSourceBuffer = ^TKDT4DEyanmicSourceBuffer;

    TKDT4DEyanmicStoreBuffer = packed array of TKDT4DE_Source;
    PKDT4DEyanmicStoreBuffer = ^TKDT4DEyanmicStoreBuffer;

    PKDT4DE_Node = ^TKDT4DE_Node;

    TKDT4DE_Node = packed record
      Parent, Right, Left: PKDT4DE_Node;
      vec: PKDT4DE_Source;
    end;

    TKDT4DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT4DE_Source; const Data: Pointer);
    TKDT4DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT4DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT4DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT4DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT4DEyanmicStoreBuffer;
    KDBuff     : TKDT4DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT4DE_Node;
    TestBuff   : TKDT4DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DE_Node;
    function GetData(const index: NativeInt): PKDT4DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT4DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DE_Node; overload;
    function Search(const Buff: TKDT4DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DE_Node; overload;
    function Search(const Buff: TKDT4DE_Vec; var SearchedDistanceMin: Double): PKDT4DE_Node; overload;
    function Search(const Buff: TKDT4DE_Vec): PKDT4DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4DE_DynamicVecBuffer; var OutBuff: TKDT4DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT4DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT4DE_Node);
    procedure PrintBuffer;

    class function KDT4DEVec(const s: string): TKDT4DE_Vec; overload;
    class function KDT4DEVec(const v: TKDT4DE_Vec): string; overload;
    class function KDT4DEPow(const v: TKDT4DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT4DEDistance(const v1, v2: TKDT4DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT5DE = class(TCoreClassObject)
  public type
    // code split
    TKDT5DE_Vec = array [0 .. KDT5DE_Axis - 1] of TKDT5DE_VecType;
    PKDT5DE_Vec = ^TKDT5DE_Vec;

    TKDT5DE_DynamicVecBuffer = packed array of TKDT5DE_Vec;
    PKDT5DE_DynamicVecBuffer = ^TKDT5DE_DynamicVecBuffer;

    TKDT5DE_Source = packed record
      Buff: TKDT5DE_Vec;
      index: Int64;
    end;

    PKDT5DE_Source       = ^TKDT5DE_Source;
    TKDT5DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT5DE_Source) - 1] of PKDT5DE_Source;
    PKDT5DE_SourceBuffer = ^TKDT5DE_SourceBuffer;

    TKDT5DEyanmicSourceBuffer = packed array of PKDT5DE_Source;
    PKDT5DEyanmicSourceBuffer = ^TKDT5DEyanmicSourceBuffer;

    TKDT5DEyanmicStoreBuffer = packed array of TKDT5DE_Source;
    PKDT5DEyanmicStoreBuffer = ^TKDT5DEyanmicStoreBuffer;

    PKDT5DE_Node = ^TKDT5DE_Node;

    TKDT5DE_Node = packed record
      Parent, Right, Left: PKDT5DE_Node;
      vec: PKDT5DE_Source;
    end;

    TKDT5DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT5DE_Source; const Data: Pointer);
    TKDT5DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT5DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT5DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT5DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT5DEyanmicStoreBuffer;
    KDBuff     : TKDT5DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT5DE_Node;
    TestBuff   : TKDT5DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DE_Node;
    function GetData(const index: NativeInt): PKDT5DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT5DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT5DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT5DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT5DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DE_Node; overload;
    function Search(const Buff: TKDT5DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DE_Node; overload;
    function Search(const Buff: TKDT5DE_Vec; var SearchedDistanceMin: Double): PKDT5DE_Node; overload;
    function Search(const Buff: TKDT5DE_Vec): PKDT5DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT5DE_DynamicVecBuffer; var OutBuff: TKDT5DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT5DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT5DE_Node);
    procedure PrintBuffer;

    class function KDT5DEVec(const s: string): TKDT5DE_Vec; overload;
    class function KDT5DEVec(const v: TKDT5DE_Vec): string; overload;
    class function KDT5DEPow(const v: TKDT5DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT5DEDistance(const v1, v2: TKDT5DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT5DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT6DE = class(TCoreClassObject)
  public type
    // code split
    TKDT6DE_Vec = array [0 .. KDT6DE_Axis - 1] of TKDT6DE_VecType;
    PKDT6DE_Vec = ^TKDT6DE_Vec;

    TKDT6DE_DynamicVecBuffer = packed array of TKDT6DE_Vec;
    PKDT6DE_DynamicVecBuffer = ^TKDT6DE_DynamicVecBuffer;

    TKDT6DE_Source = packed record
      Buff: TKDT6DE_Vec;
      index: Int64;
    end;

    PKDT6DE_Source       = ^TKDT6DE_Source;
    TKDT6DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT6DE_Source) - 1] of PKDT6DE_Source;
    PKDT6DE_SourceBuffer = ^TKDT6DE_SourceBuffer;

    TKDT6DEyanmicSourceBuffer = packed array of PKDT6DE_Source;
    PKDT6DEyanmicSourceBuffer = ^TKDT6DEyanmicSourceBuffer;

    TKDT6DEyanmicStoreBuffer = packed array of TKDT6DE_Source;
    PKDT6DEyanmicStoreBuffer = ^TKDT6DEyanmicStoreBuffer;

    PKDT6DE_Node = ^TKDT6DE_Node;

    TKDT6DE_Node = packed record
      Parent, Right, Left: PKDT6DE_Node;
      vec: PKDT6DE_Source;
    end;

    TKDT6DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT6DE_Source; const Data: Pointer);
    TKDT6DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT6DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT6DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT6DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT6DEyanmicStoreBuffer;
    KDBuff     : TKDT6DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT6DE_Node;
    TestBuff   : TKDT6DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DE_Node;
    function GetData(const index: NativeInt): PKDT6DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT6DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT6DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT6DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT6DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DE_Node; overload;
    function Search(const Buff: TKDT6DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DE_Node; overload;
    function Search(const Buff: TKDT6DE_Vec; var SearchedDistanceMin: Double): PKDT6DE_Node; overload;
    function Search(const Buff: TKDT6DE_Vec): PKDT6DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT6DE_DynamicVecBuffer; var OutBuff: TKDT6DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT6DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT6DE_Node);
    procedure PrintBuffer;

    class function KDT6DEVec(const s: string): TKDT6DE_Vec; overload;
    class function KDT6DEVec(const v: TKDT6DE_Vec): string; overload;
    class function KDT6DEPow(const v: TKDT6DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT6DEDistance(const v1, v2: TKDT6DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT6DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT7DE = class(TCoreClassObject)
  public type
    // code split
    TKDT7DE_Vec = array [0 .. KDT7DE_Axis - 1] of TKDT7DE_VecType;
    PKDT7DE_Vec = ^TKDT7DE_Vec;

    TKDT7DE_DynamicVecBuffer = packed array of TKDT7DE_Vec;
    PKDT7DE_DynamicVecBuffer = ^TKDT7DE_DynamicVecBuffer;

    TKDT7DE_Source = packed record
      Buff: TKDT7DE_Vec;
      index: Int64;
    end;

    PKDT7DE_Source       = ^TKDT7DE_Source;
    TKDT7DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT7DE_Source) - 1] of PKDT7DE_Source;
    PKDT7DE_SourceBuffer = ^TKDT7DE_SourceBuffer;

    TKDT7DEyanmicSourceBuffer = packed array of PKDT7DE_Source;
    PKDT7DEyanmicSourceBuffer = ^TKDT7DEyanmicSourceBuffer;

    TKDT7DEyanmicStoreBuffer = packed array of TKDT7DE_Source;
    PKDT7DEyanmicStoreBuffer = ^TKDT7DEyanmicStoreBuffer;

    PKDT7DE_Node = ^TKDT7DE_Node;

    TKDT7DE_Node = packed record
      Parent, Right, Left: PKDT7DE_Node;
      vec: PKDT7DE_Source;
    end;

    TKDT7DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT7DE_Source; const Data: Pointer);
    TKDT7DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT7DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT7DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT7DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT7DEyanmicStoreBuffer;
    KDBuff     : TKDT7DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT7DE_Node;
    TestBuff   : TKDT7DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DE_Node;
    function GetData(const index: NativeInt): PKDT7DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT7DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT7DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT7DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT7DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DE_Node; overload;
    function Search(const Buff: TKDT7DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DE_Node; overload;
    function Search(const Buff: TKDT7DE_Vec; var SearchedDistanceMin: Double): PKDT7DE_Node; overload;
    function Search(const Buff: TKDT7DE_Vec): PKDT7DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT7DE_DynamicVecBuffer; var OutBuff: TKDT7DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT7DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT7DE_Node);
    procedure PrintBuffer;

    class function KDT7DEVec(const s: string): TKDT7DE_Vec; overload;
    class function KDT7DEVec(const v: TKDT7DE_Vec): string; overload;
    class function KDT7DEPow(const v: TKDT7DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT7DEDistance(const v1, v2: TKDT7DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT7DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT8DE = class(TCoreClassObject)
  public type
    // code split
    TKDT8DE_Vec = array [0 .. KDT8DE_Axis - 1] of TKDT8DE_VecType;
    PKDT8DE_Vec = ^TKDT8DE_Vec;

    TKDT8DE_DynamicVecBuffer = packed array of TKDT8DE_Vec;
    PKDT8DE_DynamicVecBuffer = ^TKDT8DE_DynamicVecBuffer;

    TKDT8DE_Source = packed record
      Buff: TKDT8DE_Vec;
      index: Int64;
    end;

    PKDT8DE_Source       = ^TKDT8DE_Source;
    TKDT8DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT8DE_Source) - 1] of PKDT8DE_Source;
    PKDT8DE_SourceBuffer = ^TKDT8DE_SourceBuffer;

    TKDT8DEyanmicSourceBuffer = packed array of PKDT8DE_Source;
    PKDT8DEyanmicSourceBuffer = ^TKDT8DEyanmicSourceBuffer;

    TKDT8DEyanmicStoreBuffer = packed array of TKDT8DE_Source;
    PKDT8DEyanmicStoreBuffer = ^TKDT8DEyanmicStoreBuffer;

    PKDT8DE_Node = ^TKDT8DE_Node;

    TKDT8DE_Node = packed record
      Parent, Right, Left: PKDT8DE_Node;
      vec: PKDT8DE_Source;
    end;

    TKDT8DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT8DE_Source; const Data: Pointer);
    TKDT8DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT8DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT8DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT8DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT8DEyanmicStoreBuffer;
    KDBuff     : TKDT8DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT8DE_Node;
    TestBuff   : TKDT8DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DE_Node;
    function GetData(const index: NativeInt): PKDT8DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT8DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DE_Node; overload;
    function Search(const Buff: TKDT8DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DE_Node; overload;
    function Search(const Buff: TKDT8DE_Vec; var SearchedDistanceMin: Double): PKDT8DE_Node; overload;
    function Search(const Buff: TKDT8DE_Vec): PKDT8DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8DE_DynamicVecBuffer; var OutBuff: TKDT8DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT8DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT8DE_Node);
    procedure PrintBuffer;

    class function KDT8DEVec(const s: string): TKDT8DE_Vec; overload;
    class function KDT8DEVec(const v: TKDT8DE_Vec): string; overload;
    class function KDT8DEPow(const v: TKDT8DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT8DEDistance(const v1, v2: TKDT8DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT9DE = class(TCoreClassObject)
  public type
    // code split
    TKDT9DE_Vec = array [0 .. KDT9DE_Axis - 1] of TKDT9DE_VecType;
    PKDT9DE_Vec = ^TKDT9DE_Vec;

    TKDT9DE_DynamicVecBuffer = packed array of TKDT9DE_Vec;
    PKDT9DE_DynamicVecBuffer = ^TKDT9DE_DynamicVecBuffer;

    TKDT9DE_Source = packed record
      Buff: TKDT9DE_Vec;
      index: Int64;
    end;

    PKDT9DE_Source       = ^TKDT9DE_Source;
    TKDT9DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT9DE_Source) - 1] of PKDT9DE_Source;
    PKDT9DE_SourceBuffer = ^TKDT9DE_SourceBuffer;

    TKDT9DEyanmicSourceBuffer = packed array of PKDT9DE_Source;
    PKDT9DEyanmicSourceBuffer = ^TKDT9DEyanmicSourceBuffer;

    TKDT9DEyanmicStoreBuffer = packed array of TKDT9DE_Source;
    PKDT9DEyanmicStoreBuffer = ^TKDT9DEyanmicStoreBuffer;

    PKDT9DE_Node = ^TKDT9DE_Node;

    TKDT9DE_Node = packed record
      Parent, Right, Left: PKDT9DE_Node;
      vec: PKDT9DE_Source;
    end;

    TKDT9DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT9DE_Source; const Data: Pointer);
    TKDT9DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT9DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT9DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT9DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT9DEyanmicStoreBuffer;
    KDBuff     : TKDT9DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT9DE_Node;
    TestBuff   : TKDT9DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DE_Node;
    function GetData(const index: NativeInt): PKDT9DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT9DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT9DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT9DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT9DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DE_Node; overload;
    function Search(const Buff: TKDT9DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DE_Node; overload;
    function Search(const Buff: TKDT9DE_Vec; var SearchedDistanceMin: Double): PKDT9DE_Node; overload;
    function Search(const Buff: TKDT9DE_Vec): PKDT9DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT9DE_DynamicVecBuffer; var OutBuff: TKDT9DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT9DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT9DE_Node);
    procedure PrintBuffer;

    class function KDT9DEVec(const s: string): TKDT9DE_Vec; overload;
    class function KDT9DEVec(const v: TKDT9DE_Vec): string; overload;
    class function KDT9DEPow(const v: TKDT9DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT9DEDistance(const v1, v2: TKDT9DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT9DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT10DE = class(TCoreClassObject)
  public type
    // code split
    TKDT10DE_Vec = array [0 .. KDT10DE_Axis - 1] of TKDT10DE_VecType;
    PKDT10DE_Vec = ^TKDT10DE_Vec;

    TKDT10DE_DynamicVecBuffer = packed array of TKDT10DE_Vec;
    PKDT10DE_DynamicVecBuffer = ^TKDT10DE_DynamicVecBuffer;

    TKDT10DE_Source = packed record
      Buff: TKDT10DE_Vec;
      index: Int64;
    end;

    PKDT10DE_Source       = ^TKDT10DE_Source;
    TKDT10DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT10DE_Source) - 1] of PKDT10DE_Source;
    PKDT10DE_SourceBuffer = ^TKDT10DE_SourceBuffer;

    TKDT10DEyanmicSourceBuffer = packed array of PKDT10DE_Source;
    PKDT10DEyanmicSourceBuffer = ^TKDT10DEyanmicSourceBuffer;

    TKDT10DEyanmicStoreBuffer = packed array of TKDT10DE_Source;
    PKDT10DEyanmicStoreBuffer = ^TKDT10DEyanmicStoreBuffer;

    PKDT10DE_Node = ^TKDT10DE_Node;

    TKDT10DE_Node = packed record
      Parent, Right, Left: PKDT10DE_Node;
      vec: PKDT10DE_Source;
    end;

    TKDT10DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT10DE_Source; const Data: Pointer);
    TKDT10DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT10DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT10DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT10DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT10DEyanmicStoreBuffer;
    KDBuff     : TKDT10DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT10DE_Node;
    TestBuff   : TKDT10DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DE_Node;
    function GetData(const index: NativeInt): PKDT10DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT10DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT10DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT10DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT10DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DE_Node; overload;
    function Search(const Buff: TKDT10DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DE_Node; overload;
    function Search(const Buff: TKDT10DE_Vec; var SearchedDistanceMin: Double): PKDT10DE_Node; overload;
    function Search(const Buff: TKDT10DE_Vec): PKDT10DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT10DE_DynamicVecBuffer; var OutBuff: TKDT10DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT10DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT10DE_Node);
    procedure PrintBuffer;

    class function KDT10DEVec(const s: string): TKDT10DE_Vec; overload;
    class function KDT10DEVec(const v: TKDT10DE_Vec): string; overload;
    class function KDT10DEPow(const v: TKDT10DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT10DEDistance(const v1, v2: TKDT10DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT10DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT11DE = class(TCoreClassObject)
  public type
    // code split
    TKDT11DE_Vec = array [0 .. KDT11DE_Axis - 1] of TKDT11DE_VecType;
    PKDT11DE_Vec = ^TKDT11DE_Vec;

    TKDT11DE_DynamicVecBuffer = packed array of TKDT11DE_Vec;
    PKDT11DE_DynamicVecBuffer = ^TKDT11DE_DynamicVecBuffer;

    TKDT11DE_Source = packed record
      Buff: TKDT11DE_Vec;
      index: Int64;
    end;

    PKDT11DE_Source       = ^TKDT11DE_Source;
    TKDT11DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT11DE_Source) - 1] of PKDT11DE_Source;
    PKDT11DE_SourceBuffer = ^TKDT11DE_SourceBuffer;

    TKDT11DEyanmicSourceBuffer = packed array of PKDT11DE_Source;
    PKDT11DEyanmicSourceBuffer = ^TKDT11DEyanmicSourceBuffer;

    TKDT11DEyanmicStoreBuffer = packed array of TKDT11DE_Source;
    PKDT11DEyanmicStoreBuffer = ^TKDT11DEyanmicStoreBuffer;

    PKDT11DE_Node = ^TKDT11DE_Node;

    TKDT11DE_Node = packed record
      Parent, Right, Left: PKDT11DE_Node;
      vec: PKDT11DE_Source;
    end;

    TKDT11DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT11DE_Source; const Data: Pointer);
    TKDT11DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT11DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT11DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT11DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT11DEyanmicStoreBuffer;
    KDBuff     : TKDT11DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT11DE_Node;
    TestBuff   : TKDT11DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DE_Node;
    function GetData(const index: NativeInt): PKDT11DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT11DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT11DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT11DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT11DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DE_Node; overload;
    function Search(const Buff: TKDT11DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DE_Node; overload;
    function Search(const Buff: TKDT11DE_Vec; var SearchedDistanceMin: Double): PKDT11DE_Node; overload;
    function Search(const Buff: TKDT11DE_Vec): PKDT11DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT11DE_DynamicVecBuffer; var OutBuff: TKDT11DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT11DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT11DE_Node);
    procedure PrintBuffer;

    class function KDT11DEVec(const s: string): TKDT11DE_Vec; overload;
    class function KDT11DEVec(const v: TKDT11DE_Vec): string; overload;
    class function KDT11DEPow(const v: TKDT11DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT11DEDistance(const v1, v2: TKDT11DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT11DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT12DE = class(TCoreClassObject)
  public type
    // code split
    TKDT12DE_Vec = array [0 .. KDT12DE_Axis - 1] of TKDT12DE_VecType;
    PKDT12DE_Vec = ^TKDT12DE_Vec;

    TKDT12DE_DynamicVecBuffer = packed array of TKDT12DE_Vec;
    PKDT12DE_DynamicVecBuffer = ^TKDT12DE_DynamicVecBuffer;

    TKDT12DE_Source = packed record
      Buff: TKDT12DE_Vec;
      index: Int64;
    end;

    PKDT12DE_Source       = ^TKDT12DE_Source;
    TKDT12DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT12DE_Source) - 1] of PKDT12DE_Source;
    PKDT12DE_SourceBuffer = ^TKDT12DE_SourceBuffer;

    TKDT12DEyanmicSourceBuffer = packed array of PKDT12DE_Source;
    PKDT12DEyanmicSourceBuffer = ^TKDT12DEyanmicSourceBuffer;

    TKDT12DEyanmicStoreBuffer = packed array of TKDT12DE_Source;
    PKDT12DEyanmicStoreBuffer = ^TKDT12DEyanmicStoreBuffer;

    PKDT12DE_Node = ^TKDT12DE_Node;

    TKDT12DE_Node = packed record
      Parent, Right, Left: PKDT12DE_Node;
      vec: PKDT12DE_Source;
    end;

    TKDT12DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT12DE_Source; const Data: Pointer);
    TKDT12DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT12DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT12DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT12DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT12DEyanmicStoreBuffer;
    KDBuff     : TKDT12DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT12DE_Node;
    TestBuff   : TKDT12DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DE_Node;
    function GetData(const index: NativeInt): PKDT12DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT12DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT12DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT12DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT12DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DE_Node; overload;
    function Search(const Buff: TKDT12DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DE_Node; overload;
    function Search(const Buff: TKDT12DE_Vec; var SearchedDistanceMin: Double): PKDT12DE_Node; overload;
    function Search(const Buff: TKDT12DE_Vec): PKDT12DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT12DE_DynamicVecBuffer; var OutBuff: TKDT12DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT12DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT12DE_Node);
    procedure PrintBuffer;

    class function KDT12DEVec(const s: string): TKDT12DE_Vec; overload;
    class function KDT12DEVec(const v: TKDT12DE_Vec): string; overload;
    class function KDT12DEPow(const v: TKDT12DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT12DEDistance(const v1, v2: TKDT12DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT12DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT13DE = class(TCoreClassObject)
  public type
    // code split
    TKDT13DE_Vec = array [0 .. KDT13DE_Axis - 1] of TKDT13DE_VecType;
    PKDT13DE_Vec = ^TKDT13DE_Vec;

    TKDT13DE_DynamicVecBuffer = packed array of TKDT13DE_Vec;
    PKDT13DE_DynamicVecBuffer = ^TKDT13DE_DynamicVecBuffer;

    TKDT13DE_Source = packed record
      Buff: TKDT13DE_Vec;
      index: Int64;
    end;

    PKDT13DE_Source       = ^TKDT13DE_Source;
    TKDT13DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT13DE_Source) - 1] of PKDT13DE_Source;
    PKDT13DE_SourceBuffer = ^TKDT13DE_SourceBuffer;

    TKDT13DEyanmicSourceBuffer = packed array of PKDT13DE_Source;
    PKDT13DEyanmicSourceBuffer = ^TKDT13DEyanmicSourceBuffer;

    TKDT13DEyanmicStoreBuffer = packed array of TKDT13DE_Source;
    PKDT13DEyanmicStoreBuffer = ^TKDT13DEyanmicStoreBuffer;

    PKDT13DE_Node = ^TKDT13DE_Node;

    TKDT13DE_Node = packed record
      Parent, Right, Left: PKDT13DE_Node;
      vec: PKDT13DE_Source;
    end;

    TKDT13DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT13DE_Source; const Data: Pointer);
    TKDT13DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT13DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT13DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT13DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT13DEyanmicStoreBuffer;
    KDBuff     : TKDT13DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT13DE_Node;
    TestBuff   : TKDT13DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DE_Node;
    function GetData(const index: NativeInt): PKDT13DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT13DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT13DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT13DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT13DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DE_Node; overload;
    function Search(const Buff: TKDT13DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DE_Node; overload;
    function Search(const Buff: TKDT13DE_Vec; var SearchedDistanceMin: Double): PKDT13DE_Node; overload;
    function Search(const Buff: TKDT13DE_Vec): PKDT13DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT13DE_DynamicVecBuffer; var OutBuff: TKDT13DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT13DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT13DE_Node);
    procedure PrintBuffer;

    class function KDT13DEVec(const s: string): TKDT13DE_Vec; overload;
    class function KDT13DEVec(const v: TKDT13DE_Vec): string; overload;
    class function KDT13DEPow(const v: TKDT13DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT13DEDistance(const v1, v2: TKDT13DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT13DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT14DE = class(TCoreClassObject)
  public type
    // code split
    TKDT14DE_Vec = array [0 .. KDT14DE_Axis - 1] of TKDT14DE_VecType;
    PKDT14DE_Vec = ^TKDT14DE_Vec;

    TKDT14DE_DynamicVecBuffer = packed array of TKDT14DE_Vec;
    PKDT14DE_DynamicVecBuffer = ^TKDT14DE_DynamicVecBuffer;

    TKDT14DE_Source = packed record
      Buff: TKDT14DE_Vec;
      index: Int64;
    end;

    PKDT14DE_Source       = ^TKDT14DE_Source;
    TKDT14DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT14DE_Source) - 1] of PKDT14DE_Source;
    PKDT14DE_SourceBuffer = ^TKDT14DE_SourceBuffer;

    TKDT14DEyanmicSourceBuffer = packed array of PKDT14DE_Source;
    PKDT14DEyanmicSourceBuffer = ^TKDT14DEyanmicSourceBuffer;

    TKDT14DEyanmicStoreBuffer = packed array of TKDT14DE_Source;
    PKDT14DEyanmicStoreBuffer = ^TKDT14DEyanmicStoreBuffer;

    PKDT14DE_Node = ^TKDT14DE_Node;

    TKDT14DE_Node = packed record
      Parent, Right, Left: PKDT14DE_Node;
      vec: PKDT14DE_Source;
    end;

    TKDT14DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT14DE_Source; const Data: Pointer);
    TKDT14DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT14DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT14DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT14DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT14DEyanmicStoreBuffer;
    KDBuff     : TKDT14DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT14DE_Node;
    TestBuff   : TKDT14DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DE_Node;
    function GetData(const index: NativeInt): PKDT14DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT14DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT14DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT14DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT14DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DE_Node; overload;
    function Search(const Buff: TKDT14DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DE_Node; overload;
    function Search(const Buff: TKDT14DE_Vec; var SearchedDistanceMin: Double): PKDT14DE_Node; overload;
    function Search(const Buff: TKDT14DE_Vec): PKDT14DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT14DE_DynamicVecBuffer; var OutBuff: TKDT14DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT14DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT14DE_Node);
    procedure PrintBuffer;

    class function KDT14DEVec(const s: string): TKDT14DE_Vec; overload;
    class function KDT14DEVec(const v: TKDT14DE_Vec): string; overload;
    class function KDT14DEPow(const v: TKDT14DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT14DEDistance(const v1, v2: TKDT14DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT14DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT15DE = class(TCoreClassObject)
  public type
    // code split
    TKDT15DE_Vec = array [0 .. KDT15DE_Axis - 1] of TKDT15DE_VecType;
    PKDT15DE_Vec = ^TKDT15DE_Vec;

    TKDT15DE_DynamicVecBuffer = packed array of TKDT15DE_Vec;
    PKDT15DE_DynamicVecBuffer = ^TKDT15DE_DynamicVecBuffer;

    TKDT15DE_Source = packed record
      Buff: TKDT15DE_Vec;
      index: Int64;
    end;

    PKDT15DE_Source       = ^TKDT15DE_Source;
    TKDT15DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT15DE_Source) - 1] of PKDT15DE_Source;
    PKDT15DE_SourceBuffer = ^TKDT15DE_SourceBuffer;

    TKDT15DEyanmicSourceBuffer = packed array of PKDT15DE_Source;
    PKDT15DEyanmicSourceBuffer = ^TKDT15DEyanmicSourceBuffer;

    TKDT15DEyanmicStoreBuffer = packed array of TKDT15DE_Source;
    PKDT15DEyanmicStoreBuffer = ^TKDT15DEyanmicStoreBuffer;

    PKDT15DE_Node = ^TKDT15DE_Node;

    TKDT15DE_Node = packed record
      Parent, Right, Left: PKDT15DE_Node;
      vec: PKDT15DE_Source;
    end;

    TKDT15DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT15DE_Source; const Data: Pointer);
    TKDT15DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT15DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT15DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT15DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT15DEyanmicStoreBuffer;
    KDBuff     : TKDT15DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT15DE_Node;
    TestBuff   : TKDT15DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DE_Node;
    function GetData(const index: NativeInt): PKDT15DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT15DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT15DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT15DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT15DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DE_Node; overload;
    function Search(const Buff: TKDT15DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DE_Node; overload;
    function Search(const Buff: TKDT15DE_Vec; var SearchedDistanceMin: Double): PKDT15DE_Node; overload;
    function Search(const Buff: TKDT15DE_Vec): PKDT15DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT15DE_DynamicVecBuffer; var OutBuff: TKDT15DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT15DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT15DE_Node);
    procedure PrintBuffer;

    class function KDT15DEVec(const s: string): TKDT15DE_Vec; overload;
    class function KDT15DEVec(const v: TKDT15DE_Vec): string; overload;
    class function KDT15DEPow(const v: TKDT15DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT15DEDistance(const v1, v2: TKDT15DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT15DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT16DE = class(TCoreClassObject)
  public type
    // code split
    TKDT16DE_Vec = array [0 .. KDT16DE_Axis - 1] of TKDT16DE_VecType;
    PKDT16DE_Vec = ^TKDT16DE_Vec;

    TKDT16DE_DynamicVecBuffer = packed array of TKDT16DE_Vec;
    PKDT16DE_DynamicVecBuffer = ^TKDT16DE_DynamicVecBuffer;

    TKDT16DE_Source = packed record
      Buff: TKDT16DE_Vec;
      index: Int64;
    end;

    PKDT16DE_Source       = ^TKDT16DE_Source;
    TKDT16DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT16DE_Source) - 1] of PKDT16DE_Source;
    PKDT16DE_SourceBuffer = ^TKDT16DE_SourceBuffer;

    TKDT16DEyanmicSourceBuffer = packed array of PKDT16DE_Source;
    PKDT16DEyanmicSourceBuffer = ^TKDT16DEyanmicSourceBuffer;

    TKDT16DEyanmicStoreBuffer = packed array of TKDT16DE_Source;
    PKDT16DEyanmicStoreBuffer = ^TKDT16DEyanmicStoreBuffer;

    PKDT16DE_Node = ^TKDT16DE_Node;

    TKDT16DE_Node = packed record
      Parent, Right, Left: PKDT16DE_Node;
      vec: PKDT16DE_Source;
    end;

    TKDT16DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT16DE_Source; const Data: Pointer);
    TKDT16DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT16DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT16DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT16DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT16DEyanmicStoreBuffer;
    KDBuff     : TKDT16DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT16DE_Node;
    TestBuff   : TKDT16DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DE_Node;
    function GetData(const index: NativeInt): PKDT16DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT16DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT16DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT16DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT16DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DE_Node; overload;
    function Search(const Buff: TKDT16DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DE_Node; overload;
    function Search(const Buff: TKDT16DE_Vec; var SearchedDistanceMin: Double): PKDT16DE_Node; overload;
    function Search(const Buff: TKDT16DE_Vec): PKDT16DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT16DE_DynamicVecBuffer; var OutBuff: TKDT16DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT16DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT16DE_Node);
    procedure PrintBuffer;

    class function KDT16DEVec(const s: string): TKDT16DE_Vec; overload;
    class function KDT16DEVec(const v: TKDT16DE_Vec): string; overload;
    class function KDT16DEPow(const v: TKDT16DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT16DEDistance(const v1, v2: TKDT16DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT16DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT17DE = class(TCoreClassObject)
  public type
    // code split
    TKDT17DE_Vec = array [0 .. KDT17DE_Axis - 1] of TKDT17DE_VecType;
    PKDT17DE_Vec = ^TKDT17DE_Vec;

    TKDT17DE_DynamicVecBuffer = packed array of TKDT17DE_Vec;
    PKDT17DE_DynamicVecBuffer = ^TKDT17DE_DynamicVecBuffer;

    TKDT17DE_Source = packed record
      Buff: TKDT17DE_Vec;
      index: Int64;
    end;

    PKDT17DE_Source       = ^TKDT17DE_Source;
    TKDT17DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT17DE_Source) - 1] of PKDT17DE_Source;
    PKDT17DE_SourceBuffer = ^TKDT17DE_SourceBuffer;

    TKDT17DEyanmicSourceBuffer = packed array of PKDT17DE_Source;
    PKDT17DEyanmicSourceBuffer = ^TKDT17DEyanmicSourceBuffer;

    TKDT17DEyanmicStoreBuffer = packed array of TKDT17DE_Source;
    PKDT17DEyanmicStoreBuffer = ^TKDT17DEyanmicStoreBuffer;

    PKDT17DE_Node = ^TKDT17DE_Node;

    TKDT17DE_Node = packed record
      Parent, Right, Left: PKDT17DE_Node;
      vec: PKDT17DE_Source;
    end;

    TKDT17DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT17DE_Source; const Data: Pointer);
    TKDT17DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT17DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT17DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT17DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT17DEyanmicStoreBuffer;
    KDBuff     : TKDT17DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT17DE_Node;
    TestBuff   : TKDT17DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DE_Node;
    function GetData(const index: NativeInt): PKDT17DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT17DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT17DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT17DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT17DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DE_Node; overload;
    function Search(const Buff: TKDT17DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DE_Node; overload;
    function Search(const Buff: TKDT17DE_Vec; var SearchedDistanceMin: Double): PKDT17DE_Node; overload;
    function Search(const Buff: TKDT17DE_Vec): PKDT17DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT17DE_DynamicVecBuffer; var OutBuff: TKDT17DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT17DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT17DE_Node);
    procedure PrintBuffer;

    class function KDT17DEVec(const s: string): TKDT17DE_Vec; overload;
    class function KDT17DEVec(const v: TKDT17DE_Vec): string; overload;
    class function KDT17DEPow(const v: TKDT17DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT17DEDistance(const v1, v2: TKDT17DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT17DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT18DE = class(TCoreClassObject)
  public type
    // code split
    TKDT18DE_Vec = array [0 .. KDT18DE_Axis - 1] of TKDT18DE_VecType;
    PKDT18DE_Vec = ^TKDT18DE_Vec;

    TKDT18DE_DynamicVecBuffer = packed array of TKDT18DE_Vec;
    PKDT18DE_DynamicVecBuffer = ^TKDT18DE_DynamicVecBuffer;

    TKDT18DE_Source = packed record
      Buff: TKDT18DE_Vec;
      index: Int64;
    end;

    PKDT18DE_Source       = ^TKDT18DE_Source;
    TKDT18DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT18DE_Source) - 1] of PKDT18DE_Source;
    PKDT18DE_SourceBuffer = ^TKDT18DE_SourceBuffer;

    TKDT18DEyanmicSourceBuffer = packed array of PKDT18DE_Source;
    PKDT18DEyanmicSourceBuffer = ^TKDT18DEyanmicSourceBuffer;

    TKDT18DEyanmicStoreBuffer = packed array of TKDT18DE_Source;
    PKDT18DEyanmicStoreBuffer = ^TKDT18DEyanmicStoreBuffer;

    PKDT18DE_Node = ^TKDT18DE_Node;

    TKDT18DE_Node = packed record
      Parent, Right, Left: PKDT18DE_Node;
      vec: PKDT18DE_Source;
    end;

    TKDT18DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT18DE_Source; const Data: Pointer);
    TKDT18DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT18DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT18DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT18DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT18DEyanmicStoreBuffer;
    KDBuff     : TKDT18DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT18DE_Node;
    TestBuff   : TKDT18DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DE_Node;
    function GetData(const index: NativeInt): PKDT18DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT18DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT18DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT18DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT18DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DE_Node; overload;
    function Search(const Buff: TKDT18DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DE_Node; overload;
    function Search(const Buff: TKDT18DE_Vec; var SearchedDistanceMin: Double): PKDT18DE_Node; overload;
    function Search(const Buff: TKDT18DE_Vec): PKDT18DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT18DE_DynamicVecBuffer; var OutBuff: TKDT18DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT18DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT18DE_Node);
    procedure PrintBuffer;

    class function KDT18DEVec(const s: string): TKDT18DE_Vec; overload;
    class function KDT18DEVec(const v: TKDT18DE_Vec): string; overload;
    class function KDT18DEPow(const v: TKDT18DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT18DEDistance(const v1, v2: TKDT18DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT18DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT19DE = class(TCoreClassObject)
  public type
    // code split
    TKDT19DE_Vec = array [0 .. KDT19DE_Axis - 1] of TKDT19DE_VecType;
    PKDT19DE_Vec = ^TKDT19DE_Vec;

    TKDT19DE_DynamicVecBuffer = packed array of TKDT19DE_Vec;
    PKDT19DE_DynamicVecBuffer = ^TKDT19DE_DynamicVecBuffer;

    TKDT19DE_Source = packed record
      Buff: TKDT19DE_Vec;
      index: Int64;
    end;

    PKDT19DE_Source       = ^TKDT19DE_Source;
    TKDT19DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT19DE_Source) - 1] of PKDT19DE_Source;
    PKDT19DE_SourceBuffer = ^TKDT19DE_SourceBuffer;

    TKDT19DEyanmicSourceBuffer = packed array of PKDT19DE_Source;
    PKDT19DEyanmicSourceBuffer = ^TKDT19DEyanmicSourceBuffer;

    TKDT19DEyanmicStoreBuffer = packed array of TKDT19DE_Source;
    PKDT19DEyanmicStoreBuffer = ^TKDT19DEyanmicStoreBuffer;

    PKDT19DE_Node = ^TKDT19DE_Node;

    TKDT19DE_Node = packed record
      Parent, Right, Left: PKDT19DE_Node;
      vec: PKDT19DE_Source;
    end;

    TKDT19DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT19DE_Source; const Data: Pointer);
    TKDT19DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT19DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT19DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT19DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT19DEyanmicStoreBuffer;
    KDBuff     : TKDT19DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT19DE_Node;
    TestBuff   : TKDT19DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DE_Node;
    function GetData(const index: NativeInt): PKDT19DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT19DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT19DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT19DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT19DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DE_Node; overload;
    function Search(const Buff: TKDT19DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DE_Node; overload;
    function Search(const Buff: TKDT19DE_Vec; var SearchedDistanceMin: Double): PKDT19DE_Node; overload;
    function Search(const Buff: TKDT19DE_Vec): PKDT19DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT19DE_DynamicVecBuffer; var OutBuff: TKDT19DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT19DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT19DE_Node);
    procedure PrintBuffer;

    class function KDT19DEVec(const s: string): TKDT19DE_Vec; overload;
    class function KDT19DEVec(const v: TKDT19DE_Vec): string; overload;
    class function KDT19DEPow(const v: TKDT19DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT19DEDistance(const v1, v2: TKDT19DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT19DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT20DE = class(TCoreClassObject)
  public type
    // code split
    TKDT20DE_Vec = array [0 .. KDT20DE_Axis - 1] of TKDT20DE_VecType;
    PKDT20DE_Vec = ^TKDT20DE_Vec;

    TKDT20DE_DynamicVecBuffer = packed array of TKDT20DE_Vec;
    PKDT20DE_DynamicVecBuffer = ^TKDT20DE_DynamicVecBuffer;

    TKDT20DE_Source = packed record
      Buff: TKDT20DE_Vec;
      index: Int64;
    end;

    PKDT20DE_Source       = ^TKDT20DE_Source;
    TKDT20DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT20DE_Source) - 1] of PKDT20DE_Source;
    PKDT20DE_SourceBuffer = ^TKDT20DE_SourceBuffer;

    TKDT20DEyanmicSourceBuffer = packed array of PKDT20DE_Source;
    PKDT20DEyanmicSourceBuffer = ^TKDT20DEyanmicSourceBuffer;

    TKDT20DEyanmicStoreBuffer = packed array of TKDT20DE_Source;
    PKDT20DEyanmicStoreBuffer = ^TKDT20DEyanmicStoreBuffer;

    PKDT20DE_Node = ^TKDT20DE_Node;

    TKDT20DE_Node = packed record
      Parent, Right, Left: PKDT20DE_Node;
      vec: PKDT20DE_Source;
    end;

    TKDT20DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT20DE_Source; const Data: Pointer);
    TKDT20DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT20DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT20DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT20DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT20DEyanmicStoreBuffer;
    KDBuff     : TKDT20DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT20DE_Node;
    TestBuff   : TKDT20DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DE_Node;
    function GetData(const index: NativeInt): PKDT20DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT20DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT20DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT20DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT20DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DE_Node; overload;
    function Search(const Buff: TKDT20DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DE_Node; overload;
    function Search(const Buff: TKDT20DE_Vec; var SearchedDistanceMin: Double): PKDT20DE_Node; overload;
    function Search(const Buff: TKDT20DE_Vec): PKDT20DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT20DE_DynamicVecBuffer; var OutBuff: TKDT20DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT20DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT20DE_Node);
    procedure PrintBuffer;

    class function KDT20DEVec(const s: string): TKDT20DE_Vec; overload;
    class function KDT20DEVec(const v: TKDT20DE_Vec): string; overload;
    class function KDT20DEPow(const v: TKDT20DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT20DEDistance(const v1, v2: TKDT20DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT20DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT21DE = class(TCoreClassObject)
  public type
    // code split
    TKDT21DE_Vec = array [0 .. KDT21DE_Axis - 1] of TKDT21DE_VecType;
    PKDT21DE_Vec = ^TKDT21DE_Vec;

    TKDT21DE_DynamicVecBuffer = packed array of TKDT21DE_Vec;
    PKDT21DE_DynamicVecBuffer = ^TKDT21DE_DynamicVecBuffer;

    TKDT21DE_Source = packed record
      Buff: TKDT21DE_Vec;
      index: Int64;
    end;

    PKDT21DE_Source       = ^TKDT21DE_Source;
    TKDT21DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT21DE_Source) - 1] of PKDT21DE_Source;
    PKDT21DE_SourceBuffer = ^TKDT21DE_SourceBuffer;

    TKDT21DEyanmicSourceBuffer = packed array of PKDT21DE_Source;
    PKDT21DEyanmicSourceBuffer = ^TKDT21DEyanmicSourceBuffer;

    TKDT21DEyanmicStoreBuffer = packed array of TKDT21DE_Source;
    PKDT21DEyanmicStoreBuffer = ^TKDT21DEyanmicStoreBuffer;

    PKDT21DE_Node = ^TKDT21DE_Node;

    TKDT21DE_Node = packed record
      Parent, Right, Left: PKDT21DE_Node;
      vec: PKDT21DE_Source;
    end;

    TKDT21DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT21DE_Source; const Data: Pointer);
    TKDT21DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT21DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT21DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT21DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT21DEyanmicStoreBuffer;
    KDBuff     : TKDT21DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT21DE_Node;
    TestBuff   : TKDT21DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DE_Node;
    function GetData(const index: NativeInt): PKDT21DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT21DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT21DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT21DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT21DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DE_Node; overload;
    function Search(const Buff: TKDT21DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DE_Node; overload;
    function Search(const Buff: TKDT21DE_Vec; var SearchedDistanceMin: Double): PKDT21DE_Node; overload;
    function Search(const Buff: TKDT21DE_Vec): PKDT21DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT21DE_DynamicVecBuffer; var OutBuff: TKDT21DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT21DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT21DE_Node);
    procedure PrintBuffer;

    class function KDT21DEVec(const s: string): TKDT21DE_Vec; overload;
    class function KDT21DEVec(const v: TKDT21DE_Vec): string; overload;
    class function KDT21DEPow(const v: TKDT21DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT21DEDistance(const v1, v2: TKDT21DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT21DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT22DE = class(TCoreClassObject)
  public type
    // code split
    TKDT22DE_Vec = array [0 .. KDT22DE_Axis - 1] of TKDT22DE_VecType;
    PKDT22DE_Vec = ^TKDT22DE_Vec;

    TKDT22DE_DynamicVecBuffer = packed array of TKDT22DE_Vec;
    PKDT22DE_DynamicVecBuffer = ^TKDT22DE_DynamicVecBuffer;

    TKDT22DE_Source = packed record
      Buff: TKDT22DE_Vec;
      index: Int64;
    end;

    PKDT22DE_Source       = ^TKDT22DE_Source;
    TKDT22DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT22DE_Source) - 1] of PKDT22DE_Source;
    PKDT22DE_SourceBuffer = ^TKDT22DE_SourceBuffer;

    TKDT22DEyanmicSourceBuffer = packed array of PKDT22DE_Source;
    PKDT22DEyanmicSourceBuffer = ^TKDT22DEyanmicSourceBuffer;

    TKDT22DEyanmicStoreBuffer = packed array of TKDT22DE_Source;
    PKDT22DEyanmicStoreBuffer = ^TKDT22DEyanmicStoreBuffer;

    PKDT22DE_Node = ^TKDT22DE_Node;

    TKDT22DE_Node = packed record
      Parent, Right, Left: PKDT22DE_Node;
      vec: PKDT22DE_Source;
    end;

    TKDT22DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT22DE_Source; const Data: Pointer);
    TKDT22DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT22DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT22DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT22DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT22DEyanmicStoreBuffer;
    KDBuff     : TKDT22DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT22DE_Node;
    TestBuff   : TKDT22DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DE_Node;
    function GetData(const index: NativeInt): PKDT22DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT22DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT22DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT22DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT22DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DE_Node; overload;
    function Search(const Buff: TKDT22DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DE_Node; overload;
    function Search(const Buff: TKDT22DE_Vec; var SearchedDistanceMin: Double): PKDT22DE_Node; overload;
    function Search(const Buff: TKDT22DE_Vec): PKDT22DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT22DE_DynamicVecBuffer; var OutBuff: TKDT22DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT22DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT22DE_Node);
    procedure PrintBuffer;

    class function KDT22DEVec(const s: string): TKDT22DE_Vec; overload;
    class function KDT22DEVec(const v: TKDT22DE_Vec): string; overload;
    class function KDT22DEPow(const v: TKDT22DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT22DEDistance(const v1, v2: TKDT22DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT22DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT23DE = class(TCoreClassObject)
  public type
    // code split
    TKDT23DE_Vec = array [0 .. KDT23DE_Axis - 1] of TKDT23DE_VecType;
    PKDT23DE_Vec = ^TKDT23DE_Vec;

    TKDT23DE_DynamicVecBuffer = packed array of TKDT23DE_Vec;
    PKDT23DE_DynamicVecBuffer = ^TKDT23DE_DynamicVecBuffer;

    TKDT23DE_Source = packed record
      Buff: TKDT23DE_Vec;
      index: Int64;
    end;

    PKDT23DE_Source       = ^TKDT23DE_Source;
    TKDT23DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT23DE_Source) - 1] of PKDT23DE_Source;
    PKDT23DE_SourceBuffer = ^TKDT23DE_SourceBuffer;

    TKDT23DEyanmicSourceBuffer = packed array of PKDT23DE_Source;
    PKDT23DEyanmicSourceBuffer = ^TKDT23DEyanmicSourceBuffer;

    TKDT23DEyanmicStoreBuffer = packed array of TKDT23DE_Source;
    PKDT23DEyanmicStoreBuffer = ^TKDT23DEyanmicStoreBuffer;

    PKDT23DE_Node = ^TKDT23DE_Node;

    TKDT23DE_Node = packed record
      Parent, Right, Left: PKDT23DE_Node;
      vec: PKDT23DE_Source;
    end;

    TKDT23DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT23DE_Source; const Data: Pointer);
    TKDT23DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT23DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT23DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT23DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT23DEyanmicStoreBuffer;
    KDBuff     : TKDT23DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT23DE_Node;
    TestBuff   : TKDT23DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DE_Node;
    function GetData(const index: NativeInt): PKDT23DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT23DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT23DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT23DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT23DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DE_Node; overload;
    function Search(const Buff: TKDT23DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DE_Node; overload;
    function Search(const Buff: TKDT23DE_Vec; var SearchedDistanceMin: Double): PKDT23DE_Node; overload;
    function Search(const Buff: TKDT23DE_Vec): PKDT23DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT23DE_DynamicVecBuffer; var OutBuff: TKDT23DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT23DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT23DE_Node);
    procedure PrintBuffer;

    class function KDT23DEVec(const s: string): TKDT23DE_Vec; overload;
    class function KDT23DEVec(const v: TKDT23DE_Vec): string; overload;
    class function KDT23DEPow(const v: TKDT23DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT23DEDistance(const v1, v2: TKDT23DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT23DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT24DE = class(TCoreClassObject)
  public type
    // code split
    TKDT24DE_Vec = array [0 .. KDT24DE_Axis - 1] of TKDT24DE_VecType;
    PKDT24DE_Vec = ^TKDT24DE_Vec;

    TKDT24DE_DynamicVecBuffer = packed array of TKDT24DE_Vec;
    PKDT24DE_DynamicVecBuffer = ^TKDT24DE_DynamicVecBuffer;

    TKDT24DE_Source = packed record
      Buff: TKDT24DE_Vec;
      index: Int64;
    end;

    PKDT24DE_Source       = ^TKDT24DE_Source;
    TKDT24DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT24DE_Source) - 1] of PKDT24DE_Source;
    PKDT24DE_SourceBuffer = ^TKDT24DE_SourceBuffer;

    TKDT24DEyanmicSourceBuffer = packed array of PKDT24DE_Source;
    PKDT24DEyanmicSourceBuffer = ^TKDT24DEyanmicSourceBuffer;

    TKDT24DEyanmicStoreBuffer = packed array of TKDT24DE_Source;
    PKDT24DEyanmicStoreBuffer = ^TKDT24DEyanmicStoreBuffer;

    PKDT24DE_Node = ^TKDT24DE_Node;

    TKDT24DE_Node = packed record
      Parent, Right, Left: PKDT24DE_Node;
      vec: PKDT24DE_Source;
    end;

    TKDT24DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT24DE_Source; const Data: Pointer);
    TKDT24DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT24DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT24DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT24DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT24DEyanmicStoreBuffer;
    KDBuff     : TKDT24DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT24DE_Node;
    TestBuff   : TKDT24DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DE_Node;
    function GetData(const index: NativeInt): PKDT24DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT24DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT24DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT24DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT24DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DE_Node; overload;
    function Search(const Buff: TKDT24DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DE_Node; overload;
    function Search(const Buff: TKDT24DE_Vec; var SearchedDistanceMin: Double): PKDT24DE_Node; overload;
    function Search(const Buff: TKDT24DE_Vec): PKDT24DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT24DE_DynamicVecBuffer; var OutBuff: TKDT24DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT24DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT24DE_Node);
    procedure PrintBuffer;

    class function KDT24DEVec(const s: string): TKDT24DE_Vec; overload;
    class function KDT24DEVec(const v: TKDT24DE_Vec): string; overload;
    class function KDT24DEPow(const v: TKDT24DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT24DEDistance(const v1, v2: TKDT24DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT24DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT25DE = class(TCoreClassObject)
  public type
    // code split
    TKDT25DE_Vec = array [0 .. KDT25DE_Axis - 1] of TKDT25DE_VecType;
    PKDT25DE_Vec = ^TKDT25DE_Vec;

    TKDT25DE_DynamicVecBuffer = packed array of TKDT25DE_Vec;
    PKDT25DE_DynamicVecBuffer = ^TKDT25DE_DynamicVecBuffer;

    TKDT25DE_Source = packed record
      Buff: TKDT25DE_Vec;
      index: Int64;
    end;

    PKDT25DE_Source       = ^TKDT25DE_Source;
    TKDT25DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT25DE_Source) - 1] of PKDT25DE_Source;
    PKDT25DE_SourceBuffer = ^TKDT25DE_SourceBuffer;

    TKDT25DEyanmicSourceBuffer = packed array of PKDT25DE_Source;
    PKDT25DEyanmicSourceBuffer = ^TKDT25DEyanmicSourceBuffer;

    TKDT25DEyanmicStoreBuffer = packed array of TKDT25DE_Source;
    PKDT25DEyanmicStoreBuffer = ^TKDT25DEyanmicStoreBuffer;

    PKDT25DE_Node = ^TKDT25DE_Node;

    TKDT25DE_Node = packed record
      Parent, Right, Left: PKDT25DE_Node;
      vec: PKDT25DE_Source;
    end;

    TKDT25DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT25DE_Source; const Data: Pointer);
    TKDT25DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT25DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT25DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT25DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT25DEyanmicStoreBuffer;
    KDBuff     : TKDT25DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT25DE_Node;
    TestBuff   : TKDT25DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT25DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT25DE_Node;
    function GetData(const index: NativeInt): PKDT25DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT25DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT25DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT25DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT25DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT25DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT25DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT25DE_Node; overload;
    function Search(const Buff: TKDT25DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT25DE_Node; overload;
    function Search(const Buff: TKDT25DE_Vec; var SearchedDistanceMin: Double): PKDT25DE_Node; overload;
    function Search(const Buff: TKDT25DE_Vec): PKDT25DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT25DE_DynamicVecBuffer; var OutBuff: TKDT25DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT25DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT25DE_Node);
    procedure PrintBuffer;

    class function KDT25DEVec(const s: string): TKDT25DE_Vec; overload;
    class function KDT25DEVec(const v: TKDT25DE_Vec): string; overload;
    class function KDT25DEPow(const v: TKDT25DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT25DEDistance(const v1, v2: TKDT25DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT25DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT26DE = class(TCoreClassObject)
  public type
    // code split
    TKDT26DE_Vec = array [0 .. KDT26DE_Axis - 1] of TKDT26DE_VecType;
    PKDT26DE_Vec = ^TKDT26DE_Vec;

    TKDT26DE_DynamicVecBuffer = packed array of TKDT26DE_Vec;
    PKDT26DE_DynamicVecBuffer = ^TKDT26DE_DynamicVecBuffer;

    TKDT26DE_Source = packed record
      Buff: TKDT26DE_Vec;
      index: Int64;
    end;

    PKDT26DE_Source       = ^TKDT26DE_Source;
    TKDT26DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT26DE_Source) - 1] of PKDT26DE_Source;
    PKDT26DE_SourceBuffer = ^TKDT26DE_SourceBuffer;

    TKDT26DEyanmicSourceBuffer = packed array of PKDT26DE_Source;
    PKDT26DEyanmicSourceBuffer = ^TKDT26DEyanmicSourceBuffer;

    TKDT26DEyanmicStoreBuffer = packed array of TKDT26DE_Source;
    PKDT26DEyanmicStoreBuffer = ^TKDT26DEyanmicStoreBuffer;

    PKDT26DE_Node = ^TKDT26DE_Node;

    TKDT26DE_Node = packed record
      Parent, Right, Left: PKDT26DE_Node;
      vec: PKDT26DE_Source;
    end;

    TKDT26DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT26DE_Source; const Data: Pointer);
    TKDT26DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT26DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT26DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT26DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT26DEyanmicStoreBuffer;
    KDBuff     : TKDT26DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT26DE_Node;
    TestBuff   : TKDT26DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT26DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT26DE_Node;
    function GetData(const index: NativeInt): PKDT26DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT26DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT26DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT26DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT26DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT26DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT26DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT26DE_Node; overload;
    function Search(const Buff: TKDT26DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT26DE_Node; overload;
    function Search(const Buff: TKDT26DE_Vec; var SearchedDistanceMin: Double): PKDT26DE_Node; overload;
    function Search(const Buff: TKDT26DE_Vec): PKDT26DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT26DE_DynamicVecBuffer; var OutBuff: TKDT26DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT26DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT26DE_Node);
    procedure PrintBuffer;

    class function KDT26DEVec(const s: string): TKDT26DE_Vec; overload;
    class function KDT26DEVec(const v: TKDT26DE_Vec): string; overload;
    class function KDT26DEPow(const v: TKDT26DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT26DEDistance(const v1, v2: TKDT26DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT26DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT27DE = class(TCoreClassObject)
  public type
    // code split
    TKDT27DE_Vec = array [0 .. KDT27DE_Axis - 1] of TKDT27DE_VecType;
    PKDT27DE_Vec = ^TKDT27DE_Vec;

    TKDT27DE_DynamicVecBuffer = packed array of TKDT27DE_Vec;
    PKDT27DE_DynamicVecBuffer = ^TKDT27DE_DynamicVecBuffer;

    TKDT27DE_Source = packed record
      Buff: TKDT27DE_Vec;
      index: Int64;
    end;

    PKDT27DE_Source       = ^TKDT27DE_Source;
    TKDT27DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT27DE_Source) - 1] of PKDT27DE_Source;
    PKDT27DE_SourceBuffer = ^TKDT27DE_SourceBuffer;

    TKDT27DEyanmicSourceBuffer = packed array of PKDT27DE_Source;
    PKDT27DEyanmicSourceBuffer = ^TKDT27DEyanmicSourceBuffer;

    TKDT27DEyanmicStoreBuffer = packed array of TKDT27DE_Source;
    PKDT27DEyanmicStoreBuffer = ^TKDT27DEyanmicStoreBuffer;

    PKDT27DE_Node = ^TKDT27DE_Node;

    TKDT27DE_Node = packed record
      Parent, Right, Left: PKDT27DE_Node;
      vec: PKDT27DE_Source;
    end;

    TKDT27DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT27DE_Source; const Data: Pointer);
    TKDT27DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT27DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT27DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT27DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT27DEyanmicStoreBuffer;
    KDBuff     : TKDT27DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT27DE_Node;
    TestBuff   : TKDT27DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT27DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT27DE_Node;
    function GetData(const index: NativeInt): PKDT27DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT27DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT27DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT27DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT27DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT27DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT27DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT27DE_Node; overload;
    function Search(const Buff: TKDT27DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT27DE_Node; overload;
    function Search(const Buff: TKDT27DE_Vec; var SearchedDistanceMin: Double): PKDT27DE_Node; overload;
    function Search(const Buff: TKDT27DE_Vec): PKDT27DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT27DE_DynamicVecBuffer; var OutBuff: TKDT27DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT27DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT27DE_Node);
    procedure PrintBuffer;

    class function KDT27DEVec(const s: string): TKDT27DE_Vec; overload;
    class function KDT27DEVec(const v: TKDT27DE_Vec): string; overload;
    class function KDT27DEPow(const v: TKDT27DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT27DEDistance(const v1, v2: TKDT27DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT27DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT28DE = class(TCoreClassObject)
  public type
    // code split
    TKDT28DE_Vec = array [0 .. KDT28DE_Axis - 1] of TKDT28DE_VecType;
    PKDT28DE_Vec = ^TKDT28DE_Vec;

    TKDT28DE_DynamicVecBuffer = packed array of TKDT28DE_Vec;
    PKDT28DE_DynamicVecBuffer = ^TKDT28DE_DynamicVecBuffer;

    TKDT28DE_Source = packed record
      Buff: TKDT28DE_Vec;
      index: Int64;
    end;

    PKDT28DE_Source       = ^TKDT28DE_Source;
    TKDT28DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT28DE_Source) - 1] of PKDT28DE_Source;
    PKDT28DE_SourceBuffer = ^TKDT28DE_SourceBuffer;

    TKDT28DEyanmicSourceBuffer = packed array of PKDT28DE_Source;
    PKDT28DEyanmicSourceBuffer = ^TKDT28DEyanmicSourceBuffer;

    TKDT28DEyanmicStoreBuffer = packed array of TKDT28DE_Source;
    PKDT28DEyanmicStoreBuffer = ^TKDT28DEyanmicStoreBuffer;

    PKDT28DE_Node = ^TKDT28DE_Node;

    TKDT28DE_Node = packed record
      Parent, Right, Left: PKDT28DE_Node;
      vec: PKDT28DE_Source;
    end;

    TKDT28DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT28DE_Source; const Data: Pointer);
    TKDT28DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT28DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT28DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT28DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT28DEyanmicStoreBuffer;
    KDBuff     : TKDT28DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT28DE_Node;
    TestBuff   : TKDT28DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DE_Node;
    function GetData(const index: NativeInt): PKDT28DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT28DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT28DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT28DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT28DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DE_Node; overload;
    function Search(const Buff: TKDT28DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DE_Node; overload;
    function Search(const Buff: TKDT28DE_Vec; var SearchedDistanceMin: Double): PKDT28DE_Node; overload;
    function Search(const Buff: TKDT28DE_Vec): PKDT28DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT28DE_DynamicVecBuffer; var OutBuff: TKDT28DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT28DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT28DE_Node);
    procedure PrintBuffer;

    class function KDT28DEVec(const s: string): TKDT28DE_Vec; overload;
    class function KDT28DEVec(const v: TKDT28DE_Vec): string; overload;
    class function KDT28DEPow(const v: TKDT28DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT28DEDistance(const v1, v2: TKDT28DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT28DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT29DE = class(TCoreClassObject)
  public type
    // code split
    TKDT29DE_Vec = array [0 .. KDT29DE_Axis - 1] of TKDT29DE_VecType;
    PKDT29DE_Vec = ^TKDT29DE_Vec;

    TKDT29DE_DynamicVecBuffer = packed array of TKDT29DE_Vec;
    PKDT29DE_DynamicVecBuffer = ^TKDT29DE_DynamicVecBuffer;

    TKDT29DE_Source = packed record
      Buff: TKDT29DE_Vec;
      index: Int64;
    end;

    PKDT29DE_Source       = ^TKDT29DE_Source;
    TKDT29DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT29DE_Source) - 1] of PKDT29DE_Source;
    PKDT29DE_SourceBuffer = ^TKDT29DE_SourceBuffer;

    TKDT29DEyanmicSourceBuffer = packed array of PKDT29DE_Source;
    PKDT29DEyanmicSourceBuffer = ^TKDT29DEyanmicSourceBuffer;

    TKDT29DEyanmicStoreBuffer = packed array of TKDT29DE_Source;
    PKDT29DEyanmicStoreBuffer = ^TKDT29DEyanmicStoreBuffer;

    PKDT29DE_Node = ^TKDT29DE_Node;

    TKDT29DE_Node = packed record
      Parent, Right, Left: PKDT29DE_Node;
      vec: PKDT29DE_Source;
    end;

    TKDT29DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT29DE_Source; const Data: Pointer);
    TKDT29DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT29DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT29DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT29DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT29DEyanmicStoreBuffer;
    KDBuff     : TKDT29DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT29DE_Node;
    TestBuff   : TKDT29DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT29DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT29DE_Node;
    function GetData(const index: NativeInt): PKDT29DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT29DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT29DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT29DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT29DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT29DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT29DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT29DE_Node; overload;
    function Search(const Buff: TKDT29DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT29DE_Node; overload;
    function Search(const Buff: TKDT29DE_Vec; var SearchedDistanceMin: Double): PKDT29DE_Node; overload;
    function Search(const Buff: TKDT29DE_Vec): PKDT29DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT29DE_DynamicVecBuffer; var OutBuff: TKDT29DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT29DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT29DE_Node);
    procedure PrintBuffer;

    class function KDT29DEVec(const s: string): TKDT29DE_Vec; overload;
    class function KDT29DEVec(const v: TKDT29DE_Vec): string; overload;
    class function KDT29DEPow(const v: TKDT29DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT29DEDistance(const v1, v2: TKDT29DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT29DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT30DE = class(TCoreClassObject)
  public type
    // code split
    TKDT30DE_Vec = array [0 .. KDT30DE_Axis - 1] of TKDT30DE_VecType;
    PKDT30DE_Vec = ^TKDT30DE_Vec;

    TKDT30DE_DynamicVecBuffer = packed array of TKDT30DE_Vec;
    PKDT30DE_DynamicVecBuffer = ^TKDT30DE_DynamicVecBuffer;

    TKDT30DE_Source = packed record
      Buff: TKDT30DE_Vec;
      index: Int64;
    end;

    PKDT30DE_Source       = ^TKDT30DE_Source;
    TKDT30DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT30DE_Source) - 1] of PKDT30DE_Source;
    PKDT30DE_SourceBuffer = ^TKDT30DE_SourceBuffer;

    TKDT30DEyanmicSourceBuffer = packed array of PKDT30DE_Source;
    PKDT30DEyanmicSourceBuffer = ^TKDT30DEyanmicSourceBuffer;

    TKDT30DEyanmicStoreBuffer = packed array of TKDT30DE_Source;
    PKDT30DEyanmicStoreBuffer = ^TKDT30DEyanmicStoreBuffer;

    PKDT30DE_Node = ^TKDT30DE_Node;

    TKDT30DE_Node = packed record
      Parent, Right, Left: PKDT30DE_Node;
      vec: PKDT30DE_Source;
    end;

    TKDT30DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT30DE_Source; const Data: Pointer);
    TKDT30DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT30DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT30DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT30DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT30DEyanmicStoreBuffer;
    KDBuff     : TKDT30DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT30DE_Node;
    TestBuff   : TKDT30DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DE_Node;
    function GetData(const index: NativeInt): PKDT30DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT30DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT30DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT30DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT30DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DE_Node; overload;
    function Search(const Buff: TKDT30DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DE_Node; overload;
    function Search(const Buff: TKDT30DE_Vec; var SearchedDistanceMin: Double): PKDT30DE_Node; overload;
    function Search(const Buff: TKDT30DE_Vec): PKDT30DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT30DE_DynamicVecBuffer; var OutBuff: TKDT30DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT30DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT30DE_Node);
    procedure PrintBuffer;

    class function KDT30DEVec(const s: string): TKDT30DE_Vec; overload;
    class function KDT30DEVec(const v: TKDT30DE_Vec): string; overload;
    class function KDT30DEPow(const v: TKDT30DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT30DEDistance(const v1, v2: TKDT30DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT30DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT31DE = class(TCoreClassObject)
  public type
    // code split
    TKDT31DE_Vec = array [0 .. KDT31DE_Axis - 1] of TKDT31DE_VecType;
    PKDT31DE_Vec = ^TKDT31DE_Vec;

    TKDT31DE_DynamicVecBuffer = packed array of TKDT31DE_Vec;
    PKDT31DE_DynamicVecBuffer = ^TKDT31DE_DynamicVecBuffer;

    TKDT31DE_Source = packed record
      Buff: TKDT31DE_Vec;
      index: Int64;
    end;

    PKDT31DE_Source       = ^TKDT31DE_Source;
    TKDT31DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT31DE_Source) - 1] of PKDT31DE_Source;
    PKDT31DE_SourceBuffer = ^TKDT31DE_SourceBuffer;

    TKDT31DEyanmicSourceBuffer = packed array of PKDT31DE_Source;
    PKDT31DEyanmicSourceBuffer = ^TKDT31DEyanmicSourceBuffer;

    TKDT31DEyanmicStoreBuffer = packed array of TKDT31DE_Source;
    PKDT31DEyanmicStoreBuffer = ^TKDT31DEyanmicStoreBuffer;

    PKDT31DE_Node = ^TKDT31DE_Node;

    TKDT31DE_Node = packed record
      Parent, Right, Left: PKDT31DE_Node;
      vec: PKDT31DE_Source;
    end;

    TKDT31DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT31DE_Source; const Data: Pointer);
    TKDT31DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT31DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT31DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT31DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT31DEyanmicStoreBuffer;
    KDBuff     : TKDT31DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT31DE_Node;
    TestBuff   : TKDT31DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT31DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT31DE_Node;
    function GetData(const index: NativeInt): PKDT31DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT31DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT31DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT31DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT31DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT31DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT31DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT31DE_Node; overload;
    function Search(const Buff: TKDT31DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT31DE_Node; overload;
    function Search(const Buff: TKDT31DE_Vec; var SearchedDistanceMin: Double): PKDT31DE_Node; overload;
    function Search(const Buff: TKDT31DE_Vec): PKDT31DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT31DE_DynamicVecBuffer; var OutBuff: TKDT31DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT31DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT31DE_Node);
    procedure PrintBuffer;

    class function KDT31DEVec(const s: string): TKDT31DE_Vec; overload;
    class function KDT31DEVec(const v: TKDT31DE_Vec): string; overload;
    class function KDT31DEPow(const v: TKDT31DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT31DEDistance(const v1, v2: TKDT31DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT31DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT32DE = class(TCoreClassObject)
  public type
    // code split
    TKDT32DE_Vec = array [0 .. KDT32DE_Axis - 1] of TKDT32DE_VecType;
    PKDT32DE_Vec = ^TKDT32DE_Vec;

    TKDT32DE_DynamicVecBuffer = packed array of TKDT32DE_Vec;
    PKDT32DE_DynamicVecBuffer = ^TKDT32DE_DynamicVecBuffer;

    TKDT32DE_Source = packed record
      Buff: TKDT32DE_Vec;
      index: Int64;
    end;

    PKDT32DE_Source       = ^TKDT32DE_Source;
    TKDT32DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT32DE_Source) - 1] of PKDT32DE_Source;
    PKDT32DE_SourceBuffer = ^TKDT32DE_SourceBuffer;

    TKDT32DEyanmicSourceBuffer = packed array of PKDT32DE_Source;
    PKDT32DEyanmicSourceBuffer = ^TKDT32DEyanmicSourceBuffer;

    TKDT32DEyanmicStoreBuffer = packed array of TKDT32DE_Source;
    PKDT32DEyanmicStoreBuffer = ^TKDT32DEyanmicStoreBuffer;

    PKDT32DE_Node = ^TKDT32DE_Node;

    TKDT32DE_Node = packed record
      Parent, Right, Left: PKDT32DE_Node;
      vec: PKDT32DE_Source;
    end;

    TKDT32DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT32DE_Source; const Data: Pointer);
    TKDT32DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT32DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT32DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT32DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT32DEyanmicStoreBuffer;
    KDBuff     : TKDT32DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT32DE_Node;
    TestBuff   : TKDT32DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DE_Node;
    function GetData(const index: NativeInt): PKDT32DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT32DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT32DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT32DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT32DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DE_Node; overload;
    function Search(const Buff: TKDT32DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DE_Node; overload;
    function Search(const Buff: TKDT32DE_Vec; var SearchedDistanceMin: Double): PKDT32DE_Node; overload;
    function Search(const Buff: TKDT32DE_Vec): PKDT32DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT32DE_DynamicVecBuffer; var OutBuff: TKDT32DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT32DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT32DE_Node);
    procedure PrintBuffer;

    class function KDT32DEVec(const s: string): TKDT32DE_Vec; overload;
    class function KDT32DEVec(const v: TKDT32DE_Vec): string; overload;
    class function KDT32DEPow(const v: TKDT32DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT32DEDistance(const v1, v2: TKDT32DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT32DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT33DE = class(TCoreClassObject)
  public type
    // code split
    TKDT33DE_Vec = array [0 .. KDT33DE_Axis - 1] of TKDT33DE_VecType;
    PKDT33DE_Vec = ^TKDT33DE_Vec;

    TKDT33DE_DynamicVecBuffer = packed array of TKDT33DE_Vec;
    PKDT33DE_DynamicVecBuffer = ^TKDT33DE_DynamicVecBuffer;

    TKDT33DE_Source = packed record
      Buff: TKDT33DE_Vec;
      index: Int64;
    end;

    PKDT33DE_Source       = ^TKDT33DE_Source;
    TKDT33DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT33DE_Source) - 1] of PKDT33DE_Source;
    PKDT33DE_SourceBuffer = ^TKDT33DE_SourceBuffer;

    TKDT33DEyanmicSourceBuffer = packed array of PKDT33DE_Source;
    PKDT33DEyanmicSourceBuffer = ^TKDT33DEyanmicSourceBuffer;

    TKDT33DEyanmicStoreBuffer = packed array of TKDT33DE_Source;
    PKDT33DEyanmicStoreBuffer = ^TKDT33DEyanmicStoreBuffer;

    PKDT33DE_Node = ^TKDT33DE_Node;

    TKDT33DE_Node = packed record
      Parent, Right, Left: PKDT33DE_Node;
      vec: PKDT33DE_Source;
    end;

    TKDT33DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT33DE_Source; const Data: Pointer);
    TKDT33DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT33DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT33DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT33DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT33DEyanmicStoreBuffer;
    KDBuff     : TKDT33DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT33DE_Node;
    TestBuff   : TKDT33DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT33DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT33DE_Node;
    function GetData(const index: NativeInt): PKDT33DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT33DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT33DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT33DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT33DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT33DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT33DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT33DE_Node; overload;
    function Search(const Buff: TKDT33DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT33DE_Node; overload;
    function Search(const Buff: TKDT33DE_Vec; var SearchedDistanceMin: Double): PKDT33DE_Node; overload;
    function Search(const Buff: TKDT33DE_Vec): PKDT33DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT33DE_DynamicVecBuffer; var OutBuff: TKDT33DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT33DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT33DE_Node);
    procedure PrintBuffer;

    class function KDT33DEVec(const s: string): TKDT33DE_Vec; overload;
    class function KDT33DEVec(const v: TKDT33DE_Vec): string; overload;
    class function KDT33DEPow(const v: TKDT33DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT33DEDistance(const v1, v2: TKDT33DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT33DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT34DE = class(TCoreClassObject)
  public type
    // code split
    TKDT34DE_Vec = array [0 .. KDT34DE_Axis - 1] of TKDT34DE_VecType;
    PKDT34DE_Vec = ^TKDT34DE_Vec;

    TKDT34DE_DynamicVecBuffer = packed array of TKDT34DE_Vec;
    PKDT34DE_DynamicVecBuffer = ^TKDT34DE_DynamicVecBuffer;

    TKDT34DE_Source = packed record
      Buff: TKDT34DE_Vec;
      index: Int64;
    end;

    PKDT34DE_Source       = ^TKDT34DE_Source;
    TKDT34DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT34DE_Source) - 1] of PKDT34DE_Source;
    PKDT34DE_SourceBuffer = ^TKDT34DE_SourceBuffer;

    TKDT34DEyanmicSourceBuffer = packed array of PKDT34DE_Source;
    PKDT34DEyanmicSourceBuffer = ^TKDT34DEyanmicSourceBuffer;

    TKDT34DEyanmicStoreBuffer = packed array of TKDT34DE_Source;
    PKDT34DEyanmicStoreBuffer = ^TKDT34DEyanmicStoreBuffer;

    PKDT34DE_Node = ^TKDT34DE_Node;

    TKDT34DE_Node = packed record
      Parent, Right, Left: PKDT34DE_Node;
      vec: PKDT34DE_Source;
    end;

    TKDT34DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT34DE_Source; const Data: Pointer);
    TKDT34DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT34DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT34DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT34DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT34DEyanmicStoreBuffer;
    KDBuff     : TKDT34DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT34DE_Node;
    TestBuff   : TKDT34DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DE_Node;
    function GetData(const index: NativeInt): PKDT34DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT34DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT34DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT34DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT34DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DE_Node; overload;
    function Search(const Buff: TKDT34DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DE_Node; overload;
    function Search(const Buff: TKDT34DE_Vec; var SearchedDistanceMin: Double): PKDT34DE_Node; overload;
    function Search(const Buff: TKDT34DE_Vec): PKDT34DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT34DE_DynamicVecBuffer; var OutBuff: TKDT34DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT34DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT34DE_Node);
    procedure PrintBuffer;

    class function KDT34DEVec(const s: string): TKDT34DE_Vec; overload;
    class function KDT34DEVec(const v: TKDT34DE_Vec): string; overload;
    class function KDT34DEPow(const v: TKDT34DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT34DEDistance(const v1, v2: TKDT34DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT34DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT35DE = class(TCoreClassObject)
  public type
    // code split
    TKDT35DE_Vec = array [0 .. KDT35DE_Axis - 1] of TKDT35DE_VecType;
    PKDT35DE_Vec = ^TKDT35DE_Vec;

    TKDT35DE_DynamicVecBuffer = packed array of TKDT35DE_Vec;
    PKDT35DE_DynamicVecBuffer = ^TKDT35DE_DynamicVecBuffer;

    TKDT35DE_Source = packed record
      Buff: TKDT35DE_Vec;
      index: Int64;
    end;

    PKDT35DE_Source       = ^TKDT35DE_Source;
    TKDT35DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT35DE_Source) - 1] of PKDT35DE_Source;
    PKDT35DE_SourceBuffer = ^TKDT35DE_SourceBuffer;

    TKDT35DEyanmicSourceBuffer = packed array of PKDT35DE_Source;
    PKDT35DEyanmicSourceBuffer = ^TKDT35DEyanmicSourceBuffer;

    TKDT35DEyanmicStoreBuffer = packed array of TKDT35DE_Source;
    PKDT35DEyanmicStoreBuffer = ^TKDT35DEyanmicStoreBuffer;

    PKDT35DE_Node = ^TKDT35DE_Node;

    TKDT35DE_Node = packed record
      Parent, Right, Left: PKDT35DE_Node;
      vec: PKDT35DE_Source;
    end;

    TKDT35DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT35DE_Source; const Data: Pointer);
    TKDT35DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT35DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT35DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT35DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT35DEyanmicStoreBuffer;
    KDBuff     : TKDT35DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT35DE_Node;
    TestBuff   : TKDT35DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT35DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT35DE_Node;
    function GetData(const index: NativeInt): PKDT35DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT35DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT35DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT35DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT35DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT35DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT35DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT35DE_Node; overload;
    function Search(const Buff: TKDT35DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT35DE_Node; overload;
    function Search(const Buff: TKDT35DE_Vec; var SearchedDistanceMin: Double): PKDT35DE_Node; overload;
    function Search(const Buff: TKDT35DE_Vec): PKDT35DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT35DE_DynamicVecBuffer; var OutBuff: TKDT35DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT35DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT35DE_Node);
    procedure PrintBuffer;

    class function KDT35DEVec(const s: string): TKDT35DE_Vec; overload;
    class function KDT35DEVec(const v: TKDT35DE_Vec): string; overload;
    class function KDT35DEPow(const v: TKDT35DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT35DEDistance(const v1, v2: TKDT35DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT35DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT36DE = class(TCoreClassObject)
  public type
    // code split
    TKDT36DE_Vec = array [0 .. KDT36DE_Axis - 1] of TKDT36DE_VecType;
    PKDT36DE_Vec = ^TKDT36DE_Vec;

    TKDT36DE_DynamicVecBuffer = packed array of TKDT36DE_Vec;
    PKDT36DE_DynamicVecBuffer = ^TKDT36DE_DynamicVecBuffer;

    TKDT36DE_Source = packed record
      Buff: TKDT36DE_Vec;
      index: Int64;
    end;

    PKDT36DE_Source       = ^TKDT36DE_Source;
    TKDT36DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT36DE_Source) - 1] of PKDT36DE_Source;
    PKDT36DE_SourceBuffer = ^TKDT36DE_SourceBuffer;

    TKDT36DEyanmicSourceBuffer = packed array of PKDT36DE_Source;
    PKDT36DEyanmicSourceBuffer = ^TKDT36DEyanmicSourceBuffer;

    TKDT36DEyanmicStoreBuffer = packed array of TKDT36DE_Source;
    PKDT36DEyanmicStoreBuffer = ^TKDT36DEyanmicStoreBuffer;

    PKDT36DE_Node = ^TKDT36DE_Node;

    TKDT36DE_Node = packed record
      Parent, Right, Left: PKDT36DE_Node;
      vec: PKDT36DE_Source;
    end;

    TKDT36DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT36DE_Source; const Data: Pointer);
    TKDT36DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT36DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT36DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT36DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT36DEyanmicStoreBuffer;
    KDBuff     : TKDT36DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT36DE_Node;
    TestBuff   : TKDT36DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DE_Node;
    function GetData(const index: NativeInt): PKDT36DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT36DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT36DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT36DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT36DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DE_Node; overload;
    function Search(const Buff: TKDT36DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DE_Node; overload;
    function Search(const Buff: TKDT36DE_Vec; var SearchedDistanceMin: Double): PKDT36DE_Node; overload;
    function Search(const Buff: TKDT36DE_Vec): PKDT36DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT36DE_DynamicVecBuffer; var OutBuff: TKDT36DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT36DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT36DE_Node);
    procedure PrintBuffer;

    class function KDT36DEVec(const s: string): TKDT36DE_Vec; overload;
    class function KDT36DEVec(const v: TKDT36DE_Vec): string; overload;
    class function KDT36DEPow(const v: TKDT36DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT36DEDistance(const v1, v2: TKDT36DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT36DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT37DE = class(TCoreClassObject)
  public type
    // code split
    TKDT37DE_Vec = array [0 .. KDT37DE_Axis - 1] of TKDT37DE_VecType;
    PKDT37DE_Vec = ^TKDT37DE_Vec;

    TKDT37DE_DynamicVecBuffer = packed array of TKDT37DE_Vec;
    PKDT37DE_DynamicVecBuffer = ^TKDT37DE_DynamicVecBuffer;

    TKDT37DE_Source = packed record
      Buff: TKDT37DE_Vec;
      index: Int64;
    end;

    PKDT37DE_Source       = ^TKDT37DE_Source;
    TKDT37DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT37DE_Source) - 1] of PKDT37DE_Source;
    PKDT37DE_SourceBuffer = ^TKDT37DE_SourceBuffer;

    TKDT37DEyanmicSourceBuffer = packed array of PKDT37DE_Source;
    PKDT37DEyanmicSourceBuffer = ^TKDT37DEyanmicSourceBuffer;

    TKDT37DEyanmicStoreBuffer = packed array of TKDT37DE_Source;
    PKDT37DEyanmicStoreBuffer = ^TKDT37DEyanmicStoreBuffer;

    PKDT37DE_Node = ^TKDT37DE_Node;

    TKDT37DE_Node = packed record
      Parent, Right, Left: PKDT37DE_Node;
      vec: PKDT37DE_Source;
    end;

    TKDT37DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT37DE_Source; const Data: Pointer);
    TKDT37DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT37DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT37DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT37DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT37DEyanmicStoreBuffer;
    KDBuff     : TKDT37DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT37DE_Node;
    TestBuff   : TKDT37DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT37DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT37DE_Node;
    function GetData(const index: NativeInt): PKDT37DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT37DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT37DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT37DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT37DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT37DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT37DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT37DE_Node; overload;
    function Search(const Buff: TKDT37DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT37DE_Node; overload;
    function Search(const Buff: TKDT37DE_Vec; var SearchedDistanceMin: Double): PKDT37DE_Node; overload;
    function Search(const Buff: TKDT37DE_Vec): PKDT37DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT37DE_DynamicVecBuffer; var OutBuff: TKDT37DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT37DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT37DE_Node);
    procedure PrintBuffer;

    class function KDT37DEVec(const s: string): TKDT37DE_Vec; overload;
    class function KDT37DEVec(const v: TKDT37DE_Vec): string; overload;
    class function KDT37DEPow(const v: TKDT37DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT37DEDistance(const v1, v2: TKDT37DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT37DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT38DE = class(TCoreClassObject)
  public type
    // code split
    TKDT38DE_Vec = array [0 .. KDT38DE_Axis - 1] of TKDT38DE_VecType;
    PKDT38DE_Vec = ^TKDT38DE_Vec;

    TKDT38DE_DynamicVecBuffer = packed array of TKDT38DE_Vec;
    PKDT38DE_DynamicVecBuffer = ^TKDT38DE_DynamicVecBuffer;

    TKDT38DE_Source = packed record
      Buff: TKDT38DE_Vec;
      index: Int64;
    end;

    PKDT38DE_Source       = ^TKDT38DE_Source;
    TKDT38DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT38DE_Source) - 1] of PKDT38DE_Source;
    PKDT38DE_SourceBuffer = ^TKDT38DE_SourceBuffer;

    TKDT38DEyanmicSourceBuffer = packed array of PKDT38DE_Source;
    PKDT38DEyanmicSourceBuffer = ^TKDT38DEyanmicSourceBuffer;

    TKDT38DEyanmicStoreBuffer = packed array of TKDT38DE_Source;
    PKDT38DEyanmicStoreBuffer = ^TKDT38DEyanmicStoreBuffer;

    PKDT38DE_Node = ^TKDT38DE_Node;

    TKDT38DE_Node = packed record
      Parent, Right, Left: PKDT38DE_Node;
      vec: PKDT38DE_Source;
    end;

    TKDT38DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT38DE_Source; const Data: Pointer);
    TKDT38DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT38DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT38DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT38DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT38DEyanmicStoreBuffer;
    KDBuff     : TKDT38DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT38DE_Node;
    TestBuff   : TKDT38DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT38DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT38DE_Node;
    function GetData(const index: NativeInt): PKDT38DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT38DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT38DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT38DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT38DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT38DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT38DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT38DE_Node; overload;
    function Search(const Buff: TKDT38DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT38DE_Node; overload;
    function Search(const Buff: TKDT38DE_Vec; var SearchedDistanceMin: Double): PKDT38DE_Node; overload;
    function Search(const Buff: TKDT38DE_Vec): PKDT38DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT38DE_DynamicVecBuffer; var OutBuff: TKDT38DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT38DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT38DE_Node);
    procedure PrintBuffer;

    class function KDT38DEVec(const s: string): TKDT38DE_Vec; overload;
    class function KDT38DEVec(const v: TKDT38DE_Vec): string; overload;
    class function KDT38DEPow(const v: TKDT38DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT38DEDistance(const v1, v2: TKDT38DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT38DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT39DE = class(TCoreClassObject)
  public type
    // code split
    TKDT39DE_Vec = array [0 .. KDT39DE_Axis - 1] of TKDT39DE_VecType;
    PKDT39DE_Vec = ^TKDT39DE_Vec;

    TKDT39DE_DynamicVecBuffer = packed array of TKDT39DE_Vec;
    PKDT39DE_DynamicVecBuffer = ^TKDT39DE_DynamicVecBuffer;

    TKDT39DE_Source = packed record
      Buff: TKDT39DE_Vec;
      index: Int64;
    end;

    PKDT39DE_Source       = ^TKDT39DE_Source;
    TKDT39DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT39DE_Source) - 1] of PKDT39DE_Source;
    PKDT39DE_SourceBuffer = ^TKDT39DE_SourceBuffer;

    TKDT39DEyanmicSourceBuffer = packed array of PKDT39DE_Source;
    PKDT39DEyanmicSourceBuffer = ^TKDT39DEyanmicSourceBuffer;

    TKDT39DEyanmicStoreBuffer = packed array of TKDT39DE_Source;
    PKDT39DEyanmicStoreBuffer = ^TKDT39DEyanmicStoreBuffer;

    PKDT39DE_Node = ^TKDT39DE_Node;

    TKDT39DE_Node = packed record
      Parent, Right, Left: PKDT39DE_Node;
      vec: PKDT39DE_Source;
    end;

    TKDT39DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT39DE_Source; const Data: Pointer);
    TKDT39DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT39DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT39DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT39DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT39DEyanmicStoreBuffer;
    KDBuff     : TKDT39DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT39DE_Node;
    TestBuff   : TKDT39DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT39DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT39DE_Node;
    function GetData(const index: NativeInt): PKDT39DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT39DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT39DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT39DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT39DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT39DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT39DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT39DE_Node; overload;
    function Search(const Buff: TKDT39DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT39DE_Node; overload;
    function Search(const Buff: TKDT39DE_Vec; var SearchedDistanceMin: Double): PKDT39DE_Node; overload;
    function Search(const Buff: TKDT39DE_Vec): PKDT39DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT39DE_DynamicVecBuffer; var OutBuff: TKDT39DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT39DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT39DE_Node);
    procedure PrintBuffer;

    class function KDT39DEVec(const s: string): TKDT39DE_Vec; overload;
    class function KDT39DEVec(const v: TKDT39DE_Vec): string; overload;
    class function KDT39DEPow(const v: TKDT39DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT39DEDistance(const v1, v2: TKDT39DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT39DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT40DE = class(TCoreClassObject)
  public type
    // code split
    TKDT40DE_Vec = array [0 .. KDT40DE_Axis - 1] of TKDT40DE_VecType;
    PKDT40DE_Vec = ^TKDT40DE_Vec;

    TKDT40DE_DynamicVecBuffer = packed array of TKDT40DE_Vec;
    PKDT40DE_DynamicVecBuffer = ^TKDT40DE_DynamicVecBuffer;

    TKDT40DE_Source = packed record
      Buff: TKDT40DE_Vec;
      index: Int64;
    end;

    PKDT40DE_Source       = ^TKDT40DE_Source;
    TKDT40DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT40DE_Source) - 1] of PKDT40DE_Source;
    PKDT40DE_SourceBuffer = ^TKDT40DE_SourceBuffer;

    TKDT40DEyanmicSourceBuffer = packed array of PKDT40DE_Source;
    PKDT40DEyanmicSourceBuffer = ^TKDT40DEyanmicSourceBuffer;

    TKDT40DEyanmicStoreBuffer = packed array of TKDT40DE_Source;
    PKDT40DEyanmicStoreBuffer = ^TKDT40DEyanmicStoreBuffer;

    PKDT40DE_Node = ^TKDT40DE_Node;

    TKDT40DE_Node = packed record
      Parent, Right, Left: PKDT40DE_Node;
      vec: PKDT40DE_Source;
    end;

    TKDT40DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT40DE_Source; const Data: Pointer);
    TKDT40DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT40DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT40DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT40DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT40DEyanmicStoreBuffer;
    KDBuff     : TKDT40DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT40DE_Node;
    TestBuff   : TKDT40DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DE_Node;
    function GetData(const index: NativeInt): PKDT40DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT40DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT40DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT40DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT40DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DE_Node; overload;
    function Search(const Buff: TKDT40DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DE_Node; overload;
    function Search(const Buff: TKDT40DE_Vec; var SearchedDistanceMin: Double): PKDT40DE_Node; overload;
    function Search(const Buff: TKDT40DE_Vec): PKDT40DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT40DE_DynamicVecBuffer; var OutBuff: TKDT40DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT40DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT40DE_Node);
    procedure PrintBuffer;

    class function KDT40DEVec(const s: string): TKDT40DE_Vec; overload;
    class function KDT40DEVec(const v: TKDT40DE_Vec): string; overload;
    class function KDT40DEPow(const v: TKDT40DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT40DEDistance(const v1, v2: TKDT40DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT40DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT41DE = class(TCoreClassObject)
  public type
    // code split
    TKDT41DE_Vec = array [0 .. KDT41DE_Axis - 1] of TKDT41DE_VecType;
    PKDT41DE_Vec = ^TKDT41DE_Vec;

    TKDT41DE_DynamicVecBuffer = packed array of TKDT41DE_Vec;
    PKDT41DE_DynamicVecBuffer = ^TKDT41DE_DynamicVecBuffer;

    TKDT41DE_Source = packed record
      Buff: TKDT41DE_Vec;
      index: Int64;
    end;

    PKDT41DE_Source       = ^TKDT41DE_Source;
    TKDT41DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT41DE_Source) - 1] of PKDT41DE_Source;
    PKDT41DE_SourceBuffer = ^TKDT41DE_SourceBuffer;

    TKDT41DEyanmicSourceBuffer = packed array of PKDT41DE_Source;
    PKDT41DEyanmicSourceBuffer = ^TKDT41DEyanmicSourceBuffer;

    TKDT41DEyanmicStoreBuffer = packed array of TKDT41DE_Source;
    PKDT41DEyanmicStoreBuffer = ^TKDT41DEyanmicStoreBuffer;

    PKDT41DE_Node = ^TKDT41DE_Node;

    TKDT41DE_Node = packed record
      Parent, Right, Left: PKDT41DE_Node;
      vec: PKDT41DE_Source;
    end;

    TKDT41DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT41DE_Source; const Data: Pointer);
    TKDT41DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT41DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT41DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT41DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT41DEyanmicStoreBuffer;
    KDBuff     : TKDT41DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT41DE_Node;
    TestBuff   : TKDT41DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT41DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT41DE_Node;
    function GetData(const index: NativeInt): PKDT41DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT41DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT41DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT41DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT41DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT41DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT41DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT41DE_Node; overload;
    function Search(const Buff: TKDT41DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT41DE_Node; overload;
    function Search(const Buff: TKDT41DE_Vec; var SearchedDistanceMin: Double): PKDT41DE_Node; overload;
    function Search(const Buff: TKDT41DE_Vec): PKDT41DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT41DE_DynamicVecBuffer; var OutBuff: TKDT41DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT41DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT41DE_Node);
    procedure PrintBuffer;

    class function KDT41DEVec(const s: string): TKDT41DE_Vec; overload;
    class function KDT41DEVec(const v: TKDT41DE_Vec): string; overload;
    class function KDT41DEPow(const v: TKDT41DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT41DEDistance(const v1, v2: TKDT41DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT41DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT42DE = class(TCoreClassObject)
  public type
    // code split
    TKDT42DE_Vec = array [0 .. KDT42DE_Axis - 1] of TKDT42DE_VecType;
    PKDT42DE_Vec = ^TKDT42DE_Vec;

    TKDT42DE_DynamicVecBuffer = packed array of TKDT42DE_Vec;
    PKDT42DE_DynamicVecBuffer = ^TKDT42DE_DynamicVecBuffer;

    TKDT42DE_Source = packed record
      Buff: TKDT42DE_Vec;
      index: Int64;
    end;

    PKDT42DE_Source       = ^TKDT42DE_Source;
    TKDT42DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT42DE_Source) - 1] of PKDT42DE_Source;
    PKDT42DE_SourceBuffer = ^TKDT42DE_SourceBuffer;

    TKDT42DEyanmicSourceBuffer = packed array of PKDT42DE_Source;
    PKDT42DEyanmicSourceBuffer = ^TKDT42DEyanmicSourceBuffer;

    TKDT42DEyanmicStoreBuffer = packed array of TKDT42DE_Source;
    PKDT42DEyanmicStoreBuffer = ^TKDT42DEyanmicStoreBuffer;

    PKDT42DE_Node = ^TKDT42DE_Node;

    TKDT42DE_Node = packed record
      Parent, Right, Left: PKDT42DE_Node;
      vec: PKDT42DE_Source;
    end;

    TKDT42DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT42DE_Source; const Data: Pointer);
    TKDT42DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT42DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT42DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT42DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT42DEyanmicStoreBuffer;
    KDBuff     : TKDT42DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT42DE_Node;
    TestBuff   : TKDT42DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT42DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT42DE_Node;
    function GetData(const index: NativeInt): PKDT42DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT42DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT42DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT42DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT42DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT42DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT42DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT42DE_Node; overload;
    function Search(const Buff: TKDT42DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT42DE_Node; overload;
    function Search(const Buff: TKDT42DE_Vec; var SearchedDistanceMin: Double): PKDT42DE_Node; overload;
    function Search(const Buff: TKDT42DE_Vec): PKDT42DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT42DE_DynamicVecBuffer; var OutBuff: TKDT42DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT42DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT42DE_Node);
    procedure PrintBuffer;

    class function KDT42DEVec(const s: string): TKDT42DE_Vec; overload;
    class function KDT42DEVec(const v: TKDT42DE_Vec): string; overload;
    class function KDT42DEPow(const v: TKDT42DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT42DEDistance(const v1, v2: TKDT42DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT42DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT43DE = class(TCoreClassObject)
  public type
    // code split
    TKDT43DE_Vec = array [0 .. KDT43DE_Axis - 1] of TKDT43DE_VecType;
    PKDT43DE_Vec = ^TKDT43DE_Vec;

    TKDT43DE_DynamicVecBuffer = packed array of TKDT43DE_Vec;
    PKDT43DE_DynamicVecBuffer = ^TKDT43DE_DynamicVecBuffer;

    TKDT43DE_Source = packed record
      Buff: TKDT43DE_Vec;
      index: Int64;
    end;

    PKDT43DE_Source       = ^TKDT43DE_Source;
    TKDT43DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT43DE_Source) - 1] of PKDT43DE_Source;
    PKDT43DE_SourceBuffer = ^TKDT43DE_SourceBuffer;

    TKDT43DEyanmicSourceBuffer = packed array of PKDT43DE_Source;
    PKDT43DEyanmicSourceBuffer = ^TKDT43DEyanmicSourceBuffer;

    TKDT43DEyanmicStoreBuffer = packed array of TKDT43DE_Source;
    PKDT43DEyanmicStoreBuffer = ^TKDT43DEyanmicStoreBuffer;

    PKDT43DE_Node = ^TKDT43DE_Node;

    TKDT43DE_Node = packed record
      Parent, Right, Left: PKDT43DE_Node;
      vec: PKDT43DE_Source;
    end;

    TKDT43DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT43DE_Source; const Data: Pointer);
    TKDT43DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT43DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT43DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT43DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT43DEyanmicStoreBuffer;
    KDBuff     : TKDT43DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT43DE_Node;
    TestBuff   : TKDT43DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT43DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT43DE_Node;
    function GetData(const index: NativeInt): PKDT43DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT43DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT43DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT43DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT43DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT43DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT43DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT43DE_Node; overload;
    function Search(const Buff: TKDT43DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT43DE_Node; overload;
    function Search(const Buff: TKDT43DE_Vec; var SearchedDistanceMin: Double): PKDT43DE_Node; overload;
    function Search(const Buff: TKDT43DE_Vec): PKDT43DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT43DE_DynamicVecBuffer; var OutBuff: TKDT43DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT43DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT43DE_Node);
    procedure PrintBuffer;

    class function KDT43DEVec(const s: string): TKDT43DE_Vec; overload;
    class function KDT43DEVec(const v: TKDT43DE_Vec): string; overload;
    class function KDT43DEPow(const v: TKDT43DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT43DEDistance(const v1, v2: TKDT43DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT43DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT44DE = class(TCoreClassObject)
  public type
    // code split
    TKDT44DE_Vec = array [0 .. KDT44DE_Axis - 1] of TKDT44DE_VecType;
    PKDT44DE_Vec = ^TKDT44DE_Vec;

    TKDT44DE_DynamicVecBuffer = packed array of TKDT44DE_Vec;
    PKDT44DE_DynamicVecBuffer = ^TKDT44DE_DynamicVecBuffer;

    TKDT44DE_Source = packed record
      Buff: TKDT44DE_Vec;
      index: Int64;
    end;

    PKDT44DE_Source       = ^TKDT44DE_Source;
    TKDT44DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT44DE_Source) - 1] of PKDT44DE_Source;
    PKDT44DE_SourceBuffer = ^TKDT44DE_SourceBuffer;

    TKDT44DEyanmicSourceBuffer = packed array of PKDT44DE_Source;
    PKDT44DEyanmicSourceBuffer = ^TKDT44DEyanmicSourceBuffer;

    TKDT44DEyanmicStoreBuffer = packed array of TKDT44DE_Source;
    PKDT44DEyanmicStoreBuffer = ^TKDT44DEyanmicStoreBuffer;

    PKDT44DE_Node = ^TKDT44DE_Node;

    TKDT44DE_Node = packed record
      Parent, Right, Left: PKDT44DE_Node;
      vec: PKDT44DE_Source;
    end;

    TKDT44DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT44DE_Source; const Data: Pointer);
    TKDT44DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT44DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT44DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT44DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT44DEyanmicStoreBuffer;
    KDBuff     : TKDT44DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT44DE_Node;
    TestBuff   : TKDT44DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT44DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT44DE_Node;
    function GetData(const index: NativeInt): PKDT44DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT44DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT44DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT44DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT44DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT44DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT44DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT44DE_Node; overload;
    function Search(const Buff: TKDT44DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT44DE_Node; overload;
    function Search(const Buff: TKDT44DE_Vec; var SearchedDistanceMin: Double): PKDT44DE_Node; overload;
    function Search(const Buff: TKDT44DE_Vec): PKDT44DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT44DE_DynamicVecBuffer; var OutBuff: TKDT44DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT44DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT44DE_Node);
    procedure PrintBuffer;

    class function KDT44DEVec(const s: string): TKDT44DE_Vec; overload;
    class function KDT44DEVec(const v: TKDT44DE_Vec): string; overload;
    class function KDT44DEPow(const v: TKDT44DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT44DEDistance(const v1, v2: TKDT44DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT44DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT45DE = class(TCoreClassObject)
  public type
    // code split
    TKDT45DE_Vec = array [0 .. KDT45DE_Axis - 1] of TKDT45DE_VecType;
    PKDT45DE_Vec = ^TKDT45DE_Vec;

    TKDT45DE_DynamicVecBuffer = packed array of TKDT45DE_Vec;
    PKDT45DE_DynamicVecBuffer = ^TKDT45DE_DynamicVecBuffer;

    TKDT45DE_Source = packed record
      Buff: TKDT45DE_Vec;
      index: Int64;
    end;

    PKDT45DE_Source       = ^TKDT45DE_Source;
    TKDT45DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT45DE_Source) - 1] of PKDT45DE_Source;
    PKDT45DE_SourceBuffer = ^TKDT45DE_SourceBuffer;

    TKDT45DEyanmicSourceBuffer = packed array of PKDT45DE_Source;
    PKDT45DEyanmicSourceBuffer = ^TKDT45DEyanmicSourceBuffer;

    TKDT45DEyanmicStoreBuffer = packed array of TKDT45DE_Source;
    PKDT45DEyanmicStoreBuffer = ^TKDT45DEyanmicStoreBuffer;

    PKDT45DE_Node = ^TKDT45DE_Node;

    TKDT45DE_Node = packed record
      Parent, Right, Left: PKDT45DE_Node;
      vec: PKDT45DE_Source;
    end;

    TKDT45DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT45DE_Source; const Data: Pointer);
    TKDT45DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT45DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT45DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT45DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT45DEyanmicStoreBuffer;
    KDBuff     : TKDT45DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT45DE_Node;
    TestBuff   : TKDT45DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT45DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT45DE_Node;
    function GetData(const index: NativeInt): PKDT45DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT45DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT45DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT45DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT45DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT45DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT45DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT45DE_Node; overload;
    function Search(const Buff: TKDT45DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT45DE_Node; overload;
    function Search(const Buff: TKDT45DE_Vec; var SearchedDistanceMin: Double): PKDT45DE_Node; overload;
    function Search(const Buff: TKDT45DE_Vec): PKDT45DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT45DE_DynamicVecBuffer; var OutBuff: TKDT45DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT45DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT45DE_Node);
    procedure PrintBuffer;

    class function KDT45DEVec(const s: string): TKDT45DE_Vec; overload;
    class function KDT45DEVec(const v: TKDT45DE_Vec): string; overload;
    class function KDT45DEPow(const v: TKDT45DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT45DEDistance(const v1, v2: TKDT45DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT45DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT46DE = class(TCoreClassObject)
  public type
    // code split
    TKDT46DE_Vec = array [0 .. KDT46DE_Axis - 1] of TKDT46DE_VecType;
    PKDT46DE_Vec = ^TKDT46DE_Vec;

    TKDT46DE_DynamicVecBuffer = packed array of TKDT46DE_Vec;
    PKDT46DE_DynamicVecBuffer = ^TKDT46DE_DynamicVecBuffer;

    TKDT46DE_Source = packed record
      Buff: TKDT46DE_Vec;
      index: Int64;
    end;

    PKDT46DE_Source       = ^TKDT46DE_Source;
    TKDT46DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT46DE_Source) - 1] of PKDT46DE_Source;
    PKDT46DE_SourceBuffer = ^TKDT46DE_SourceBuffer;

    TKDT46DEyanmicSourceBuffer = packed array of PKDT46DE_Source;
    PKDT46DEyanmicSourceBuffer = ^TKDT46DEyanmicSourceBuffer;

    TKDT46DEyanmicStoreBuffer = packed array of TKDT46DE_Source;
    PKDT46DEyanmicStoreBuffer = ^TKDT46DEyanmicStoreBuffer;

    PKDT46DE_Node = ^TKDT46DE_Node;

    TKDT46DE_Node = packed record
      Parent, Right, Left: PKDT46DE_Node;
      vec: PKDT46DE_Source;
    end;

    TKDT46DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT46DE_Source; const Data: Pointer);
    TKDT46DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT46DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT46DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT46DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT46DEyanmicStoreBuffer;
    KDBuff     : TKDT46DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT46DE_Node;
    TestBuff   : TKDT46DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT46DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT46DE_Node;
    function GetData(const index: NativeInt): PKDT46DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT46DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT46DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT46DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT46DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT46DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT46DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT46DE_Node; overload;
    function Search(const Buff: TKDT46DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT46DE_Node; overload;
    function Search(const Buff: TKDT46DE_Vec; var SearchedDistanceMin: Double): PKDT46DE_Node; overload;
    function Search(const Buff: TKDT46DE_Vec): PKDT46DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT46DE_DynamicVecBuffer; var OutBuff: TKDT46DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT46DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT46DE_Node);
    procedure PrintBuffer;

    class function KDT46DEVec(const s: string): TKDT46DE_Vec; overload;
    class function KDT46DEVec(const v: TKDT46DE_Vec): string; overload;
    class function KDT46DEPow(const v: TKDT46DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT46DEDistance(const v1, v2: TKDT46DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT46DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT47DE = class(TCoreClassObject)
  public type
    // code split
    TKDT47DE_Vec = array [0 .. KDT47DE_Axis - 1] of TKDT47DE_VecType;
    PKDT47DE_Vec = ^TKDT47DE_Vec;

    TKDT47DE_DynamicVecBuffer = packed array of TKDT47DE_Vec;
    PKDT47DE_DynamicVecBuffer = ^TKDT47DE_DynamicVecBuffer;

    TKDT47DE_Source = packed record
      Buff: TKDT47DE_Vec;
      index: Int64;
    end;

    PKDT47DE_Source       = ^TKDT47DE_Source;
    TKDT47DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT47DE_Source) - 1] of PKDT47DE_Source;
    PKDT47DE_SourceBuffer = ^TKDT47DE_SourceBuffer;

    TKDT47DEyanmicSourceBuffer = packed array of PKDT47DE_Source;
    PKDT47DEyanmicSourceBuffer = ^TKDT47DEyanmicSourceBuffer;

    TKDT47DEyanmicStoreBuffer = packed array of TKDT47DE_Source;
    PKDT47DEyanmicStoreBuffer = ^TKDT47DEyanmicStoreBuffer;

    PKDT47DE_Node = ^TKDT47DE_Node;

    TKDT47DE_Node = packed record
      Parent, Right, Left: PKDT47DE_Node;
      vec: PKDT47DE_Source;
    end;

    TKDT47DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT47DE_Source; const Data: Pointer);
    TKDT47DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT47DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT47DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT47DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT47DEyanmicStoreBuffer;
    KDBuff     : TKDT47DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT47DE_Node;
    TestBuff   : TKDT47DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT47DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT47DE_Node;
    function GetData(const index: NativeInt): PKDT47DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT47DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT47DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT47DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT47DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT47DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT47DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT47DE_Node; overload;
    function Search(const Buff: TKDT47DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT47DE_Node; overload;
    function Search(const Buff: TKDT47DE_Vec; var SearchedDistanceMin: Double): PKDT47DE_Node; overload;
    function Search(const Buff: TKDT47DE_Vec): PKDT47DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT47DE_DynamicVecBuffer; var OutBuff: TKDT47DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT47DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT47DE_Node);
    procedure PrintBuffer;

    class function KDT47DEVec(const s: string): TKDT47DE_Vec; overload;
    class function KDT47DEVec(const v: TKDT47DE_Vec): string; overload;
    class function KDT47DEPow(const v: TKDT47DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT47DEDistance(const v1, v2: TKDT47DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT47DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT48DE = class(TCoreClassObject)
  public type
    // code split
    TKDT48DE_Vec = array [0 .. KDT48DE_Axis - 1] of TKDT48DE_VecType;
    PKDT48DE_Vec = ^TKDT48DE_Vec;

    TKDT48DE_DynamicVecBuffer = packed array of TKDT48DE_Vec;
    PKDT48DE_DynamicVecBuffer = ^TKDT48DE_DynamicVecBuffer;

    TKDT48DE_Source = packed record
      Buff: TKDT48DE_Vec;
      index: Int64;
    end;

    PKDT48DE_Source       = ^TKDT48DE_Source;
    TKDT48DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT48DE_Source) - 1] of PKDT48DE_Source;
    PKDT48DE_SourceBuffer = ^TKDT48DE_SourceBuffer;

    TKDT48DEyanmicSourceBuffer = packed array of PKDT48DE_Source;
    PKDT48DEyanmicSourceBuffer = ^TKDT48DEyanmicSourceBuffer;

    TKDT48DEyanmicStoreBuffer = packed array of TKDT48DE_Source;
    PKDT48DEyanmicStoreBuffer = ^TKDT48DEyanmicStoreBuffer;

    PKDT48DE_Node = ^TKDT48DE_Node;

    TKDT48DE_Node = packed record
      Parent, Right, Left: PKDT48DE_Node;
      vec: PKDT48DE_Source;
    end;

    TKDT48DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT48DE_Source; const Data: Pointer);
    TKDT48DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT48DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT48DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT48DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT48DEyanmicStoreBuffer;
    KDBuff     : TKDT48DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT48DE_Node;
    TestBuff   : TKDT48DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DE_Node;
    function GetData(const index: NativeInt): PKDT48DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT48DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT48DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT48DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT48DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DE_Node; overload;
    function Search(const Buff: TKDT48DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DE_Node; overload;
    function Search(const Buff: TKDT48DE_Vec; var SearchedDistanceMin: Double): PKDT48DE_Node; overload;
    function Search(const Buff: TKDT48DE_Vec): PKDT48DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT48DE_DynamicVecBuffer; var OutBuff: TKDT48DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT48DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT48DE_Node);
    procedure PrintBuffer;

    class function KDT48DEVec(const s: string): TKDT48DE_Vec; overload;
    class function KDT48DEVec(const v: TKDT48DE_Vec): string; overload;
    class function KDT48DEPow(const v: TKDT48DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT48DEDistance(const v1, v2: TKDT48DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT48DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT49DE = class(TCoreClassObject)
  public type
    // code split
    TKDT49DE_Vec = array [0 .. KDT49DE_Axis - 1] of TKDT49DE_VecType;
    PKDT49DE_Vec = ^TKDT49DE_Vec;

    TKDT49DE_DynamicVecBuffer = packed array of TKDT49DE_Vec;
    PKDT49DE_DynamicVecBuffer = ^TKDT49DE_DynamicVecBuffer;

    TKDT49DE_Source = packed record
      Buff: TKDT49DE_Vec;
      index: Int64;
    end;

    PKDT49DE_Source       = ^TKDT49DE_Source;
    TKDT49DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT49DE_Source) - 1] of PKDT49DE_Source;
    PKDT49DE_SourceBuffer = ^TKDT49DE_SourceBuffer;

    TKDT49DEyanmicSourceBuffer = packed array of PKDT49DE_Source;
    PKDT49DEyanmicSourceBuffer = ^TKDT49DEyanmicSourceBuffer;

    TKDT49DEyanmicStoreBuffer = packed array of TKDT49DE_Source;
    PKDT49DEyanmicStoreBuffer = ^TKDT49DEyanmicStoreBuffer;

    PKDT49DE_Node = ^TKDT49DE_Node;

    TKDT49DE_Node = packed record
      Parent, Right, Left: PKDT49DE_Node;
      vec: PKDT49DE_Source;
    end;

    TKDT49DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT49DE_Source; const Data: Pointer);
    TKDT49DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT49DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT49DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT49DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT49DEyanmicStoreBuffer;
    KDBuff     : TKDT49DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT49DE_Node;
    TestBuff   : TKDT49DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT49DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT49DE_Node;
    function GetData(const index: NativeInt): PKDT49DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT49DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT49DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT49DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT49DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT49DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT49DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT49DE_Node; overload;
    function Search(const Buff: TKDT49DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT49DE_Node; overload;
    function Search(const Buff: TKDT49DE_Vec; var SearchedDistanceMin: Double): PKDT49DE_Node; overload;
    function Search(const Buff: TKDT49DE_Vec): PKDT49DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT49DE_DynamicVecBuffer; var OutBuff: TKDT49DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT49DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT49DE_Node);
    procedure PrintBuffer;

    class function KDT49DEVec(const s: string): TKDT49DE_Vec; overload;
    class function KDT49DEVec(const v: TKDT49DE_Vec): string; overload;
    class function KDT49DEPow(const v: TKDT49DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT49DEDistance(const v1, v2: TKDT49DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT49DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT50DE = class(TCoreClassObject)
  public type
    // code split
    TKDT50DE_Vec = array [0 .. KDT50DE_Axis - 1] of TKDT50DE_VecType;
    PKDT50DE_Vec = ^TKDT50DE_Vec;

    TKDT50DE_DynamicVecBuffer = packed array of TKDT50DE_Vec;
    PKDT50DE_DynamicVecBuffer = ^TKDT50DE_DynamicVecBuffer;

    TKDT50DE_Source = packed record
      Buff: TKDT50DE_Vec;
      index: Int64;
    end;

    PKDT50DE_Source       = ^TKDT50DE_Source;
    TKDT50DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT50DE_Source) - 1] of PKDT50DE_Source;
    PKDT50DE_SourceBuffer = ^TKDT50DE_SourceBuffer;

    TKDT50DEyanmicSourceBuffer = packed array of PKDT50DE_Source;
    PKDT50DEyanmicSourceBuffer = ^TKDT50DEyanmicSourceBuffer;

    TKDT50DEyanmicStoreBuffer = packed array of TKDT50DE_Source;
    PKDT50DEyanmicStoreBuffer = ^TKDT50DEyanmicStoreBuffer;

    PKDT50DE_Node = ^TKDT50DE_Node;

    TKDT50DE_Node = packed record
      Parent, Right, Left: PKDT50DE_Node;
      vec: PKDT50DE_Source;
    end;

    TKDT50DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT50DE_Source; const Data: Pointer);
    TKDT50DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT50DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT50DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT50DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT50DEyanmicStoreBuffer;
    KDBuff     : TKDT50DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT50DE_Node;
    TestBuff   : TKDT50DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT50DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT50DE_Node;
    function GetData(const index: NativeInt): PKDT50DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT50DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT50DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT50DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT50DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT50DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT50DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT50DE_Node; overload;
    function Search(const Buff: TKDT50DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT50DE_Node; overload;
    function Search(const Buff: TKDT50DE_Vec; var SearchedDistanceMin: Double): PKDT50DE_Node; overload;
    function Search(const Buff: TKDT50DE_Vec): PKDT50DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT50DE_DynamicVecBuffer; var OutBuff: TKDT50DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT50DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT50DE_Node);
    procedure PrintBuffer;

    class function KDT50DEVec(const s: string): TKDT50DE_Vec; overload;
    class function KDT50DEVec(const v: TKDT50DE_Vec): string; overload;
    class function KDT50DEPow(const v: TKDT50DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT50DEDistance(const v1, v2: TKDT50DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT50DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT51DE = class(TCoreClassObject)
  public type
    // code split
    TKDT51DE_Vec = array [0 .. KDT51DE_Axis - 1] of TKDT51DE_VecType;
    PKDT51DE_Vec = ^TKDT51DE_Vec;

    TKDT51DE_DynamicVecBuffer = packed array of TKDT51DE_Vec;
    PKDT51DE_DynamicVecBuffer = ^TKDT51DE_DynamicVecBuffer;

    TKDT51DE_Source = packed record
      Buff: TKDT51DE_Vec;
      index: Int64;
    end;

    PKDT51DE_Source       = ^TKDT51DE_Source;
    TKDT51DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT51DE_Source) - 1] of PKDT51DE_Source;
    PKDT51DE_SourceBuffer = ^TKDT51DE_SourceBuffer;

    TKDT51DEyanmicSourceBuffer = packed array of PKDT51DE_Source;
    PKDT51DEyanmicSourceBuffer = ^TKDT51DEyanmicSourceBuffer;

    TKDT51DEyanmicStoreBuffer = packed array of TKDT51DE_Source;
    PKDT51DEyanmicStoreBuffer = ^TKDT51DEyanmicStoreBuffer;

    PKDT51DE_Node = ^TKDT51DE_Node;

    TKDT51DE_Node = packed record
      Parent, Right, Left: PKDT51DE_Node;
      vec: PKDT51DE_Source;
    end;

    TKDT51DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT51DE_Source; const Data: Pointer);
    TKDT51DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT51DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT51DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT51DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT51DEyanmicStoreBuffer;
    KDBuff     : TKDT51DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT51DE_Node;
    TestBuff   : TKDT51DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT51DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT51DE_Node;
    function GetData(const index: NativeInt): PKDT51DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT51DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT51DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT51DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT51DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT51DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT51DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT51DE_Node; overload;
    function Search(const Buff: TKDT51DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT51DE_Node; overload;
    function Search(const Buff: TKDT51DE_Vec; var SearchedDistanceMin: Double): PKDT51DE_Node; overload;
    function Search(const Buff: TKDT51DE_Vec): PKDT51DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT51DE_DynamicVecBuffer; var OutBuff: TKDT51DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT51DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT51DE_Node);
    procedure PrintBuffer;

    class function KDT51DEVec(const s: string): TKDT51DE_Vec; overload;
    class function KDT51DEVec(const v: TKDT51DE_Vec): string; overload;
    class function KDT51DEPow(const v: TKDT51DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT51DEDistance(const v1, v2: TKDT51DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT51DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT52DE = class(TCoreClassObject)
  public type
    // code split
    TKDT52DE_Vec = array [0 .. KDT52DE_Axis - 1] of TKDT52DE_VecType;
    PKDT52DE_Vec = ^TKDT52DE_Vec;

    TKDT52DE_DynamicVecBuffer = packed array of TKDT52DE_Vec;
    PKDT52DE_DynamicVecBuffer = ^TKDT52DE_DynamicVecBuffer;

    TKDT52DE_Source = packed record
      Buff: TKDT52DE_Vec;
      index: Int64;
    end;

    PKDT52DE_Source       = ^TKDT52DE_Source;
    TKDT52DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT52DE_Source) - 1] of PKDT52DE_Source;
    PKDT52DE_SourceBuffer = ^TKDT52DE_SourceBuffer;

    TKDT52DEyanmicSourceBuffer = packed array of PKDT52DE_Source;
    PKDT52DEyanmicSourceBuffer = ^TKDT52DEyanmicSourceBuffer;

    TKDT52DEyanmicStoreBuffer = packed array of TKDT52DE_Source;
    PKDT52DEyanmicStoreBuffer = ^TKDT52DEyanmicStoreBuffer;

    PKDT52DE_Node = ^TKDT52DE_Node;

    TKDT52DE_Node = packed record
      Parent, Right, Left: PKDT52DE_Node;
      vec: PKDT52DE_Source;
    end;

    TKDT52DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT52DE_Source; const Data: Pointer);
    TKDT52DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT52DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT52DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT52DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT52DEyanmicStoreBuffer;
    KDBuff     : TKDT52DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT52DE_Node;
    TestBuff   : TKDT52DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT52DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT52DE_Node;
    function GetData(const index: NativeInt): PKDT52DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT52DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT52DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT52DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT52DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT52DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT52DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT52DE_Node; overload;
    function Search(const Buff: TKDT52DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT52DE_Node; overload;
    function Search(const Buff: TKDT52DE_Vec; var SearchedDistanceMin: Double): PKDT52DE_Node; overload;
    function Search(const Buff: TKDT52DE_Vec): PKDT52DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT52DE_DynamicVecBuffer; var OutBuff: TKDT52DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT52DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT52DE_Node);
    procedure PrintBuffer;

    class function KDT52DEVec(const s: string): TKDT52DE_Vec; overload;
    class function KDT52DEVec(const v: TKDT52DE_Vec): string; overload;
    class function KDT52DEPow(const v: TKDT52DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT52DEDistance(const v1, v2: TKDT52DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT52DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT53DE = class(TCoreClassObject)
  public type
    // code split
    TKDT53DE_Vec = array [0 .. KDT53DE_Axis - 1] of TKDT53DE_VecType;
    PKDT53DE_Vec = ^TKDT53DE_Vec;

    TKDT53DE_DynamicVecBuffer = packed array of TKDT53DE_Vec;
    PKDT53DE_DynamicVecBuffer = ^TKDT53DE_DynamicVecBuffer;

    TKDT53DE_Source = packed record
      Buff: TKDT53DE_Vec;
      index: Int64;
    end;

    PKDT53DE_Source       = ^TKDT53DE_Source;
    TKDT53DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT53DE_Source) - 1] of PKDT53DE_Source;
    PKDT53DE_SourceBuffer = ^TKDT53DE_SourceBuffer;

    TKDT53DEyanmicSourceBuffer = packed array of PKDT53DE_Source;
    PKDT53DEyanmicSourceBuffer = ^TKDT53DEyanmicSourceBuffer;

    TKDT53DEyanmicStoreBuffer = packed array of TKDT53DE_Source;
    PKDT53DEyanmicStoreBuffer = ^TKDT53DEyanmicStoreBuffer;

    PKDT53DE_Node = ^TKDT53DE_Node;

    TKDT53DE_Node = packed record
      Parent, Right, Left: PKDT53DE_Node;
      vec: PKDT53DE_Source;
    end;

    TKDT53DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT53DE_Source; const Data: Pointer);
    TKDT53DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT53DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT53DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT53DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT53DEyanmicStoreBuffer;
    KDBuff     : TKDT53DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT53DE_Node;
    TestBuff   : TKDT53DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT53DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT53DE_Node;
    function GetData(const index: NativeInt): PKDT53DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT53DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT53DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT53DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT53DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT53DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT53DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT53DE_Node; overload;
    function Search(const Buff: TKDT53DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT53DE_Node; overload;
    function Search(const Buff: TKDT53DE_Vec; var SearchedDistanceMin: Double): PKDT53DE_Node; overload;
    function Search(const Buff: TKDT53DE_Vec): PKDT53DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT53DE_DynamicVecBuffer; var OutBuff: TKDT53DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT53DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT53DE_Node);
    procedure PrintBuffer;

    class function KDT53DEVec(const s: string): TKDT53DE_Vec; overload;
    class function KDT53DEVec(const v: TKDT53DE_Vec): string; overload;
    class function KDT53DEPow(const v: TKDT53DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT53DEDistance(const v1, v2: TKDT53DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT53DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT54DE = class(TCoreClassObject)
  public type
    // code split
    TKDT54DE_Vec = array [0 .. KDT54DE_Axis - 1] of TKDT54DE_VecType;
    PKDT54DE_Vec = ^TKDT54DE_Vec;

    TKDT54DE_DynamicVecBuffer = packed array of TKDT54DE_Vec;
    PKDT54DE_DynamicVecBuffer = ^TKDT54DE_DynamicVecBuffer;

    TKDT54DE_Source = packed record
      Buff: TKDT54DE_Vec;
      index: Int64;
    end;

    PKDT54DE_Source       = ^TKDT54DE_Source;
    TKDT54DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT54DE_Source) - 1] of PKDT54DE_Source;
    PKDT54DE_SourceBuffer = ^TKDT54DE_SourceBuffer;

    TKDT54DEyanmicSourceBuffer = packed array of PKDT54DE_Source;
    PKDT54DEyanmicSourceBuffer = ^TKDT54DEyanmicSourceBuffer;

    TKDT54DEyanmicStoreBuffer = packed array of TKDT54DE_Source;
    PKDT54DEyanmicStoreBuffer = ^TKDT54DEyanmicStoreBuffer;

    PKDT54DE_Node = ^TKDT54DE_Node;

    TKDT54DE_Node = packed record
      Parent, Right, Left: PKDT54DE_Node;
      vec: PKDT54DE_Source;
    end;

    TKDT54DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT54DE_Source; const Data: Pointer);
    TKDT54DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT54DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT54DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT54DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT54DEyanmicStoreBuffer;
    KDBuff     : TKDT54DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT54DE_Node;
    TestBuff   : TKDT54DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT54DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT54DE_Node;
    function GetData(const index: NativeInt): PKDT54DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT54DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT54DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT54DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT54DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT54DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT54DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT54DE_Node; overload;
    function Search(const Buff: TKDT54DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT54DE_Node; overload;
    function Search(const Buff: TKDT54DE_Vec; var SearchedDistanceMin: Double): PKDT54DE_Node; overload;
    function Search(const Buff: TKDT54DE_Vec): PKDT54DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT54DE_DynamicVecBuffer; var OutBuff: TKDT54DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT54DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT54DE_Node);
    procedure PrintBuffer;

    class function KDT54DEVec(const s: string): TKDT54DE_Vec; overload;
    class function KDT54DEVec(const v: TKDT54DE_Vec): string; overload;
    class function KDT54DEPow(const v: TKDT54DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT54DEDistance(const v1, v2: TKDT54DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT54DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT55DE = class(TCoreClassObject)
  public type
    // code split
    TKDT55DE_Vec = array [0 .. KDT55DE_Axis - 1] of TKDT55DE_VecType;
    PKDT55DE_Vec = ^TKDT55DE_Vec;

    TKDT55DE_DynamicVecBuffer = packed array of TKDT55DE_Vec;
    PKDT55DE_DynamicVecBuffer = ^TKDT55DE_DynamicVecBuffer;

    TKDT55DE_Source = packed record
      Buff: TKDT55DE_Vec;
      index: Int64;
    end;

    PKDT55DE_Source       = ^TKDT55DE_Source;
    TKDT55DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT55DE_Source) - 1] of PKDT55DE_Source;
    PKDT55DE_SourceBuffer = ^TKDT55DE_SourceBuffer;

    TKDT55DEyanmicSourceBuffer = packed array of PKDT55DE_Source;
    PKDT55DEyanmicSourceBuffer = ^TKDT55DEyanmicSourceBuffer;

    TKDT55DEyanmicStoreBuffer = packed array of TKDT55DE_Source;
    PKDT55DEyanmicStoreBuffer = ^TKDT55DEyanmicStoreBuffer;

    PKDT55DE_Node = ^TKDT55DE_Node;

    TKDT55DE_Node = packed record
      Parent, Right, Left: PKDT55DE_Node;
      vec: PKDT55DE_Source;
    end;

    TKDT55DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT55DE_Source; const Data: Pointer);
    TKDT55DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT55DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT55DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT55DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT55DEyanmicStoreBuffer;
    KDBuff     : TKDT55DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT55DE_Node;
    TestBuff   : TKDT55DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT55DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT55DE_Node;
    function GetData(const index: NativeInt): PKDT55DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT55DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT55DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT55DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT55DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT55DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT55DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT55DE_Node; overload;
    function Search(const Buff: TKDT55DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT55DE_Node; overload;
    function Search(const Buff: TKDT55DE_Vec; var SearchedDistanceMin: Double): PKDT55DE_Node; overload;
    function Search(const Buff: TKDT55DE_Vec): PKDT55DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT55DE_DynamicVecBuffer; var OutBuff: TKDT55DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT55DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT55DE_Node);
    procedure PrintBuffer;

    class function KDT55DEVec(const s: string): TKDT55DE_Vec; overload;
    class function KDT55DEVec(const v: TKDT55DE_Vec): string; overload;
    class function KDT55DEPow(const v: TKDT55DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT55DEDistance(const v1, v2: TKDT55DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT55DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT56DE = class(TCoreClassObject)
  public type
    // code split
    TKDT56DE_Vec = array [0 .. KDT56DE_Axis - 1] of TKDT56DE_VecType;
    PKDT56DE_Vec = ^TKDT56DE_Vec;

    TKDT56DE_DynamicVecBuffer = packed array of TKDT56DE_Vec;
    PKDT56DE_DynamicVecBuffer = ^TKDT56DE_DynamicVecBuffer;

    TKDT56DE_Source = packed record
      Buff: TKDT56DE_Vec;
      index: Int64;
    end;

    PKDT56DE_Source       = ^TKDT56DE_Source;
    TKDT56DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT56DE_Source) - 1] of PKDT56DE_Source;
    PKDT56DE_SourceBuffer = ^TKDT56DE_SourceBuffer;

    TKDT56DEyanmicSourceBuffer = packed array of PKDT56DE_Source;
    PKDT56DEyanmicSourceBuffer = ^TKDT56DEyanmicSourceBuffer;

    TKDT56DEyanmicStoreBuffer = packed array of TKDT56DE_Source;
    PKDT56DEyanmicStoreBuffer = ^TKDT56DEyanmicStoreBuffer;

    PKDT56DE_Node = ^TKDT56DE_Node;

    TKDT56DE_Node = packed record
      Parent, Right, Left: PKDT56DE_Node;
      vec: PKDT56DE_Source;
    end;

    TKDT56DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT56DE_Source; const Data: Pointer);
    TKDT56DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT56DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT56DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT56DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT56DEyanmicStoreBuffer;
    KDBuff     : TKDT56DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT56DE_Node;
    TestBuff   : TKDT56DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT56DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT56DE_Node;
    function GetData(const index: NativeInt): PKDT56DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT56DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT56DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT56DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT56DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT56DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT56DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT56DE_Node; overload;
    function Search(const Buff: TKDT56DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT56DE_Node; overload;
    function Search(const Buff: TKDT56DE_Vec; var SearchedDistanceMin: Double): PKDT56DE_Node; overload;
    function Search(const Buff: TKDT56DE_Vec): PKDT56DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT56DE_DynamicVecBuffer; var OutBuff: TKDT56DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT56DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT56DE_Node);
    procedure PrintBuffer;

    class function KDT56DEVec(const s: string): TKDT56DE_Vec; overload;
    class function KDT56DEVec(const v: TKDT56DE_Vec): string; overload;
    class function KDT56DEPow(const v: TKDT56DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT56DEDistance(const v1, v2: TKDT56DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT56DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT57DE = class(TCoreClassObject)
  public type
    // code split
    TKDT57DE_Vec = array [0 .. KDT57DE_Axis - 1] of TKDT57DE_VecType;
    PKDT57DE_Vec = ^TKDT57DE_Vec;

    TKDT57DE_DynamicVecBuffer = packed array of TKDT57DE_Vec;
    PKDT57DE_DynamicVecBuffer = ^TKDT57DE_DynamicVecBuffer;

    TKDT57DE_Source = packed record
      Buff: TKDT57DE_Vec;
      index: Int64;
    end;

    PKDT57DE_Source       = ^TKDT57DE_Source;
    TKDT57DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT57DE_Source) - 1] of PKDT57DE_Source;
    PKDT57DE_SourceBuffer = ^TKDT57DE_SourceBuffer;

    TKDT57DEyanmicSourceBuffer = packed array of PKDT57DE_Source;
    PKDT57DEyanmicSourceBuffer = ^TKDT57DEyanmicSourceBuffer;

    TKDT57DEyanmicStoreBuffer = packed array of TKDT57DE_Source;
    PKDT57DEyanmicStoreBuffer = ^TKDT57DEyanmicStoreBuffer;

    PKDT57DE_Node = ^TKDT57DE_Node;

    TKDT57DE_Node = packed record
      Parent, Right, Left: PKDT57DE_Node;
      vec: PKDT57DE_Source;
    end;

    TKDT57DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT57DE_Source; const Data: Pointer);
    TKDT57DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT57DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT57DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT57DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT57DEyanmicStoreBuffer;
    KDBuff     : TKDT57DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT57DE_Node;
    TestBuff   : TKDT57DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT57DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT57DE_Node;
    function GetData(const index: NativeInt): PKDT57DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT57DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT57DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT57DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT57DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT57DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT57DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT57DE_Node; overload;
    function Search(const Buff: TKDT57DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT57DE_Node; overload;
    function Search(const Buff: TKDT57DE_Vec; var SearchedDistanceMin: Double): PKDT57DE_Node; overload;
    function Search(const Buff: TKDT57DE_Vec): PKDT57DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT57DE_DynamicVecBuffer; var OutBuff: TKDT57DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT57DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT57DE_Node);
    procedure PrintBuffer;

    class function KDT57DEVec(const s: string): TKDT57DE_Vec; overload;
    class function KDT57DEVec(const v: TKDT57DE_Vec): string; overload;
    class function KDT57DEPow(const v: TKDT57DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT57DEDistance(const v1, v2: TKDT57DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT57DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT58DE = class(TCoreClassObject)
  public type
    // code split
    TKDT58DE_Vec = array [0 .. KDT58DE_Axis - 1] of TKDT58DE_VecType;
    PKDT58DE_Vec = ^TKDT58DE_Vec;

    TKDT58DE_DynamicVecBuffer = packed array of TKDT58DE_Vec;
    PKDT58DE_DynamicVecBuffer = ^TKDT58DE_DynamicVecBuffer;

    TKDT58DE_Source = packed record
      Buff: TKDT58DE_Vec;
      index: Int64;
    end;

    PKDT58DE_Source       = ^TKDT58DE_Source;
    TKDT58DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT58DE_Source) - 1] of PKDT58DE_Source;
    PKDT58DE_SourceBuffer = ^TKDT58DE_SourceBuffer;

    TKDT58DEyanmicSourceBuffer = packed array of PKDT58DE_Source;
    PKDT58DEyanmicSourceBuffer = ^TKDT58DEyanmicSourceBuffer;

    TKDT58DEyanmicStoreBuffer = packed array of TKDT58DE_Source;
    PKDT58DEyanmicStoreBuffer = ^TKDT58DEyanmicStoreBuffer;

    PKDT58DE_Node = ^TKDT58DE_Node;

    TKDT58DE_Node = packed record
      Parent, Right, Left: PKDT58DE_Node;
      vec: PKDT58DE_Source;
    end;

    TKDT58DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT58DE_Source; const Data: Pointer);
    TKDT58DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT58DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT58DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT58DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT58DEyanmicStoreBuffer;
    KDBuff     : TKDT58DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT58DE_Node;
    TestBuff   : TKDT58DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT58DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT58DE_Node;
    function GetData(const index: NativeInt): PKDT58DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT58DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT58DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT58DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT58DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT58DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT58DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT58DE_Node; overload;
    function Search(const Buff: TKDT58DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT58DE_Node; overload;
    function Search(const Buff: TKDT58DE_Vec; var SearchedDistanceMin: Double): PKDT58DE_Node; overload;
    function Search(const Buff: TKDT58DE_Vec): PKDT58DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT58DE_DynamicVecBuffer; var OutBuff: TKDT58DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT58DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT58DE_Node);
    procedure PrintBuffer;

    class function KDT58DEVec(const s: string): TKDT58DE_Vec; overload;
    class function KDT58DEVec(const v: TKDT58DE_Vec): string; overload;
    class function KDT58DEPow(const v: TKDT58DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT58DEDistance(const v1, v2: TKDT58DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT58DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT59DE = class(TCoreClassObject)
  public type
    // code split
    TKDT59DE_Vec = array [0 .. KDT59DE_Axis - 1] of TKDT59DE_VecType;
    PKDT59DE_Vec = ^TKDT59DE_Vec;

    TKDT59DE_DynamicVecBuffer = packed array of TKDT59DE_Vec;
    PKDT59DE_DynamicVecBuffer = ^TKDT59DE_DynamicVecBuffer;

    TKDT59DE_Source = packed record
      Buff: TKDT59DE_Vec;
      index: Int64;
    end;

    PKDT59DE_Source       = ^TKDT59DE_Source;
    TKDT59DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT59DE_Source) - 1] of PKDT59DE_Source;
    PKDT59DE_SourceBuffer = ^TKDT59DE_SourceBuffer;

    TKDT59DEyanmicSourceBuffer = packed array of PKDT59DE_Source;
    PKDT59DEyanmicSourceBuffer = ^TKDT59DEyanmicSourceBuffer;

    TKDT59DEyanmicStoreBuffer = packed array of TKDT59DE_Source;
    PKDT59DEyanmicStoreBuffer = ^TKDT59DEyanmicStoreBuffer;

    PKDT59DE_Node = ^TKDT59DE_Node;

    TKDT59DE_Node = packed record
      Parent, Right, Left: PKDT59DE_Node;
      vec: PKDT59DE_Source;
    end;

    TKDT59DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT59DE_Source; const Data: Pointer);
    TKDT59DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT59DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT59DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT59DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT59DEyanmicStoreBuffer;
    KDBuff     : TKDT59DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT59DE_Node;
    TestBuff   : TKDT59DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT59DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT59DE_Node;
    function GetData(const index: NativeInt): PKDT59DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT59DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT59DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT59DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT59DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT59DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT59DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT59DE_Node; overload;
    function Search(const Buff: TKDT59DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT59DE_Node; overload;
    function Search(const Buff: TKDT59DE_Vec; var SearchedDistanceMin: Double): PKDT59DE_Node; overload;
    function Search(const Buff: TKDT59DE_Vec): PKDT59DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT59DE_DynamicVecBuffer; var OutBuff: TKDT59DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT59DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT59DE_Node);
    procedure PrintBuffer;

    class function KDT59DEVec(const s: string): TKDT59DE_Vec; overload;
    class function KDT59DEVec(const v: TKDT59DE_Vec): string; overload;
    class function KDT59DEPow(const v: TKDT59DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT59DEDistance(const v1, v2: TKDT59DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT59DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT60DE = class(TCoreClassObject)
  public type
    // code split
    TKDT60DE_Vec = array [0 .. KDT60DE_Axis - 1] of TKDT60DE_VecType;
    PKDT60DE_Vec = ^TKDT60DE_Vec;

    TKDT60DE_DynamicVecBuffer = packed array of TKDT60DE_Vec;
    PKDT60DE_DynamicVecBuffer = ^TKDT60DE_DynamicVecBuffer;

    TKDT60DE_Source = packed record
      Buff: TKDT60DE_Vec;
      index: Int64;
    end;

    PKDT60DE_Source       = ^TKDT60DE_Source;
    TKDT60DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT60DE_Source) - 1] of PKDT60DE_Source;
    PKDT60DE_SourceBuffer = ^TKDT60DE_SourceBuffer;

    TKDT60DEyanmicSourceBuffer = packed array of PKDT60DE_Source;
    PKDT60DEyanmicSourceBuffer = ^TKDT60DEyanmicSourceBuffer;

    TKDT60DEyanmicStoreBuffer = packed array of TKDT60DE_Source;
    PKDT60DEyanmicStoreBuffer = ^TKDT60DEyanmicStoreBuffer;

    PKDT60DE_Node = ^TKDT60DE_Node;

    TKDT60DE_Node = packed record
      Parent, Right, Left: PKDT60DE_Node;
      vec: PKDT60DE_Source;
    end;

    TKDT60DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT60DE_Source; const Data: Pointer);
    TKDT60DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT60DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT60DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT60DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT60DEyanmicStoreBuffer;
    KDBuff     : TKDT60DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT60DE_Node;
    TestBuff   : TKDT60DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT60DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT60DE_Node;
    function GetData(const index: NativeInt): PKDT60DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT60DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT60DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT60DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT60DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT60DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT60DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT60DE_Node; overload;
    function Search(const Buff: TKDT60DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT60DE_Node; overload;
    function Search(const Buff: TKDT60DE_Vec; var SearchedDistanceMin: Double): PKDT60DE_Node; overload;
    function Search(const Buff: TKDT60DE_Vec): PKDT60DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT60DE_DynamicVecBuffer; var OutBuff: TKDT60DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT60DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT60DE_Node);
    procedure PrintBuffer;

    class function KDT60DEVec(const s: string): TKDT60DE_Vec; overload;
    class function KDT60DEVec(const v: TKDT60DE_Vec): string; overload;
    class function KDT60DEPow(const v: TKDT60DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT60DEDistance(const v1, v2: TKDT60DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT60DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT61DE = class(TCoreClassObject)
  public type
    // code split
    TKDT61DE_Vec = array [0 .. KDT61DE_Axis - 1] of TKDT61DE_VecType;
    PKDT61DE_Vec = ^TKDT61DE_Vec;

    TKDT61DE_DynamicVecBuffer = packed array of TKDT61DE_Vec;
    PKDT61DE_DynamicVecBuffer = ^TKDT61DE_DynamicVecBuffer;

    TKDT61DE_Source = packed record
      Buff: TKDT61DE_Vec;
      index: Int64;
    end;

    PKDT61DE_Source       = ^TKDT61DE_Source;
    TKDT61DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT61DE_Source) - 1] of PKDT61DE_Source;
    PKDT61DE_SourceBuffer = ^TKDT61DE_SourceBuffer;

    TKDT61DEyanmicSourceBuffer = packed array of PKDT61DE_Source;
    PKDT61DEyanmicSourceBuffer = ^TKDT61DEyanmicSourceBuffer;

    TKDT61DEyanmicStoreBuffer = packed array of TKDT61DE_Source;
    PKDT61DEyanmicStoreBuffer = ^TKDT61DEyanmicStoreBuffer;

    PKDT61DE_Node = ^TKDT61DE_Node;

    TKDT61DE_Node = packed record
      Parent, Right, Left: PKDT61DE_Node;
      vec: PKDT61DE_Source;
    end;

    TKDT61DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT61DE_Source; const Data: Pointer);
    TKDT61DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT61DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT61DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT61DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT61DEyanmicStoreBuffer;
    KDBuff     : TKDT61DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT61DE_Node;
    TestBuff   : TKDT61DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT61DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT61DE_Node;
    function GetData(const index: NativeInt): PKDT61DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT61DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT61DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT61DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT61DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT61DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT61DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT61DE_Node; overload;
    function Search(const Buff: TKDT61DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT61DE_Node; overload;
    function Search(const Buff: TKDT61DE_Vec; var SearchedDistanceMin: Double): PKDT61DE_Node; overload;
    function Search(const Buff: TKDT61DE_Vec): PKDT61DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT61DE_DynamicVecBuffer; var OutBuff: TKDT61DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT61DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT61DE_Node);
    procedure PrintBuffer;

    class function KDT61DEVec(const s: string): TKDT61DE_Vec; overload;
    class function KDT61DEVec(const v: TKDT61DE_Vec): string; overload;
    class function KDT61DEPow(const v: TKDT61DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT61DEDistance(const v1, v2: TKDT61DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT61DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT62DE = class(TCoreClassObject)
  public type
    // code split
    TKDT62DE_Vec = array [0 .. KDT62DE_Axis - 1] of TKDT62DE_VecType;
    PKDT62DE_Vec = ^TKDT62DE_Vec;

    TKDT62DE_DynamicVecBuffer = packed array of TKDT62DE_Vec;
    PKDT62DE_DynamicVecBuffer = ^TKDT62DE_DynamicVecBuffer;

    TKDT62DE_Source = packed record
      Buff: TKDT62DE_Vec;
      index: Int64;
    end;

    PKDT62DE_Source       = ^TKDT62DE_Source;
    TKDT62DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT62DE_Source) - 1] of PKDT62DE_Source;
    PKDT62DE_SourceBuffer = ^TKDT62DE_SourceBuffer;

    TKDT62DEyanmicSourceBuffer = packed array of PKDT62DE_Source;
    PKDT62DEyanmicSourceBuffer = ^TKDT62DEyanmicSourceBuffer;

    TKDT62DEyanmicStoreBuffer = packed array of TKDT62DE_Source;
    PKDT62DEyanmicStoreBuffer = ^TKDT62DEyanmicStoreBuffer;

    PKDT62DE_Node = ^TKDT62DE_Node;

    TKDT62DE_Node = packed record
      Parent, Right, Left: PKDT62DE_Node;
      vec: PKDT62DE_Source;
    end;

    TKDT62DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT62DE_Source; const Data: Pointer);
    TKDT62DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT62DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT62DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT62DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT62DEyanmicStoreBuffer;
    KDBuff     : TKDT62DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT62DE_Node;
    TestBuff   : TKDT62DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT62DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT62DE_Node;
    function GetData(const index: NativeInt): PKDT62DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT62DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT62DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT62DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT62DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT62DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT62DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT62DE_Node; overload;
    function Search(const Buff: TKDT62DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT62DE_Node; overload;
    function Search(const Buff: TKDT62DE_Vec; var SearchedDistanceMin: Double): PKDT62DE_Node; overload;
    function Search(const Buff: TKDT62DE_Vec): PKDT62DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT62DE_DynamicVecBuffer; var OutBuff: TKDT62DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT62DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT62DE_Node);
    procedure PrintBuffer;

    class function KDT62DEVec(const s: string): TKDT62DE_Vec; overload;
    class function KDT62DEVec(const v: TKDT62DE_Vec): string; overload;
    class function KDT62DEPow(const v: TKDT62DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT62DEDistance(const v1, v2: TKDT62DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT62DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT63DE = class(TCoreClassObject)
  public type
    // code split
    TKDT63DE_Vec = array [0 .. KDT63DE_Axis - 1] of TKDT63DE_VecType;
    PKDT63DE_Vec = ^TKDT63DE_Vec;

    TKDT63DE_DynamicVecBuffer = packed array of TKDT63DE_Vec;
    PKDT63DE_DynamicVecBuffer = ^TKDT63DE_DynamicVecBuffer;

    TKDT63DE_Source = packed record
      Buff: TKDT63DE_Vec;
      index: Int64;
    end;

    PKDT63DE_Source       = ^TKDT63DE_Source;
    TKDT63DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT63DE_Source) - 1] of PKDT63DE_Source;
    PKDT63DE_SourceBuffer = ^TKDT63DE_SourceBuffer;

    TKDT63DEyanmicSourceBuffer = packed array of PKDT63DE_Source;
    PKDT63DEyanmicSourceBuffer = ^TKDT63DEyanmicSourceBuffer;

    TKDT63DEyanmicStoreBuffer = packed array of TKDT63DE_Source;
    PKDT63DEyanmicStoreBuffer = ^TKDT63DEyanmicStoreBuffer;

    PKDT63DE_Node = ^TKDT63DE_Node;

    TKDT63DE_Node = packed record
      Parent, Right, Left: PKDT63DE_Node;
      vec: PKDT63DE_Source;
    end;

    TKDT63DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT63DE_Source; const Data: Pointer);
    TKDT63DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT63DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT63DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT63DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT63DEyanmicStoreBuffer;
    KDBuff     : TKDT63DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT63DE_Node;
    TestBuff   : TKDT63DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT63DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT63DE_Node;
    function GetData(const index: NativeInt): PKDT63DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT63DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT63DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT63DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT63DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT63DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT63DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT63DE_Node; overload;
    function Search(const Buff: TKDT63DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT63DE_Node; overload;
    function Search(const Buff: TKDT63DE_Vec; var SearchedDistanceMin: Double): PKDT63DE_Node; overload;
    function Search(const Buff: TKDT63DE_Vec): PKDT63DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT63DE_DynamicVecBuffer; var OutBuff: TKDT63DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT63DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT63DE_Node);
    procedure PrintBuffer;

    class function KDT63DEVec(const s: string): TKDT63DE_Vec; overload;
    class function KDT63DEVec(const v: TKDT63DE_Vec): string; overload;
    class function KDT63DEPow(const v: TKDT63DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT63DEDistance(const v1, v2: TKDT63DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT63DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT64DE = class(TCoreClassObject)
  public type
    // code split
    TKDT64DE_Vec = array [0 .. KDT64DE_Axis - 1] of TKDT64DE_VecType;
    PKDT64DE_Vec = ^TKDT64DE_Vec;

    TKDT64DE_DynamicVecBuffer = packed array of TKDT64DE_Vec;
    PKDT64DE_DynamicVecBuffer = ^TKDT64DE_DynamicVecBuffer;

    TKDT64DE_Source = packed record
      Buff: TKDT64DE_Vec;
      index: Int64;
    end;

    PKDT64DE_Source       = ^TKDT64DE_Source;
    TKDT64DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT64DE_Source) - 1] of PKDT64DE_Source;
    PKDT64DE_SourceBuffer = ^TKDT64DE_SourceBuffer;

    TKDT64DEyanmicSourceBuffer = packed array of PKDT64DE_Source;
    PKDT64DEyanmicSourceBuffer = ^TKDT64DEyanmicSourceBuffer;

    TKDT64DEyanmicStoreBuffer = packed array of TKDT64DE_Source;
    PKDT64DEyanmicStoreBuffer = ^TKDT64DEyanmicStoreBuffer;

    PKDT64DE_Node = ^TKDT64DE_Node;

    TKDT64DE_Node = packed record
      Parent, Right, Left: PKDT64DE_Node;
      vec: PKDT64DE_Source;
    end;

    TKDT64DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT64DE_Source; const Data: Pointer);
    TKDT64DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT64DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT64DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT64DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT64DEyanmicStoreBuffer;
    KDBuff     : TKDT64DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT64DE_Node;
    TestBuff   : TKDT64DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DE_Node;
    function GetData(const index: NativeInt): PKDT64DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT64DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT64DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT64DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT64DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DE_Node; overload;
    function Search(const Buff: TKDT64DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DE_Node; overload;
    function Search(const Buff: TKDT64DE_Vec; var SearchedDistanceMin: Double): PKDT64DE_Node; overload;
    function Search(const Buff: TKDT64DE_Vec): PKDT64DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT64DE_DynamicVecBuffer; var OutBuff: TKDT64DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT64DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT64DE_Node);
    procedure PrintBuffer;

    class function KDT64DEVec(const s: string): TKDT64DE_Vec; overload;
    class function KDT64DEVec(const v: TKDT64DE_Vec): string; overload;
    class function KDT64DEPow(const v: TKDT64DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT64DEDistance(const v1, v2: TKDT64DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT64DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT65DE = class(TCoreClassObject)
  public type
    // code split
    TKDT65DE_Vec = array [0 .. KDT65DE_Axis - 1] of TKDT65DE_VecType;
    PKDT65DE_Vec = ^TKDT65DE_Vec;

    TKDT65DE_DynamicVecBuffer = packed array of TKDT65DE_Vec;
    PKDT65DE_DynamicVecBuffer = ^TKDT65DE_DynamicVecBuffer;

    TKDT65DE_Source = packed record
      Buff: TKDT65DE_Vec;
      index: Int64;
    end;

    PKDT65DE_Source       = ^TKDT65DE_Source;
    TKDT65DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT65DE_Source) - 1] of PKDT65DE_Source;
    PKDT65DE_SourceBuffer = ^TKDT65DE_SourceBuffer;

    TKDT65DEyanmicSourceBuffer = packed array of PKDT65DE_Source;
    PKDT65DEyanmicSourceBuffer = ^TKDT65DEyanmicSourceBuffer;

    TKDT65DEyanmicStoreBuffer = packed array of TKDT65DE_Source;
    PKDT65DEyanmicStoreBuffer = ^TKDT65DEyanmicStoreBuffer;

    PKDT65DE_Node = ^TKDT65DE_Node;

    TKDT65DE_Node = packed record
      Parent, Right, Left: PKDT65DE_Node;
      vec: PKDT65DE_Source;
    end;

    TKDT65DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT65DE_Source; const Data: Pointer);
    TKDT65DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT65DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT65DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT65DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT65DEyanmicStoreBuffer;
    KDBuff     : TKDT65DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT65DE_Node;
    TestBuff   : TKDT65DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT65DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT65DE_Node;
    function GetData(const index: NativeInt): PKDT65DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT65DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT65DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT65DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT65DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT65DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT65DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT65DE_Node; overload;
    function Search(const Buff: TKDT65DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT65DE_Node; overload;
    function Search(const Buff: TKDT65DE_Vec; var SearchedDistanceMin: Double): PKDT65DE_Node; overload;
    function Search(const Buff: TKDT65DE_Vec): PKDT65DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT65DE_DynamicVecBuffer; var OutBuff: TKDT65DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT65DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT65DE_Node);
    procedure PrintBuffer;

    class function KDT65DEVec(const s: string): TKDT65DE_Vec; overload;
    class function KDT65DEVec(const v: TKDT65DE_Vec): string; overload;
    class function KDT65DEPow(const v: TKDT65DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT65DEDistance(const v1, v2: TKDT65DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT65DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT66DE = class(TCoreClassObject)
  public type
    // code split
    TKDT66DE_Vec = array [0 .. KDT66DE_Axis - 1] of TKDT66DE_VecType;
    PKDT66DE_Vec = ^TKDT66DE_Vec;

    TKDT66DE_DynamicVecBuffer = packed array of TKDT66DE_Vec;
    PKDT66DE_DynamicVecBuffer = ^TKDT66DE_DynamicVecBuffer;

    TKDT66DE_Source = packed record
      Buff: TKDT66DE_Vec;
      index: Int64;
    end;

    PKDT66DE_Source       = ^TKDT66DE_Source;
    TKDT66DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT66DE_Source) - 1] of PKDT66DE_Source;
    PKDT66DE_SourceBuffer = ^TKDT66DE_SourceBuffer;

    TKDT66DEyanmicSourceBuffer = packed array of PKDT66DE_Source;
    PKDT66DEyanmicSourceBuffer = ^TKDT66DEyanmicSourceBuffer;

    TKDT66DEyanmicStoreBuffer = packed array of TKDT66DE_Source;
    PKDT66DEyanmicStoreBuffer = ^TKDT66DEyanmicStoreBuffer;

    PKDT66DE_Node = ^TKDT66DE_Node;

    TKDT66DE_Node = packed record
      Parent, Right, Left: PKDT66DE_Node;
      vec: PKDT66DE_Source;
    end;

    TKDT66DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT66DE_Source; const Data: Pointer);
    TKDT66DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT66DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT66DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT66DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT66DEyanmicStoreBuffer;
    KDBuff     : TKDT66DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT66DE_Node;
    TestBuff   : TKDT66DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT66DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT66DE_Node;
    function GetData(const index: NativeInt): PKDT66DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT66DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT66DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT66DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT66DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT66DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT66DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT66DE_Node; overload;
    function Search(const Buff: TKDT66DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT66DE_Node; overload;
    function Search(const Buff: TKDT66DE_Vec; var SearchedDistanceMin: Double): PKDT66DE_Node; overload;
    function Search(const Buff: TKDT66DE_Vec): PKDT66DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT66DE_DynamicVecBuffer; var OutBuff: TKDT66DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT66DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT66DE_Node);
    procedure PrintBuffer;

    class function KDT66DEVec(const s: string): TKDT66DE_Vec; overload;
    class function KDT66DEVec(const v: TKDT66DE_Vec): string; overload;
    class function KDT66DEPow(const v: TKDT66DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT66DEDistance(const v1, v2: TKDT66DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT66DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT67DE = class(TCoreClassObject)
  public type
    // code split
    TKDT67DE_Vec = array [0 .. KDT67DE_Axis - 1] of TKDT67DE_VecType;
    PKDT67DE_Vec = ^TKDT67DE_Vec;

    TKDT67DE_DynamicVecBuffer = packed array of TKDT67DE_Vec;
    PKDT67DE_DynamicVecBuffer = ^TKDT67DE_DynamicVecBuffer;

    TKDT67DE_Source = packed record
      Buff: TKDT67DE_Vec;
      index: Int64;
    end;

    PKDT67DE_Source       = ^TKDT67DE_Source;
    TKDT67DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT67DE_Source) - 1] of PKDT67DE_Source;
    PKDT67DE_SourceBuffer = ^TKDT67DE_SourceBuffer;

    TKDT67DEyanmicSourceBuffer = packed array of PKDT67DE_Source;
    PKDT67DEyanmicSourceBuffer = ^TKDT67DEyanmicSourceBuffer;

    TKDT67DEyanmicStoreBuffer = packed array of TKDT67DE_Source;
    PKDT67DEyanmicStoreBuffer = ^TKDT67DEyanmicStoreBuffer;

    PKDT67DE_Node = ^TKDT67DE_Node;

    TKDT67DE_Node = packed record
      Parent, Right, Left: PKDT67DE_Node;
      vec: PKDT67DE_Source;
    end;

    TKDT67DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT67DE_Source; const Data: Pointer);
    TKDT67DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT67DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT67DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT67DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT67DEyanmicStoreBuffer;
    KDBuff     : TKDT67DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT67DE_Node;
    TestBuff   : TKDT67DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT67DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT67DE_Node;
    function GetData(const index: NativeInt): PKDT67DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT67DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT67DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT67DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT67DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT67DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT67DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT67DE_Node; overload;
    function Search(const Buff: TKDT67DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT67DE_Node; overload;
    function Search(const Buff: TKDT67DE_Vec; var SearchedDistanceMin: Double): PKDT67DE_Node; overload;
    function Search(const Buff: TKDT67DE_Vec): PKDT67DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT67DE_DynamicVecBuffer; var OutBuff: TKDT67DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT67DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT67DE_Node);
    procedure PrintBuffer;

    class function KDT67DEVec(const s: string): TKDT67DE_Vec; overload;
    class function KDT67DEVec(const v: TKDT67DE_Vec): string; overload;
    class function KDT67DEPow(const v: TKDT67DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT67DEDistance(const v1, v2: TKDT67DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT67DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT68DE = class(TCoreClassObject)
  public type
    // code split
    TKDT68DE_Vec = array [0 .. KDT68DE_Axis - 1] of TKDT68DE_VecType;
    PKDT68DE_Vec = ^TKDT68DE_Vec;

    TKDT68DE_DynamicVecBuffer = packed array of TKDT68DE_Vec;
    PKDT68DE_DynamicVecBuffer = ^TKDT68DE_DynamicVecBuffer;

    TKDT68DE_Source = packed record
      Buff: TKDT68DE_Vec;
      index: Int64;
    end;

    PKDT68DE_Source       = ^TKDT68DE_Source;
    TKDT68DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT68DE_Source) - 1] of PKDT68DE_Source;
    PKDT68DE_SourceBuffer = ^TKDT68DE_SourceBuffer;

    TKDT68DEyanmicSourceBuffer = packed array of PKDT68DE_Source;
    PKDT68DEyanmicSourceBuffer = ^TKDT68DEyanmicSourceBuffer;

    TKDT68DEyanmicStoreBuffer = packed array of TKDT68DE_Source;
    PKDT68DEyanmicStoreBuffer = ^TKDT68DEyanmicStoreBuffer;

    PKDT68DE_Node = ^TKDT68DE_Node;

    TKDT68DE_Node = packed record
      Parent, Right, Left: PKDT68DE_Node;
      vec: PKDT68DE_Source;
    end;

    TKDT68DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT68DE_Source; const Data: Pointer);
    TKDT68DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT68DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT68DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT68DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT68DEyanmicStoreBuffer;
    KDBuff     : TKDT68DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT68DE_Node;
    TestBuff   : TKDT68DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT68DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT68DE_Node;
    function GetData(const index: NativeInt): PKDT68DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT68DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT68DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT68DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT68DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT68DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT68DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT68DE_Node; overload;
    function Search(const Buff: TKDT68DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT68DE_Node; overload;
    function Search(const Buff: TKDT68DE_Vec; var SearchedDistanceMin: Double): PKDT68DE_Node; overload;
    function Search(const Buff: TKDT68DE_Vec): PKDT68DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT68DE_DynamicVecBuffer; var OutBuff: TKDT68DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT68DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT68DE_Node);
    procedure PrintBuffer;

    class function KDT68DEVec(const s: string): TKDT68DE_Vec; overload;
    class function KDT68DEVec(const v: TKDT68DE_Vec): string; overload;
    class function KDT68DEPow(const v: TKDT68DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT68DEDistance(const v1, v2: TKDT68DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT68DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT69DE = class(TCoreClassObject)
  public type
    // code split
    TKDT69DE_Vec = array [0 .. KDT69DE_Axis - 1] of TKDT69DE_VecType;
    PKDT69DE_Vec = ^TKDT69DE_Vec;

    TKDT69DE_DynamicVecBuffer = packed array of TKDT69DE_Vec;
    PKDT69DE_DynamicVecBuffer = ^TKDT69DE_DynamicVecBuffer;

    TKDT69DE_Source = packed record
      Buff: TKDT69DE_Vec;
      index: Int64;
    end;

    PKDT69DE_Source       = ^TKDT69DE_Source;
    TKDT69DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT69DE_Source) - 1] of PKDT69DE_Source;
    PKDT69DE_SourceBuffer = ^TKDT69DE_SourceBuffer;

    TKDT69DEyanmicSourceBuffer = packed array of PKDT69DE_Source;
    PKDT69DEyanmicSourceBuffer = ^TKDT69DEyanmicSourceBuffer;

    TKDT69DEyanmicStoreBuffer = packed array of TKDT69DE_Source;
    PKDT69DEyanmicStoreBuffer = ^TKDT69DEyanmicStoreBuffer;

    PKDT69DE_Node = ^TKDT69DE_Node;

    TKDT69DE_Node = packed record
      Parent, Right, Left: PKDT69DE_Node;
      vec: PKDT69DE_Source;
    end;

    TKDT69DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT69DE_Source; const Data: Pointer);
    TKDT69DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT69DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT69DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT69DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT69DEyanmicStoreBuffer;
    KDBuff     : TKDT69DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT69DE_Node;
    TestBuff   : TKDT69DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT69DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT69DE_Node;
    function GetData(const index: NativeInt): PKDT69DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT69DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT69DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT69DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT69DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT69DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT69DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT69DE_Node; overload;
    function Search(const Buff: TKDT69DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT69DE_Node; overload;
    function Search(const Buff: TKDT69DE_Vec; var SearchedDistanceMin: Double): PKDT69DE_Node; overload;
    function Search(const Buff: TKDT69DE_Vec): PKDT69DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT69DE_DynamicVecBuffer; var OutBuff: TKDT69DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT69DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT69DE_Node);
    procedure PrintBuffer;

    class function KDT69DEVec(const s: string): TKDT69DE_Vec; overload;
    class function KDT69DEVec(const v: TKDT69DE_Vec): string; overload;
    class function KDT69DEPow(const v: TKDT69DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT69DEDistance(const v1, v2: TKDT69DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT69DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT70DE = class(TCoreClassObject)
  public type
    // code split
    TKDT70DE_Vec = array [0 .. KDT70DE_Axis - 1] of TKDT70DE_VecType;
    PKDT70DE_Vec = ^TKDT70DE_Vec;

    TKDT70DE_DynamicVecBuffer = packed array of TKDT70DE_Vec;
    PKDT70DE_DynamicVecBuffer = ^TKDT70DE_DynamicVecBuffer;

    TKDT70DE_Source = packed record
      Buff: TKDT70DE_Vec;
      index: Int64;
    end;

    PKDT70DE_Source       = ^TKDT70DE_Source;
    TKDT70DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT70DE_Source) - 1] of PKDT70DE_Source;
    PKDT70DE_SourceBuffer = ^TKDT70DE_SourceBuffer;

    TKDT70DEyanmicSourceBuffer = packed array of PKDT70DE_Source;
    PKDT70DEyanmicSourceBuffer = ^TKDT70DEyanmicSourceBuffer;

    TKDT70DEyanmicStoreBuffer = packed array of TKDT70DE_Source;
    PKDT70DEyanmicStoreBuffer = ^TKDT70DEyanmicStoreBuffer;

    PKDT70DE_Node = ^TKDT70DE_Node;

    TKDT70DE_Node = packed record
      Parent, Right, Left: PKDT70DE_Node;
      vec: PKDT70DE_Source;
    end;

    TKDT70DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT70DE_Source; const Data: Pointer);
    TKDT70DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT70DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT70DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT70DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT70DEyanmicStoreBuffer;
    KDBuff     : TKDT70DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT70DE_Node;
    TestBuff   : TKDT70DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT70DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT70DE_Node;
    function GetData(const index: NativeInt): PKDT70DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT70DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT70DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT70DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT70DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT70DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT70DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT70DE_Node; overload;
    function Search(const Buff: TKDT70DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT70DE_Node; overload;
    function Search(const Buff: TKDT70DE_Vec; var SearchedDistanceMin: Double): PKDT70DE_Node; overload;
    function Search(const Buff: TKDT70DE_Vec): PKDT70DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT70DE_DynamicVecBuffer; var OutBuff: TKDT70DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT70DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT70DE_Node);
    procedure PrintBuffer;

    class function KDT70DEVec(const s: string): TKDT70DE_Vec; overload;
    class function KDT70DEVec(const v: TKDT70DE_Vec): string; overload;
    class function KDT70DEPow(const v: TKDT70DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT70DEDistance(const v1, v2: TKDT70DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT70DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT71DE = class(TCoreClassObject)
  public type
    // code split
    TKDT71DE_Vec = array [0 .. KDT71DE_Axis - 1] of TKDT71DE_VecType;
    PKDT71DE_Vec = ^TKDT71DE_Vec;

    TKDT71DE_DynamicVecBuffer = packed array of TKDT71DE_Vec;
    PKDT71DE_DynamicVecBuffer = ^TKDT71DE_DynamicVecBuffer;

    TKDT71DE_Source = packed record
      Buff: TKDT71DE_Vec;
      index: Int64;
    end;

    PKDT71DE_Source       = ^TKDT71DE_Source;
    TKDT71DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT71DE_Source) - 1] of PKDT71DE_Source;
    PKDT71DE_SourceBuffer = ^TKDT71DE_SourceBuffer;

    TKDT71DEyanmicSourceBuffer = packed array of PKDT71DE_Source;
    PKDT71DEyanmicSourceBuffer = ^TKDT71DEyanmicSourceBuffer;

    TKDT71DEyanmicStoreBuffer = packed array of TKDT71DE_Source;
    PKDT71DEyanmicStoreBuffer = ^TKDT71DEyanmicStoreBuffer;

    PKDT71DE_Node = ^TKDT71DE_Node;

    TKDT71DE_Node = packed record
      Parent, Right, Left: PKDT71DE_Node;
      vec: PKDT71DE_Source;
    end;

    TKDT71DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT71DE_Source; const Data: Pointer);
    TKDT71DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT71DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT71DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT71DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT71DEyanmicStoreBuffer;
    KDBuff     : TKDT71DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT71DE_Node;
    TestBuff   : TKDT71DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT71DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT71DE_Node;
    function GetData(const index: NativeInt): PKDT71DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT71DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT71DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT71DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT71DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT71DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT71DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT71DE_Node; overload;
    function Search(const Buff: TKDT71DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT71DE_Node; overload;
    function Search(const Buff: TKDT71DE_Vec; var SearchedDistanceMin: Double): PKDT71DE_Node; overload;
    function Search(const Buff: TKDT71DE_Vec): PKDT71DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT71DE_DynamicVecBuffer; var OutBuff: TKDT71DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT71DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT71DE_Node);
    procedure PrintBuffer;

    class function KDT71DEVec(const s: string): TKDT71DE_Vec; overload;
    class function KDT71DEVec(const v: TKDT71DE_Vec): string; overload;
    class function KDT71DEPow(const v: TKDT71DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT71DEDistance(const v1, v2: TKDT71DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT71DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT72DE = class(TCoreClassObject)
  public type
    // code split
    TKDT72DE_Vec = array [0 .. KDT72DE_Axis - 1] of TKDT72DE_VecType;
    PKDT72DE_Vec = ^TKDT72DE_Vec;

    TKDT72DE_DynamicVecBuffer = packed array of TKDT72DE_Vec;
    PKDT72DE_DynamicVecBuffer = ^TKDT72DE_DynamicVecBuffer;

    TKDT72DE_Source = packed record
      Buff: TKDT72DE_Vec;
      index: Int64;
    end;

    PKDT72DE_Source       = ^TKDT72DE_Source;
    TKDT72DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT72DE_Source) - 1] of PKDT72DE_Source;
    PKDT72DE_SourceBuffer = ^TKDT72DE_SourceBuffer;

    TKDT72DEyanmicSourceBuffer = packed array of PKDT72DE_Source;
    PKDT72DEyanmicSourceBuffer = ^TKDT72DEyanmicSourceBuffer;

    TKDT72DEyanmicStoreBuffer = packed array of TKDT72DE_Source;
    PKDT72DEyanmicStoreBuffer = ^TKDT72DEyanmicStoreBuffer;

    PKDT72DE_Node = ^TKDT72DE_Node;

    TKDT72DE_Node = packed record
      Parent, Right, Left: PKDT72DE_Node;
      vec: PKDT72DE_Source;
    end;

    TKDT72DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT72DE_Source; const Data: Pointer);
    TKDT72DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT72DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT72DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT72DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT72DEyanmicStoreBuffer;
    KDBuff     : TKDT72DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT72DE_Node;
    TestBuff   : TKDT72DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT72DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT72DE_Node;
    function GetData(const index: NativeInt): PKDT72DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT72DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT72DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT72DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT72DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT72DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT72DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT72DE_Node; overload;
    function Search(const Buff: TKDT72DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT72DE_Node; overload;
    function Search(const Buff: TKDT72DE_Vec; var SearchedDistanceMin: Double): PKDT72DE_Node; overload;
    function Search(const Buff: TKDT72DE_Vec): PKDT72DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT72DE_DynamicVecBuffer; var OutBuff: TKDT72DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT72DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT72DE_Node);
    procedure PrintBuffer;

    class function KDT72DEVec(const s: string): TKDT72DE_Vec; overload;
    class function KDT72DEVec(const v: TKDT72DE_Vec): string; overload;
    class function KDT72DEPow(const v: TKDT72DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT72DEDistance(const v1, v2: TKDT72DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT72DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT84DE = class(TCoreClassObject)
  public type
    // code split
    TKDT84DE_Vec = array [0 .. KDT84DE_Axis - 1] of TKDT84DE_VecType;
    PKDT84DE_Vec = ^TKDT84DE_Vec;

    TKDT84DE_DynamicVecBuffer = packed array of TKDT84DE_Vec;
    PKDT84DE_DynamicVecBuffer = ^TKDT84DE_DynamicVecBuffer;

    TKDT84DE_Source = packed record
      Buff: TKDT84DE_Vec;
      index: Int64;
    end;

    PKDT84DE_Source       = ^TKDT84DE_Source;
    TKDT84DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT84DE_Source) - 1] of PKDT84DE_Source;
    PKDT84DE_SourceBuffer = ^TKDT84DE_SourceBuffer;

    TKDT84DEyanmicSourceBuffer = packed array of PKDT84DE_Source;
    PKDT84DEyanmicSourceBuffer = ^TKDT84DEyanmicSourceBuffer;

    TKDT84DEyanmicStoreBuffer = packed array of TKDT84DE_Source;
    PKDT84DEyanmicStoreBuffer = ^TKDT84DEyanmicStoreBuffer;

    PKDT84DE_Node = ^TKDT84DE_Node;

    TKDT84DE_Node = packed record
      Parent, Right, Left: PKDT84DE_Node;
      vec: PKDT84DE_Source;
    end;

    TKDT84DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT84DE_Source; const Data: Pointer);
    TKDT84DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT84DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT84DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT84DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT84DEyanmicStoreBuffer;
    KDBuff     : TKDT84DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT84DE_Node;
    TestBuff   : TKDT84DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT84DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT84DE_Node;
    function GetData(const index: NativeInt): PKDT84DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT84DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT84DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT84DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT84DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT84DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT84DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT84DE_Node; overload;
    function Search(const Buff: TKDT84DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT84DE_Node; overload;
    function Search(const Buff: TKDT84DE_Vec; var SearchedDistanceMin: Double): PKDT84DE_Node; overload;
    function Search(const Buff: TKDT84DE_Vec): PKDT84DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT84DE_DynamicVecBuffer; var OutBuff: TKDT84DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT84DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT84DE_Node);
    procedure PrintBuffer;

    class function KDT84DEVec(const s: string): TKDT84DE_Vec; overload;
    class function KDT84DEVec(const v: TKDT84DE_Vec): string; overload;
    class function KDT84DEPow(const v: TKDT84DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT84DEDistance(const v1, v2: TKDT84DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT84DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT96DE = class(TCoreClassObject)
  public type
    // code split
    TKDT96DE_Vec = array [0 .. KDT96DE_Axis - 1] of TKDT96DE_VecType;
    PKDT96DE_Vec = ^TKDT96DE_Vec;

    TKDT96DE_DynamicVecBuffer = packed array of TKDT96DE_Vec;
    PKDT96DE_DynamicVecBuffer = ^TKDT96DE_DynamicVecBuffer;

    TKDT96DE_Source = packed record
      Buff: TKDT96DE_Vec;
      index: Int64;
    end;

    PKDT96DE_Source       = ^TKDT96DE_Source;
    TKDT96DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT96DE_Source) - 1] of PKDT96DE_Source;
    PKDT96DE_SourceBuffer = ^TKDT96DE_SourceBuffer;

    TKDT96DEyanmicSourceBuffer = packed array of PKDT96DE_Source;
    PKDT96DEyanmicSourceBuffer = ^TKDT96DEyanmicSourceBuffer;

    TKDT96DEyanmicStoreBuffer = packed array of TKDT96DE_Source;
    PKDT96DEyanmicStoreBuffer = ^TKDT96DEyanmicStoreBuffer;

    PKDT96DE_Node = ^TKDT96DE_Node;

    TKDT96DE_Node = packed record
      Parent, Right, Left: PKDT96DE_Node;
      vec: PKDT96DE_Source;
    end;

    TKDT96DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT96DE_Source; const Data: Pointer);
    TKDT96DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT96DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT96DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT96DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT96DEyanmicStoreBuffer;
    KDBuff     : TKDT96DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT96DE_Node;
    TestBuff   : TKDT96DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DE_Node;
    function GetData(const index: NativeInt): PKDT96DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT96DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT96DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT96DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT96DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DE_Node; overload;
    function Search(const Buff: TKDT96DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DE_Node; overload;
    function Search(const Buff: TKDT96DE_Vec; var SearchedDistanceMin: Double): PKDT96DE_Node; overload;
    function Search(const Buff: TKDT96DE_Vec): PKDT96DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT96DE_DynamicVecBuffer; var OutBuff: TKDT96DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT96DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT96DE_Node);
    procedure PrintBuffer;

    class function KDT96DEVec(const s: string): TKDT96DE_Vec; overload;
    class function KDT96DEVec(const v: TKDT96DE_Vec): string; overload;
    class function KDT96DEPow(const v: TKDT96DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT96DEDistance(const v1, v2: TKDT96DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT96DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT128DE = class(TCoreClassObject)
  public type
    // code split
    TKDT128DE_Vec = array [0 .. KDT128DE_Axis - 1] of TKDT128DE_VecType;
    PKDT128DE_Vec = ^TKDT128DE_Vec;

    TKDT128DE_DynamicVecBuffer = packed array of TKDT128DE_Vec;
    PKDT128DE_DynamicVecBuffer = ^TKDT128DE_DynamicVecBuffer;

    TKDT128DE_Source = packed record
      Buff: TKDT128DE_Vec;
      index: Int64;
    end;

    PKDT128DE_Source       = ^TKDT128DE_Source;
    TKDT128DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT128DE_Source) - 1] of PKDT128DE_Source;
    PKDT128DE_SourceBuffer = ^TKDT128DE_SourceBuffer;

    TKDT128DEyanmicSourceBuffer = packed array of PKDT128DE_Source;
    PKDT128DEyanmicSourceBuffer = ^TKDT128DEyanmicSourceBuffer;

    TKDT128DEyanmicStoreBuffer = packed array of TKDT128DE_Source;
    PKDT128DEyanmicStoreBuffer = ^TKDT128DEyanmicStoreBuffer;

    PKDT128DE_Node = ^TKDT128DE_Node;

    TKDT128DE_Node = packed record
      Parent, Right, Left: PKDT128DE_Node;
      vec: PKDT128DE_Source;
    end;

    TKDT128DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT128DE_Source; const Data: Pointer);
    TKDT128DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT128DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT128DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT128DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT128DEyanmicStoreBuffer;
    KDBuff     : TKDT128DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT128DE_Node;
    TestBuff   : TKDT128DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DE_Node;
    function GetData(const index: NativeInt): PKDT128DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT128DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT128DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT128DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT128DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DE_Node; overload;
    function Search(const Buff: TKDT128DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DE_Node; overload;
    function Search(const Buff: TKDT128DE_Vec; var SearchedDistanceMin: Double): PKDT128DE_Node; overload;
    function Search(const Buff: TKDT128DE_Vec): PKDT128DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT128DE_DynamicVecBuffer; var OutBuff: TKDT128DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT128DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT128DE_Node);
    procedure PrintBuffer;

    class function KDT128DEVec(const s: string): TKDT128DE_Vec; overload;
    class function KDT128DEVec(const v: TKDT128DE_Vec): string; overload;
    class function KDT128DEPow(const v: TKDT128DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT128DEDistance(const v1, v2: TKDT128DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT128DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT140DE = class(TCoreClassObject)
  public type
    // code split
    TKDT140DE_Vec = array [0 .. KDT140DE_Axis - 1] of TKDT140DE_VecType;
    PKDT140DE_Vec = ^TKDT140DE_Vec;

    TKDT140DE_DynamicVecBuffer = packed array of TKDT140DE_Vec;
    PKDT140DE_DynamicVecBuffer = ^TKDT140DE_DynamicVecBuffer;

    TKDT140DE_Source = packed record
      Buff: TKDT140DE_Vec;
      index: Int64;
    end;

    PKDT140DE_Source       = ^TKDT140DE_Source;
    TKDT140DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT140DE_Source) - 1] of PKDT140DE_Source;
    PKDT140DE_SourceBuffer = ^TKDT140DE_SourceBuffer;

    TKDT140DEyanmicSourceBuffer = packed array of PKDT140DE_Source;
    PKDT140DEyanmicSourceBuffer = ^TKDT140DEyanmicSourceBuffer;

    TKDT140DEyanmicStoreBuffer = packed array of TKDT140DE_Source;
    PKDT140DEyanmicStoreBuffer = ^TKDT140DEyanmicStoreBuffer;

    PKDT140DE_Node = ^TKDT140DE_Node;

    TKDT140DE_Node = packed record
      Parent, Right, Left: PKDT140DE_Node;
      vec: PKDT140DE_Source;
    end;

    TKDT140DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT140DE_Source; const Data: Pointer);
    TKDT140DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT140DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT140DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT140DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT140DEyanmicStoreBuffer;
    KDBuff     : TKDT140DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT140DE_Node;
    TestBuff   : TKDT140DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT140DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT140DE_Node;
    function GetData(const index: NativeInt): PKDT140DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT140DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT140DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT140DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT140DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT140DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT140DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT140DE_Node; overload;
    function Search(const Buff: TKDT140DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT140DE_Node; overload;
    function Search(const Buff: TKDT140DE_Vec; var SearchedDistanceMin: Double): PKDT140DE_Node; overload;
    function Search(const Buff: TKDT140DE_Vec): PKDT140DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT140DE_DynamicVecBuffer; var OutBuff: TKDT140DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT140DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT140DE_Node);
    procedure PrintBuffer;

    class function KDT140DEVec(const s: string): TKDT140DE_Vec; overload;
    class function KDT140DEVec(const v: TKDT140DE_Vec): string; overload;
    class function KDT140DEPow(const v: TKDT140DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT140DEDistance(const v1, v2: TKDT140DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT140DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT160DE = class(TCoreClassObject)
  public type
    // code split
    TKDT160DE_Vec = array [0 .. KDT160DE_Axis - 1] of TKDT160DE_VecType;
    PKDT160DE_Vec = ^TKDT160DE_Vec;

    TKDT160DE_DynamicVecBuffer = packed array of TKDT160DE_Vec;
    PKDT160DE_DynamicVecBuffer = ^TKDT160DE_DynamicVecBuffer;

    TKDT160DE_Source = packed record
      Buff: TKDT160DE_Vec;
      index: Int64;
    end;

    PKDT160DE_Source       = ^TKDT160DE_Source;
    TKDT160DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT160DE_Source) - 1] of PKDT160DE_Source;
    PKDT160DE_SourceBuffer = ^TKDT160DE_SourceBuffer;

    TKDT160DEyanmicSourceBuffer = packed array of PKDT160DE_Source;
    PKDT160DEyanmicSourceBuffer = ^TKDT160DEyanmicSourceBuffer;

    TKDT160DEyanmicStoreBuffer = packed array of TKDT160DE_Source;
    PKDT160DEyanmicStoreBuffer = ^TKDT160DEyanmicStoreBuffer;

    PKDT160DE_Node = ^TKDT160DE_Node;

    TKDT160DE_Node = packed record
      Parent, Right, Left: PKDT160DE_Node;
      vec: PKDT160DE_Source;
    end;

    TKDT160DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT160DE_Source; const Data: Pointer);
    TKDT160DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT160DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT160DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT160DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT160DEyanmicStoreBuffer;
    KDBuff     : TKDT160DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT160DE_Node;
    TestBuff   : TKDT160DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT160DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT160DE_Node;
    function GetData(const index: NativeInt): PKDT160DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT160DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT160DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT160DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT160DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT160DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT160DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT160DE_Node; overload;
    function Search(const Buff: TKDT160DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT160DE_Node; overload;
    function Search(const Buff: TKDT160DE_Vec; var SearchedDistanceMin: Double): PKDT160DE_Node; overload;
    function Search(const Buff: TKDT160DE_Vec): PKDT160DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT160DE_DynamicVecBuffer; var OutBuff: TKDT160DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT160DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT160DE_Node);
    procedure PrintBuffer;

    class function KDT160DEVec(const s: string): TKDT160DE_Vec; overload;
    class function KDT160DEVec(const v: TKDT160DE_Vec): string; overload;
    class function KDT160DEPow(const v: TKDT160DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT160DEDistance(const v1, v2: TKDT160DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT160DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT196DE = class(TCoreClassObject)
  public type
    // code split
    TKDT196DE_Vec = array [0 .. KDT196DE_Axis - 1] of TKDT196DE_VecType;
    PKDT196DE_Vec = ^TKDT196DE_Vec;

    TKDT196DE_DynamicVecBuffer = packed array of TKDT196DE_Vec;
    PKDT196DE_DynamicVecBuffer = ^TKDT196DE_DynamicVecBuffer;

    TKDT196DE_Source = packed record
      Buff: TKDT196DE_Vec;
      index: Int64;
    end;

    PKDT196DE_Source       = ^TKDT196DE_Source;
    TKDT196DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT196DE_Source) - 1] of PKDT196DE_Source;
    PKDT196DE_SourceBuffer = ^TKDT196DE_SourceBuffer;

    TKDT196DEyanmicSourceBuffer = packed array of PKDT196DE_Source;
    PKDT196DEyanmicSourceBuffer = ^TKDT196DEyanmicSourceBuffer;

    TKDT196DEyanmicStoreBuffer = packed array of TKDT196DE_Source;
    PKDT196DEyanmicStoreBuffer = ^TKDT196DEyanmicStoreBuffer;

    PKDT196DE_Node = ^TKDT196DE_Node;

    TKDT196DE_Node = packed record
      Parent, Right, Left: PKDT196DE_Node;
      vec: PKDT196DE_Source;
    end;

    TKDT196DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT196DE_Source; const Data: Pointer);
    TKDT196DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT196DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT196DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT196DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT196DEyanmicStoreBuffer;
    KDBuff     : TKDT196DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT196DE_Node;
    TestBuff   : TKDT196DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT196DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT196DE_Node;
    function GetData(const index: NativeInt): PKDT196DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT196DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT196DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT196DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT196DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT196DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT196DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT196DE_Node; overload;
    function Search(const Buff: TKDT196DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT196DE_Node; overload;
    function Search(const Buff: TKDT196DE_Vec; var SearchedDistanceMin: Double): PKDT196DE_Node; overload;
    function Search(const Buff: TKDT196DE_Vec): PKDT196DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT196DE_DynamicVecBuffer; var OutBuff: TKDT196DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT196DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT196DE_Node);
    procedure PrintBuffer;

    class function KDT196DEVec(const s: string): TKDT196DE_Vec; overload;
    class function KDT196DEVec(const v: TKDT196DE_Vec): string; overload;
    class function KDT196DEPow(const v: TKDT196DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT196DEDistance(const v1, v2: TKDT196DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT196DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT256DE = class(TCoreClassObject)
  public type
    // code split
    TKDT256DE_Vec = array [0 .. KDT256DE_Axis - 1] of TKDT256DE_VecType;
    PKDT256DE_Vec = ^TKDT256DE_Vec;

    TKDT256DE_DynamicVecBuffer = packed array of TKDT256DE_Vec;
    PKDT256DE_DynamicVecBuffer = ^TKDT256DE_DynamicVecBuffer;

    TKDT256DE_Source = packed record
      Buff: TKDT256DE_Vec;
      index: Int64;
    end;

    PKDT256DE_Source       = ^TKDT256DE_Source;
    TKDT256DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT256DE_Source) - 1] of PKDT256DE_Source;
    PKDT256DE_SourceBuffer = ^TKDT256DE_SourceBuffer;

    TKDT256DEyanmicSourceBuffer = packed array of PKDT256DE_Source;
    PKDT256DEyanmicSourceBuffer = ^TKDT256DEyanmicSourceBuffer;

    TKDT256DEyanmicStoreBuffer = packed array of TKDT256DE_Source;
    PKDT256DEyanmicStoreBuffer = ^TKDT256DEyanmicStoreBuffer;

    PKDT256DE_Node = ^TKDT256DE_Node;

    TKDT256DE_Node = packed record
      Parent, Right, Left: PKDT256DE_Node;
      vec: PKDT256DE_Source;
    end;

    TKDT256DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT256DE_Source; const Data: Pointer);
    TKDT256DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT256DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT256DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT256DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT256DEyanmicStoreBuffer;
    KDBuff     : TKDT256DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT256DE_Node;
    TestBuff   : TKDT256DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DE_Node;
    function GetData(const index: NativeInt): PKDT256DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT256DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT256DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT256DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT256DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DE_Node; overload;
    function Search(const Buff: TKDT256DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DE_Node; overload;
    function Search(const Buff: TKDT256DE_Vec; var SearchedDistanceMin: Double): PKDT256DE_Node; overload;
    function Search(const Buff: TKDT256DE_Vec): PKDT256DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT256DE_DynamicVecBuffer; var OutBuff: TKDT256DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT256DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT256DE_Node);
    procedure PrintBuffer;

    class function KDT256DEVec(const s: string): TKDT256DE_Vec; overload;
    class function KDT256DEVec(const v: TKDT256DE_Vec): string; overload;
    class function KDT256DEPow(const v: TKDT256DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT256DEDistance(const v1, v2: TKDT256DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT256DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT272DE = class(TCoreClassObject)
  public type
    // code split
    TKDT272DE_Vec = array [0 .. KDT272DE_Axis - 1] of TKDT272DE_VecType;
    PKDT272DE_Vec = ^TKDT272DE_Vec;

    TKDT272DE_DynamicVecBuffer = packed array of TKDT272DE_Vec;
    PKDT272DE_DynamicVecBuffer = ^TKDT272DE_DynamicVecBuffer;

    TKDT272DE_Source = packed record
      Buff: TKDT272DE_Vec;
      index: Int64;
    end;

    PKDT272DE_Source       = ^TKDT272DE_Source;
    TKDT272DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT272DE_Source) - 1] of PKDT272DE_Source;
    PKDT272DE_SourceBuffer = ^TKDT272DE_SourceBuffer;

    TKDT272DEyanmicSourceBuffer = packed array of PKDT272DE_Source;
    PKDT272DEyanmicSourceBuffer = ^TKDT272DEyanmicSourceBuffer;

    TKDT272DEyanmicStoreBuffer = packed array of TKDT272DE_Source;
    PKDT272DEyanmicStoreBuffer = ^TKDT272DEyanmicStoreBuffer;

    PKDT272DE_Node = ^TKDT272DE_Node;

    TKDT272DE_Node = packed record
      Parent, Right, Left: PKDT272DE_Node;
      vec: PKDT272DE_Source;
    end;

    TKDT272DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT272DE_Source; const Data: Pointer);
    TKDT272DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT272DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT272DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT272DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT272DEyanmicStoreBuffer;
    KDBuff     : TKDT272DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT272DE_Node;
    TestBuff   : TKDT272DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT272DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT272DE_Node;
    function GetData(const index: NativeInt): PKDT272DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT272DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT272DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT272DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT272DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT272DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT272DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT272DE_Node; overload;
    function Search(const Buff: TKDT272DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT272DE_Node; overload;
    function Search(const Buff: TKDT272DE_Vec; var SearchedDistanceMin: Double): PKDT272DE_Node; overload;
    function Search(const Buff: TKDT272DE_Vec): PKDT272DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT272DE_DynamicVecBuffer; var OutBuff: TKDT272DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT272DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT272DE_Node);
    procedure PrintBuffer;

    class function KDT272DEVec(const s: string): TKDT272DE_Vec; overload;
    class function KDT272DEVec(const v: TKDT272DE_Vec): string; overload;
    class function KDT272DEPow(const v: TKDT272DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT272DEDistance(const v1, v2: TKDT272DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT272DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT288DE = class(TCoreClassObject)
  public type
    // code split
    TKDT288DE_Vec = array [0 .. KDT288DE_Axis - 1] of TKDT288DE_VecType;
    PKDT288DE_Vec = ^TKDT288DE_Vec;

    TKDT288DE_DynamicVecBuffer = packed array of TKDT288DE_Vec;
    PKDT288DE_DynamicVecBuffer = ^TKDT288DE_DynamicVecBuffer;

    TKDT288DE_Source = packed record
      Buff: TKDT288DE_Vec;
      index: Int64;
    end;

    PKDT288DE_Source       = ^TKDT288DE_Source;
    TKDT288DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT288DE_Source) - 1] of PKDT288DE_Source;
    PKDT288DE_SourceBuffer = ^TKDT288DE_SourceBuffer;

    TKDT288DEyanmicSourceBuffer = packed array of PKDT288DE_Source;
    PKDT288DEyanmicSourceBuffer = ^TKDT288DEyanmicSourceBuffer;

    TKDT288DEyanmicStoreBuffer = packed array of TKDT288DE_Source;
    PKDT288DEyanmicStoreBuffer = ^TKDT288DEyanmicStoreBuffer;

    PKDT288DE_Node = ^TKDT288DE_Node;

    TKDT288DE_Node = packed record
      Parent, Right, Left: PKDT288DE_Node;
      vec: PKDT288DE_Source;
    end;

    TKDT288DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT288DE_Source; const Data: Pointer);
    TKDT288DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT288DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT288DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT288DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT288DEyanmicStoreBuffer;
    KDBuff     : TKDT288DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT288DE_Node;
    TestBuff   : TKDT288DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT288DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT288DE_Node;
    function GetData(const index: NativeInt): PKDT288DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT288DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT288DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT288DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT288DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT288DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT288DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT288DE_Node; overload;
    function Search(const Buff: TKDT288DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT288DE_Node; overload;
    function Search(const Buff: TKDT288DE_Vec; var SearchedDistanceMin: Double): PKDT288DE_Node; overload;
    function Search(const Buff: TKDT288DE_Vec): PKDT288DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT288DE_DynamicVecBuffer; var OutBuff: TKDT288DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT288DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT288DE_Node);
    procedure PrintBuffer;

    class function KDT288DEVec(const s: string): TKDT288DE_Vec; overload;
    class function KDT288DEVec(const v: TKDT288DE_Vec): string; overload;
    class function KDT288DEPow(const v: TKDT288DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT288DEDistance(const v1, v2: TKDT288DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT288DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT372DE = class(TCoreClassObject)
  public type
    // code split
    TKDT372DE_Vec = array [0 .. KDT372DE_Axis - 1] of TKDT372DE_VecType;
    PKDT372DE_Vec = ^TKDT372DE_Vec;

    TKDT372DE_DynamicVecBuffer = packed array of TKDT372DE_Vec;
    PKDT372DE_DynamicVecBuffer = ^TKDT372DE_DynamicVecBuffer;

    TKDT372DE_Source = packed record
      Buff: TKDT372DE_Vec;
      index: Int64;
    end;

    PKDT372DE_Source       = ^TKDT372DE_Source;
    TKDT372DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT372DE_Source) - 1] of PKDT372DE_Source;
    PKDT372DE_SourceBuffer = ^TKDT372DE_SourceBuffer;

    TKDT372DEyanmicSourceBuffer = packed array of PKDT372DE_Source;
    PKDT372DEyanmicSourceBuffer = ^TKDT372DEyanmicSourceBuffer;

    TKDT372DEyanmicStoreBuffer = packed array of TKDT372DE_Source;
    PKDT372DEyanmicStoreBuffer = ^TKDT372DEyanmicStoreBuffer;

    PKDT372DE_Node = ^TKDT372DE_Node;

    TKDT372DE_Node = packed record
      Parent, Right, Left: PKDT372DE_Node;
      vec: PKDT372DE_Source;
    end;

    TKDT372DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT372DE_Source; const Data: Pointer);
    TKDT372DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT372DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT372DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT372DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT372DEyanmicStoreBuffer;
    KDBuff     : TKDT372DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT372DE_Node;
    TestBuff   : TKDT372DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DE_Node;
    function GetData(const index: NativeInt): PKDT372DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT372DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT372DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT372DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT372DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DE_Node; overload;
    function Search(const Buff: TKDT372DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DE_Node; overload;
    function Search(const Buff: TKDT372DE_Vec; var SearchedDistanceMin: Double): PKDT372DE_Node; overload;
    function Search(const Buff: TKDT372DE_Vec): PKDT372DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT372DE_DynamicVecBuffer; var OutBuff: TKDT372DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT372DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT372DE_Node);
    procedure PrintBuffer;

    class function KDT372DEVec(const s: string): TKDT372DE_Vec; overload;
    class function KDT372DEVec(const v: TKDT372DE_Vec): string; overload;
    class function KDT372DEPow(const v: TKDT372DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT372DEDistance(const v1, v2: TKDT372DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT372DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT512DE = class(TCoreClassObject)
  public type
    // code split
    TKDT512DE_Vec = array [0 .. KDT512DE_Axis - 1] of TKDT512DE_VecType;
    PKDT512DE_Vec = ^TKDT512DE_Vec;

    TKDT512DE_DynamicVecBuffer = packed array of TKDT512DE_Vec;
    PKDT512DE_DynamicVecBuffer = ^TKDT512DE_DynamicVecBuffer;

    TKDT512DE_Source = packed record
      Buff: TKDT512DE_Vec;
      index: Int64;
    end;

    PKDT512DE_Source       = ^TKDT512DE_Source;
    TKDT512DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT512DE_Source) - 1] of PKDT512DE_Source;
    PKDT512DE_SourceBuffer = ^TKDT512DE_SourceBuffer;

    TKDT512DEyanmicSourceBuffer = packed array of PKDT512DE_Source;
    PKDT512DEyanmicSourceBuffer = ^TKDT512DEyanmicSourceBuffer;

    TKDT512DEyanmicStoreBuffer = packed array of TKDT512DE_Source;
    PKDT512DEyanmicStoreBuffer = ^TKDT512DEyanmicStoreBuffer;

    PKDT512DE_Node = ^TKDT512DE_Node;

    TKDT512DE_Node = packed record
      Parent, Right, Left: PKDT512DE_Node;
      vec: PKDT512DE_Source;
    end;

    TKDT512DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT512DE_Source; const Data: Pointer);
    TKDT512DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT512DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT512DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT512DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT512DEyanmicStoreBuffer;
    KDBuff     : TKDT512DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT512DE_Node;
    TestBuff   : TKDT512DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DE_Node;
    function GetData(const index: NativeInt): PKDT512DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT512DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT512DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT512DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT512DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DE_Node; overload;
    function Search(const Buff: TKDT512DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DE_Node; overload;
    function Search(const Buff: TKDT512DE_Vec; var SearchedDistanceMin: Double): PKDT512DE_Node; overload;
    function Search(const Buff: TKDT512DE_Vec): PKDT512DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT512DE_DynamicVecBuffer; var OutBuff: TKDT512DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT512DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT512DE_Node);
    procedure PrintBuffer;

    class function KDT512DEVec(const s: string): TKDT512DE_Vec; overload;
    class function KDT512DEVec(const v: TKDT512DE_Vec): string; overload;
    class function KDT512DEPow(const v: TKDT512DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT512DEDistance(const v1, v2: TKDT512DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT512DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT576DE = class(TCoreClassObject)
  public type
    // code split
    TKDT576DE_Vec = array [0 .. KDT576DE_Axis - 1] of TKDT576DE_VecType;
    PKDT576DE_Vec = ^TKDT576DE_Vec;

    TKDT576DE_DynamicVecBuffer = packed array of TKDT576DE_Vec;
    PKDT576DE_DynamicVecBuffer = ^TKDT576DE_DynamicVecBuffer;

    TKDT576DE_Source = packed record
      Buff: TKDT576DE_Vec;
      index: Int64;
    end;

    PKDT576DE_Source       = ^TKDT576DE_Source;
    TKDT576DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT576DE_Source) - 1] of PKDT576DE_Source;
    PKDT576DE_SourceBuffer = ^TKDT576DE_SourceBuffer;

    TKDT576DEyanmicSourceBuffer = packed array of PKDT576DE_Source;
    PKDT576DEyanmicSourceBuffer = ^TKDT576DEyanmicSourceBuffer;

    TKDT576DEyanmicStoreBuffer = packed array of TKDT576DE_Source;
    PKDT576DEyanmicStoreBuffer = ^TKDT576DEyanmicStoreBuffer;

    PKDT576DE_Node = ^TKDT576DE_Node;

    TKDT576DE_Node = packed record
      Parent, Right, Left: PKDT576DE_Node;
      vec: PKDT576DE_Source;
    end;

    TKDT576DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT576DE_Source; const Data: Pointer);
    TKDT576DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT576DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT576DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT576DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT576DEyanmicStoreBuffer;
    KDBuff     : TKDT576DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT576DE_Node;
    TestBuff   : TKDT576DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT576DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT576DE_Node;
    function GetData(const index: NativeInt): PKDT576DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT576DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT576DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT576DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT576DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT576DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT576DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT576DE_Node; overload;
    function Search(const Buff: TKDT576DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT576DE_Node; overload;
    function Search(const Buff: TKDT576DE_Vec; var SearchedDistanceMin: Double): PKDT576DE_Node; overload;
    function Search(const Buff: TKDT576DE_Vec): PKDT576DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT576DE_DynamicVecBuffer; var OutBuff: TKDT576DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT576DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT576DE_Node);
    procedure PrintBuffer;

    class function KDT576DEVec(const s: string): TKDT576DE_Vec; overload;
    class function KDT576DEVec(const v: TKDT576DE_Vec): string; overload;
    class function KDT576DEPow(const v: TKDT576DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT576DEDistance(const v1, v2: TKDT576DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT576DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT768DE = class(TCoreClassObject)
  public type
    // code split
    TKDT768DE_Vec = array [0 .. KDT768DE_Axis - 1] of TKDT768DE_VecType;
    PKDT768DE_Vec = ^TKDT768DE_Vec;

    TKDT768DE_DynamicVecBuffer = packed array of TKDT768DE_Vec;
    PKDT768DE_DynamicVecBuffer = ^TKDT768DE_DynamicVecBuffer;

    TKDT768DE_Source = packed record
      Buff: TKDT768DE_Vec;
      index: Int64;
    end;

    PKDT768DE_Source       = ^TKDT768DE_Source;
    TKDT768DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT768DE_Source) - 1] of PKDT768DE_Source;
    PKDT768DE_SourceBuffer = ^TKDT768DE_SourceBuffer;

    TKDT768DEyanmicSourceBuffer = packed array of PKDT768DE_Source;
    PKDT768DEyanmicSourceBuffer = ^TKDT768DEyanmicSourceBuffer;

    TKDT768DEyanmicStoreBuffer = packed array of TKDT768DE_Source;
    PKDT768DEyanmicStoreBuffer = ^TKDT768DEyanmicStoreBuffer;

    PKDT768DE_Node = ^TKDT768DE_Node;

    TKDT768DE_Node = packed record
      Parent, Right, Left: PKDT768DE_Node;
      vec: PKDT768DE_Source;
    end;

    TKDT768DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT768DE_Source; const Data: Pointer);
    TKDT768DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT768DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT768DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT768DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT768DEyanmicStoreBuffer;
    KDBuff     : TKDT768DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT768DE_Node;
    TestBuff   : TKDT768DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DE_Node;
    function GetData(const index: NativeInt): PKDT768DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT768DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT768DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT768DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT768DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DE_Node; overload;
    function Search(const Buff: TKDT768DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DE_Node; overload;
    function Search(const Buff: TKDT768DE_Vec; var SearchedDistanceMin: Double): PKDT768DE_Node; overload;
    function Search(const Buff: TKDT768DE_Vec): PKDT768DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT768DE_DynamicVecBuffer; var OutBuff: TKDT768DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT768DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT768DE_Node);
    procedure PrintBuffer;

    class function KDT768DEVec(const s: string): TKDT768DE_Vec; overload;
    class function KDT768DEVec(const v: TKDT768DE_Vec): string; overload;
    class function KDT768DEPow(const v: TKDT768DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT768DEDistance(const v1, v2: TKDT768DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT768DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1024DE = class(TCoreClassObject)
  public type
    // code split
    TKDT1024DE_Vec = array [0 .. KDT1024DE_Axis - 1] of TKDT1024DE_VecType;
    PKDT1024DE_Vec = ^TKDT1024DE_Vec;

    TKDT1024DE_DynamicVecBuffer = packed array of TKDT1024DE_Vec;
    PKDT1024DE_DynamicVecBuffer = ^TKDT1024DE_DynamicVecBuffer;

    TKDT1024DE_Source = packed record
      Buff: TKDT1024DE_Vec;
      index: Int64;
    end;

    PKDT1024DE_Source       = ^TKDT1024DE_Source;
    TKDT1024DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT1024DE_Source) - 1] of PKDT1024DE_Source;
    PKDT1024DE_SourceBuffer = ^TKDT1024DE_SourceBuffer;

    TKDT1024DEyanmicSourceBuffer = packed array of PKDT1024DE_Source;
    PKDT1024DEyanmicSourceBuffer = ^TKDT1024DEyanmicSourceBuffer;

    TKDT1024DEyanmicStoreBuffer = packed array of TKDT1024DE_Source;
    PKDT1024DEyanmicStoreBuffer = ^TKDT1024DEyanmicStoreBuffer;

    PKDT1024DE_Node = ^TKDT1024DE_Node;

    TKDT1024DE_Node = packed record
      Parent, Right, Left: PKDT1024DE_Node;
      vec: PKDT1024DE_Source;
    end;

    TKDT1024DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1024DE_Source; const Data: Pointer);
    TKDT1024DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1024DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1024DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1024DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1024DEyanmicStoreBuffer;
    KDBuff     : TKDT1024DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT1024DE_Node;
    TestBuff   : TKDT1024DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DE_Node;
    function GetData(const index: NativeInt): PKDT1024DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1024DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1024DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1024DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1024DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DE_Node; overload;
    function Search(const Buff: TKDT1024DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DE_Node; overload;
    function Search(const Buff: TKDT1024DE_Vec; var SearchedDistanceMin: Double): PKDT1024DE_Node; overload;
    function Search(const Buff: TKDT1024DE_Vec): PKDT1024DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1024DE_DynamicVecBuffer; var OutBuff: TKDT1024DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1024DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1024DE_Node);
    procedure PrintBuffer;

    class function KDT1024DEVec(const s: string): TKDT1024DE_Vec; overload;
    class function KDT1024DEVec(const v: TKDT1024DE_Vec): string; overload;
    class function KDT1024DEPow(const v: TKDT1024DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1024DEDistance(const v1, v2: TKDT1024DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1024DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1040DE = class(TCoreClassObject)
  public type
    // code split
    TKDT1040DE_Vec = array [0 .. KDT1040DE_Axis - 1] of TKDT1040DE_VecType;
    PKDT1040DE_Vec = ^TKDT1040DE_Vec;

    TKDT1040DE_DynamicVecBuffer = packed array of TKDT1040DE_Vec;
    PKDT1040DE_DynamicVecBuffer = ^TKDT1040DE_DynamicVecBuffer;

    TKDT1040DE_Source = packed record
      Buff: TKDT1040DE_Vec;
      index: Int64;
    end;

    PKDT1040DE_Source       = ^TKDT1040DE_Source;
    TKDT1040DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT1040DE_Source) - 1] of PKDT1040DE_Source;
    PKDT1040DE_SourceBuffer = ^TKDT1040DE_SourceBuffer;

    TKDT1040DEyanmicSourceBuffer = packed array of PKDT1040DE_Source;
    PKDT1040DEyanmicSourceBuffer = ^TKDT1040DEyanmicSourceBuffer;

    TKDT1040DEyanmicStoreBuffer = packed array of TKDT1040DE_Source;
    PKDT1040DEyanmicStoreBuffer = ^TKDT1040DEyanmicStoreBuffer;

    PKDT1040DE_Node = ^TKDT1040DE_Node;

    TKDT1040DE_Node = packed record
      Parent, Right, Left: PKDT1040DE_Node;
      vec: PKDT1040DE_Source;
    end;

    TKDT1040DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1040DE_Source; const Data: Pointer);
    TKDT1040DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1040DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1040DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1040DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1040DEyanmicStoreBuffer;
    KDBuff     : TKDT1040DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT1040DE_Node;
    TestBuff   : TKDT1040DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1040DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1040DE_Node;
    function GetData(const index: NativeInt): PKDT1040DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1040DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1040DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1040DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1040DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1040DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1040DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1040DE_Node; overload;
    function Search(const Buff: TKDT1040DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1040DE_Node; overload;
    function Search(const Buff: TKDT1040DE_Vec; var SearchedDistanceMin: Double): PKDT1040DE_Node; overload;
    function Search(const Buff: TKDT1040DE_Vec): PKDT1040DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1040DE_DynamicVecBuffer; var OutBuff: TKDT1040DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1040DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1040DE_Node);
    procedure PrintBuffer;

    class function KDT1040DEVec(const s: string): TKDT1040DE_Vec; overload;
    class function KDT1040DEVec(const v: TKDT1040DE_Vec): string; overload;
    class function KDT1040DEPow(const v: TKDT1040DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1040DEDistance(const v1, v2: TKDT1040DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1040DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1056DE = class(TCoreClassObject)
  public type
    // code split
    TKDT1056DE_Vec = array [0 .. KDT1056DE_Axis - 1] of TKDT1056DE_VecType;
    PKDT1056DE_Vec = ^TKDT1056DE_Vec;

    TKDT1056DE_DynamicVecBuffer = packed array of TKDT1056DE_Vec;
    PKDT1056DE_DynamicVecBuffer = ^TKDT1056DE_DynamicVecBuffer;

    TKDT1056DE_Source = packed record
      Buff: TKDT1056DE_Vec;
      index: Int64;
    end;

    PKDT1056DE_Source       = ^TKDT1056DE_Source;
    TKDT1056DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT1056DE_Source) - 1] of PKDT1056DE_Source;
    PKDT1056DE_SourceBuffer = ^TKDT1056DE_SourceBuffer;

    TKDT1056DEyanmicSourceBuffer = packed array of PKDT1056DE_Source;
    PKDT1056DEyanmicSourceBuffer = ^TKDT1056DEyanmicSourceBuffer;

    TKDT1056DEyanmicStoreBuffer = packed array of TKDT1056DE_Source;
    PKDT1056DEyanmicStoreBuffer = ^TKDT1056DEyanmicStoreBuffer;

    PKDT1056DE_Node = ^TKDT1056DE_Node;

    TKDT1056DE_Node = packed record
      Parent, Right, Left: PKDT1056DE_Node;
      vec: PKDT1056DE_Source;
    end;

    TKDT1056DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1056DE_Source; const Data: Pointer);
    TKDT1056DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1056DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1056DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1056DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1056DEyanmicStoreBuffer;
    KDBuff     : TKDT1056DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT1056DE_Node;
    TestBuff   : TKDT1056DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1056DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1056DE_Node;
    function GetData(const index: NativeInt): PKDT1056DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1056DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1056DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1056DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1056DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1056DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1056DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1056DE_Node; overload;
    function Search(const Buff: TKDT1056DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1056DE_Node; overload;
    function Search(const Buff: TKDT1056DE_Vec; var SearchedDistanceMin: Double): PKDT1056DE_Node; overload;
    function Search(const Buff: TKDT1056DE_Vec): PKDT1056DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1056DE_DynamicVecBuffer; var OutBuff: TKDT1056DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1056DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1056DE_Node);
    procedure PrintBuffer;

    class function KDT1056DEVec(const s: string): TKDT1056DE_Vec; overload;
    class function KDT1056DEVec(const v: TKDT1056DE_Vec): string; overload;
    class function KDT1056DEPow(const v: TKDT1056DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1056DEDistance(const v1, v2: TKDT1056DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1056DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1536DE = class(TCoreClassObject)
  public type
    // code split
    TKDT1536DE_Vec = array [0 .. KDT1536DE_Axis - 1] of TKDT1536DE_VecType;
    PKDT1536DE_Vec = ^TKDT1536DE_Vec;

    TKDT1536DE_DynamicVecBuffer = packed array of TKDT1536DE_Vec;
    PKDT1536DE_DynamicVecBuffer = ^TKDT1536DE_DynamicVecBuffer;

    TKDT1536DE_Source = packed record
      Buff: TKDT1536DE_Vec;
      index: Int64;
    end;

    PKDT1536DE_Source       = ^TKDT1536DE_Source;
    TKDT1536DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT1536DE_Source) - 1] of PKDT1536DE_Source;
    PKDT1536DE_SourceBuffer = ^TKDT1536DE_SourceBuffer;

    TKDT1536DEyanmicSourceBuffer = packed array of PKDT1536DE_Source;
    PKDT1536DEyanmicSourceBuffer = ^TKDT1536DEyanmicSourceBuffer;

    TKDT1536DEyanmicStoreBuffer = packed array of TKDT1536DE_Source;
    PKDT1536DEyanmicStoreBuffer = ^TKDT1536DEyanmicStoreBuffer;

    PKDT1536DE_Node = ^TKDT1536DE_Node;

    TKDT1536DE_Node = packed record
      Parent, Right, Left: PKDT1536DE_Node;
      vec: PKDT1536DE_Source;
    end;

    TKDT1536DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1536DE_Source; const Data: Pointer);
    TKDT1536DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1536DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1536DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1536DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1536DEyanmicStoreBuffer;
    KDBuff     : TKDT1536DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT1536DE_Node;
    TestBuff   : TKDT1536DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DE_Node;
    function GetData(const index: NativeInt): PKDT1536DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1536DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1536DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1536DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1536DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DE_Node; overload;
    function Search(const Buff: TKDT1536DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DE_Node; overload;
    function Search(const Buff: TKDT1536DE_Vec; var SearchedDistanceMin: Double): PKDT1536DE_Node; overload;
    function Search(const Buff: TKDT1536DE_Vec): PKDT1536DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1536DE_DynamicVecBuffer; var OutBuff: TKDT1536DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1536DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1536DE_Node);
    procedure PrintBuffer;

    class function KDT1536DEVec(const s: string): TKDT1536DE_Vec; overload;
    class function KDT1536DEVec(const v: TKDT1536DE_Vec): string; overload;
    class function KDT1536DEPow(const v: TKDT1536DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1536DEDistance(const v1, v2: TKDT1536DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1536DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1920DE = class(TCoreClassObject)
  public type
    // code split
    TKDT1920DE_Vec = array [0 .. KDT1920DE_Axis - 1] of TKDT1920DE_VecType;
    PKDT1920DE_Vec = ^TKDT1920DE_Vec;

    TKDT1920DE_DynamicVecBuffer = packed array of TKDT1920DE_Vec;
    PKDT1920DE_DynamicVecBuffer = ^TKDT1920DE_DynamicVecBuffer;

    TKDT1920DE_Source = packed record
      Buff: TKDT1920DE_Vec;
      index: Int64;
    end;

    PKDT1920DE_Source       = ^TKDT1920DE_Source;
    TKDT1920DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT1920DE_Source) - 1] of PKDT1920DE_Source;
    PKDT1920DE_SourceBuffer = ^TKDT1920DE_SourceBuffer;

    TKDT1920DEyanmicSourceBuffer = packed array of PKDT1920DE_Source;
    PKDT1920DEyanmicSourceBuffer = ^TKDT1920DEyanmicSourceBuffer;

    TKDT1920DEyanmicStoreBuffer = packed array of TKDT1920DE_Source;
    PKDT1920DEyanmicStoreBuffer = ^TKDT1920DEyanmicStoreBuffer;

    PKDT1920DE_Node = ^TKDT1920DE_Node;

    TKDT1920DE_Node = packed record
      Parent, Right, Left: PKDT1920DE_Node;
      vec: PKDT1920DE_Source;
    end;

    TKDT1920DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1920DE_Source; const Data: Pointer);
    TKDT1920DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1920DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1920DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1920DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1920DEyanmicStoreBuffer;
    KDBuff     : TKDT1920DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT1920DE_Node;
    TestBuff   : TKDT1920DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DE_Node;
    function GetData(const index: NativeInt): PKDT1920DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1920DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1920DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1920DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1920DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DE_Node; overload;
    function Search(const Buff: TKDT1920DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DE_Node; overload;
    function Search(const Buff: TKDT1920DE_Vec; var SearchedDistanceMin: Double): PKDT1920DE_Node; overload;
    function Search(const Buff: TKDT1920DE_Vec): PKDT1920DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1920DE_DynamicVecBuffer; var OutBuff: TKDT1920DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1920DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1920DE_Node);
    procedure PrintBuffer;

    class function KDT1920DEVec(const s: string): TKDT1920DE_Vec; overload;
    class function KDT1920DEVec(const v: TKDT1920DE_Vec): string; overload;
    class function KDT1920DEPow(const v: TKDT1920DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1920DEDistance(const v1, v2: TKDT1920DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1920DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1980DE = class(TCoreClassObject)
  public type
    // code split
    TKDT1980DE_Vec = array [0 .. KDT1980DE_Axis - 1] of TKDT1980DE_VecType;
    PKDT1980DE_Vec = ^TKDT1980DE_Vec;

    TKDT1980DE_DynamicVecBuffer = packed array of TKDT1980DE_Vec;
    PKDT1980DE_DynamicVecBuffer = ^TKDT1980DE_DynamicVecBuffer;

    TKDT1980DE_Source = packed record
      Buff: TKDT1980DE_Vec;
      index: Int64;
    end;

    PKDT1980DE_Source       = ^TKDT1980DE_Source;
    TKDT1980DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT1980DE_Source) - 1] of PKDT1980DE_Source;
    PKDT1980DE_SourceBuffer = ^TKDT1980DE_SourceBuffer;

    TKDT1980DEyanmicSourceBuffer = packed array of PKDT1980DE_Source;
    PKDT1980DEyanmicSourceBuffer = ^TKDT1980DEyanmicSourceBuffer;

    TKDT1980DEyanmicStoreBuffer = packed array of TKDT1980DE_Source;
    PKDT1980DEyanmicStoreBuffer = ^TKDT1980DEyanmicStoreBuffer;

    PKDT1980DE_Node = ^TKDT1980DE_Node;

    TKDT1980DE_Node = packed record
      Parent, Right, Left: PKDT1980DE_Node;
      vec: PKDT1980DE_Source;
    end;

    TKDT1980DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1980DE_Source; const Data: Pointer);
    TKDT1980DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1980DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1980DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1980DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1980DEyanmicStoreBuffer;
    KDBuff     : TKDT1980DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT1980DE_Node;
    TestBuff   : TKDT1980DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1980DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1980DE_Node;
    function GetData(const index: NativeInt): PKDT1980DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1980DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1980DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1980DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1980DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1980DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1980DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1980DE_Node; overload;
    function Search(const Buff: TKDT1980DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1980DE_Node; overload;
    function Search(const Buff: TKDT1980DE_Vec; var SearchedDistanceMin: Double): PKDT1980DE_Node; overload;
    function Search(const Buff: TKDT1980DE_Vec): PKDT1980DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1980DE_DynamicVecBuffer; var OutBuff: TKDT1980DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1980DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1980DE_Node);
    procedure PrintBuffer;

    class function KDT1980DEVec(const s: string): TKDT1980DE_Vec; overload;
    class function KDT1980DEVec(const v: TKDT1980DE_Vec): string; overload;
    class function KDT1980DEPow(const v: TKDT1980DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1980DEDistance(const v1, v2: TKDT1980DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1980DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT2048DE = class(TCoreClassObject)
  public type
    // code split
    TKDT2048DE_Vec = array [0 .. KDT2048DE_Axis - 1] of TKDT2048DE_VecType;
    PKDT2048DE_Vec = ^TKDT2048DE_Vec;

    TKDT2048DE_DynamicVecBuffer = packed array of TKDT2048DE_Vec;
    PKDT2048DE_DynamicVecBuffer = ^TKDT2048DE_DynamicVecBuffer;

    TKDT2048DE_Source = packed record
      Buff: TKDT2048DE_Vec;
      index: Int64;
    end;

    PKDT2048DE_Source       = ^TKDT2048DE_Source;
    TKDT2048DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT2048DE_Source) - 1] of PKDT2048DE_Source;
    PKDT2048DE_SourceBuffer = ^TKDT2048DE_SourceBuffer;

    TKDT2048DEyanmicSourceBuffer = packed array of PKDT2048DE_Source;
    PKDT2048DEyanmicSourceBuffer = ^TKDT2048DEyanmicSourceBuffer;

    TKDT2048DEyanmicStoreBuffer = packed array of TKDT2048DE_Source;
    PKDT2048DEyanmicStoreBuffer = ^TKDT2048DEyanmicStoreBuffer;

    PKDT2048DE_Node = ^TKDT2048DE_Node;

    TKDT2048DE_Node = packed record
      Parent, Right, Left: PKDT2048DE_Node;
      vec: PKDT2048DE_Source;
    end;

    TKDT2048DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT2048DE_Source; const Data: Pointer);
    TKDT2048DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT2048DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT2048DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT2048DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT2048DEyanmicStoreBuffer;
    KDBuff     : TKDT2048DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT2048DE_Node;
    TestBuff   : TKDT2048DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DE_Node;
    function GetData(const index: NativeInt): PKDT2048DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2048DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2048DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT2048DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2048DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DE_Node; overload;
    function Search(const Buff: TKDT2048DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DE_Node; overload;
    function Search(const Buff: TKDT2048DE_Vec; var SearchedDistanceMin: Double): PKDT2048DE_Node; overload;
    function Search(const Buff: TKDT2048DE_Vec): PKDT2048DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2048DE_DynamicVecBuffer; var OutBuff: TKDT2048DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT2048DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT2048DE_Node);
    procedure PrintBuffer;

    class function KDT2048DEVec(const s: string): TKDT2048DE_Vec; overload;
    class function KDT2048DEVec(const v: TKDT2048DE_Vec): string; overload;
    class function KDT2048DEPow(const v: TKDT2048DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT2048DEDistance(const v1, v2: TKDT2048DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2048DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT3072DE = class(TCoreClassObject)
  public type
    // code split
    TKDT3072DE_Vec = array [0 .. KDT3072DE_Axis - 1] of TKDT3072DE_VecType;
    PKDT3072DE_Vec = ^TKDT3072DE_Vec;

    TKDT3072DE_DynamicVecBuffer = packed array of TKDT3072DE_Vec;
    PKDT3072DE_DynamicVecBuffer = ^TKDT3072DE_DynamicVecBuffer;

    TKDT3072DE_Source = packed record
      Buff: TKDT3072DE_Vec;
      index: Int64;
    end;

    PKDT3072DE_Source       = ^TKDT3072DE_Source;
    TKDT3072DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT3072DE_Source) - 1] of PKDT3072DE_Source;
    PKDT3072DE_SourceBuffer = ^TKDT3072DE_SourceBuffer;

    TKDT3072DEyanmicSourceBuffer = packed array of PKDT3072DE_Source;
    PKDT3072DEyanmicSourceBuffer = ^TKDT3072DEyanmicSourceBuffer;

    TKDT3072DEyanmicStoreBuffer = packed array of TKDT3072DE_Source;
    PKDT3072DEyanmicStoreBuffer = ^TKDT3072DEyanmicStoreBuffer;

    PKDT3072DE_Node = ^TKDT3072DE_Node;

    TKDT3072DE_Node = packed record
      Parent, Right, Left: PKDT3072DE_Node;
      vec: PKDT3072DE_Source;
    end;

    TKDT3072DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3072DE_Source; const Data: Pointer);
    TKDT3072DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3072DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT3072DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3072DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT3072DEyanmicStoreBuffer;
    KDBuff     : TKDT3072DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT3072DE_Node;
    TestBuff   : TKDT3072DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DE_Node;
    function GetData(const index: NativeInt): PKDT3072DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3072DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3072DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT3072DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3072DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DE_Node; overload;
    function Search(const Buff: TKDT3072DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DE_Node; overload;
    function Search(const Buff: TKDT3072DE_Vec; var SearchedDistanceMin: Double): PKDT3072DE_Node; overload;
    function Search(const Buff: TKDT3072DE_Vec): PKDT3072DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3072DE_DynamicVecBuffer; var OutBuff: TKDT3072DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3072DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT3072DE_Node);
    procedure PrintBuffer;

    class function KDT3072DEVec(const s: string): TKDT3072DE_Vec; overload;
    class function KDT3072DEVec(const v: TKDT3072DE_Vec): string; overload;
    class function KDT3072DEPow(const v: TKDT3072DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3072DEDistance(const v1, v2: TKDT3072DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3072DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT3088DE = class(TCoreClassObject)
  public type
    // code split
    TKDT3088DE_Vec = array [0 .. KDT3088DE_Axis - 1] of TKDT3088DE_VecType;
    PKDT3088DE_Vec = ^TKDT3088DE_Vec;

    TKDT3088DE_DynamicVecBuffer = packed array of TKDT3088DE_Vec;
    PKDT3088DE_DynamicVecBuffer = ^TKDT3088DE_DynamicVecBuffer;

    TKDT3088DE_Source = packed record
      Buff: TKDT3088DE_Vec;
      index: Int64;
    end;

    PKDT3088DE_Source       = ^TKDT3088DE_Source;
    TKDT3088DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT3088DE_Source) - 1] of PKDT3088DE_Source;
    PKDT3088DE_SourceBuffer = ^TKDT3088DE_SourceBuffer;

    TKDT3088DEyanmicSourceBuffer = packed array of PKDT3088DE_Source;
    PKDT3088DEyanmicSourceBuffer = ^TKDT3088DEyanmicSourceBuffer;

    TKDT3088DEyanmicStoreBuffer = packed array of TKDT3088DE_Source;
    PKDT3088DEyanmicStoreBuffer = ^TKDT3088DEyanmicStoreBuffer;

    PKDT3088DE_Node = ^TKDT3088DE_Node;

    TKDT3088DE_Node = packed record
      Parent, Right, Left: PKDT3088DE_Node;
      vec: PKDT3088DE_Source;
    end;

    TKDT3088DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3088DE_Source; const Data: Pointer);
    TKDT3088DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3088DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT3088DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3088DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT3088DEyanmicStoreBuffer;
    KDBuff     : TKDT3088DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT3088DE_Node;
    TestBuff   : TKDT3088DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3088DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3088DE_Node;
    function GetData(const index: NativeInt): PKDT3088DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3088DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3088DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT3088DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3088DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3088DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3088DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3088DE_Node; overload;
    function Search(const Buff: TKDT3088DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3088DE_Node; overload;
    function Search(const Buff: TKDT3088DE_Vec; var SearchedDistanceMin: Double): PKDT3088DE_Node; overload;
    function Search(const Buff: TKDT3088DE_Vec): PKDT3088DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3088DE_DynamicVecBuffer; var OutBuff: TKDT3088DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3088DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT3088DE_Node);
    procedure PrintBuffer;

    class function KDT3088DEVec(const s: string): TKDT3088DE_Vec; overload;
    class function KDT3088DEVec(const v: TKDT3088DE_Vec): string; overload;
    class function KDT3088DEPow(const v: TKDT3088DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3088DEDistance(const v1, v2: TKDT3088DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3088DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT3104DE = class(TCoreClassObject)
  public type
    // code split
    TKDT3104DE_Vec = array [0 .. KDT3104DE_Axis - 1] of TKDT3104DE_VecType;
    PKDT3104DE_Vec = ^TKDT3104DE_Vec;

    TKDT3104DE_DynamicVecBuffer = packed array of TKDT3104DE_Vec;
    PKDT3104DE_DynamicVecBuffer = ^TKDT3104DE_DynamicVecBuffer;

    TKDT3104DE_Source = packed record
      Buff: TKDT3104DE_Vec;
      index: Int64;
    end;

    PKDT3104DE_Source       = ^TKDT3104DE_Source;
    TKDT3104DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT3104DE_Source) - 1] of PKDT3104DE_Source;
    PKDT3104DE_SourceBuffer = ^TKDT3104DE_SourceBuffer;

    TKDT3104DEyanmicSourceBuffer = packed array of PKDT3104DE_Source;
    PKDT3104DEyanmicSourceBuffer = ^TKDT3104DEyanmicSourceBuffer;

    TKDT3104DEyanmicStoreBuffer = packed array of TKDT3104DE_Source;
    PKDT3104DEyanmicStoreBuffer = ^TKDT3104DEyanmicStoreBuffer;

    PKDT3104DE_Node = ^TKDT3104DE_Node;

    TKDT3104DE_Node = packed record
      Parent, Right, Left: PKDT3104DE_Node;
      vec: PKDT3104DE_Source;
    end;

    TKDT3104DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3104DE_Source; const Data: Pointer);
    TKDT3104DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3104DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT3104DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3104DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT3104DEyanmicStoreBuffer;
    KDBuff     : TKDT3104DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT3104DE_Node;
    TestBuff   : TKDT3104DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3104DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3104DE_Node;
    function GetData(const index: NativeInt): PKDT3104DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3104DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3104DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT3104DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3104DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3104DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3104DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3104DE_Node; overload;
    function Search(const Buff: TKDT3104DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3104DE_Node; overload;
    function Search(const Buff: TKDT3104DE_Vec; var SearchedDistanceMin: Double): PKDT3104DE_Node; overload;
    function Search(const Buff: TKDT3104DE_Vec): PKDT3104DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3104DE_DynamicVecBuffer; var OutBuff: TKDT3104DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3104DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT3104DE_Node);
    procedure PrintBuffer;

    class function KDT3104DEVec(const s: string): TKDT3104DE_Vec; overload;
    class function KDT3104DEVec(const v: TKDT3104DE_Vec): string; overload;
    class function KDT3104DEPow(const v: TKDT3104DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3104DEDistance(const v1, v2: TKDT3104DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3104DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT4096DE = class(TCoreClassObject)
  public type
    // code split
    TKDT4096DE_Vec = array [0 .. KDT4096DE_Axis - 1] of TKDT4096DE_VecType;
    PKDT4096DE_Vec = ^TKDT4096DE_Vec;

    TKDT4096DE_DynamicVecBuffer = packed array of TKDT4096DE_Vec;
    PKDT4096DE_DynamicVecBuffer = ^TKDT4096DE_DynamicVecBuffer;

    TKDT4096DE_Source = packed record
      Buff: TKDT4096DE_Vec;
      index: Int64;
    end;

    PKDT4096DE_Source       = ^TKDT4096DE_Source;
    TKDT4096DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT4096DE_Source) - 1] of PKDT4096DE_Source;
    PKDT4096DE_SourceBuffer = ^TKDT4096DE_SourceBuffer;

    TKDT4096DEyanmicSourceBuffer = packed array of PKDT4096DE_Source;
    PKDT4096DEyanmicSourceBuffer = ^TKDT4096DEyanmicSourceBuffer;

    TKDT4096DEyanmicStoreBuffer = packed array of TKDT4096DE_Source;
    PKDT4096DEyanmicStoreBuffer = ^TKDT4096DEyanmicStoreBuffer;

    PKDT4096DE_Node = ^TKDT4096DE_Node;

    TKDT4096DE_Node = packed record
      Parent, Right, Left: PKDT4096DE_Node;
      vec: PKDT4096DE_Source;
    end;

    TKDT4096DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT4096DE_Source; const Data: Pointer);
    TKDT4096DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT4096DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT4096DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT4096DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT4096DEyanmicStoreBuffer;
    KDBuff     : TKDT4096DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT4096DE_Node;
    TestBuff   : TKDT4096DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4096DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4096DE_Node;
    function GetData(const index: NativeInt): PKDT4096DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4096DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4096DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT4096DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4096DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4096DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4096DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4096DE_Node; overload;
    function Search(const Buff: TKDT4096DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4096DE_Node; overload;
    function Search(const Buff: TKDT4096DE_Vec; var SearchedDistanceMin: Double): PKDT4096DE_Node; overload;
    function Search(const Buff: TKDT4096DE_Vec): PKDT4096DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4096DE_DynamicVecBuffer; var OutBuff: TKDT4096DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT4096DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT4096DE_Node);
    procedure PrintBuffer;

    class function KDT4096DEVec(const s: string): TKDT4096DE_Vec; overload;
    class function KDT4096DEVec(const v: TKDT4096DE_Vec): string; overload;
    class function KDT4096DEPow(const v: TKDT4096DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT4096DEDistance(const v1, v2: TKDT4096DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4096DE_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT8192DE = class(TCoreClassObject)
  public type
    // code split
    TKDT8192DE_Vec = array [0 .. KDT8192DE_Axis - 1] of TKDT8192DE_VecType;
    PKDT8192DE_Vec = ^TKDT8192DE_Vec;

    TKDT8192DE_DynamicVecBuffer = packed array of TKDT8192DE_Vec;
    PKDT8192DE_DynamicVecBuffer = ^TKDT8192DE_DynamicVecBuffer;

    TKDT8192DE_Source = packed record
      Buff: TKDT8192DE_Vec;
      index: Int64;
    end;

    PKDT8192DE_Source       = ^TKDT8192DE_Source;
    TKDT8192DE_SourceBuffer = array [0 .. MaxInt div SizeOf(PKDT8192DE_Source) - 1] of PKDT8192DE_Source;
    PKDT8192DE_SourceBuffer = ^TKDT8192DE_SourceBuffer;

    TKDT8192DEyanmicSourceBuffer = packed array of PKDT8192DE_Source;
    PKDT8192DEyanmicSourceBuffer = ^TKDT8192DEyanmicSourceBuffer;

    TKDT8192DEyanmicStoreBuffer = packed array of TKDT8192DE_Source;
    PKDT8192DEyanmicStoreBuffer = ^TKDT8192DEyanmicStoreBuffer;

    PKDT8192DE_Node = ^TKDT8192DE_Node;

    TKDT8192DE_Node = packed record
      Parent, Right, Left: PKDT8192DE_Node;
      vec: PKDT8192DE_Source;
    end;

    TKDT8192DE_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT8192DE_Source; const Data: Pointer);
    TKDT8192DE_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT8192DE_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT8192DE_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT8192DE_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT8192DEyanmicStoreBuffer;
    KDBuff     : TKDT8192DEyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : packed array of PKDT8192DE_Node;
    TestBuff   : TKDT8192DE_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8192DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8192DE_Node;
    function GetData(const index: NativeInt): PKDT8192DE_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8192DE_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8192DEyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT8192DE_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DE_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DE_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DE_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8192DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8192DE_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DE_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DE_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DE_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8192DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8192DE_Node; overload;
    function Search(const Buff: TKDT8192DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8192DE_Node; overload;
    function Search(const Buff: TKDT8192DE_Vec; var SearchedDistanceMin: Double): PKDT8192DE_Node; overload;
    function Search(const Buff: TKDT8192DE_Vec): PKDT8192DE_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8192DE_DynamicVecBuffer; var OutBuff: TKDT8192DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT8192DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT8192DE_Node);
    procedure PrintBuffer;

    class function KDT8192DEVec(const s: string): TKDT8192DE_Vec; overload;
    class function KDT8192DEVec(const v: TKDT8192DE_Vec): string; overload;
    class function KDT8192DEPow(const v: TKDT8192DE_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT8192DEDistance(const v1, v2: TKDT8192DE_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8192DE_Source; const Data: Pointer);
    class procedure Test;
  end;






procedure Test_All;



implementation

uses
  {$IFDEF FPC}
  mtprocs,
  {$ELSE FPC}
  Threading,
  {$ENDIF FPC}
  PascalStrings, TextParsing, UnicodeMixedLib, DoStatusIO;





const
  SaveToken = $22;



function TKDT1DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DE_Node;
  function SortCompare(const p1, p2: PKDT1DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1DE_SourceBuffer;
  dynBuff  : PKDT1DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1DE.GetData(const index: NativeInt): PKDT1DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1DE.StoreBuffPtr: PKDT1DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1DE.BuildKDTreeWithCluster(const inBuff: TKDT1DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1DE.BuildKDTreeWithCluster(const inBuff: TKDT1DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DE_BuildCall);
var
  TempStoreBuff: TKDT1DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DE_BuildMethod);
var
  TempStoreBuff: TKDT1DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DE_BuildProc);
var
  TempStoreBuff: TKDT1DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1DE.Search(const Buff: TKDT1DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DE_Node;

var
  NearestNeighbour: PKDT1DE_Node;

  function FindParentNode(const BuffPtr: PKDT1DE_Vec; NodePtr: PKDT1DE_Node): PKDT1DE_Node;
  var
    Next       : PKDT1DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1DE_Node; const BuffPtr: PKDT1DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1DE_Vec; const p1, p2: PKDT1DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1DE_Node(NearestNodes[0]);
    end;
end;

function TKDT1DE.Search(const Buff: TKDT1DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1DE.Search(const Buff: TKDT1DE_Vec; var SearchedDistanceMin: Double): PKDT1DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1DE.Search(const Buff: TKDT1DE_Vec): PKDT1DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1DE.Search(const inBuff: TKDT1DE_DynamicVecBuffer; var OutBuff: TKDT1DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1DE_DynamicVecBuffer;
  outBuffPtr : PKDT1DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DE.Search(const inBuff: TKDT1DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1DE_Source));
end;

procedure TKDT1DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DE.PrintNodeTree(const NodePtr: PKDT1DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1DE.KDT1DEVec(const s: string): TKDT1DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1DE.KDT1DEVec(const v: TKDT1DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1DE.KDT1DEPow(const v: TKDT1DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1DE.KDT1DEDistance(const v1, v2: TKDT1DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1DE_Axis - 1 do
      Result := Result + KDT1DEPow(v2[i] - v1[i]);
end;

procedure TKDT1DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1DE.Test;
var
  TKDT1DE_Test    : TKDT1DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1DE_Test := TKDT1DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT1DE_Test.TestBuff) - 1 do
    for j := 0 to KDT1DE_Axis - 1 do
        TKDT1DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1DE_Test.TestBuff), length(TKDT1DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1DE_Test.BuildKDTreeM(length(TKDT1DE_Test.TestBuff), nil, @TKDT1DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1DE_Test.BuildKDTreeM(length(TKDT1DE_Test.TestBuff), nil, TKDT1DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1DE_Test.TestBuff));
  TKDT1DE_Test.Search(TKDT1DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1DEDistance(TKDT1DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1DE_Test.Clear;
  { kMean test }
  TKDT1DE_Test.BuildKDTreeWithCluster(TKDT1DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1DE_Test.Search(TKDT1DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1DE_Test);
end;


function TKDT2DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DE_Node;
  function SortCompare(const p1, p2: PKDT2DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2DE_SourceBuffer;
  dynBuff  : PKDT2DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT2DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2DE.GetData(const index: NativeInt): PKDT2DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2DE.StoreBuffPtr: PKDT2DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2DE.BuildKDTreeWithCluster(const inBuff: TKDT2DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT2DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT2DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT2DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2DE.BuildKDTreeWithCluster(const inBuff: TKDT2DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DE_BuildCall);
var
  TempStoreBuff: TKDT2DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DE_BuildMethod);
var
  TempStoreBuff: TKDT2DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DE_BuildProc);
var
  TempStoreBuff: TKDT2DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT2DE.Search(const Buff: TKDT2DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DE_Node;

var
  NearestNeighbour: PKDT2DE_Node;

  function FindParentNode(const BuffPtr: PKDT2DE_Vec; NodePtr: PKDT2DE_Node): PKDT2DE_Node;
  var
    Next       : PKDT2DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT2DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2DE_Node; const BuffPtr: PKDT2DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT2DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2DE_Vec; const p1, p2: PKDT2DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2DE_Node(NearestNodes[0]);
    end;
end;

function TKDT2DE.Search(const Buff: TKDT2DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2DE.Search(const Buff: TKDT2DE_Vec; var SearchedDistanceMin: Double): PKDT2DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2DE.Search(const Buff: TKDT2DE_Vec): PKDT2DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2DE.Search(const inBuff: TKDT2DE_DynamicVecBuffer; var OutBuff: TKDT2DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2DE_DynamicVecBuffer;
  outBuffPtr : PKDT2DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DE.Search(const inBuff: TKDT2DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT2DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2DE_Source));
end;

procedure TKDT2DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT2DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DE.PrintNodeTree(const NodePtr: PKDT2DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT2DE.KDT2DEVec(const s: string): TKDT2DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT2DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT2DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT2DE.KDT2DEVec(const v: TKDT2DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT2DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT2DE.KDT2DEPow(const v: TKDT2DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT2DE.KDT2DEDistance(const v1, v2: TKDT2DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT2DE_Axis - 1 do
      Result := Result + KDT2DEPow(v2[i] - v1[i]);
end;

procedure TKDT2DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2DE.Test;
var
  TKDT2DE_Test    : TKDT2DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2DE_Test := TKDT2DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT2DE_Test.TestBuff) - 1 do
    for j := 0 to KDT2DE_Axis - 1 do
        TKDT2DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT2DE_Test.TestBuff), length(TKDT2DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2DE_Test.BuildKDTreeM(length(TKDT2DE_Test.TestBuff), nil, @TKDT2DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2DE_Test.BuildKDTreeM(length(TKDT2DE_Test.TestBuff), nil, TKDT2DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2DE_Test.TestBuff));
  TKDT2DE_Test.Search(TKDT2DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2DEDistance(TKDT2DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2DE_Test.Clear;
  { kMean test }
  TKDT2DE_Test.BuildKDTreeWithCluster(TKDT2DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2DE_Test.Search(TKDT2DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2DE_Test);
end;


function TKDT3DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DE_Node;
  function SortCompare(const p1, p2: PKDT3DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3DE_SourceBuffer;
  dynBuff  : PKDT3DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3DE.GetData(const index: NativeInt): PKDT3DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3DE.StoreBuffPtr: PKDT3DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3DE.BuildKDTreeWithCluster(const inBuff: TKDT3DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3DE.BuildKDTreeWithCluster(const inBuff: TKDT3DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DE_BuildCall);
var
  TempStoreBuff: TKDT3DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DE_BuildMethod);
var
  TempStoreBuff: TKDT3DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DE_BuildProc);
var
  TempStoreBuff: TKDT3DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT3DE.Search(const Buff: TKDT3DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DE_Node;

var
  NearestNeighbour: PKDT3DE_Node;

  function FindParentNode(const BuffPtr: PKDT3DE_Vec; NodePtr: PKDT3DE_Node): PKDT3DE_Node;
  var
    Next       : PKDT3DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3DE_Node; const BuffPtr: PKDT3DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3DE_Vec; const p1, p2: PKDT3DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3DE_Node(NearestNodes[0]);
    end;
end;

function TKDT3DE.Search(const Buff: TKDT3DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3DE.Search(const Buff: TKDT3DE_Vec; var SearchedDistanceMin: Double): PKDT3DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3DE.Search(const Buff: TKDT3DE_Vec): PKDT3DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3DE.Search(const inBuff: TKDT3DE_DynamicVecBuffer; var OutBuff: TKDT3DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3DE_DynamicVecBuffer;
  outBuffPtr : PKDT3DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DE.Search(const inBuff: TKDT3DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3DE_Source));
end;

procedure TKDT3DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DE.PrintNodeTree(const NodePtr: PKDT3DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3DE.KDT3DEVec(const s: string): TKDT3DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3DE.KDT3DEVec(const v: TKDT3DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT3DE.KDT3DEPow(const v: TKDT3DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3DE.KDT3DEDistance(const v1, v2: TKDT3DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3DE_Axis - 1 do
      Result := Result + KDT3DEPow(v2[i] - v1[i]);
end;

procedure TKDT3DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3DE.Test;
var
  TKDT3DE_Test    : TKDT3DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3DE_Test := TKDT3DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT3DE_Test.TestBuff) - 1 do
    for j := 0 to KDT3DE_Axis - 1 do
        TKDT3DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3DE_Test.TestBuff), length(TKDT3DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3DE_Test.BuildKDTreeM(length(TKDT3DE_Test.TestBuff), nil, @TKDT3DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3DE_Test.BuildKDTreeM(length(TKDT3DE_Test.TestBuff), nil, TKDT3DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3DE_Test.TestBuff));
  TKDT3DE_Test.Search(TKDT3DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3DEDistance(TKDT3DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3DE_Test.Clear;
  { kMean test }
  TKDT3DE_Test.BuildKDTreeWithCluster(TKDT3DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3DE_Test.Search(TKDT3DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3DE_Test);
end;


function TKDT4DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DE_Node;
  function SortCompare(const p1, p2: PKDT4DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4DE_SourceBuffer;
  dynBuff  : PKDT4DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT4DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4DE.GetData(const index: NativeInt): PKDT4DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4DE.StoreBuffPtr: PKDT4DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4DE.BuildKDTreeWithCluster(const inBuff: TKDT4DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT4DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT4DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT4DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4DE.BuildKDTreeWithCluster(const inBuff: TKDT4DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DE_BuildCall);
var
  TempStoreBuff: TKDT4DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DE_BuildMethod);
var
  TempStoreBuff: TKDT4DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DE_BuildProc);
var
  TempStoreBuff: TKDT4DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT4DE.Search(const Buff: TKDT4DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DE_Node;

var
  NearestNeighbour: PKDT4DE_Node;

  function FindParentNode(const BuffPtr: PKDT4DE_Vec; NodePtr: PKDT4DE_Node): PKDT4DE_Node;
  var
    Next       : PKDT4DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT4DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4DE_Node; const BuffPtr: PKDT4DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT4DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4DE_Vec; const p1, p2: PKDT4DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4DE_Node(NearestNodes[0]);
    end;
end;

function TKDT4DE.Search(const Buff: TKDT4DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4DE.Search(const Buff: TKDT4DE_Vec; var SearchedDistanceMin: Double): PKDT4DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4DE.Search(const Buff: TKDT4DE_Vec): PKDT4DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4DE.Search(const inBuff: TKDT4DE_DynamicVecBuffer; var OutBuff: TKDT4DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4DE_DynamicVecBuffer;
  outBuffPtr : PKDT4DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DE.Search(const inBuff: TKDT4DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT4DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4DE_Source));
end;

procedure TKDT4DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT4DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DE.PrintNodeTree(const NodePtr: PKDT4DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT4DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT4DE.KDT4DEVec(const s: string): TKDT4DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT4DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT4DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT4DE.KDT4DEVec(const v: TKDT4DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT4DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT4DE.KDT4DEPow(const v: TKDT4DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT4DE.KDT4DEDistance(const v1, v2: TKDT4DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT4DE_Axis - 1 do
      Result := Result + KDT4DEPow(v2[i] - v1[i]);
end;

procedure TKDT4DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4DE.Test;
var
  TKDT4DE_Test    : TKDT4DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4DE_Test := TKDT4DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT4DE_Test.TestBuff) - 1 do
    for j := 0 to KDT4DE_Axis - 1 do
        TKDT4DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT4DE_Test.TestBuff), length(TKDT4DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4DE_Test.BuildKDTreeM(length(TKDT4DE_Test.TestBuff), nil, @TKDT4DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4DE_Test.BuildKDTreeM(length(TKDT4DE_Test.TestBuff), nil, TKDT4DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4DE_Test.TestBuff));
  TKDT4DE_Test.Search(TKDT4DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4DEDistance(TKDT4DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4DE_Test.Clear;
  { kMean test }
  TKDT4DE_Test.BuildKDTreeWithCluster(TKDT4DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4DE_Test.Search(TKDT4DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4DE_Test);
end;


function TKDT5DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DE_Node;
  function SortCompare(const p1, p2: PKDT5DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT5DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT5DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT5DE_SourceBuffer;
  dynBuff  : PKDT5DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT5DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT5DE.GetData(const index: NativeInt): PKDT5DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT5DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT5DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT5DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT5DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT5DE.StoreBuffPtr: PKDT5DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT5DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT5DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT5DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT5DE.BuildKDTreeWithCluster(const inBuff: TKDT5DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT5DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT5DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT5DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT5DE.BuildKDTreeWithCluster(const inBuff: TKDT5DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT5DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DE_BuildCall);
var
  TempStoreBuff: TKDT5DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT5DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DE_BuildMethod);
var
  TempStoreBuff: TKDT5DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT5DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT5DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DE_BuildProc);
var
  TempStoreBuff: TKDT5DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT5DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT5DE.Search(const Buff: TKDT5DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DE_Node;

var
  NearestNeighbour: PKDT5DE_Node;

  function FindParentNode(const BuffPtr: PKDT5DE_Vec; NodePtr: PKDT5DE_Node): PKDT5DE_Node;
  var
    Next       : PKDT5DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT5DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT5DE_Node; const BuffPtr: PKDT5DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT5DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT5DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT5DE_Vec; const p1, p2: PKDT5DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT5DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT5DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT5DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT5DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT5DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT5DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT5DE_Node(NearestNodes[0]);
    end;
end;

function TKDT5DE.Search(const Buff: TKDT5DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT5DE.Search(const Buff: TKDT5DE_Vec; var SearchedDistanceMin: Double): PKDT5DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT5DE.Search(const Buff: TKDT5DE_Vec): PKDT5DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT5DE.Search(const inBuff: TKDT5DE_DynamicVecBuffer; var OutBuff: TKDT5DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT5DE_DynamicVecBuffer;
  outBuffPtr : PKDT5DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT5DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT5DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT5DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT5DE.Search(const inBuff: TKDT5DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT5DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT5DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT5DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT5DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT5DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT5DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT5DE_Source));
end;

procedure TKDT5DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT5DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT5DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT5DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT5DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT5DE.PrintNodeTree(const NodePtr: PKDT5DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT5DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT5DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT5DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT5DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT5DE.KDT5DEVec(const s: string): TKDT5DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT5DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT5DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT5DE.KDT5DEVec(const v: TKDT5DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT5DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT5DE.KDT5DEPow(const v: TKDT5DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT5DE.KDT5DEDistance(const v1, v2: TKDT5DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT5DE_Axis - 1 do
      Result := Result + KDT5DEPow(v2[i] - v1[i]);
end;

procedure TKDT5DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT5DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT5DE.Test;
var
  TKDT5DE_Test    : TKDT5DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT5DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT5DE_Test := TKDT5DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT5DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT5DE_Test.TestBuff) - 1 do
    for j := 0 to KDT5DE_Axis - 1 do
        TKDT5DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT5DE_Test.TestBuff), length(TKDT5DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT5DE_Test.BuildKDTreeM(length(TKDT5DE_Test.TestBuff), nil, @TKDT5DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT5DE_Test.BuildKDTreeM(length(TKDT5DE_Test.TestBuff), nil, TKDT5DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT5DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT5DE_Test.TestBuff));
  TKDT5DE_Test.Search(TKDT5DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT5DEDistance(TKDT5DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT5DE_Test.Clear;
  { kMean test }
  TKDT5DE_Test.BuildKDTreeWithCluster(TKDT5DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT5DE_Test.Search(TKDT5DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT5DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT5DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT5DE_Test);
end;


function TKDT6DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DE_Node;
  function SortCompare(const p1, p2: PKDT6DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT6DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT6DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT6DE_SourceBuffer;
  dynBuff  : PKDT6DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT6DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT6DE.GetData(const index: NativeInt): PKDT6DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT6DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT6DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT6DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT6DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT6DE.StoreBuffPtr: PKDT6DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT6DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT6DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT6DE.BuildKDTreeWithCluster(const inBuff: TKDT6DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT6DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT6DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT6DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT6DE.BuildKDTreeWithCluster(const inBuff: TKDT6DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DE_BuildCall);
var
  TempStoreBuff: TKDT6DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT6DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DE_BuildMethod);
var
  TempStoreBuff: TKDT6DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT6DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DE_BuildProc);
var
  TempStoreBuff: TKDT6DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT6DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT6DE.Search(const Buff: TKDT6DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DE_Node;

var
  NearestNeighbour: PKDT6DE_Node;

  function FindParentNode(const BuffPtr: PKDT6DE_Vec; NodePtr: PKDT6DE_Node): PKDT6DE_Node;
  var
    Next       : PKDT6DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT6DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT6DE_Node; const BuffPtr: PKDT6DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT6DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT6DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT6DE_Vec; const p1, p2: PKDT6DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT6DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT6DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT6DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT6DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT6DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT6DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT6DE_Node(NearestNodes[0]);
    end;
end;

function TKDT6DE.Search(const Buff: TKDT6DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT6DE.Search(const Buff: TKDT6DE_Vec; var SearchedDistanceMin: Double): PKDT6DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT6DE.Search(const Buff: TKDT6DE_Vec): PKDT6DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT6DE.Search(const inBuff: TKDT6DE_DynamicVecBuffer; var OutBuff: TKDT6DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT6DE_DynamicVecBuffer;
  outBuffPtr : PKDT6DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT6DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT6DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DE.Search(const inBuff: TKDT6DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT6DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT6DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT6DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT6DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT6DE_Source));
end;

procedure TKDT6DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT6DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT6DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT6DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DE.PrintNodeTree(const NodePtr: PKDT6DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT6DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT6DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT6DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT6DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT6DE.KDT6DEVec(const s: string): TKDT6DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT6DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT6DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT6DE.KDT6DEVec(const v: TKDT6DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT6DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT6DE.KDT6DEPow(const v: TKDT6DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT6DE.KDT6DEDistance(const v1, v2: TKDT6DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT6DE_Axis - 1 do
      Result := Result + KDT6DEPow(v2[i] - v1[i]);
end;

procedure TKDT6DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT6DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT6DE.Test;
var
  TKDT6DE_Test    : TKDT6DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT6DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT6DE_Test := TKDT6DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT6DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT6DE_Test.TestBuff) - 1 do
    for j := 0 to KDT6DE_Axis - 1 do
        TKDT6DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT6DE_Test.TestBuff), length(TKDT6DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT6DE_Test.BuildKDTreeM(length(TKDT6DE_Test.TestBuff), nil, @TKDT6DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT6DE_Test.BuildKDTreeM(length(TKDT6DE_Test.TestBuff), nil, TKDT6DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT6DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT6DE_Test.TestBuff));
  TKDT6DE_Test.Search(TKDT6DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT6DEDistance(TKDT6DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT6DE_Test.Clear;
  { kMean test }
  TKDT6DE_Test.BuildKDTreeWithCluster(TKDT6DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT6DE_Test.Search(TKDT6DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT6DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT6DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT6DE_Test);
end;


function TKDT7DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DE_Node;
  function SortCompare(const p1, p2: PKDT7DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT7DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT7DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT7DE_SourceBuffer;
  dynBuff  : PKDT7DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT7DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT7DE.GetData(const index: NativeInt): PKDT7DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT7DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT7DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT7DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT7DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT7DE.StoreBuffPtr: PKDT7DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT7DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT7DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT7DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT7DE.BuildKDTreeWithCluster(const inBuff: TKDT7DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT7DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT7DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT7DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT7DE.BuildKDTreeWithCluster(const inBuff: TKDT7DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT7DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DE_BuildCall);
var
  TempStoreBuff: TKDT7DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT7DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DE_BuildMethod);
var
  TempStoreBuff: TKDT7DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT7DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT7DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DE_BuildProc);
var
  TempStoreBuff: TKDT7DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT7DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT7DE.Search(const Buff: TKDT7DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DE_Node;

var
  NearestNeighbour: PKDT7DE_Node;

  function FindParentNode(const BuffPtr: PKDT7DE_Vec; NodePtr: PKDT7DE_Node): PKDT7DE_Node;
  var
    Next       : PKDT7DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT7DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT7DE_Node; const BuffPtr: PKDT7DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT7DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT7DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT7DE_Vec; const p1, p2: PKDT7DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT7DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT7DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT7DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT7DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT7DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT7DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT7DE_Node(NearestNodes[0]);
    end;
end;

function TKDT7DE.Search(const Buff: TKDT7DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT7DE.Search(const Buff: TKDT7DE_Vec; var SearchedDistanceMin: Double): PKDT7DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT7DE.Search(const Buff: TKDT7DE_Vec): PKDT7DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT7DE.Search(const inBuff: TKDT7DE_DynamicVecBuffer; var OutBuff: TKDT7DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT7DE_DynamicVecBuffer;
  outBuffPtr : PKDT7DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT7DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT7DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT7DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT7DE.Search(const inBuff: TKDT7DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT7DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT7DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT7DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT7DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT7DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT7DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT7DE_Source));
end;

procedure TKDT7DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT7DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT7DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT7DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT7DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT7DE.PrintNodeTree(const NodePtr: PKDT7DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT7DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT7DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT7DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT7DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT7DE.KDT7DEVec(const s: string): TKDT7DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT7DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT7DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT7DE.KDT7DEVec(const v: TKDT7DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT7DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT7DE.KDT7DEPow(const v: TKDT7DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT7DE.KDT7DEDistance(const v1, v2: TKDT7DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT7DE_Axis - 1 do
      Result := Result + KDT7DEPow(v2[i] - v1[i]);
end;

procedure TKDT7DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT7DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT7DE.Test;
var
  TKDT7DE_Test    : TKDT7DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT7DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT7DE_Test := TKDT7DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT7DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT7DE_Test.TestBuff) - 1 do
    for j := 0 to KDT7DE_Axis - 1 do
        TKDT7DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT7DE_Test.TestBuff), length(TKDT7DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT7DE_Test.BuildKDTreeM(length(TKDT7DE_Test.TestBuff), nil, @TKDT7DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT7DE_Test.BuildKDTreeM(length(TKDT7DE_Test.TestBuff), nil, TKDT7DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT7DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT7DE_Test.TestBuff));
  TKDT7DE_Test.Search(TKDT7DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT7DEDistance(TKDT7DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT7DE_Test.Clear;
  { kMean test }
  TKDT7DE_Test.BuildKDTreeWithCluster(TKDT7DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT7DE_Test.Search(TKDT7DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT7DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT7DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT7DE_Test);
end;


function TKDT8DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DE_Node;
  function SortCompare(const p1, p2: PKDT8DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8DE_SourceBuffer;
  dynBuff  : PKDT8DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT8DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8DE.GetData(const index: NativeInt): PKDT8DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8DE.StoreBuffPtr: PKDT8DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8DE.BuildKDTreeWithCluster(const inBuff: TKDT8DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT8DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT8DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT8DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8DE.BuildKDTreeWithCluster(const inBuff: TKDT8DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DE_BuildCall);
var
  TempStoreBuff: TKDT8DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DE_BuildMethod);
var
  TempStoreBuff: TKDT8DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DE_BuildProc);
var
  TempStoreBuff: TKDT8DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT8DE.Search(const Buff: TKDT8DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DE_Node;

var
  NearestNeighbour: PKDT8DE_Node;

  function FindParentNode(const BuffPtr: PKDT8DE_Vec; NodePtr: PKDT8DE_Node): PKDT8DE_Node;
  var
    Next       : PKDT8DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT8DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8DE_Node; const BuffPtr: PKDT8DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT8DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8DE_Vec; const p1, p2: PKDT8DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8DE_Node(NearestNodes[0]);
    end;
end;

function TKDT8DE.Search(const Buff: TKDT8DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8DE.Search(const Buff: TKDT8DE_Vec; var SearchedDistanceMin: Double): PKDT8DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8DE.Search(const Buff: TKDT8DE_Vec): PKDT8DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8DE.Search(const inBuff: TKDT8DE_DynamicVecBuffer; var OutBuff: TKDT8DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8DE_DynamicVecBuffer;
  outBuffPtr : PKDT8DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DE.Search(const inBuff: TKDT8DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT8DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8DE_Source));
end;

procedure TKDT8DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT8DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DE.PrintNodeTree(const NodePtr: PKDT8DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT8DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT8DE.KDT8DEVec(const s: string): TKDT8DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT8DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT8DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT8DE.KDT8DEVec(const v: TKDT8DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT8DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT8DE.KDT8DEPow(const v: TKDT8DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT8DE.KDT8DEDistance(const v1, v2: TKDT8DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT8DE_Axis - 1 do
      Result := Result + KDT8DEPow(v2[i] - v1[i]);
end;

procedure TKDT8DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8DE.Test;
var
  TKDT8DE_Test    : TKDT8DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8DE_Test := TKDT8DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT8DE_Test.TestBuff) - 1 do
    for j := 0 to KDT8DE_Axis - 1 do
        TKDT8DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT8DE_Test.TestBuff), length(TKDT8DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8DE_Test.BuildKDTreeM(length(TKDT8DE_Test.TestBuff), nil, @TKDT8DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8DE_Test.BuildKDTreeM(length(TKDT8DE_Test.TestBuff), nil, TKDT8DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8DE_Test.TestBuff));
  TKDT8DE_Test.Search(TKDT8DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8DEDistance(TKDT8DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8DE_Test.Clear;
  { kMean test }
  TKDT8DE_Test.BuildKDTreeWithCluster(TKDT8DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8DE_Test.Search(TKDT8DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8DE_Test);
end;


function TKDT9DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DE_Node;
  function SortCompare(const p1, p2: PKDT9DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT9DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT9DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT9DE_SourceBuffer;
  dynBuff  : PKDT9DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT9DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT9DE.GetData(const index: NativeInt): PKDT9DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT9DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT9DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT9DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT9DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT9DE.StoreBuffPtr: PKDT9DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT9DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT9DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT9DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT9DE.BuildKDTreeWithCluster(const inBuff: TKDT9DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT9DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT9DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT9DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT9DE.BuildKDTreeWithCluster(const inBuff: TKDT9DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT9DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DE_BuildCall);
var
  TempStoreBuff: TKDT9DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT9DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DE_BuildMethod);
var
  TempStoreBuff: TKDT9DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT9DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT9DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DE_BuildProc);
var
  TempStoreBuff: TKDT9DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT9DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT9DE.Search(const Buff: TKDT9DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DE_Node;

var
  NearestNeighbour: PKDT9DE_Node;

  function FindParentNode(const BuffPtr: PKDT9DE_Vec; NodePtr: PKDT9DE_Node): PKDT9DE_Node;
  var
    Next       : PKDT9DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT9DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT9DE_Node; const BuffPtr: PKDT9DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT9DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT9DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT9DE_Vec; const p1, p2: PKDT9DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT9DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT9DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT9DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT9DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT9DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT9DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT9DE_Node(NearestNodes[0]);
    end;
end;

function TKDT9DE.Search(const Buff: TKDT9DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT9DE.Search(const Buff: TKDT9DE_Vec; var SearchedDistanceMin: Double): PKDT9DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT9DE.Search(const Buff: TKDT9DE_Vec): PKDT9DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT9DE.Search(const inBuff: TKDT9DE_DynamicVecBuffer; var OutBuff: TKDT9DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT9DE_DynamicVecBuffer;
  outBuffPtr : PKDT9DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT9DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT9DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT9DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT9DE.Search(const inBuff: TKDT9DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT9DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT9DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT9DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT9DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT9DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT9DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT9DE_Source));
end;

procedure TKDT9DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT9DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT9DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT9DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT9DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT9DE.PrintNodeTree(const NodePtr: PKDT9DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT9DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT9DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT9DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT9DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT9DE.KDT9DEVec(const s: string): TKDT9DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT9DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT9DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT9DE.KDT9DEVec(const v: TKDT9DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT9DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT9DE.KDT9DEPow(const v: TKDT9DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT9DE.KDT9DEDistance(const v1, v2: TKDT9DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT9DE_Axis - 1 do
      Result := Result + KDT9DEPow(v2[i] - v1[i]);
end;

procedure TKDT9DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT9DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT9DE.Test;
var
  TKDT9DE_Test    : TKDT9DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT9DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT9DE_Test := TKDT9DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT9DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT9DE_Test.TestBuff) - 1 do
    for j := 0 to KDT9DE_Axis - 1 do
        TKDT9DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT9DE_Test.TestBuff), length(TKDT9DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT9DE_Test.BuildKDTreeM(length(TKDT9DE_Test.TestBuff), nil, @TKDT9DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT9DE_Test.BuildKDTreeM(length(TKDT9DE_Test.TestBuff), nil, TKDT9DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT9DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT9DE_Test.TestBuff));
  TKDT9DE_Test.Search(TKDT9DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT9DEDistance(TKDT9DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT9DE_Test.Clear;
  { kMean test }
  TKDT9DE_Test.BuildKDTreeWithCluster(TKDT9DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT9DE_Test.Search(TKDT9DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT9DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT9DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT9DE_Test);
end;


function TKDT10DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DE_Node;
  function SortCompare(const p1, p2: PKDT10DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT10DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT10DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT10DE_SourceBuffer;
  dynBuff  : PKDT10DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT10DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT10DE.GetData(const index: NativeInt): PKDT10DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT10DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT10DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT10DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT10DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT10DE.StoreBuffPtr: PKDT10DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT10DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT10DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT10DE.BuildKDTreeWithCluster(const inBuff: TKDT10DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT10DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT10DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT10DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT10DE.BuildKDTreeWithCluster(const inBuff: TKDT10DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DE_BuildCall);
var
  TempStoreBuff: TKDT10DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT10DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DE_BuildMethod);
var
  TempStoreBuff: TKDT10DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT10DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DE_BuildProc);
var
  TempStoreBuff: TKDT10DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT10DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT10DE.Search(const Buff: TKDT10DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DE_Node;

var
  NearestNeighbour: PKDT10DE_Node;

  function FindParentNode(const BuffPtr: PKDT10DE_Vec; NodePtr: PKDT10DE_Node): PKDT10DE_Node;
  var
    Next       : PKDT10DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT10DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT10DE_Node; const BuffPtr: PKDT10DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT10DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT10DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT10DE_Vec; const p1, p2: PKDT10DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT10DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT10DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT10DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT10DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT10DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT10DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT10DE_Node(NearestNodes[0]);
    end;
end;

function TKDT10DE.Search(const Buff: TKDT10DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT10DE.Search(const Buff: TKDT10DE_Vec; var SearchedDistanceMin: Double): PKDT10DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT10DE.Search(const Buff: TKDT10DE_Vec): PKDT10DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT10DE.Search(const inBuff: TKDT10DE_DynamicVecBuffer; var OutBuff: TKDT10DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT10DE_DynamicVecBuffer;
  outBuffPtr : PKDT10DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT10DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT10DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DE.Search(const inBuff: TKDT10DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT10DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT10DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT10DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT10DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT10DE_Source));
end;

procedure TKDT10DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT10DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT10DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT10DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DE.PrintNodeTree(const NodePtr: PKDT10DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT10DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT10DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT10DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT10DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT10DE.KDT10DEVec(const s: string): TKDT10DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT10DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT10DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT10DE.KDT10DEVec(const v: TKDT10DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT10DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT10DE.KDT10DEPow(const v: TKDT10DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT10DE.KDT10DEDistance(const v1, v2: TKDT10DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT10DE_Axis - 1 do
      Result := Result + KDT10DEPow(v2[i] - v1[i]);
end;

procedure TKDT10DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT10DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT10DE.Test;
var
  TKDT10DE_Test    : TKDT10DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT10DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT10DE_Test := TKDT10DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT10DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT10DE_Test.TestBuff) - 1 do
    for j := 0 to KDT10DE_Axis - 1 do
        TKDT10DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT10DE_Test.TestBuff), length(TKDT10DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT10DE_Test.BuildKDTreeM(length(TKDT10DE_Test.TestBuff), nil, @TKDT10DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT10DE_Test.BuildKDTreeM(length(TKDT10DE_Test.TestBuff), nil, TKDT10DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT10DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT10DE_Test.TestBuff));
  TKDT10DE_Test.Search(TKDT10DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT10DEDistance(TKDT10DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT10DE_Test.Clear;
  { kMean test }
  TKDT10DE_Test.BuildKDTreeWithCluster(TKDT10DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT10DE_Test.Search(TKDT10DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT10DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT10DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT10DE_Test);
end;


function TKDT11DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DE_Node;
  function SortCompare(const p1, p2: PKDT11DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT11DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT11DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT11DE_SourceBuffer;
  dynBuff  : PKDT11DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT11DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT11DE.GetData(const index: NativeInt): PKDT11DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT11DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT11DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT11DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT11DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT11DE.StoreBuffPtr: PKDT11DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT11DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT11DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT11DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT11DE.BuildKDTreeWithCluster(const inBuff: TKDT11DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT11DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT11DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT11DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT11DE.BuildKDTreeWithCluster(const inBuff: TKDT11DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT11DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DE_BuildCall);
var
  TempStoreBuff: TKDT11DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT11DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DE_BuildMethod);
var
  TempStoreBuff: TKDT11DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT11DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT11DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DE_BuildProc);
var
  TempStoreBuff: TKDT11DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT11DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT11DE.Search(const Buff: TKDT11DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DE_Node;

var
  NearestNeighbour: PKDT11DE_Node;

  function FindParentNode(const BuffPtr: PKDT11DE_Vec; NodePtr: PKDT11DE_Node): PKDT11DE_Node;
  var
    Next       : PKDT11DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT11DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT11DE_Node; const BuffPtr: PKDT11DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT11DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT11DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT11DE_Vec; const p1, p2: PKDT11DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT11DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT11DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT11DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT11DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT11DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT11DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT11DE_Node(NearestNodes[0]);
    end;
end;

function TKDT11DE.Search(const Buff: TKDT11DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT11DE.Search(const Buff: TKDT11DE_Vec; var SearchedDistanceMin: Double): PKDT11DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT11DE.Search(const Buff: TKDT11DE_Vec): PKDT11DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT11DE.Search(const inBuff: TKDT11DE_DynamicVecBuffer; var OutBuff: TKDT11DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT11DE_DynamicVecBuffer;
  outBuffPtr : PKDT11DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT11DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT11DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT11DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT11DE.Search(const inBuff: TKDT11DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT11DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT11DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT11DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT11DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT11DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT11DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT11DE_Source));
end;

procedure TKDT11DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT11DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT11DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT11DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT11DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT11DE.PrintNodeTree(const NodePtr: PKDT11DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT11DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT11DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT11DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT11DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT11DE.KDT11DEVec(const s: string): TKDT11DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT11DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT11DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT11DE.KDT11DEVec(const v: TKDT11DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT11DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT11DE.KDT11DEPow(const v: TKDT11DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT11DE.KDT11DEDistance(const v1, v2: TKDT11DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT11DE_Axis - 1 do
      Result := Result + KDT11DEPow(v2[i] - v1[i]);
end;

procedure TKDT11DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT11DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT11DE.Test;
var
  TKDT11DE_Test    : TKDT11DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT11DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT11DE_Test := TKDT11DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT11DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT11DE_Test.TestBuff) - 1 do
    for j := 0 to KDT11DE_Axis - 1 do
        TKDT11DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT11DE_Test.TestBuff), length(TKDT11DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT11DE_Test.BuildKDTreeM(length(TKDT11DE_Test.TestBuff), nil, @TKDT11DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT11DE_Test.BuildKDTreeM(length(TKDT11DE_Test.TestBuff), nil, TKDT11DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT11DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT11DE_Test.TestBuff));
  TKDT11DE_Test.Search(TKDT11DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT11DEDistance(TKDT11DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT11DE_Test.Clear;
  { kMean test }
  TKDT11DE_Test.BuildKDTreeWithCluster(TKDT11DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT11DE_Test.Search(TKDT11DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT11DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT11DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT11DE_Test);
end;


function TKDT12DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DE_Node;
  function SortCompare(const p1, p2: PKDT12DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT12DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT12DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT12DE_SourceBuffer;
  dynBuff  : PKDT12DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT12DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT12DE.GetData(const index: NativeInt): PKDT12DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT12DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT12DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT12DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT12DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT12DE.StoreBuffPtr: PKDT12DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT12DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT12DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT12DE.BuildKDTreeWithCluster(const inBuff: TKDT12DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT12DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT12DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT12DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT12DE.BuildKDTreeWithCluster(const inBuff: TKDT12DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DE_BuildCall);
var
  TempStoreBuff: TKDT12DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT12DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DE_BuildMethod);
var
  TempStoreBuff: TKDT12DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT12DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DE_BuildProc);
var
  TempStoreBuff: TKDT12DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT12DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT12DE.Search(const Buff: TKDT12DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DE_Node;

var
  NearestNeighbour: PKDT12DE_Node;

  function FindParentNode(const BuffPtr: PKDT12DE_Vec; NodePtr: PKDT12DE_Node): PKDT12DE_Node;
  var
    Next       : PKDT12DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT12DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT12DE_Node; const BuffPtr: PKDT12DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT12DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT12DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT12DE_Vec; const p1, p2: PKDT12DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT12DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT12DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT12DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT12DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT12DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT12DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT12DE_Node(NearestNodes[0]);
    end;
end;

function TKDT12DE.Search(const Buff: TKDT12DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT12DE.Search(const Buff: TKDT12DE_Vec; var SearchedDistanceMin: Double): PKDT12DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT12DE.Search(const Buff: TKDT12DE_Vec): PKDT12DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT12DE.Search(const inBuff: TKDT12DE_DynamicVecBuffer; var OutBuff: TKDT12DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT12DE_DynamicVecBuffer;
  outBuffPtr : PKDT12DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT12DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT12DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DE.Search(const inBuff: TKDT12DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT12DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT12DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT12DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT12DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT12DE_Source));
end;

procedure TKDT12DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT12DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT12DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT12DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DE.PrintNodeTree(const NodePtr: PKDT12DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT12DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT12DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT12DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT12DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT12DE.KDT12DEVec(const s: string): TKDT12DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT12DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT12DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT12DE.KDT12DEVec(const v: TKDT12DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT12DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT12DE.KDT12DEPow(const v: TKDT12DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT12DE.KDT12DEDistance(const v1, v2: TKDT12DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT12DE_Axis - 1 do
      Result := Result + KDT12DEPow(v2[i] - v1[i]);
end;

procedure TKDT12DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT12DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT12DE.Test;
var
  TKDT12DE_Test    : TKDT12DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT12DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT12DE_Test := TKDT12DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT12DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT12DE_Test.TestBuff) - 1 do
    for j := 0 to KDT12DE_Axis - 1 do
        TKDT12DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT12DE_Test.TestBuff), length(TKDT12DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT12DE_Test.BuildKDTreeM(length(TKDT12DE_Test.TestBuff), nil, @TKDT12DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT12DE_Test.BuildKDTreeM(length(TKDT12DE_Test.TestBuff), nil, TKDT12DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT12DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT12DE_Test.TestBuff));
  TKDT12DE_Test.Search(TKDT12DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT12DEDistance(TKDT12DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT12DE_Test.Clear;
  { kMean test }
  TKDT12DE_Test.BuildKDTreeWithCluster(TKDT12DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT12DE_Test.Search(TKDT12DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT12DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT12DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT12DE_Test);
end;


function TKDT13DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DE_Node;
  function SortCompare(const p1, p2: PKDT13DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT13DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT13DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT13DE_SourceBuffer;
  dynBuff  : PKDT13DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT13DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT13DE.GetData(const index: NativeInt): PKDT13DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT13DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT13DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT13DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT13DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT13DE.StoreBuffPtr: PKDT13DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT13DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT13DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT13DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT13DE.BuildKDTreeWithCluster(const inBuff: TKDT13DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT13DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT13DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT13DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT13DE.BuildKDTreeWithCluster(const inBuff: TKDT13DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT13DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DE_BuildCall);
var
  TempStoreBuff: TKDT13DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT13DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DE_BuildMethod);
var
  TempStoreBuff: TKDT13DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT13DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT13DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DE_BuildProc);
var
  TempStoreBuff: TKDT13DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT13DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT13DE.Search(const Buff: TKDT13DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DE_Node;

var
  NearestNeighbour: PKDT13DE_Node;

  function FindParentNode(const BuffPtr: PKDT13DE_Vec; NodePtr: PKDT13DE_Node): PKDT13DE_Node;
  var
    Next       : PKDT13DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT13DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT13DE_Node; const BuffPtr: PKDT13DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT13DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT13DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT13DE_Vec; const p1, p2: PKDT13DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT13DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT13DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT13DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT13DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT13DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT13DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT13DE_Node(NearestNodes[0]);
    end;
end;

function TKDT13DE.Search(const Buff: TKDT13DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT13DE.Search(const Buff: TKDT13DE_Vec; var SearchedDistanceMin: Double): PKDT13DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT13DE.Search(const Buff: TKDT13DE_Vec): PKDT13DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT13DE.Search(const inBuff: TKDT13DE_DynamicVecBuffer; var OutBuff: TKDT13DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT13DE_DynamicVecBuffer;
  outBuffPtr : PKDT13DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT13DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT13DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT13DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT13DE.Search(const inBuff: TKDT13DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT13DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT13DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT13DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT13DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT13DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT13DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT13DE_Source));
end;

procedure TKDT13DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT13DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT13DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT13DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT13DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT13DE.PrintNodeTree(const NodePtr: PKDT13DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT13DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT13DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT13DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT13DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT13DE.KDT13DEVec(const s: string): TKDT13DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT13DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT13DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT13DE.KDT13DEVec(const v: TKDT13DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT13DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT13DE.KDT13DEPow(const v: TKDT13DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT13DE.KDT13DEDistance(const v1, v2: TKDT13DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT13DE_Axis - 1 do
      Result := Result + KDT13DEPow(v2[i] - v1[i]);
end;

procedure TKDT13DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT13DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT13DE.Test;
var
  TKDT13DE_Test    : TKDT13DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT13DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT13DE_Test := TKDT13DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT13DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT13DE_Test.TestBuff) - 1 do
    for j := 0 to KDT13DE_Axis - 1 do
        TKDT13DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT13DE_Test.TestBuff), length(TKDT13DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT13DE_Test.BuildKDTreeM(length(TKDT13DE_Test.TestBuff), nil, @TKDT13DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT13DE_Test.BuildKDTreeM(length(TKDT13DE_Test.TestBuff), nil, TKDT13DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT13DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT13DE_Test.TestBuff));
  TKDT13DE_Test.Search(TKDT13DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT13DEDistance(TKDT13DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT13DE_Test.Clear;
  { kMean test }
  TKDT13DE_Test.BuildKDTreeWithCluster(TKDT13DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT13DE_Test.Search(TKDT13DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT13DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT13DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT13DE_Test);
end;


function TKDT14DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DE_Node;
  function SortCompare(const p1, p2: PKDT14DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT14DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT14DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT14DE_SourceBuffer;
  dynBuff  : PKDT14DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT14DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT14DE.GetData(const index: NativeInt): PKDT14DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT14DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT14DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT14DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT14DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT14DE.StoreBuffPtr: PKDT14DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT14DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT14DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT14DE.BuildKDTreeWithCluster(const inBuff: TKDT14DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT14DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT14DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT14DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT14DE.BuildKDTreeWithCluster(const inBuff: TKDT14DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DE_BuildCall);
var
  TempStoreBuff: TKDT14DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT14DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DE_BuildMethod);
var
  TempStoreBuff: TKDT14DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT14DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DE_BuildProc);
var
  TempStoreBuff: TKDT14DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT14DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT14DE.Search(const Buff: TKDT14DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DE_Node;

var
  NearestNeighbour: PKDT14DE_Node;

  function FindParentNode(const BuffPtr: PKDT14DE_Vec; NodePtr: PKDT14DE_Node): PKDT14DE_Node;
  var
    Next       : PKDT14DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT14DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT14DE_Node; const BuffPtr: PKDT14DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT14DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT14DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT14DE_Vec; const p1, p2: PKDT14DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT14DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT14DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT14DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT14DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT14DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT14DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT14DE_Node(NearestNodes[0]);
    end;
end;

function TKDT14DE.Search(const Buff: TKDT14DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT14DE.Search(const Buff: TKDT14DE_Vec; var SearchedDistanceMin: Double): PKDT14DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT14DE.Search(const Buff: TKDT14DE_Vec): PKDT14DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT14DE.Search(const inBuff: TKDT14DE_DynamicVecBuffer; var OutBuff: TKDT14DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT14DE_DynamicVecBuffer;
  outBuffPtr : PKDT14DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT14DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT14DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DE.Search(const inBuff: TKDT14DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT14DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT14DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT14DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT14DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT14DE_Source));
end;

procedure TKDT14DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT14DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT14DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT14DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DE.PrintNodeTree(const NodePtr: PKDT14DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT14DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT14DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT14DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT14DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT14DE.KDT14DEVec(const s: string): TKDT14DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT14DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT14DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT14DE.KDT14DEVec(const v: TKDT14DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT14DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT14DE.KDT14DEPow(const v: TKDT14DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT14DE.KDT14DEDistance(const v1, v2: TKDT14DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT14DE_Axis - 1 do
      Result := Result + KDT14DEPow(v2[i] - v1[i]);
end;

procedure TKDT14DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT14DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT14DE.Test;
var
  TKDT14DE_Test    : TKDT14DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT14DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT14DE_Test := TKDT14DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT14DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT14DE_Test.TestBuff) - 1 do
    for j := 0 to KDT14DE_Axis - 1 do
        TKDT14DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT14DE_Test.TestBuff), length(TKDT14DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT14DE_Test.BuildKDTreeM(length(TKDT14DE_Test.TestBuff), nil, @TKDT14DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT14DE_Test.BuildKDTreeM(length(TKDT14DE_Test.TestBuff), nil, TKDT14DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT14DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT14DE_Test.TestBuff));
  TKDT14DE_Test.Search(TKDT14DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT14DEDistance(TKDT14DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT14DE_Test.Clear;
  { kMean test }
  TKDT14DE_Test.BuildKDTreeWithCluster(TKDT14DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT14DE_Test.Search(TKDT14DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT14DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT14DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT14DE_Test);
end;


function TKDT15DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DE_Node;
  function SortCompare(const p1, p2: PKDT15DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT15DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT15DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT15DE_SourceBuffer;
  dynBuff  : PKDT15DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT15DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT15DE.GetData(const index: NativeInt): PKDT15DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT15DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT15DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT15DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT15DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT15DE.StoreBuffPtr: PKDT15DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT15DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT15DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT15DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT15DE.BuildKDTreeWithCluster(const inBuff: TKDT15DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT15DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT15DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT15DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT15DE.BuildKDTreeWithCluster(const inBuff: TKDT15DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT15DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DE_BuildCall);
var
  TempStoreBuff: TKDT15DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT15DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DE_BuildMethod);
var
  TempStoreBuff: TKDT15DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT15DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT15DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DE_BuildProc);
var
  TempStoreBuff: TKDT15DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT15DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT15DE.Search(const Buff: TKDT15DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DE_Node;

var
  NearestNeighbour: PKDT15DE_Node;

  function FindParentNode(const BuffPtr: PKDT15DE_Vec; NodePtr: PKDT15DE_Node): PKDT15DE_Node;
  var
    Next       : PKDT15DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT15DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT15DE_Node; const BuffPtr: PKDT15DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT15DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT15DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT15DE_Vec; const p1, p2: PKDT15DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT15DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT15DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT15DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT15DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT15DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT15DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT15DE_Node(NearestNodes[0]);
    end;
end;

function TKDT15DE.Search(const Buff: TKDT15DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT15DE.Search(const Buff: TKDT15DE_Vec; var SearchedDistanceMin: Double): PKDT15DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT15DE.Search(const Buff: TKDT15DE_Vec): PKDT15DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT15DE.Search(const inBuff: TKDT15DE_DynamicVecBuffer; var OutBuff: TKDT15DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT15DE_DynamicVecBuffer;
  outBuffPtr : PKDT15DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT15DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT15DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT15DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT15DE.Search(const inBuff: TKDT15DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT15DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT15DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT15DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT15DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT15DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT15DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT15DE_Source));
end;

procedure TKDT15DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT15DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT15DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT15DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT15DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT15DE.PrintNodeTree(const NodePtr: PKDT15DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT15DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT15DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT15DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT15DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT15DE.KDT15DEVec(const s: string): TKDT15DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT15DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT15DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT15DE.KDT15DEVec(const v: TKDT15DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT15DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT15DE.KDT15DEPow(const v: TKDT15DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT15DE.KDT15DEDistance(const v1, v2: TKDT15DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT15DE_Axis - 1 do
      Result := Result + KDT15DEPow(v2[i] - v1[i]);
end;

procedure TKDT15DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT15DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT15DE.Test;
var
  TKDT15DE_Test    : TKDT15DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT15DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT15DE_Test := TKDT15DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT15DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT15DE_Test.TestBuff) - 1 do
    for j := 0 to KDT15DE_Axis - 1 do
        TKDT15DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT15DE_Test.TestBuff), length(TKDT15DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT15DE_Test.BuildKDTreeM(length(TKDT15DE_Test.TestBuff), nil, @TKDT15DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT15DE_Test.BuildKDTreeM(length(TKDT15DE_Test.TestBuff), nil, TKDT15DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT15DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT15DE_Test.TestBuff));
  TKDT15DE_Test.Search(TKDT15DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT15DEDistance(TKDT15DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT15DE_Test.Clear;
  { kMean test }
  TKDT15DE_Test.BuildKDTreeWithCluster(TKDT15DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT15DE_Test.Search(TKDT15DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT15DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT15DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT15DE_Test);
end;


function TKDT16DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DE_Node;
  function SortCompare(const p1, p2: PKDT16DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT16DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT16DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT16DE_SourceBuffer;
  dynBuff  : PKDT16DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT16DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT16DE.GetData(const index: NativeInt): PKDT16DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT16DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT16DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT16DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT16DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT16DE.StoreBuffPtr: PKDT16DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT16DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT16DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT16DE.BuildKDTreeWithCluster(const inBuff: TKDT16DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT16DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT16DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT16DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT16DE.BuildKDTreeWithCluster(const inBuff: TKDT16DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DE_BuildCall);
var
  TempStoreBuff: TKDT16DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT16DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DE_BuildMethod);
var
  TempStoreBuff: TKDT16DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT16DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DE_BuildProc);
var
  TempStoreBuff: TKDT16DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT16DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT16DE.Search(const Buff: TKDT16DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DE_Node;

var
  NearestNeighbour: PKDT16DE_Node;

  function FindParentNode(const BuffPtr: PKDT16DE_Vec; NodePtr: PKDT16DE_Node): PKDT16DE_Node;
  var
    Next       : PKDT16DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT16DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT16DE_Node; const BuffPtr: PKDT16DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT16DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT16DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT16DE_Vec; const p1, p2: PKDT16DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT16DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT16DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT16DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT16DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT16DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT16DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT16DE_Node(NearestNodes[0]);
    end;
end;

function TKDT16DE.Search(const Buff: TKDT16DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT16DE.Search(const Buff: TKDT16DE_Vec; var SearchedDistanceMin: Double): PKDT16DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT16DE.Search(const Buff: TKDT16DE_Vec): PKDT16DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT16DE.Search(const inBuff: TKDT16DE_DynamicVecBuffer; var OutBuff: TKDT16DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT16DE_DynamicVecBuffer;
  outBuffPtr : PKDT16DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT16DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT16DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DE.Search(const inBuff: TKDT16DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT16DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT16DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT16DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT16DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT16DE_Source));
end;

procedure TKDT16DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT16DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT16DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT16DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DE.PrintNodeTree(const NodePtr: PKDT16DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT16DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT16DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT16DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT16DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT16DE.KDT16DEVec(const s: string): TKDT16DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT16DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT16DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT16DE.KDT16DEVec(const v: TKDT16DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT16DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT16DE.KDT16DEPow(const v: TKDT16DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT16DE.KDT16DEDistance(const v1, v2: TKDT16DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT16DE_Axis - 1 do
      Result := Result + KDT16DEPow(v2[i] - v1[i]);
end;

procedure TKDT16DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT16DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT16DE.Test;
var
  TKDT16DE_Test    : TKDT16DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT16DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT16DE_Test := TKDT16DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT16DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT16DE_Test.TestBuff) - 1 do
    for j := 0 to KDT16DE_Axis - 1 do
        TKDT16DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT16DE_Test.TestBuff), length(TKDT16DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT16DE_Test.BuildKDTreeM(length(TKDT16DE_Test.TestBuff), nil, @TKDT16DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT16DE_Test.BuildKDTreeM(length(TKDT16DE_Test.TestBuff), nil, TKDT16DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT16DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT16DE_Test.TestBuff));
  TKDT16DE_Test.Search(TKDT16DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT16DEDistance(TKDT16DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT16DE_Test.Clear;
  { kMean test }
  TKDT16DE_Test.BuildKDTreeWithCluster(TKDT16DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT16DE_Test.Search(TKDT16DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT16DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT16DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT16DE_Test);
end;


function TKDT17DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DE_Node;
  function SortCompare(const p1, p2: PKDT17DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT17DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT17DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT17DE_SourceBuffer;
  dynBuff  : PKDT17DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT17DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT17DE.GetData(const index: NativeInt): PKDT17DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT17DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT17DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT17DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT17DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT17DE.StoreBuffPtr: PKDT17DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT17DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT17DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT17DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT17DE.BuildKDTreeWithCluster(const inBuff: TKDT17DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT17DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT17DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT17DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT17DE.BuildKDTreeWithCluster(const inBuff: TKDT17DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT17DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DE_BuildCall);
var
  TempStoreBuff: TKDT17DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT17DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DE_BuildMethod);
var
  TempStoreBuff: TKDT17DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT17DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT17DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DE_BuildProc);
var
  TempStoreBuff: TKDT17DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT17DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT17DE.Search(const Buff: TKDT17DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DE_Node;

var
  NearestNeighbour: PKDT17DE_Node;

  function FindParentNode(const BuffPtr: PKDT17DE_Vec; NodePtr: PKDT17DE_Node): PKDT17DE_Node;
  var
    Next       : PKDT17DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT17DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT17DE_Node; const BuffPtr: PKDT17DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT17DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT17DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT17DE_Vec; const p1, p2: PKDT17DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT17DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT17DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT17DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT17DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT17DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT17DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT17DE_Node(NearestNodes[0]);
    end;
end;

function TKDT17DE.Search(const Buff: TKDT17DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT17DE.Search(const Buff: TKDT17DE_Vec; var SearchedDistanceMin: Double): PKDT17DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT17DE.Search(const Buff: TKDT17DE_Vec): PKDT17DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT17DE.Search(const inBuff: TKDT17DE_DynamicVecBuffer; var OutBuff: TKDT17DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT17DE_DynamicVecBuffer;
  outBuffPtr : PKDT17DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT17DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT17DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT17DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT17DE.Search(const inBuff: TKDT17DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT17DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT17DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT17DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT17DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT17DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT17DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT17DE_Source));
end;

procedure TKDT17DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT17DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT17DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT17DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT17DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT17DE.PrintNodeTree(const NodePtr: PKDT17DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT17DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT17DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT17DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT17DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT17DE.KDT17DEVec(const s: string): TKDT17DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT17DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT17DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT17DE.KDT17DEVec(const v: TKDT17DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT17DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT17DE.KDT17DEPow(const v: TKDT17DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT17DE.KDT17DEDistance(const v1, v2: TKDT17DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT17DE_Axis - 1 do
      Result := Result + KDT17DEPow(v2[i] - v1[i]);
end;

procedure TKDT17DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT17DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT17DE.Test;
var
  TKDT17DE_Test    : TKDT17DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT17DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT17DE_Test := TKDT17DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT17DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT17DE_Test.TestBuff) - 1 do
    for j := 0 to KDT17DE_Axis - 1 do
        TKDT17DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT17DE_Test.TestBuff), length(TKDT17DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT17DE_Test.BuildKDTreeM(length(TKDT17DE_Test.TestBuff), nil, @TKDT17DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT17DE_Test.BuildKDTreeM(length(TKDT17DE_Test.TestBuff), nil, TKDT17DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT17DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT17DE_Test.TestBuff));
  TKDT17DE_Test.Search(TKDT17DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT17DEDistance(TKDT17DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT17DE_Test.Clear;
  { kMean test }
  TKDT17DE_Test.BuildKDTreeWithCluster(TKDT17DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT17DE_Test.Search(TKDT17DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT17DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT17DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT17DE_Test);
end;


function TKDT18DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DE_Node;
  function SortCompare(const p1, p2: PKDT18DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT18DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT18DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT18DE_SourceBuffer;
  dynBuff  : PKDT18DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT18DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT18DE.GetData(const index: NativeInt): PKDT18DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT18DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT18DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT18DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT18DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT18DE.StoreBuffPtr: PKDT18DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT18DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT18DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT18DE.BuildKDTreeWithCluster(const inBuff: TKDT18DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT18DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT18DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT18DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT18DE.BuildKDTreeWithCluster(const inBuff: TKDT18DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DE_BuildCall);
var
  TempStoreBuff: TKDT18DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT18DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DE_BuildMethod);
var
  TempStoreBuff: TKDT18DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT18DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DE_BuildProc);
var
  TempStoreBuff: TKDT18DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT18DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT18DE.Search(const Buff: TKDT18DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DE_Node;

var
  NearestNeighbour: PKDT18DE_Node;

  function FindParentNode(const BuffPtr: PKDT18DE_Vec; NodePtr: PKDT18DE_Node): PKDT18DE_Node;
  var
    Next       : PKDT18DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT18DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT18DE_Node; const BuffPtr: PKDT18DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT18DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT18DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT18DE_Vec; const p1, p2: PKDT18DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT18DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT18DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT18DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT18DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT18DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT18DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT18DE_Node(NearestNodes[0]);
    end;
end;

function TKDT18DE.Search(const Buff: TKDT18DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT18DE.Search(const Buff: TKDT18DE_Vec; var SearchedDistanceMin: Double): PKDT18DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT18DE.Search(const Buff: TKDT18DE_Vec): PKDT18DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT18DE.Search(const inBuff: TKDT18DE_DynamicVecBuffer; var OutBuff: TKDT18DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT18DE_DynamicVecBuffer;
  outBuffPtr : PKDT18DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT18DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT18DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DE.Search(const inBuff: TKDT18DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT18DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT18DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT18DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT18DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT18DE_Source));
end;

procedure TKDT18DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT18DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT18DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT18DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DE.PrintNodeTree(const NodePtr: PKDT18DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT18DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT18DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT18DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT18DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT18DE.KDT18DEVec(const s: string): TKDT18DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT18DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT18DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT18DE.KDT18DEVec(const v: TKDT18DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT18DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT18DE.KDT18DEPow(const v: TKDT18DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT18DE.KDT18DEDistance(const v1, v2: TKDT18DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT18DE_Axis - 1 do
      Result := Result + KDT18DEPow(v2[i] - v1[i]);
end;

procedure TKDT18DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT18DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT18DE.Test;
var
  TKDT18DE_Test    : TKDT18DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT18DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT18DE_Test := TKDT18DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT18DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT18DE_Test.TestBuff) - 1 do
    for j := 0 to KDT18DE_Axis - 1 do
        TKDT18DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT18DE_Test.TestBuff), length(TKDT18DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT18DE_Test.BuildKDTreeM(length(TKDT18DE_Test.TestBuff), nil, @TKDT18DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT18DE_Test.BuildKDTreeM(length(TKDT18DE_Test.TestBuff), nil, TKDT18DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT18DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT18DE_Test.TestBuff));
  TKDT18DE_Test.Search(TKDT18DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT18DEDistance(TKDT18DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT18DE_Test.Clear;
  { kMean test }
  TKDT18DE_Test.BuildKDTreeWithCluster(TKDT18DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT18DE_Test.Search(TKDT18DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT18DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT18DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT18DE_Test);
end;


function TKDT19DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DE_Node;
  function SortCompare(const p1, p2: PKDT19DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT19DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT19DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT19DE_SourceBuffer;
  dynBuff  : PKDT19DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT19DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT19DE.GetData(const index: NativeInt): PKDT19DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT19DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT19DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT19DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT19DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT19DE.StoreBuffPtr: PKDT19DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT19DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT19DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT19DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT19DE.BuildKDTreeWithCluster(const inBuff: TKDT19DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT19DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT19DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT19DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT19DE.BuildKDTreeWithCluster(const inBuff: TKDT19DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT19DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DE_BuildCall);
var
  TempStoreBuff: TKDT19DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT19DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DE_BuildMethod);
var
  TempStoreBuff: TKDT19DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT19DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT19DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DE_BuildProc);
var
  TempStoreBuff: TKDT19DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT19DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT19DE.Search(const Buff: TKDT19DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DE_Node;

var
  NearestNeighbour: PKDT19DE_Node;

  function FindParentNode(const BuffPtr: PKDT19DE_Vec; NodePtr: PKDT19DE_Node): PKDT19DE_Node;
  var
    Next       : PKDT19DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT19DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT19DE_Node; const BuffPtr: PKDT19DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT19DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT19DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT19DE_Vec; const p1, p2: PKDT19DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT19DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT19DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT19DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT19DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT19DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT19DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT19DE_Node(NearestNodes[0]);
    end;
end;

function TKDT19DE.Search(const Buff: TKDT19DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT19DE.Search(const Buff: TKDT19DE_Vec; var SearchedDistanceMin: Double): PKDT19DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT19DE.Search(const Buff: TKDT19DE_Vec): PKDT19DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT19DE.Search(const inBuff: TKDT19DE_DynamicVecBuffer; var OutBuff: TKDT19DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT19DE_DynamicVecBuffer;
  outBuffPtr : PKDT19DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT19DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT19DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT19DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT19DE.Search(const inBuff: TKDT19DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT19DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT19DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT19DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT19DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT19DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT19DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT19DE_Source));
end;

procedure TKDT19DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT19DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT19DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT19DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT19DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT19DE.PrintNodeTree(const NodePtr: PKDT19DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT19DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT19DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT19DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT19DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT19DE.KDT19DEVec(const s: string): TKDT19DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT19DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT19DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT19DE.KDT19DEVec(const v: TKDT19DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT19DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT19DE.KDT19DEPow(const v: TKDT19DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT19DE.KDT19DEDistance(const v1, v2: TKDT19DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT19DE_Axis - 1 do
      Result := Result + KDT19DEPow(v2[i] - v1[i]);
end;

procedure TKDT19DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT19DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT19DE.Test;
var
  TKDT19DE_Test    : TKDT19DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT19DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT19DE_Test := TKDT19DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT19DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT19DE_Test.TestBuff) - 1 do
    for j := 0 to KDT19DE_Axis - 1 do
        TKDT19DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT19DE_Test.TestBuff), length(TKDT19DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT19DE_Test.BuildKDTreeM(length(TKDT19DE_Test.TestBuff), nil, @TKDT19DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT19DE_Test.BuildKDTreeM(length(TKDT19DE_Test.TestBuff), nil, TKDT19DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT19DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT19DE_Test.TestBuff));
  TKDT19DE_Test.Search(TKDT19DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT19DEDistance(TKDT19DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT19DE_Test.Clear;
  { kMean test }
  TKDT19DE_Test.BuildKDTreeWithCluster(TKDT19DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT19DE_Test.Search(TKDT19DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT19DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT19DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT19DE_Test);
end;


function TKDT20DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DE_Node;
  function SortCompare(const p1, p2: PKDT20DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT20DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT20DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT20DE_SourceBuffer;
  dynBuff  : PKDT20DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT20DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT20DE.GetData(const index: NativeInt): PKDT20DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT20DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT20DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT20DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT20DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT20DE.StoreBuffPtr: PKDT20DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT20DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT20DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT20DE.BuildKDTreeWithCluster(const inBuff: TKDT20DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT20DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT20DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT20DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT20DE.BuildKDTreeWithCluster(const inBuff: TKDT20DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DE_BuildCall);
var
  TempStoreBuff: TKDT20DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT20DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DE_BuildMethod);
var
  TempStoreBuff: TKDT20DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT20DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DE_BuildProc);
var
  TempStoreBuff: TKDT20DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT20DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT20DE.Search(const Buff: TKDT20DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DE_Node;

var
  NearestNeighbour: PKDT20DE_Node;

  function FindParentNode(const BuffPtr: PKDT20DE_Vec; NodePtr: PKDT20DE_Node): PKDT20DE_Node;
  var
    Next       : PKDT20DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT20DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT20DE_Node; const BuffPtr: PKDT20DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT20DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT20DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT20DE_Vec; const p1, p2: PKDT20DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT20DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT20DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT20DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT20DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT20DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT20DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT20DE_Node(NearestNodes[0]);
    end;
end;

function TKDT20DE.Search(const Buff: TKDT20DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT20DE.Search(const Buff: TKDT20DE_Vec; var SearchedDistanceMin: Double): PKDT20DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT20DE.Search(const Buff: TKDT20DE_Vec): PKDT20DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT20DE.Search(const inBuff: TKDT20DE_DynamicVecBuffer; var OutBuff: TKDT20DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT20DE_DynamicVecBuffer;
  outBuffPtr : PKDT20DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT20DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT20DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DE.Search(const inBuff: TKDT20DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT20DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT20DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT20DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT20DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT20DE_Source));
end;

procedure TKDT20DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT20DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT20DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT20DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DE.PrintNodeTree(const NodePtr: PKDT20DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT20DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT20DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT20DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT20DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT20DE.KDT20DEVec(const s: string): TKDT20DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT20DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT20DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT20DE.KDT20DEVec(const v: TKDT20DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT20DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT20DE.KDT20DEPow(const v: TKDT20DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT20DE.KDT20DEDistance(const v1, v2: TKDT20DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT20DE_Axis - 1 do
      Result := Result + KDT20DEPow(v2[i] - v1[i]);
end;

procedure TKDT20DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT20DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT20DE.Test;
var
  TKDT20DE_Test    : TKDT20DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT20DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT20DE_Test := TKDT20DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT20DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT20DE_Test.TestBuff) - 1 do
    for j := 0 to KDT20DE_Axis - 1 do
        TKDT20DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT20DE_Test.TestBuff), length(TKDT20DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT20DE_Test.BuildKDTreeM(length(TKDT20DE_Test.TestBuff), nil, @TKDT20DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT20DE_Test.BuildKDTreeM(length(TKDT20DE_Test.TestBuff), nil, TKDT20DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT20DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT20DE_Test.TestBuff));
  TKDT20DE_Test.Search(TKDT20DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT20DEDistance(TKDT20DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT20DE_Test.Clear;
  { kMean test }
  TKDT20DE_Test.BuildKDTreeWithCluster(TKDT20DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT20DE_Test.Search(TKDT20DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT20DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT20DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT20DE_Test);
end;


function TKDT21DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DE_Node;
  function SortCompare(const p1, p2: PKDT21DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT21DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT21DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT21DE_SourceBuffer;
  dynBuff  : PKDT21DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT21DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT21DE.GetData(const index: NativeInt): PKDT21DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT21DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT21DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT21DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT21DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT21DE.StoreBuffPtr: PKDT21DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT21DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT21DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT21DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT21DE.BuildKDTreeWithCluster(const inBuff: TKDT21DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT21DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT21DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT21DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT21DE.BuildKDTreeWithCluster(const inBuff: TKDT21DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT21DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DE_BuildCall);
var
  TempStoreBuff: TKDT21DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT21DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DE_BuildMethod);
var
  TempStoreBuff: TKDT21DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT21DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT21DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DE_BuildProc);
var
  TempStoreBuff: TKDT21DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT21DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT21DE.Search(const Buff: TKDT21DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DE_Node;

var
  NearestNeighbour: PKDT21DE_Node;

  function FindParentNode(const BuffPtr: PKDT21DE_Vec; NodePtr: PKDT21DE_Node): PKDT21DE_Node;
  var
    Next       : PKDT21DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT21DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT21DE_Node; const BuffPtr: PKDT21DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT21DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT21DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT21DE_Vec; const p1, p2: PKDT21DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT21DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT21DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT21DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT21DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT21DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT21DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT21DE_Node(NearestNodes[0]);
    end;
end;

function TKDT21DE.Search(const Buff: TKDT21DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT21DE.Search(const Buff: TKDT21DE_Vec; var SearchedDistanceMin: Double): PKDT21DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT21DE.Search(const Buff: TKDT21DE_Vec): PKDT21DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT21DE.Search(const inBuff: TKDT21DE_DynamicVecBuffer; var OutBuff: TKDT21DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT21DE_DynamicVecBuffer;
  outBuffPtr : PKDT21DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT21DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT21DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT21DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT21DE.Search(const inBuff: TKDT21DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT21DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT21DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT21DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT21DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT21DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT21DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT21DE_Source));
end;

procedure TKDT21DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT21DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT21DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT21DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT21DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT21DE.PrintNodeTree(const NodePtr: PKDT21DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT21DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT21DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT21DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT21DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT21DE.KDT21DEVec(const s: string): TKDT21DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT21DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT21DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT21DE.KDT21DEVec(const v: TKDT21DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT21DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT21DE.KDT21DEPow(const v: TKDT21DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT21DE.KDT21DEDistance(const v1, v2: TKDT21DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT21DE_Axis - 1 do
      Result := Result + KDT21DEPow(v2[i] - v1[i]);
end;

procedure TKDT21DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT21DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT21DE.Test;
var
  TKDT21DE_Test    : TKDT21DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT21DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT21DE_Test := TKDT21DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT21DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT21DE_Test.TestBuff) - 1 do
    for j := 0 to KDT21DE_Axis - 1 do
        TKDT21DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT21DE_Test.TestBuff), length(TKDT21DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT21DE_Test.BuildKDTreeM(length(TKDT21DE_Test.TestBuff), nil, @TKDT21DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT21DE_Test.BuildKDTreeM(length(TKDT21DE_Test.TestBuff), nil, TKDT21DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT21DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT21DE_Test.TestBuff));
  TKDT21DE_Test.Search(TKDT21DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT21DEDistance(TKDT21DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT21DE_Test.Clear;
  { kMean test }
  TKDT21DE_Test.BuildKDTreeWithCluster(TKDT21DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT21DE_Test.Search(TKDT21DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT21DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT21DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT21DE_Test);
end;


function TKDT22DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DE_Node;
  function SortCompare(const p1, p2: PKDT22DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT22DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT22DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT22DE_SourceBuffer;
  dynBuff  : PKDT22DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT22DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT22DE.GetData(const index: NativeInt): PKDT22DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT22DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT22DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT22DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT22DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT22DE.StoreBuffPtr: PKDT22DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT22DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT22DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT22DE.BuildKDTreeWithCluster(const inBuff: TKDT22DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT22DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT22DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT22DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT22DE.BuildKDTreeWithCluster(const inBuff: TKDT22DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DE_BuildCall);
var
  TempStoreBuff: TKDT22DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT22DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DE_BuildMethod);
var
  TempStoreBuff: TKDT22DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT22DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DE_BuildProc);
var
  TempStoreBuff: TKDT22DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT22DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT22DE.Search(const Buff: TKDT22DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DE_Node;

var
  NearestNeighbour: PKDT22DE_Node;

  function FindParentNode(const BuffPtr: PKDT22DE_Vec; NodePtr: PKDT22DE_Node): PKDT22DE_Node;
  var
    Next       : PKDT22DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT22DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT22DE_Node; const BuffPtr: PKDT22DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT22DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT22DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT22DE_Vec; const p1, p2: PKDT22DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT22DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT22DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT22DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT22DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT22DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT22DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT22DE_Node(NearestNodes[0]);
    end;
end;

function TKDT22DE.Search(const Buff: TKDT22DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT22DE.Search(const Buff: TKDT22DE_Vec; var SearchedDistanceMin: Double): PKDT22DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT22DE.Search(const Buff: TKDT22DE_Vec): PKDT22DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT22DE.Search(const inBuff: TKDT22DE_DynamicVecBuffer; var OutBuff: TKDT22DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT22DE_DynamicVecBuffer;
  outBuffPtr : PKDT22DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT22DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT22DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DE.Search(const inBuff: TKDT22DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT22DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT22DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT22DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT22DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT22DE_Source));
end;

procedure TKDT22DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT22DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT22DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT22DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DE.PrintNodeTree(const NodePtr: PKDT22DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT22DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT22DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT22DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT22DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT22DE.KDT22DEVec(const s: string): TKDT22DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT22DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT22DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT22DE.KDT22DEVec(const v: TKDT22DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT22DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT22DE.KDT22DEPow(const v: TKDT22DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT22DE.KDT22DEDistance(const v1, v2: TKDT22DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT22DE_Axis - 1 do
      Result := Result + KDT22DEPow(v2[i] - v1[i]);
end;

procedure TKDT22DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT22DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT22DE.Test;
var
  TKDT22DE_Test    : TKDT22DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT22DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT22DE_Test := TKDT22DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT22DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT22DE_Test.TestBuff) - 1 do
    for j := 0 to KDT22DE_Axis - 1 do
        TKDT22DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT22DE_Test.TestBuff), length(TKDT22DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT22DE_Test.BuildKDTreeM(length(TKDT22DE_Test.TestBuff), nil, @TKDT22DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT22DE_Test.BuildKDTreeM(length(TKDT22DE_Test.TestBuff), nil, TKDT22DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT22DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT22DE_Test.TestBuff));
  TKDT22DE_Test.Search(TKDT22DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT22DEDistance(TKDT22DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT22DE_Test.Clear;
  { kMean test }
  TKDT22DE_Test.BuildKDTreeWithCluster(TKDT22DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT22DE_Test.Search(TKDT22DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT22DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT22DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT22DE_Test);
end;


function TKDT23DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DE_Node;
  function SortCompare(const p1, p2: PKDT23DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT23DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT23DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT23DE_SourceBuffer;
  dynBuff  : PKDT23DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT23DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT23DE.GetData(const index: NativeInt): PKDT23DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT23DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT23DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT23DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT23DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT23DE.StoreBuffPtr: PKDT23DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT23DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT23DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT23DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT23DE.BuildKDTreeWithCluster(const inBuff: TKDT23DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT23DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT23DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT23DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT23DE.BuildKDTreeWithCluster(const inBuff: TKDT23DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT23DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DE_BuildCall);
var
  TempStoreBuff: TKDT23DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT23DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DE_BuildMethod);
var
  TempStoreBuff: TKDT23DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT23DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT23DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DE_BuildProc);
var
  TempStoreBuff: TKDT23DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT23DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT23DE.Search(const Buff: TKDT23DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DE_Node;

var
  NearestNeighbour: PKDT23DE_Node;

  function FindParentNode(const BuffPtr: PKDT23DE_Vec; NodePtr: PKDT23DE_Node): PKDT23DE_Node;
  var
    Next       : PKDT23DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT23DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT23DE_Node; const BuffPtr: PKDT23DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT23DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT23DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT23DE_Vec; const p1, p2: PKDT23DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT23DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT23DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT23DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT23DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT23DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT23DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT23DE_Node(NearestNodes[0]);
    end;
end;

function TKDT23DE.Search(const Buff: TKDT23DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT23DE.Search(const Buff: TKDT23DE_Vec; var SearchedDistanceMin: Double): PKDT23DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT23DE.Search(const Buff: TKDT23DE_Vec): PKDT23DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT23DE.Search(const inBuff: TKDT23DE_DynamicVecBuffer; var OutBuff: TKDT23DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT23DE_DynamicVecBuffer;
  outBuffPtr : PKDT23DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT23DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT23DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT23DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT23DE.Search(const inBuff: TKDT23DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT23DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT23DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT23DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT23DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT23DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT23DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT23DE_Source));
end;

procedure TKDT23DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT23DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT23DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT23DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT23DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT23DE.PrintNodeTree(const NodePtr: PKDT23DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT23DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT23DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT23DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT23DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT23DE.KDT23DEVec(const s: string): TKDT23DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT23DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT23DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT23DE.KDT23DEVec(const v: TKDT23DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT23DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT23DE.KDT23DEPow(const v: TKDT23DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT23DE.KDT23DEDistance(const v1, v2: TKDT23DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT23DE_Axis - 1 do
      Result := Result + KDT23DEPow(v2[i] - v1[i]);
end;

procedure TKDT23DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT23DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT23DE.Test;
var
  TKDT23DE_Test    : TKDT23DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT23DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT23DE_Test := TKDT23DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT23DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT23DE_Test.TestBuff) - 1 do
    for j := 0 to KDT23DE_Axis - 1 do
        TKDT23DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT23DE_Test.TestBuff), length(TKDT23DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT23DE_Test.BuildKDTreeM(length(TKDT23DE_Test.TestBuff), nil, @TKDT23DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT23DE_Test.BuildKDTreeM(length(TKDT23DE_Test.TestBuff), nil, TKDT23DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT23DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT23DE_Test.TestBuff));
  TKDT23DE_Test.Search(TKDT23DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT23DEDistance(TKDT23DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT23DE_Test.Clear;
  { kMean test }
  TKDT23DE_Test.BuildKDTreeWithCluster(TKDT23DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT23DE_Test.Search(TKDT23DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT23DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT23DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT23DE_Test);
end;


function TKDT24DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DE_Node;
  function SortCompare(const p1, p2: PKDT24DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT24DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT24DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT24DE_SourceBuffer;
  dynBuff  : PKDT24DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT24DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT24DE.GetData(const index: NativeInt): PKDT24DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT24DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT24DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT24DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT24DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT24DE.StoreBuffPtr: PKDT24DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT24DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT24DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT24DE.BuildKDTreeWithCluster(const inBuff: TKDT24DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT24DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT24DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT24DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT24DE.BuildKDTreeWithCluster(const inBuff: TKDT24DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DE_BuildCall);
var
  TempStoreBuff: TKDT24DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT24DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DE_BuildMethod);
var
  TempStoreBuff: TKDT24DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT24DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DE_BuildProc);
var
  TempStoreBuff: TKDT24DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT24DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT24DE.Search(const Buff: TKDT24DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DE_Node;

var
  NearestNeighbour: PKDT24DE_Node;

  function FindParentNode(const BuffPtr: PKDT24DE_Vec; NodePtr: PKDT24DE_Node): PKDT24DE_Node;
  var
    Next       : PKDT24DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT24DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT24DE_Node; const BuffPtr: PKDT24DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT24DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT24DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT24DE_Vec; const p1, p2: PKDT24DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT24DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT24DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT24DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT24DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT24DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT24DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT24DE_Node(NearestNodes[0]);
    end;
end;

function TKDT24DE.Search(const Buff: TKDT24DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT24DE.Search(const Buff: TKDT24DE_Vec; var SearchedDistanceMin: Double): PKDT24DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT24DE.Search(const Buff: TKDT24DE_Vec): PKDT24DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT24DE.Search(const inBuff: TKDT24DE_DynamicVecBuffer; var OutBuff: TKDT24DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT24DE_DynamicVecBuffer;
  outBuffPtr : PKDT24DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT24DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT24DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DE.Search(const inBuff: TKDT24DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT24DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT24DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT24DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT24DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT24DE_Source));
end;

procedure TKDT24DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT24DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT24DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT24DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DE.PrintNodeTree(const NodePtr: PKDT24DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT24DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT24DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT24DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT24DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT24DE.KDT24DEVec(const s: string): TKDT24DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT24DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT24DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT24DE.KDT24DEVec(const v: TKDT24DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT24DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT24DE.KDT24DEPow(const v: TKDT24DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT24DE.KDT24DEDistance(const v1, v2: TKDT24DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT24DE_Axis - 1 do
      Result := Result + KDT24DEPow(v2[i] - v1[i]);
end;

procedure TKDT24DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT24DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT24DE.Test;
var
  TKDT24DE_Test    : TKDT24DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT24DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT24DE_Test := TKDT24DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT24DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT24DE_Test.TestBuff) - 1 do
    for j := 0 to KDT24DE_Axis - 1 do
        TKDT24DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT24DE_Test.TestBuff), length(TKDT24DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT24DE_Test.BuildKDTreeM(length(TKDT24DE_Test.TestBuff), nil, @TKDT24DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT24DE_Test.BuildKDTreeM(length(TKDT24DE_Test.TestBuff), nil, TKDT24DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT24DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT24DE_Test.TestBuff));
  TKDT24DE_Test.Search(TKDT24DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT24DEDistance(TKDT24DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT24DE_Test.Clear;
  { kMean test }
  TKDT24DE_Test.BuildKDTreeWithCluster(TKDT24DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT24DE_Test.Search(TKDT24DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT24DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT24DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT24DE_Test);
end;


function TKDT25DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT25DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT25DE_Node;
  function SortCompare(const p1, p2: PKDT25DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT25DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT25DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT25DE_SourceBuffer;
  dynBuff  : PKDT25DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT25DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT25DE.GetData(const index: NativeInt): PKDT25DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT25DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT25DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT25DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT25DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT25DE.StoreBuffPtr: PKDT25DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT25DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT25DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT25DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT25DE.BuildKDTreeWithCluster(const inBuff: TKDT25DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT25DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT25DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT25DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT25DE.BuildKDTreeWithCluster(const inBuff: TKDT25DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT25DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DE_BuildCall);
var
  TempStoreBuff: TKDT25DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT25DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT25DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT25DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT25DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DE_BuildMethod);
var
  TempStoreBuff: TKDT25DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT25DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT25DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT25DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT25DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DE_BuildProc);
var
  TempStoreBuff: TKDT25DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT25DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT25DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT25DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT25DE.Search(const Buff: TKDT25DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT25DE_Node;

var
  NearestNeighbour: PKDT25DE_Node;

  function FindParentNode(const BuffPtr: PKDT25DE_Vec; NodePtr: PKDT25DE_Node): PKDT25DE_Node;
  var
    Next       : PKDT25DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT25DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT25DE_Node; const BuffPtr: PKDT25DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT25DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT25DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT25DE_Vec; const p1, p2: PKDT25DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT25DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT25DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT25DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT25DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT25DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT25DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT25DE_Node(NearestNodes[0]);
    end;
end;

function TKDT25DE.Search(const Buff: TKDT25DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT25DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT25DE.Search(const Buff: TKDT25DE_Vec; var SearchedDistanceMin: Double): PKDT25DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT25DE.Search(const Buff: TKDT25DE_Vec): PKDT25DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT25DE.Search(const inBuff: TKDT25DE_DynamicVecBuffer; var OutBuff: TKDT25DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT25DE_DynamicVecBuffer;
  outBuffPtr : PKDT25DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT25DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT25DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT25DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT25DE.Search(const inBuff: TKDT25DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT25DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT25DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT25DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT25DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT25DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT25DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT25DE_Source));
end;

procedure TKDT25DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT25DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT25DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT25DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT25DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT25DE.PrintNodeTree(const NodePtr: PKDT25DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT25DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT25DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT25DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT25DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT25DE.KDT25DEVec(const s: string): TKDT25DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT25DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT25DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT25DE.KDT25DEVec(const v: TKDT25DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT25DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT25DE.KDT25DEPow(const v: TKDT25DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT25DE.KDT25DEDistance(const v1, v2: TKDT25DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT25DE_Axis - 1 do
      Result := Result + KDT25DEPow(v2[i] - v1[i]);
end;

procedure TKDT25DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT25DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT25DE.Test;
var
  TKDT25DE_Test    : TKDT25DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT25DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT25DE_Test := TKDT25DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT25DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT25DE_Test.TestBuff) - 1 do
    for j := 0 to KDT25DE_Axis - 1 do
        TKDT25DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT25DE_Test.TestBuff), length(TKDT25DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT25DE_Test.BuildKDTreeM(length(TKDT25DE_Test.TestBuff), nil, @TKDT25DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT25DE_Test.BuildKDTreeM(length(TKDT25DE_Test.TestBuff), nil, TKDT25DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT25DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT25DE_Test.TestBuff));
  TKDT25DE_Test.Search(TKDT25DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT25DEDistance(TKDT25DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT25DE_Test.Clear;
  { kMean test }
  TKDT25DE_Test.BuildKDTreeWithCluster(TKDT25DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT25DE_Test.Search(TKDT25DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT25DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT25DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT25DE_Test);
end;


function TKDT26DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT26DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT26DE_Node;
  function SortCompare(const p1, p2: PKDT26DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT26DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT26DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT26DE_SourceBuffer;
  dynBuff  : PKDT26DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT26DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT26DE.GetData(const index: NativeInt): PKDT26DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT26DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT26DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT26DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT26DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT26DE.StoreBuffPtr: PKDT26DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT26DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT26DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT26DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT26DE.BuildKDTreeWithCluster(const inBuff: TKDT26DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT26DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT26DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT26DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT26DE.BuildKDTreeWithCluster(const inBuff: TKDT26DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT26DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DE_BuildCall);
var
  TempStoreBuff: TKDT26DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT26DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT26DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT26DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT26DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DE_BuildMethod);
var
  TempStoreBuff: TKDT26DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT26DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT26DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT26DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT26DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DE_BuildProc);
var
  TempStoreBuff: TKDT26DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT26DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT26DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT26DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT26DE.Search(const Buff: TKDT26DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT26DE_Node;

var
  NearestNeighbour: PKDT26DE_Node;

  function FindParentNode(const BuffPtr: PKDT26DE_Vec; NodePtr: PKDT26DE_Node): PKDT26DE_Node;
  var
    Next       : PKDT26DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT26DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT26DE_Node; const BuffPtr: PKDT26DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT26DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT26DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT26DE_Vec; const p1, p2: PKDT26DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT26DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT26DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT26DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT26DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT26DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT26DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT26DE_Node(NearestNodes[0]);
    end;
end;

function TKDT26DE.Search(const Buff: TKDT26DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT26DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT26DE.Search(const Buff: TKDT26DE_Vec; var SearchedDistanceMin: Double): PKDT26DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT26DE.Search(const Buff: TKDT26DE_Vec): PKDT26DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT26DE.Search(const inBuff: TKDT26DE_DynamicVecBuffer; var OutBuff: TKDT26DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT26DE_DynamicVecBuffer;
  outBuffPtr : PKDT26DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT26DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT26DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT26DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT26DE.Search(const inBuff: TKDT26DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT26DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT26DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT26DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT26DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT26DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT26DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT26DE_Source));
end;

procedure TKDT26DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT26DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT26DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT26DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT26DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT26DE.PrintNodeTree(const NodePtr: PKDT26DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT26DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT26DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT26DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT26DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT26DE.KDT26DEVec(const s: string): TKDT26DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT26DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT26DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT26DE.KDT26DEVec(const v: TKDT26DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT26DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT26DE.KDT26DEPow(const v: TKDT26DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT26DE.KDT26DEDistance(const v1, v2: TKDT26DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT26DE_Axis - 1 do
      Result := Result + KDT26DEPow(v2[i] - v1[i]);
end;

procedure TKDT26DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT26DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT26DE.Test;
var
  TKDT26DE_Test    : TKDT26DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT26DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT26DE_Test := TKDT26DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT26DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT26DE_Test.TestBuff) - 1 do
    for j := 0 to KDT26DE_Axis - 1 do
        TKDT26DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT26DE_Test.TestBuff), length(TKDT26DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT26DE_Test.BuildKDTreeM(length(TKDT26DE_Test.TestBuff), nil, @TKDT26DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT26DE_Test.BuildKDTreeM(length(TKDT26DE_Test.TestBuff), nil, TKDT26DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT26DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT26DE_Test.TestBuff));
  TKDT26DE_Test.Search(TKDT26DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT26DEDistance(TKDT26DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT26DE_Test.Clear;
  { kMean test }
  TKDT26DE_Test.BuildKDTreeWithCluster(TKDT26DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT26DE_Test.Search(TKDT26DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT26DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT26DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT26DE_Test);
end;


function TKDT27DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT27DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT27DE_Node;
  function SortCompare(const p1, p2: PKDT27DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT27DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT27DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT27DE_SourceBuffer;
  dynBuff  : PKDT27DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT27DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT27DE.GetData(const index: NativeInt): PKDT27DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT27DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT27DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT27DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT27DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT27DE.StoreBuffPtr: PKDT27DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT27DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT27DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT27DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT27DE.BuildKDTreeWithCluster(const inBuff: TKDT27DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT27DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT27DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT27DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT27DE.BuildKDTreeWithCluster(const inBuff: TKDT27DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT27DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DE_BuildCall);
var
  TempStoreBuff: TKDT27DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT27DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT27DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT27DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT27DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DE_BuildMethod);
var
  TempStoreBuff: TKDT27DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT27DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT27DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT27DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT27DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DE_BuildProc);
var
  TempStoreBuff: TKDT27DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT27DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT27DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT27DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT27DE.Search(const Buff: TKDT27DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT27DE_Node;

var
  NearestNeighbour: PKDT27DE_Node;

  function FindParentNode(const BuffPtr: PKDT27DE_Vec; NodePtr: PKDT27DE_Node): PKDT27DE_Node;
  var
    Next       : PKDT27DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT27DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT27DE_Node; const BuffPtr: PKDT27DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT27DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT27DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT27DE_Vec; const p1, p2: PKDT27DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT27DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT27DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT27DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT27DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT27DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT27DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT27DE_Node(NearestNodes[0]);
    end;
end;

function TKDT27DE.Search(const Buff: TKDT27DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT27DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT27DE.Search(const Buff: TKDT27DE_Vec; var SearchedDistanceMin: Double): PKDT27DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT27DE.Search(const Buff: TKDT27DE_Vec): PKDT27DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT27DE.Search(const inBuff: TKDT27DE_DynamicVecBuffer; var OutBuff: TKDT27DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT27DE_DynamicVecBuffer;
  outBuffPtr : PKDT27DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT27DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT27DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT27DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT27DE.Search(const inBuff: TKDT27DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT27DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT27DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT27DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT27DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT27DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT27DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT27DE_Source));
end;

procedure TKDT27DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT27DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT27DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT27DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT27DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT27DE.PrintNodeTree(const NodePtr: PKDT27DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT27DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT27DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT27DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT27DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT27DE.KDT27DEVec(const s: string): TKDT27DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT27DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT27DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT27DE.KDT27DEVec(const v: TKDT27DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT27DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT27DE.KDT27DEPow(const v: TKDT27DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT27DE.KDT27DEDistance(const v1, v2: TKDT27DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT27DE_Axis - 1 do
      Result := Result + KDT27DEPow(v2[i] - v1[i]);
end;

procedure TKDT27DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT27DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT27DE.Test;
var
  TKDT27DE_Test    : TKDT27DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT27DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT27DE_Test := TKDT27DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT27DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT27DE_Test.TestBuff) - 1 do
    for j := 0 to KDT27DE_Axis - 1 do
        TKDT27DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT27DE_Test.TestBuff), length(TKDT27DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT27DE_Test.BuildKDTreeM(length(TKDT27DE_Test.TestBuff), nil, @TKDT27DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT27DE_Test.BuildKDTreeM(length(TKDT27DE_Test.TestBuff), nil, TKDT27DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT27DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT27DE_Test.TestBuff));
  TKDT27DE_Test.Search(TKDT27DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT27DEDistance(TKDT27DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT27DE_Test.Clear;
  { kMean test }
  TKDT27DE_Test.BuildKDTreeWithCluster(TKDT27DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT27DE_Test.Search(TKDT27DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT27DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT27DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT27DE_Test);
end;


function TKDT28DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DE_Node;
  function SortCompare(const p1, p2: PKDT28DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT28DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT28DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT28DE_SourceBuffer;
  dynBuff  : PKDT28DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT28DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT28DE.GetData(const index: NativeInt): PKDT28DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT28DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT28DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT28DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT28DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT28DE.StoreBuffPtr: PKDT28DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT28DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT28DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT28DE.BuildKDTreeWithCluster(const inBuff: TKDT28DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT28DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT28DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT28DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT28DE.BuildKDTreeWithCluster(const inBuff: TKDT28DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DE_BuildCall);
var
  TempStoreBuff: TKDT28DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT28DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT28DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT28DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DE_BuildMethod);
var
  TempStoreBuff: TKDT28DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT28DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT28DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT28DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DE_BuildProc);
var
  TempStoreBuff: TKDT28DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT28DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT28DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT28DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT28DE.Search(const Buff: TKDT28DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DE_Node;

var
  NearestNeighbour: PKDT28DE_Node;

  function FindParentNode(const BuffPtr: PKDT28DE_Vec; NodePtr: PKDT28DE_Node): PKDT28DE_Node;
  var
    Next       : PKDT28DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT28DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT28DE_Node; const BuffPtr: PKDT28DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT28DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT28DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT28DE_Vec; const p1, p2: PKDT28DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT28DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT28DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT28DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT28DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT28DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT28DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT28DE_Node(NearestNodes[0]);
    end;
end;

function TKDT28DE.Search(const Buff: TKDT28DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT28DE.Search(const Buff: TKDT28DE_Vec; var SearchedDistanceMin: Double): PKDT28DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT28DE.Search(const Buff: TKDT28DE_Vec): PKDT28DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT28DE.Search(const inBuff: TKDT28DE_DynamicVecBuffer; var OutBuff: TKDT28DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT28DE_DynamicVecBuffer;
  outBuffPtr : PKDT28DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT28DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT28DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT28DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT28DE.Search(const inBuff: TKDT28DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT28DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT28DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT28DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT28DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT28DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT28DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT28DE_Source));
end;

procedure TKDT28DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT28DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT28DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT28DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT28DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT28DE.PrintNodeTree(const NodePtr: PKDT28DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT28DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT28DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT28DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT28DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT28DE.KDT28DEVec(const s: string): TKDT28DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT28DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT28DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT28DE.KDT28DEVec(const v: TKDT28DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT28DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT28DE.KDT28DEPow(const v: TKDT28DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT28DE.KDT28DEDistance(const v1, v2: TKDT28DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT28DE_Axis - 1 do
      Result := Result + KDT28DEPow(v2[i] - v1[i]);
end;

procedure TKDT28DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT28DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT28DE.Test;
var
  TKDT28DE_Test    : TKDT28DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT28DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT28DE_Test := TKDT28DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT28DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT28DE_Test.TestBuff) - 1 do
    for j := 0 to KDT28DE_Axis - 1 do
        TKDT28DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT28DE_Test.TestBuff), length(TKDT28DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT28DE_Test.BuildKDTreeM(length(TKDT28DE_Test.TestBuff), nil, @TKDT28DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT28DE_Test.BuildKDTreeM(length(TKDT28DE_Test.TestBuff), nil, TKDT28DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT28DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT28DE_Test.TestBuff));
  TKDT28DE_Test.Search(TKDT28DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT28DEDistance(TKDT28DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT28DE_Test.Clear;
  { kMean test }
  TKDT28DE_Test.BuildKDTreeWithCluster(TKDT28DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT28DE_Test.Search(TKDT28DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT28DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT28DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT28DE_Test);
end;


function TKDT29DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT29DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT29DE_Node;
  function SortCompare(const p1, p2: PKDT29DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT29DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT29DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT29DE_SourceBuffer;
  dynBuff  : PKDT29DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT29DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT29DE.GetData(const index: NativeInt): PKDT29DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT29DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT29DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT29DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT29DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT29DE.StoreBuffPtr: PKDT29DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT29DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT29DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT29DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT29DE.BuildKDTreeWithCluster(const inBuff: TKDT29DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT29DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT29DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT29DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT29DE.BuildKDTreeWithCluster(const inBuff: TKDT29DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT29DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DE_BuildCall);
var
  TempStoreBuff: TKDT29DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT29DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT29DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT29DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT29DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DE_BuildMethod);
var
  TempStoreBuff: TKDT29DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT29DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT29DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT29DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT29DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DE_BuildProc);
var
  TempStoreBuff: TKDT29DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT29DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT29DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT29DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT29DE.Search(const Buff: TKDT29DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT29DE_Node;

var
  NearestNeighbour: PKDT29DE_Node;

  function FindParentNode(const BuffPtr: PKDT29DE_Vec; NodePtr: PKDT29DE_Node): PKDT29DE_Node;
  var
    Next       : PKDT29DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT29DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT29DE_Node; const BuffPtr: PKDT29DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT29DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT29DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT29DE_Vec; const p1, p2: PKDT29DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT29DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT29DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT29DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT29DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT29DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT29DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT29DE_Node(NearestNodes[0]);
    end;
end;

function TKDT29DE.Search(const Buff: TKDT29DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT29DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT29DE.Search(const Buff: TKDT29DE_Vec; var SearchedDistanceMin: Double): PKDT29DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT29DE.Search(const Buff: TKDT29DE_Vec): PKDT29DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT29DE.Search(const inBuff: TKDT29DE_DynamicVecBuffer; var OutBuff: TKDT29DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT29DE_DynamicVecBuffer;
  outBuffPtr : PKDT29DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT29DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT29DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT29DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT29DE.Search(const inBuff: TKDT29DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT29DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT29DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT29DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT29DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT29DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT29DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT29DE_Source));
end;

procedure TKDT29DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT29DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT29DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT29DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT29DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT29DE.PrintNodeTree(const NodePtr: PKDT29DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT29DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT29DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT29DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT29DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT29DE.KDT29DEVec(const s: string): TKDT29DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT29DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT29DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT29DE.KDT29DEVec(const v: TKDT29DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT29DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT29DE.KDT29DEPow(const v: TKDT29DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT29DE.KDT29DEDistance(const v1, v2: TKDT29DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT29DE_Axis - 1 do
      Result := Result + KDT29DEPow(v2[i] - v1[i]);
end;

procedure TKDT29DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT29DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT29DE.Test;
var
  TKDT29DE_Test    : TKDT29DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT29DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT29DE_Test := TKDT29DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT29DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT29DE_Test.TestBuff) - 1 do
    for j := 0 to KDT29DE_Axis - 1 do
        TKDT29DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT29DE_Test.TestBuff), length(TKDT29DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT29DE_Test.BuildKDTreeM(length(TKDT29DE_Test.TestBuff), nil, @TKDT29DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT29DE_Test.BuildKDTreeM(length(TKDT29DE_Test.TestBuff), nil, TKDT29DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT29DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT29DE_Test.TestBuff));
  TKDT29DE_Test.Search(TKDT29DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT29DEDistance(TKDT29DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT29DE_Test.Clear;
  { kMean test }
  TKDT29DE_Test.BuildKDTreeWithCluster(TKDT29DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT29DE_Test.Search(TKDT29DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT29DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT29DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT29DE_Test);
end;


function TKDT30DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DE_Node;
  function SortCompare(const p1, p2: PKDT30DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT30DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT30DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT30DE_SourceBuffer;
  dynBuff  : PKDT30DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT30DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT30DE.GetData(const index: NativeInt): PKDT30DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT30DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT30DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT30DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT30DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT30DE.StoreBuffPtr: PKDT30DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT30DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT30DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT30DE.BuildKDTreeWithCluster(const inBuff: TKDT30DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT30DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT30DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT30DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT30DE.BuildKDTreeWithCluster(const inBuff: TKDT30DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DE_BuildCall);
var
  TempStoreBuff: TKDT30DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT30DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT30DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT30DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DE_BuildMethod);
var
  TempStoreBuff: TKDT30DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT30DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT30DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT30DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DE_BuildProc);
var
  TempStoreBuff: TKDT30DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT30DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT30DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT30DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT30DE.Search(const Buff: TKDT30DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DE_Node;

var
  NearestNeighbour: PKDT30DE_Node;

  function FindParentNode(const BuffPtr: PKDT30DE_Vec; NodePtr: PKDT30DE_Node): PKDT30DE_Node;
  var
    Next       : PKDT30DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT30DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT30DE_Node; const BuffPtr: PKDT30DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT30DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT30DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT30DE_Vec; const p1, p2: PKDT30DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT30DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT30DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT30DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT30DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT30DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT30DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT30DE_Node(NearestNodes[0]);
    end;
end;

function TKDT30DE.Search(const Buff: TKDT30DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT30DE.Search(const Buff: TKDT30DE_Vec; var SearchedDistanceMin: Double): PKDT30DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT30DE.Search(const Buff: TKDT30DE_Vec): PKDT30DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT30DE.Search(const inBuff: TKDT30DE_DynamicVecBuffer; var OutBuff: TKDT30DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT30DE_DynamicVecBuffer;
  outBuffPtr : PKDT30DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT30DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT30DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT30DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT30DE.Search(const inBuff: TKDT30DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT30DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT30DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT30DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT30DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT30DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT30DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT30DE_Source));
end;

procedure TKDT30DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT30DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT30DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT30DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT30DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT30DE.PrintNodeTree(const NodePtr: PKDT30DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT30DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT30DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT30DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT30DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT30DE.KDT30DEVec(const s: string): TKDT30DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT30DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT30DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT30DE.KDT30DEVec(const v: TKDT30DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT30DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT30DE.KDT30DEPow(const v: TKDT30DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT30DE.KDT30DEDistance(const v1, v2: TKDT30DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT30DE_Axis - 1 do
      Result := Result + KDT30DEPow(v2[i] - v1[i]);
end;

procedure TKDT30DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT30DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT30DE.Test;
var
  TKDT30DE_Test    : TKDT30DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT30DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT30DE_Test := TKDT30DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT30DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT30DE_Test.TestBuff) - 1 do
    for j := 0 to KDT30DE_Axis - 1 do
        TKDT30DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT30DE_Test.TestBuff), length(TKDT30DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT30DE_Test.BuildKDTreeM(length(TKDT30DE_Test.TestBuff), nil, @TKDT30DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT30DE_Test.BuildKDTreeM(length(TKDT30DE_Test.TestBuff), nil, TKDT30DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT30DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT30DE_Test.TestBuff));
  TKDT30DE_Test.Search(TKDT30DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT30DEDistance(TKDT30DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT30DE_Test.Clear;
  { kMean test }
  TKDT30DE_Test.BuildKDTreeWithCluster(TKDT30DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT30DE_Test.Search(TKDT30DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT30DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT30DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT30DE_Test);
end;


function TKDT31DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT31DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT31DE_Node;
  function SortCompare(const p1, p2: PKDT31DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT31DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT31DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT31DE_SourceBuffer;
  dynBuff  : PKDT31DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT31DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT31DE.GetData(const index: NativeInt): PKDT31DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT31DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT31DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT31DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT31DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT31DE.StoreBuffPtr: PKDT31DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT31DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT31DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT31DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT31DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT31DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT31DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT31DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT31DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT31DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT31DE.BuildKDTreeWithCluster(const inBuff: TKDT31DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT31DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT31DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT31DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT31DE.BuildKDTreeWithCluster(const inBuff: TKDT31DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT31DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DE_BuildCall);
var
  TempStoreBuff: TKDT31DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT31DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT31DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT31DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT31DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT31DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DE_BuildMethod);
var
  TempStoreBuff: TKDT31DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT31DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT31DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT31DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT31DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT31DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DE_BuildProc);
var
  TempStoreBuff: TKDT31DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT31DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT31DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT31DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT31DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT31DE.Search(const Buff: TKDT31DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT31DE_Node;

var
  NearestNeighbour: PKDT31DE_Node;

  function FindParentNode(const BuffPtr: PKDT31DE_Vec; NodePtr: PKDT31DE_Node): PKDT31DE_Node;
  var
    Next       : PKDT31DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT31DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT31DE_Node; const BuffPtr: PKDT31DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT31DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT31DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT31DE_Vec; const p1, p2: PKDT31DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT31DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT31DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT31DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT31DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT31DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT31DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT31DE_Node(NearestNodes[0]);
    end;
end;

function TKDT31DE.Search(const Buff: TKDT31DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT31DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT31DE.Search(const Buff: TKDT31DE_Vec; var SearchedDistanceMin: Double): PKDT31DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT31DE.Search(const Buff: TKDT31DE_Vec): PKDT31DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT31DE.Search(const inBuff: TKDT31DE_DynamicVecBuffer; var OutBuff: TKDT31DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT31DE_DynamicVecBuffer;
  outBuffPtr : PKDT31DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT31DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT31DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT31DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT31DE.Search(const inBuff: TKDT31DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT31DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT31DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT31DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT31DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT31DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT31DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT31DE_Source));
end;

procedure TKDT31DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT31DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT31DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT31DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT31DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT31DE.PrintNodeTree(const NodePtr: PKDT31DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT31DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT31DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT31DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT31DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT31DE.KDT31DEVec(const s: string): TKDT31DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT31DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT31DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT31DE.KDT31DEVec(const v: TKDT31DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT31DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT31DE.KDT31DEPow(const v: TKDT31DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT31DE.KDT31DEDistance(const v1, v2: TKDT31DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT31DE_Axis - 1 do
      Result := Result + KDT31DEPow(v2[i] - v1[i]);
end;

procedure TKDT31DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT31DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT31DE.Test;
var
  TKDT31DE_Test    : TKDT31DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT31DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT31DE_Test := TKDT31DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT31DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT31DE_Test.TestBuff) - 1 do
    for j := 0 to KDT31DE_Axis - 1 do
        TKDT31DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT31DE_Test.TestBuff), length(TKDT31DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT31DE_Test.BuildKDTreeM(length(TKDT31DE_Test.TestBuff), nil, @TKDT31DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT31DE_Test.BuildKDTreeM(length(TKDT31DE_Test.TestBuff), nil, TKDT31DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT31DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT31DE_Test.TestBuff));
  TKDT31DE_Test.Search(TKDT31DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT31DEDistance(TKDT31DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT31DE_Test.Clear;
  { kMean test }
  TKDT31DE_Test.BuildKDTreeWithCluster(TKDT31DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT31DE_Test.Search(TKDT31DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT31DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT31DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT31DE_Test);
end;


function TKDT32DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DE_Node;
  function SortCompare(const p1, p2: PKDT32DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT32DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT32DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT32DE_SourceBuffer;
  dynBuff  : PKDT32DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT32DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT32DE.GetData(const index: NativeInt): PKDT32DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT32DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT32DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT32DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT32DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT32DE.StoreBuffPtr: PKDT32DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT32DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT32DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT32DE.BuildKDTreeWithCluster(const inBuff: TKDT32DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT32DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT32DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT32DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT32DE.BuildKDTreeWithCluster(const inBuff: TKDT32DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DE_BuildCall);
var
  TempStoreBuff: TKDT32DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT32DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT32DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT32DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DE_BuildMethod);
var
  TempStoreBuff: TKDT32DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT32DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT32DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT32DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DE_BuildProc);
var
  TempStoreBuff: TKDT32DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT32DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT32DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT32DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT32DE.Search(const Buff: TKDT32DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DE_Node;

var
  NearestNeighbour: PKDT32DE_Node;

  function FindParentNode(const BuffPtr: PKDT32DE_Vec; NodePtr: PKDT32DE_Node): PKDT32DE_Node;
  var
    Next       : PKDT32DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT32DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT32DE_Node; const BuffPtr: PKDT32DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT32DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT32DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT32DE_Vec; const p1, p2: PKDT32DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT32DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT32DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT32DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT32DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT32DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT32DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT32DE_Node(NearestNodes[0]);
    end;
end;

function TKDT32DE.Search(const Buff: TKDT32DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT32DE.Search(const Buff: TKDT32DE_Vec; var SearchedDistanceMin: Double): PKDT32DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT32DE.Search(const Buff: TKDT32DE_Vec): PKDT32DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT32DE.Search(const inBuff: TKDT32DE_DynamicVecBuffer; var OutBuff: TKDT32DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT32DE_DynamicVecBuffer;
  outBuffPtr : PKDT32DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT32DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT32DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT32DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT32DE.Search(const inBuff: TKDT32DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT32DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT32DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT32DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT32DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT32DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT32DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT32DE_Source));
end;

procedure TKDT32DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT32DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT32DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT32DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT32DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT32DE.PrintNodeTree(const NodePtr: PKDT32DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT32DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT32DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT32DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT32DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT32DE.KDT32DEVec(const s: string): TKDT32DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT32DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT32DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT32DE.KDT32DEVec(const v: TKDT32DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT32DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT32DE.KDT32DEPow(const v: TKDT32DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT32DE.KDT32DEDistance(const v1, v2: TKDT32DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT32DE_Axis - 1 do
      Result := Result + KDT32DEPow(v2[i] - v1[i]);
end;

procedure TKDT32DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT32DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT32DE.Test;
var
  TKDT32DE_Test    : TKDT32DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT32DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT32DE_Test := TKDT32DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT32DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT32DE_Test.TestBuff) - 1 do
    for j := 0 to KDT32DE_Axis - 1 do
        TKDT32DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT32DE_Test.TestBuff), length(TKDT32DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT32DE_Test.BuildKDTreeM(length(TKDT32DE_Test.TestBuff), nil, @TKDT32DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT32DE_Test.BuildKDTreeM(length(TKDT32DE_Test.TestBuff), nil, TKDT32DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT32DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT32DE_Test.TestBuff));
  TKDT32DE_Test.Search(TKDT32DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT32DEDistance(TKDT32DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT32DE_Test.Clear;
  { kMean test }
  TKDT32DE_Test.BuildKDTreeWithCluster(TKDT32DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT32DE_Test.Search(TKDT32DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT32DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT32DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT32DE_Test);
end;


function TKDT33DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT33DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT33DE_Node;
  function SortCompare(const p1, p2: PKDT33DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT33DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT33DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT33DE_SourceBuffer;
  dynBuff  : PKDT33DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT33DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT33DE.GetData(const index: NativeInt): PKDT33DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT33DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT33DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT33DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT33DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT33DE.StoreBuffPtr: PKDT33DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT33DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT33DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT33DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT33DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT33DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT33DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT33DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT33DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT33DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT33DE.BuildKDTreeWithCluster(const inBuff: TKDT33DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT33DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT33DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT33DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT33DE.BuildKDTreeWithCluster(const inBuff: TKDT33DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT33DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DE_BuildCall);
var
  TempStoreBuff: TKDT33DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT33DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT33DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT33DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT33DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT33DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DE_BuildMethod);
var
  TempStoreBuff: TKDT33DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT33DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT33DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT33DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT33DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT33DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DE_BuildProc);
var
  TempStoreBuff: TKDT33DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT33DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT33DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT33DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT33DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT33DE.Search(const Buff: TKDT33DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT33DE_Node;

var
  NearestNeighbour: PKDT33DE_Node;

  function FindParentNode(const BuffPtr: PKDT33DE_Vec; NodePtr: PKDT33DE_Node): PKDT33DE_Node;
  var
    Next       : PKDT33DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT33DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT33DE_Node; const BuffPtr: PKDT33DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT33DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT33DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT33DE_Vec; const p1, p2: PKDT33DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT33DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT33DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT33DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT33DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT33DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT33DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT33DE_Node(NearestNodes[0]);
    end;
end;

function TKDT33DE.Search(const Buff: TKDT33DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT33DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT33DE.Search(const Buff: TKDT33DE_Vec; var SearchedDistanceMin: Double): PKDT33DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT33DE.Search(const Buff: TKDT33DE_Vec): PKDT33DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT33DE.Search(const inBuff: TKDT33DE_DynamicVecBuffer; var OutBuff: TKDT33DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT33DE_DynamicVecBuffer;
  outBuffPtr : PKDT33DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT33DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT33DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT33DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT33DE.Search(const inBuff: TKDT33DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT33DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT33DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT33DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT33DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT33DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT33DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT33DE_Source));
end;

procedure TKDT33DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT33DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT33DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT33DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT33DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT33DE.PrintNodeTree(const NodePtr: PKDT33DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT33DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT33DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT33DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT33DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT33DE.KDT33DEVec(const s: string): TKDT33DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT33DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT33DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT33DE.KDT33DEVec(const v: TKDT33DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT33DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT33DE.KDT33DEPow(const v: TKDT33DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT33DE.KDT33DEDistance(const v1, v2: TKDT33DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT33DE_Axis - 1 do
      Result := Result + KDT33DEPow(v2[i] - v1[i]);
end;

procedure TKDT33DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT33DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT33DE.Test;
var
  TKDT33DE_Test    : TKDT33DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT33DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT33DE_Test := TKDT33DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT33DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT33DE_Test.TestBuff) - 1 do
    for j := 0 to KDT33DE_Axis - 1 do
        TKDT33DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT33DE_Test.TestBuff), length(TKDT33DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT33DE_Test.BuildKDTreeM(length(TKDT33DE_Test.TestBuff), nil, @TKDT33DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT33DE_Test.BuildKDTreeM(length(TKDT33DE_Test.TestBuff), nil, TKDT33DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT33DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT33DE_Test.TestBuff));
  TKDT33DE_Test.Search(TKDT33DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT33DEDistance(TKDT33DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT33DE_Test.Clear;
  { kMean test }
  TKDT33DE_Test.BuildKDTreeWithCluster(TKDT33DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT33DE_Test.Search(TKDT33DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT33DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT33DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT33DE_Test);
end;


function TKDT34DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DE_Node;
  function SortCompare(const p1, p2: PKDT34DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT34DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT34DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT34DE_SourceBuffer;
  dynBuff  : PKDT34DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT34DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT34DE.GetData(const index: NativeInt): PKDT34DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT34DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT34DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT34DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT34DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT34DE.StoreBuffPtr: PKDT34DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT34DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT34DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT34DE.BuildKDTreeWithCluster(const inBuff: TKDT34DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT34DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT34DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT34DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT34DE.BuildKDTreeWithCluster(const inBuff: TKDT34DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DE_BuildCall);
var
  TempStoreBuff: TKDT34DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT34DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT34DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT34DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DE_BuildMethod);
var
  TempStoreBuff: TKDT34DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT34DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT34DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT34DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DE_BuildProc);
var
  TempStoreBuff: TKDT34DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT34DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT34DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT34DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT34DE.Search(const Buff: TKDT34DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DE_Node;

var
  NearestNeighbour: PKDT34DE_Node;

  function FindParentNode(const BuffPtr: PKDT34DE_Vec; NodePtr: PKDT34DE_Node): PKDT34DE_Node;
  var
    Next       : PKDT34DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT34DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT34DE_Node; const BuffPtr: PKDT34DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT34DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT34DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT34DE_Vec; const p1, p2: PKDT34DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT34DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT34DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT34DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT34DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT34DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT34DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT34DE_Node(NearestNodes[0]);
    end;
end;

function TKDT34DE.Search(const Buff: TKDT34DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT34DE.Search(const Buff: TKDT34DE_Vec; var SearchedDistanceMin: Double): PKDT34DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT34DE.Search(const Buff: TKDT34DE_Vec): PKDT34DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT34DE.Search(const inBuff: TKDT34DE_DynamicVecBuffer; var OutBuff: TKDT34DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT34DE_DynamicVecBuffer;
  outBuffPtr : PKDT34DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT34DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT34DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT34DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT34DE.Search(const inBuff: TKDT34DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT34DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT34DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT34DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT34DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT34DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT34DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT34DE_Source));
end;

procedure TKDT34DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT34DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT34DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT34DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT34DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT34DE.PrintNodeTree(const NodePtr: PKDT34DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT34DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT34DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT34DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT34DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT34DE.KDT34DEVec(const s: string): TKDT34DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT34DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT34DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT34DE.KDT34DEVec(const v: TKDT34DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT34DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT34DE.KDT34DEPow(const v: TKDT34DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT34DE.KDT34DEDistance(const v1, v2: TKDT34DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT34DE_Axis - 1 do
      Result := Result + KDT34DEPow(v2[i] - v1[i]);
end;

procedure TKDT34DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT34DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT34DE.Test;
var
  TKDT34DE_Test    : TKDT34DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT34DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT34DE_Test := TKDT34DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT34DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT34DE_Test.TestBuff) - 1 do
    for j := 0 to KDT34DE_Axis - 1 do
        TKDT34DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT34DE_Test.TestBuff), length(TKDT34DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT34DE_Test.BuildKDTreeM(length(TKDT34DE_Test.TestBuff), nil, @TKDT34DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT34DE_Test.BuildKDTreeM(length(TKDT34DE_Test.TestBuff), nil, TKDT34DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT34DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT34DE_Test.TestBuff));
  TKDT34DE_Test.Search(TKDT34DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT34DEDistance(TKDT34DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT34DE_Test.Clear;
  { kMean test }
  TKDT34DE_Test.BuildKDTreeWithCluster(TKDT34DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT34DE_Test.Search(TKDT34DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT34DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT34DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT34DE_Test);
end;


function TKDT35DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT35DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT35DE_Node;
  function SortCompare(const p1, p2: PKDT35DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT35DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT35DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT35DE_SourceBuffer;
  dynBuff  : PKDT35DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT35DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT35DE.GetData(const index: NativeInt): PKDT35DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT35DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT35DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT35DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT35DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT35DE.StoreBuffPtr: PKDT35DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT35DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT35DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT35DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT35DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT35DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT35DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT35DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT35DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT35DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT35DE.BuildKDTreeWithCluster(const inBuff: TKDT35DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT35DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT35DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT35DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT35DE.BuildKDTreeWithCluster(const inBuff: TKDT35DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT35DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DE_BuildCall);
var
  TempStoreBuff: TKDT35DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT35DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT35DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT35DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT35DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT35DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DE_BuildMethod);
var
  TempStoreBuff: TKDT35DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT35DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT35DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT35DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT35DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT35DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DE_BuildProc);
var
  TempStoreBuff: TKDT35DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT35DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT35DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT35DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT35DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT35DE.Search(const Buff: TKDT35DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT35DE_Node;

var
  NearestNeighbour: PKDT35DE_Node;

  function FindParentNode(const BuffPtr: PKDT35DE_Vec; NodePtr: PKDT35DE_Node): PKDT35DE_Node;
  var
    Next       : PKDT35DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT35DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT35DE_Node; const BuffPtr: PKDT35DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT35DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT35DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT35DE_Vec; const p1, p2: PKDT35DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT35DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT35DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT35DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT35DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT35DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT35DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT35DE_Node(NearestNodes[0]);
    end;
end;

function TKDT35DE.Search(const Buff: TKDT35DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT35DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT35DE.Search(const Buff: TKDT35DE_Vec; var SearchedDistanceMin: Double): PKDT35DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT35DE.Search(const Buff: TKDT35DE_Vec): PKDT35DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT35DE.Search(const inBuff: TKDT35DE_DynamicVecBuffer; var OutBuff: TKDT35DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT35DE_DynamicVecBuffer;
  outBuffPtr : PKDT35DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT35DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT35DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT35DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT35DE.Search(const inBuff: TKDT35DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT35DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT35DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT35DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT35DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT35DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT35DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT35DE_Source));
end;

procedure TKDT35DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT35DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT35DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT35DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT35DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT35DE.PrintNodeTree(const NodePtr: PKDT35DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT35DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT35DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT35DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT35DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT35DE.KDT35DEVec(const s: string): TKDT35DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT35DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT35DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT35DE.KDT35DEVec(const v: TKDT35DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT35DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT35DE.KDT35DEPow(const v: TKDT35DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT35DE.KDT35DEDistance(const v1, v2: TKDT35DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT35DE_Axis - 1 do
      Result := Result + KDT35DEPow(v2[i] - v1[i]);
end;

procedure TKDT35DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT35DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT35DE.Test;
var
  TKDT35DE_Test    : TKDT35DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT35DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT35DE_Test := TKDT35DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT35DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT35DE_Test.TestBuff) - 1 do
    for j := 0 to KDT35DE_Axis - 1 do
        TKDT35DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT35DE_Test.TestBuff), length(TKDT35DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT35DE_Test.BuildKDTreeM(length(TKDT35DE_Test.TestBuff), nil, @TKDT35DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT35DE_Test.BuildKDTreeM(length(TKDT35DE_Test.TestBuff), nil, TKDT35DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT35DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT35DE_Test.TestBuff));
  TKDT35DE_Test.Search(TKDT35DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT35DEDistance(TKDT35DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT35DE_Test.Clear;
  { kMean test }
  TKDT35DE_Test.BuildKDTreeWithCluster(TKDT35DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT35DE_Test.Search(TKDT35DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT35DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT35DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT35DE_Test);
end;


function TKDT36DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DE_Node;
  function SortCompare(const p1, p2: PKDT36DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT36DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT36DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT36DE_SourceBuffer;
  dynBuff  : PKDT36DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT36DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT36DE.GetData(const index: NativeInt): PKDT36DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT36DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT36DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT36DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT36DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT36DE.StoreBuffPtr: PKDT36DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT36DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT36DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT36DE.BuildKDTreeWithCluster(const inBuff: TKDT36DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT36DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT36DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT36DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT36DE.BuildKDTreeWithCluster(const inBuff: TKDT36DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DE_BuildCall);
var
  TempStoreBuff: TKDT36DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT36DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT36DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT36DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DE_BuildMethod);
var
  TempStoreBuff: TKDT36DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT36DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT36DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT36DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DE_BuildProc);
var
  TempStoreBuff: TKDT36DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT36DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT36DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT36DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT36DE.Search(const Buff: TKDT36DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DE_Node;

var
  NearestNeighbour: PKDT36DE_Node;

  function FindParentNode(const BuffPtr: PKDT36DE_Vec; NodePtr: PKDT36DE_Node): PKDT36DE_Node;
  var
    Next       : PKDT36DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT36DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT36DE_Node; const BuffPtr: PKDT36DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT36DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT36DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT36DE_Vec; const p1, p2: PKDT36DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT36DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT36DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT36DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT36DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT36DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT36DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT36DE_Node(NearestNodes[0]);
    end;
end;

function TKDT36DE.Search(const Buff: TKDT36DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT36DE.Search(const Buff: TKDT36DE_Vec; var SearchedDistanceMin: Double): PKDT36DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT36DE.Search(const Buff: TKDT36DE_Vec): PKDT36DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT36DE.Search(const inBuff: TKDT36DE_DynamicVecBuffer; var OutBuff: TKDT36DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT36DE_DynamicVecBuffer;
  outBuffPtr : PKDT36DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT36DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT36DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT36DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT36DE.Search(const inBuff: TKDT36DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT36DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT36DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT36DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT36DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT36DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT36DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT36DE_Source));
end;

procedure TKDT36DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT36DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT36DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT36DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT36DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT36DE.PrintNodeTree(const NodePtr: PKDT36DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT36DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT36DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT36DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT36DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT36DE.KDT36DEVec(const s: string): TKDT36DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT36DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT36DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT36DE.KDT36DEVec(const v: TKDT36DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT36DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT36DE.KDT36DEPow(const v: TKDT36DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT36DE.KDT36DEDistance(const v1, v2: TKDT36DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT36DE_Axis - 1 do
      Result := Result + KDT36DEPow(v2[i] - v1[i]);
end;

procedure TKDT36DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT36DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT36DE.Test;
var
  TKDT36DE_Test    : TKDT36DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT36DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT36DE_Test := TKDT36DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT36DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT36DE_Test.TestBuff) - 1 do
    for j := 0 to KDT36DE_Axis - 1 do
        TKDT36DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT36DE_Test.TestBuff), length(TKDT36DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT36DE_Test.BuildKDTreeM(length(TKDT36DE_Test.TestBuff), nil, @TKDT36DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT36DE_Test.BuildKDTreeM(length(TKDT36DE_Test.TestBuff), nil, TKDT36DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT36DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT36DE_Test.TestBuff));
  TKDT36DE_Test.Search(TKDT36DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT36DEDistance(TKDT36DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT36DE_Test.Clear;
  { kMean test }
  TKDT36DE_Test.BuildKDTreeWithCluster(TKDT36DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT36DE_Test.Search(TKDT36DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT36DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT36DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT36DE_Test);
end;


function TKDT37DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT37DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT37DE_Node;
  function SortCompare(const p1, p2: PKDT37DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT37DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT37DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT37DE_SourceBuffer;
  dynBuff  : PKDT37DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT37DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT37DE.GetData(const index: NativeInt): PKDT37DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT37DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT37DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT37DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT37DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT37DE.StoreBuffPtr: PKDT37DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT37DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT37DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT37DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT37DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT37DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT37DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT37DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT37DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT37DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT37DE.BuildKDTreeWithCluster(const inBuff: TKDT37DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT37DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT37DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT37DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT37DE.BuildKDTreeWithCluster(const inBuff: TKDT37DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT37DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DE_BuildCall);
var
  TempStoreBuff: TKDT37DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT37DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT37DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT37DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT37DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT37DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DE_BuildMethod);
var
  TempStoreBuff: TKDT37DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT37DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT37DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT37DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT37DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT37DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DE_BuildProc);
var
  TempStoreBuff: TKDT37DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT37DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT37DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT37DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT37DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT37DE.Search(const Buff: TKDT37DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT37DE_Node;

var
  NearestNeighbour: PKDT37DE_Node;

  function FindParentNode(const BuffPtr: PKDT37DE_Vec; NodePtr: PKDT37DE_Node): PKDT37DE_Node;
  var
    Next       : PKDT37DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT37DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT37DE_Node; const BuffPtr: PKDT37DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT37DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT37DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT37DE_Vec; const p1, p2: PKDT37DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT37DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT37DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT37DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT37DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT37DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT37DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT37DE_Node(NearestNodes[0]);
    end;
end;

function TKDT37DE.Search(const Buff: TKDT37DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT37DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT37DE.Search(const Buff: TKDT37DE_Vec; var SearchedDistanceMin: Double): PKDT37DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT37DE.Search(const Buff: TKDT37DE_Vec): PKDT37DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT37DE.Search(const inBuff: TKDT37DE_DynamicVecBuffer; var OutBuff: TKDT37DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT37DE_DynamicVecBuffer;
  outBuffPtr : PKDT37DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT37DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT37DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT37DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT37DE.Search(const inBuff: TKDT37DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT37DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT37DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT37DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT37DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT37DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT37DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT37DE_Source));
end;

procedure TKDT37DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT37DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT37DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT37DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT37DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT37DE.PrintNodeTree(const NodePtr: PKDT37DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT37DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT37DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT37DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT37DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT37DE.KDT37DEVec(const s: string): TKDT37DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT37DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT37DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT37DE.KDT37DEVec(const v: TKDT37DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT37DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT37DE.KDT37DEPow(const v: TKDT37DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT37DE.KDT37DEDistance(const v1, v2: TKDT37DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT37DE_Axis - 1 do
      Result := Result + KDT37DEPow(v2[i] - v1[i]);
end;

procedure TKDT37DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT37DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT37DE.Test;
var
  TKDT37DE_Test    : TKDT37DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT37DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT37DE_Test := TKDT37DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT37DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT37DE_Test.TestBuff) - 1 do
    for j := 0 to KDT37DE_Axis - 1 do
        TKDT37DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT37DE_Test.TestBuff), length(TKDT37DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT37DE_Test.BuildKDTreeM(length(TKDT37DE_Test.TestBuff), nil, @TKDT37DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT37DE_Test.BuildKDTreeM(length(TKDT37DE_Test.TestBuff), nil, TKDT37DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT37DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT37DE_Test.TestBuff));
  TKDT37DE_Test.Search(TKDT37DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT37DEDistance(TKDT37DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT37DE_Test.Clear;
  { kMean test }
  TKDT37DE_Test.BuildKDTreeWithCluster(TKDT37DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT37DE_Test.Search(TKDT37DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT37DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT37DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT37DE_Test);
end;


function TKDT38DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT38DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT38DE_Node;
  function SortCompare(const p1, p2: PKDT38DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT38DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT38DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT38DE_SourceBuffer;
  dynBuff  : PKDT38DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT38DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT38DE.GetData(const index: NativeInt): PKDT38DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT38DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT38DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT38DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT38DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT38DE.StoreBuffPtr: PKDT38DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT38DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT38DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT38DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT38DE.BuildKDTreeWithCluster(const inBuff: TKDT38DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT38DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT38DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT38DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT38DE.BuildKDTreeWithCluster(const inBuff: TKDT38DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT38DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DE_BuildCall);
var
  TempStoreBuff: TKDT38DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT38DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT38DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT38DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT38DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DE_BuildMethod);
var
  TempStoreBuff: TKDT38DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT38DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT38DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT38DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT38DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DE_BuildProc);
var
  TempStoreBuff: TKDT38DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT38DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT38DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT38DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT38DE.Search(const Buff: TKDT38DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT38DE_Node;

var
  NearestNeighbour: PKDT38DE_Node;

  function FindParentNode(const BuffPtr: PKDT38DE_Vec; NodePtr: PKDT38DE_Node): PKDT38DE_Node;
  var
    Next       : PKDT38DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT38DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT38DE_Node; const BuffPtr: PKDT38DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT38DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT38DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT38DE_Vec; const p1, p2: PKDT38DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT38DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT38DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT38DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT38DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT38DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT38DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT38DE_Node(NearestNodes[0]);
    end;
end;

function TKDT38DE.Search(const Buff: TKDT38DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT38DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT38DE.Search(const Buff: TKDT38DE_Vec; var SearchedDistanceMin: Double): PKDT38DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT38DE.Search(const Buff: TKDT38DE_Vec): PKDT38DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT38DE.Search(const inBuff: TKDT38DE_DynamicVecBuffer; var OutBuff: TKDT38DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT38DE_DynamicVecBuffer;
  outBuffPtr : PKDT38DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT38DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT38DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT38DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT38DE.Search(const inBuff: TKDT38DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT38DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT38DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT38DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT38DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT38DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT38DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT38DE_Source));
end;

procedure TKDT38DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT38DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT38DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT38DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT38DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT38DE.PrintNodeTree(const NodePtr: PKDT38DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT38DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT38DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT38DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT38DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT38DE.KDT38DEVec(const s: string): TKDT38DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT38DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT38DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT38DE.KDT38DEVec(const v: TKDT38DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT38DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT38DE.KDT38DEPow(const v: TKDT38DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT38DE.KDT38DEDistance(const v1, v2: TKDT38DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT38DE_Axis - 1 do
      Result := Result + KDT38DEPow(v2[i] - v1[i]);
end;

procedure TKDT38DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT38DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT38DE.Test;
var
  TKDT38DE_Test    : TKDT38DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT38DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT38DE_Test := TKDT38DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT38DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT38DE_Test.TestBuff) - 1 do
    for j := 0 to KDT38DE_Axis - 1 do
        TKDT38DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT38DE_Test.TestBuff), length(TKDT38DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT38DE_Test.BuildKDTreeM(length(TKDT38DE_Test.TestBuff), nil, @TKDT38DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT38DE_Test.BuildKDTreeM(length(TKDT38DE_Test.TestBuff), nil, TKDT38DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT38DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT38DE_Test.TestBuff));
  TKDT38DE_Test.Search(TKDT38DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT38DEDistance(TKDT38DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT38DE_Test.Clear;
  { kMean test }
  TKDT38DE_Test.BuildKDTreeWithCluster(TKDT38DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT38DE_Test.Search(TKDT38DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT38DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT38DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT38DE_Test);
end;


function TKDT39DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT39DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT39DE_Node;
  function SortCompare(const p1, p2: PKDT39DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT39DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT39DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT39DE_SourceBuffer;
  dynBuff  : PKDT39DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT39DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT39DE.GetData(const index: NativeInt): PKDT39DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT39DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT39DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT39DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT39DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT39DE.StoreBuffPtr: PKDT39DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT39DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT39DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT39DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT39DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT39DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT39DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT39DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT39DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT39DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT39DE.BuildKDTreeWithCluster(const inBuff: TKDT39DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT39DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT39DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT39DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT39DE.BuildKDTreeWithCluster(const inBuff: TKDT39DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT39DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DE_BuildCall);
var
  TempStoreBuff: TKDT39DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT39DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT39DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT39DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT39DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT39DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DE_BuildMethod);
var
  TempStoreBuff: TKDT39DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT39DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT39DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT39DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT39DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT39DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DE_BuildProc);
var
  TempStoreBuff: TKDT39DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT39DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT39DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT39DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT39DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT39DE.Search(const Buff: TKDT39DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT39DE_Node;

var
  NearestNeighbour: PKDT39DE_Node;

  function FindParentNode(const BuffPtr: PKDT39DE_Vec; NodePtr: PKDT39DE_Node): PKDT39DE_Node;
  var
    Next       : PKDT39DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT39DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT39DE_Node; const BuffPtr: PKDT39DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT39DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT39DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT39DE_Vec; const p1, p2: PKDT39DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT39DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT39DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT39DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT39DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT39DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT39DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT39DE_Node(NearestNodes[0]);
    end;
end;

function TKDT39DE.Search(const Buff: TKDT39DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT39DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT39DE.Search(const Buff: TKDT39DE_Vec; var SearchedDistanceMin: Double): PKDT39DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT39DE.Search(const Buff: TKDT39DE_Vec): PKDT39DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT39DE.Search(const inBuff: TKDT39DE_DynamicVecBuffer; var OutBuff: TKDT39DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT39DE_DynamicVecBuffer;
  outBuffPtr : PKDT39DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT39DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT39DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT39DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT39DE.Search(const inBuff: TKDT39DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT39DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT39DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT39DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT39DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT39DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT39DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT39DE_Source));
end;

procedure TKDT39DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT39DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT39DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT39DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT39DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT39DE.PrintNodeTree(const NodePtr: PKDT39DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT39DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT39DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT39DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT39DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT39DE.KDT39DEVec(const s: string): TKDT39DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT39DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT39DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT39DE.KDT39DEVec(const v: TKDT39DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT39DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT39DE.KDT39DEPow(const v: TKDT39DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT39DE.KDT39DEDistance(const v1, v2: TKDT39DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT39DE_Axis - 1 do
      Result := Result + KDT39DEPow(v2[i] - v1[i]);
end;

procedure TKDT39DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT39DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT39DE.Test;
var
  TKDT39DE_Test    : TKDT39DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT39DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT39DE_Test := TKDT39DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT39DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT39DE_Test.TestBuff) - 1 do
    for j := 0 to KDT39DE_Axis - 1 do
        TKDT39DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT39DE_Test.TestBuff), length(TKDT39DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT39DE_Test.BuildKDTreeM(length(TKDT39DE_Test.TestBuff), nil, @TKDT39DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT39DE_Test.BuildKDTreeM(length(TKDT39DE_Test.TestBuff), nil, TKDT39DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT39DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT39DE_Test.TestBuff));
  TKDT39DE_Test.Search(TKDT39DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT39DEDistance(TKDT39DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT39DE_Test.Clear;
  { kMean test }
  TKDT39DE_Test.BuildKDTreeWithCluster(TKDT39DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT39DE_Test.Search(TKDT39DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT39DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT39DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT39DE_Test);
end;


function TKDT40DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DE_Node;
  function SortCompare(const p1, p2: PKDT40DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT40DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT40DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT40DE_SourceBuffer;
  dynBuff  : PKDT40DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT40DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT40DE.GetData(const index: NativeInt): PKDT40DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT40DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT40DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT40DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT40DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT40DE.StoreBuffPtr: PKDT40DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT40DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT40DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT40DE.BuildKDTreeWithCluster(const inBuff: TKDT40DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT40DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT40DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT40DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT40DE.BuildKDTreeWithCluster(const inBuff: TKDT40DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DE_BuildCall);
var
  TempStoreBuff: TKDT40DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT40DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT40DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT40DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DE_BuildMethod);
var
  TempStoreBuff: TKDT40DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT40DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT40DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT40DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DE_BuildProc);
var
  TempStoreBuff: TKDT40DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT40DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT40DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT40DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT40DE.Search(const Buff: TKDT40DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DE_Node;

var
  NearestNeighbour: PKDT40DE_Node;

  function FindParentNode(const BuffPtr: PKDT40DE_Vec; NodePtr: PKDT40DE_Node): PKDT40DE_Node;
  var
    Next       : PKDT40DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT40DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT40DE_Node; const BuffPtr: PKDT40DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT40DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT40DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT40DE_Vec; const p1, p2: PKDT40DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT40DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT40DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT40DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT40DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT40DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT40DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT40DE_Node(NearestNodes[0]);
    end;
end;

function TKDT40DE.Search(const Buff: TKDT40DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT40DE.Search(const Buff: TKDT40DE_Vec; var SearchedDistanceMin: Double): PKDT40DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT40DE.Search(const Buff: TKDT40DE_Vec): PKDT40DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT40DE.Search(const inBuff: TKDT40DE_DynamicVecBuffer; var OutBuff: TKDT40DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT40DE_DynamicVecBuffer;
  outBuffPtr : PKDT40DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT40DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT40DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT40DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT40DE.Search(const inBuff: TKDT40DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT40DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT40DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT40DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT40DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT40DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT40DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT40DE_Source));
end;

procedure TKDT40DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT40DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT40DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT40DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT40DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT40DE.PrintNodeTree(const NodePtr: PKDT40DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT40DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT40DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT40DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT40DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT40DE.KDT40DEVec(const s: string): TKDT40DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT40DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT40DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT40DE.KDT40DEVec(const v: TKDT40DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT40DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT40DE.KDT40DEPow(const v: TKDT40DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT40DE.KDT40DEDistance(const v1, v2: TKDT40DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT40DE_Axis - 1 do
      Result := Result + KDT40DEPow(v2[i] - v1[i]);
end;

procedure TKDT40DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT40DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT40DE.Test;
var
  TKDT40DE_Test    : TKDT40DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT40DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT40DE_Test := TKDT40DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT40DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT40DE_Test.TestBuff) - 1 do
    for j := 0 to KDT40DE_Axis - 1 do
        TKDT40DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT40DE_Test.TestBuff), length(TKDT40DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT40DE_Test.BuildKDTreeM(length(TKDT40DE_Test.TestBuff), nil, @TKDT40DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT40DE_Test.BuildKDTreeM(length(TKDT40DE_Test.TestBuff), nil, TKDT40DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT40DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT40DE_Test.TestBuff));
  TKDT40DE_Test.Search(TKDT40DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT40DEDistance(TKDT40DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT40DE_Test.Clear;
  { kMean test }
  TKDT40DE_Test.BuildKDTreeWithCluster(TKDT40DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT40DE_Test.Search(TKDT40DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT40DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT40DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT40DE_Test);
end;


function TKDT41DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT41DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT41DE_Node;
  function SortCompare(const p1, p2: PKDT41DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT41DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT41DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT41DE_SourceBuffer;
  dynBuff  : PKDT41DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT41DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT41DE.GetData(const index: NativeInt): PKDT41DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT41DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT41DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT41DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT41DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT41DE.StoreBuffPtr: PKDT41DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT41DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT41DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT41DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT41DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT41DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT41DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT41DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT41DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT41DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT41DE.BuildKDTreeWithCluster(const inBuff: TKDT41DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT41DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT41DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT41DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT41DE.BuildKDTreeWithCluster(const inBuff: TKDT41DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT41DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DE_BuildCall);
var
  TempStoreBuff: TKDT41DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT41DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT41DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT41DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT41DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT41DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DE_BuildMethod);
var
  TempStoreBuff: TKDT41DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT41DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT41DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT41DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT41DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT41DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DE_BuildProc);
var
  TempStoreBuff: TKDT41DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT41DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT41DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT41DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT41DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT41DE.Search(const Buff: TKDT41DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT41DE_Node;

var
  NearestNeighbour: PKDT41DE_Node;

  function FindParentNode(const BuffPtr: PKDT41DE_Vec; NodePtr: PKDT41DE_Node): PKDT41DE_Node;
  var
    Next       : PKDT41DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT41DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT41DE_Node; const BuffPtr: PKDT41DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT41DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT41DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT41DE_Vec; const p1, p2: PKDT41DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT41DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT41DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT41DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT41DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT41DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT41DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT41DE_Node(NearestNodes[0]);
    end;
end;

function TKDT41DE.Search(const Buff: TKDT41DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT41DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT41DE.Search(const Buff: TKDT41DE_Vec; var SearchedDistanceMin: Double): PKDT41DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT41DE.Search(const Buff: TKDT41DE_Vec): PKDT41DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT41DE.Search(const inBuff: TKDT41DE_DynamicVecBuffer; var OutBuff: TKDT41DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT41DE_DynamicVecBuffer;
  outBuffPtr : PKDT41DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT41DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT41DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT41DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT41DE.Search(const inBuff: TKDT41DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT41DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT41DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT41DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT41DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT41DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT41DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT41DE_Source));
end;

procedure TKDT41DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT41DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT41DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT41DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT41DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT41DE.PrintNodeTree(const NodePtr: PKDT41DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT41DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT41DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT41DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT41DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT41DE.KDT41DEVec(const s: string): TKDT41DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT41DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT41DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT41DE.KDT41DEVec(const v: TKDT41DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT41DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT41DE.KDT41DEPow(const v: TKDT41DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT41DE.KDT41DEDistance(const v1, v2: TKDT41DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT41DE_Axis - 1 do
      Result := Result + KDT41DEPow(v2[i] - v1[i]);
end;

procedure TKDT41DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT41DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT41DE.Test;
var
  TKDT41DE_Test    : TKDT41DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT41DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT41DE_Test := TKDT41DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT41DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT41DE_Test.TestBuff) - 1 do
    for j := 0 to KDT41DE_Axis - 1 do
        TKDT41DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT41DE_Test.TestBuff), length(TKDT41DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT41DE_Test.BuildKDTreeM(length(TKDT41DE_Test.TestBuff), nil, @TKDT41DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT41DE_Test.BuildKDTreeM(length(TKDT41DE_Test.TestBuff), nil, TKDT41DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT41DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT41DE_Test.TestBuff));
  TKDT41DE_Test.Search(TKDT41DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT41DEDistance(TKDT41DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT41DE_Test.Clear;
  { kMean test }
  TKDT41DE_Test.BuildKDTreeWithCluster(TKDT41DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT41DE_Test.Search(TKDT41DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT41DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT41DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT41DE_Test);
end;


function TKDT42DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT42DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT42DE_Node;
  function SortCompare(const p1, p2: PKDT42DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT42DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT42DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT42DE_SourceBuffer;
  dynBuff  : PKDT42DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT42DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT42DE.GetData(const index: NativeInt): PKDT42DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT42DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT42DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT42DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT42DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT42DE.StoreBuffPtr: PKDT42DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT42DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT42DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT42DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT42DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT42DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT42DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT42DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT42DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT42DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT42DE.BuildKDTreeWithCluster(const inBuff: TKDT42DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT42DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT42DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT42DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT42DE.BuildKDTreeWithCluster(const inBuff: TKDT42DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT42DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DE_BuildCall);
var
  TempStoreBuff: TKDT42DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT42DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT42DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT42DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT42DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT42DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DE_BuildMethod);
var
  TempStoreBuff: TKDT42DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT42DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT42DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT42DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT42DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT42DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DE_BuildProc);
var
  TempStoreBuff: TKDT42DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT42DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT42DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT42DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT42DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT42DE.Search(const Buff: TKDT42DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT42DE_Node;

var
  NearestNeighbour: PKDT42DE_Node;

  function FindParentNode(const BuffPtr: PKDT42DE_Vec; NodePtr: PKDT42DE_Node): PKDT42DE_Node;
  var
    Next       : PKDT42DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT42DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT42DE_Node; const BuffPtr: PKDT42DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT42DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT42DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT42DE_Vec; const p1, p2: PKDT42DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT42DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT42DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT42DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT42DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT42DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT42DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT42DE_Node(NearestNodes[0]);
    end;
end;

function TKDT42DE.Search(const Buff: TKDT42DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT42DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT42DE.Search(const Buff: TKDT42DE_Vec; var SearchedDistanceMin: Double): PKDT42DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT42DE.Search(const Buff: TKDT42DE_Vec): PKDT42DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT42DE.Search(const inBuff: TKDT42DE_DynamicVecBuffer; var OutBuff: TKDT42DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT42DE_DynamicVecBuffer;
  outBuffPtr : PKDT42DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT42DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT42DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT42DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT42DE.Search(const inBuff: TKDT42DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT42DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT42DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT42DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT42DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT42DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT42DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT42DE_Source));
end;

procedure TKDT42DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT42DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT42DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT42DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT42DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT42DE.PrintNodeTree(const NodePtr: PKDT42DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT42DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT42DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT42DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT42DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT42DE.KDT42DEVec(const s: string): TKDT42DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT42DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT42DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT42DE.KDT42DEVec(const v: TKDT42DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT42DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT42DE.KDT42DEPow(const v: TKDT42DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT42DE.KDT42DEDistance(const v1, v2: TKDT42DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT42DE_Axis - 1 do
      Result := Result + KDT42DEPow(v2[i] - v1[i]);
end;

procedure TKDT42DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT42DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT42DE.Test;
var
  TKDT42DE_Test    : TKDT42DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT42DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT42DE_Test := TKDT42DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT42DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT42DE_Test.TestBuff) - 1 do
    for j := 0 to KDT42DE_Axis - 1 do
        TKDT42DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT42DE_Test.TestBuff), length(TKDT42DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT42DE_Test.BuildKDTreeM(length(TKDT42DE_Test.TestBuff), nil, @TKDT42DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT42DE_Test.BuildKDTreeM(length(TKDT42DE_Test.TestBuff), nil, TKDT42DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT42DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT42DE_Test.TestBuff));
  TKDT42DE_Test.Search(TKDT42DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT42DEDistance(TKDT42DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT42DE_Test.Clear;
  { kMean test }
  TKDT42DE_Test.BuildKDTreeWithCluster(TKDT42DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT42DE_Test.Search(TKDT42DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT42DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT42DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT42DE_Test);
end;


function TKDT43DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT43DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT43DE_Node;
  function SortCompare(const p1, p2: PKDT43DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT43DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT43DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT43DE_SourceBuffer;
  dynBuff  : PKDT43DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT43DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT43DE.GetData(const index: NativeInt): PKDT43DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT43DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT43DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT43DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT43DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT43DE.StoreBuffPtr: PKDT43DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT43DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT43DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT43DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT43DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT43DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT43DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT43DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT43DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT43DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT43DE.BuildKDTreeWithCluster(const inBuff: TKDT43DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT43DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT43DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT43DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT43DE.BuildKDTreeWithCluster(const inBuff: TKDT43DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT43DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DE_BuildCall);
var
  TempStoreBuff: TKDT43DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT43DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT43DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT43DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT43DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT43DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DE_BuildMethod);
var
  TempStoreBuff: TKDT43DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT43DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT43DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT43DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT43DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT43DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DE_BuildProc);
var
  TempStoreBuff: TKDT43DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT43DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT43DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT43DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT43DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT43DE.Search(const Buff: TKDT43DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT43DE_Node;

var
  NearestNeighbour: PKDT43DE_Node;

  function FindParentNode(const BuffPtr: PKDT43DE_Vec; NodePtr: PKDT43DE_Node): PKDT43DE_Node;
  var
    Next       : PKDT43DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT43DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT43DE_Node; const BuffPtr: PKDT43DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT43DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT43DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT43DE_Vec; const p1, p2: PKDT43DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT43DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT43DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT43DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT43DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT43DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT43DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT43DE_Node(NearestNodes[0]);
    end;
end;

function TKDT43DE.Search(const Buff: TKDT43DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT43DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT43DE.Search(const Buff: TKDT43DE_Vec; var SearchedDistanceMin: Double): PKDT43DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT43DE.Search(const Buff: TKDT43DE_Vec): PKDT43DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT43DE.Search(const inBuff: TKDT43DE_DynamicVecBuffer; var OutBuff: TKDT43DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT43DE_DynamicVecBuffer;
  outBuffPtr : PKDT43DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT43DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT43DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT43DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT43DE.Search(const inBuff: TKDT43DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT43DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT43DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT43DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT43DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT43DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT43DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT43DE_Source));
end;

procedure TKDT43DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT43DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT43DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT43DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT43DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT43DE.PrintNodeTree(const NodePtr: PKDT43DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT43DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT43DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT43DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT43DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT43DE.KDT43DEVec(const s: string): TKDT43DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT43DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT43DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT43DE.KDT43DEVec(const v: TKDT43DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT43DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT43DE.KDT43DEPow(const v: TKDT43DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT43DE.KDT43DEDistance(const v1, v2: TKDT43DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT43DE_Axis - 1 do
      Result := Result + KDT43DEPow(v2[i] - v1[i]);
end;

procedure TKDT43DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT43DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT43DE.Test;
var
  TKDT43DE_Test    : TKDT43DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT43DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT43DE_Test := TKDT43DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT43DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT43DE_Test.TestBuff) - 1 do
    for j := 0 to KDT43DE_Axis - 1 do
        TKDT43DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT43DE_Test.TestBuff), length(TKDT43DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT43DE_Test.BuildKDTreeM(length(TKDT43DE_Test.TestBuff), nil, @TKDT43DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT43DE_Test.BuildKDTreeM(length(TKDT43DE_Test.TestBuff), nil, TKDT43DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT43DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT43DE_Test.TestBuff));
  TKDT43DE_Test.Search(TKDT43DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT43DEDistance(TKDT43DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT43DE_Test.Clear;
  { kMean test }
  TKDT43DE_Test.BuildKDTreeWithCluster(TKDT43DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT43DE_Test.Search(TKDT43DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT43DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT43DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT43DE_Test);
end;


function TKDT44DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT44DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT44DE_Node;
  function SortCompare(const p1, p2: PKDT44DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT44DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT44DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT44DE_SourceBuffer;
  dynBuff  : PKDT44DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT44DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT44DE.GetData(const index: NativeInt): PKDT44DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT44DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT44DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT44DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT44DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT44DE.StoreBuffPtr: PKDT44DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT44DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT44DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT44DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT44DE.BuildKDTreeWithCluster(const inBuff: TKDT44DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT44DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT44DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT44DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT44DE.BuildKDTreeWithCluster(const inBuff: TKDT44DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT44DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DE_BuildCall);
var
  TempStoreBuff: TKDT44DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT44DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT44DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT44DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT44DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DE_BuildMethod);
var
  TempStoreBuff: TKDT44DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT44DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT44DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT44DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT44DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DE_BuildProc);
var
  TempStoreBuff: TKDT44DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT44DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT44DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT44DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT44DE.Search(const Buff: TKDT44DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT44DE_Node;

var
  NearestNeighbour: PKDT44DE_Node;

  function FindParentNode(const BuffPtr: PKDT44DE_Vec; NodePtr: PKDT44DE_Node): PKDT44DE_Node;
  var
    Next       : PKDT44DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT44DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT44DE_Node; const BuffPtr: PKDT44DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT44DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT44DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT44DE_Vec; const p1, p2: PKDT44DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT44DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT44DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT44DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT44DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT44DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT44DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT44DE_Node(NearestNodes[0]);
    end;
end;

function TKDT44DE.Search(const Buff: TKDT44DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT44DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT44DE.Search(const Buff: TKDT44DE_Vec; var SearchedDistanceMin: Double): PKDT44DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT44DE.Search(const Buff: TKDT44DE_Vec): PKDT44DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT44DE.Search(const inBuff: TKDT44DE_DynamicVecBuffer; var OutBuff: TKDT44DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT44DE_DynamicVecBuffer;
  outBuffPtr : PKDT44DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT44DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT44DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT44DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT44DE.Search(const inBuff: TKDT44DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT44DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT44DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT44DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT44DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT44DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT44DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT44DE_Source));
end;

procedure TKDT44DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT44DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT44DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT44DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT44DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT44DE.PrintNodeTree(const NodePtr: PKDT44DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT44DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT44DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT44DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT44DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT44DE.KDT44DEVec(const s: string): TKDT44DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT44DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT44DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT44DE.KDT44DEVec(const v: TKDT44DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT44DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT44DE.KDT44DEPow(const v: TKDT44DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT44DE.KDT44DEDistance(const v1, v2: TKDT44DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT44DE_Axis - 1 do
      Result := Result + KDT44DEPow(v2[i] - v1[i]);
end;

procedure TKDT44DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT44DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT44DE.Test;
var
  TKDT44DE_Test    : TKDT44DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT44DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT44DE_Test := TKDT44DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT44DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT44DE_Test.TestBuff) - 1 do
    for j := 0 to KDT44DE_Axis - 1 do
        TKDT44DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT44DE_Test.TestBuff), length(TKDT44DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT44DE_Test.BuildKDTreeM(length(TKDT44DE_Test.TestBuff), nil, @TKDT44DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT44DE_Test.BuildKDTreeM(length(TKDT44DE_Test.TestBuff), nil, TKDT44DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT44DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT44DE_Test.TestBuff));
  TKDT44DE_Test.Search(TKDT44DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT44DEDistance(TKDT44DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT44DE_Test.Clear;
  { kMean test }
  TKDT44DE_Test.BuildKDTreeWithCluster(TKDT44DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT44DE_Test.Search(TKDT44DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT44DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT44DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT44DE_Test);
end;


function TKDT45DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT45DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT45DE_Node;
  function SortCompare(const p1, p2: PKDT45DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT45DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT45DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT45DE_SourceBuffer;
  dynBuff  : PKDT45DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT45DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT45DE.GetData(const index: NativeInt): PKDT45DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT45DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT45DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT45DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT45DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT45DE.StoreBuffPtr: PKDT45DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT45DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT45DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT45DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT45DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT45DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT45DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT45DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT45DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT45DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT45DE.BuildKDTreeWithCluster(const inBuff: TKDT45DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT45DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT45DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT45DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT45DE.BuildKDTreeWithCluster(const inBuff: TKDT45DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT45DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DE_BuildCall);
var
  TempStoreBuff: TKDT45DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT45DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT45DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT45DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT45DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT45DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DE_BuildMethod);
var
  TempStoreBuff: TKDT45DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT45DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT45DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT45DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT45DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT45DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DE_BuildProc);
var
  TempStoreBuff: TKDT45DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT45DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT45DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT45DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT45DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT45DE.Search(const Buff: TKDT45DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT45DE_Node;

var
  NearestNeighbour: PKDT45DE_Node;

  function FindParentNode(const BuffPtr: PKDT45DE_Vec; NodePtr: PKDT45DE_Node): PKDT45DE_Node;
  var
    Next       : PKDT45DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT45DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT45DE_Node; const BuffPtr: PKDT45DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT45DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT45DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT45DE_Vec; const p1, p2: PKDT45DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT45DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT45DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT45DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT45DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT45DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT45DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT45DE_Node(NearestNodes[0]);
    end;
end;

function TKDT45DE.Search(const Buff: TKDT45DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT45DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT45DE.Search(const Buff: TKDT45DE_Vec; var SearchedDistanceMin: Double): PKDT45DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT45DE.Search(const Buff: TKDT45DE_Vec): PKDT45DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT45DE.Search(const inBuff: TKDT45DE_DynamicVecBuffer; var OutBuff: TKDT45DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT45DE_DynamicVecBuffer;
  outBuffPtr : PKDT45DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT45DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT45DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT45DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT45DE.Search(const inBuff: TKDT45DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT45DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT45DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT45DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT45DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT45DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT45DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT45DE_Source));
end;

procedure TKDT45DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT45DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT45DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT45DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT45DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT45DE.PrintNodeTree(const NodePtr: PKDT45DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT45DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT45DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT45DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT45DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT45DE.KDT45DEVec(const s: string): TKDT45DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT45DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT45DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT45DE.KDT45DEVec(const v: TKDT45DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT45DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT45DE.KDT45DEPow(const v: TKDT45DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT45DE.KDT45DEDistance(const v1, v2: TKDT45DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT45DE_Axis - 1 do
      Result := Result + KDT45DEPow(v2[i] - v1[i]);
end;

procedure TKDT45DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT45DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT45DE.Test;
var
  TKDT45DE_Test    : TKDT45DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT45DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT45DE_Test := TKDT45DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT45DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT45DE_Test.TestBuff) - 1 do
    for j := 0 to KDT45DE_Axis - 1 do
        TKDT45DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT45DE_Test.TestBuff), length(TKDT45DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT45DE_Test.BuildKDTreeM(length(TKDT45DE_Test.TestBuff), nil, @TKDT45DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT45DE_Test.BuildKDTreeM(length(TKDT45DE_Test.TestBuff), nil, TKDT45DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT45DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT45DE_Test.TestBuff));
  TKDT45DE_Test.Search(TKDT45DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT45DEDistance(TKDT45DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT45DE_Test.Clear;
  { kMean test }
  TKDT45DE_Test.BuildKDTreeWithCluster(TKDT45DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT45DE_Test.Search(TKDT45DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT45DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT45DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT45DE_Test);
end;


function TKDT46DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT46DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT46DE_Node;
  function SortCompare(const p1, p2: PKDT46DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT46DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT46DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT46DE_SourceBuffer;
  dynBuff  : PKDT46DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT46DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT46DE.GetData(const index: NativeInt): PKDT46DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT46DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT46DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT46DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT46DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT46DE.StoreBuffPtr: PKDT46DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT46DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT46DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT46DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT46DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT46DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT46DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT46DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT46DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT46DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT46DE.BuildKDTreeWithCluster(const inBuff: TKDT46DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT46DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT46DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT46DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT46DE.BuildKDTreeWithCluster(const inBuff: TKDT46DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT46DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DE_BuildCall);
var
  TempStoreBuff: TKDT46DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT46DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT46DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT46DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT46DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT46DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DE_BuildMethod);
var
  TempStoreBuff: TKDT46DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT46DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT46DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT46DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT46DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT46DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DE_BuildProc);
var
  TempStoreBuff: TKDT46DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT46DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT46DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT46DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT46DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT46DE.Search(const Buff: TKDT46DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT46DE_Node;

var
  NearestNeighbour: PKDT46DE_Node;

  function FindParentNode(const BuffPtr: PKDT46DE_Vec; NodePtr: PKDT46DE_Node): PKDT46DE_Node;
  var
    Next       : PKDT46DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT46DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT46DE_Node; const BuffPtr: PKDT46DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT46DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT46DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT46DE_Vec; const p1, p2: PKDT46DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT46DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT46DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT46DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT46DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT46DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT46DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT46DE_Node(NearestNodes[0]);
    end;
end;

function TKDT46DE.Search(const Buff: TKDT46DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT46DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT46DE.Search(const Buff: TKDT46DE_Vec; var SearchedDistanceMin: Double): PKDT46DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT46DE.Search(const Buff: TKDT46DE_Vec): PKDT46DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT46DE.Search(const inBuff: TKDT46DE_DynamicVecBuffer; var OutBuff: TKDT46DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT46DE_DynamicVecBuffer;
  outBuffPtr : PKDT46DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT46DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT46DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT46DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT46DE.Search(const inBuff: TKDT46DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT46DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT46DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT46DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT46DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT46DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT46DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT46DE_Source));
end;

procedure TKDT46DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT46DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT46DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT46DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT46DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT46DE.PrintNodeTree(const NodePtr: PKDT46DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT46DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT46DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT46DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT46DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT46DE.KDT46DEVec(const s: string): TKDT46DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT46DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT46DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT46DE.KDT46DEVec(const v: TKDT46DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT46DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT46DE.KDT46DEPow(const v: TKDT46DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT46DE.KDT46DEDistance(const v1, v2: TKDT46DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT46DE_Axis - 1 do
      Result := Result + KDT46DEPow(v2[i] - v1[i]);
end;

procedure TKDT46DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT46DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT46DE.Test;
var
  TKDT46DE_Test    : TKDT46DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT46DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT46DE_Test := TKDT46DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT46DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT46DE_Test.TestBuff) - 1 do
    for j := 0 to KDT46DE_Axis - 1 do
        TKDT46DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT46DE_Test.TestBuff), length(TKDT46DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT46DE_Test.BuildKDTreeM(length(TKDT46DE_Test.TestBuff), nil, @TKDT46DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT46DE_Test.BuildKDTreeM(length(TKDT46DE_Test.TestBuff), nil, TKDT46DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT46DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT46DE_Test.TestBuff));
  TKDT46DE_Test.Search(TKDT46DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT46DEDistance(TKDT46DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT46DE_Test.Clear;
  { kMean test }
  TKDT46DE_Test.BuildKDTreeWithCluster(TKDT46DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT46DE_Test.Search(TKDT46DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT46DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT46DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT46DE_Test);
end;


function TKDT47DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT47DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT47DE_Node;
  function SortCompare(const p1, p2: PKDT47DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT47DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT47DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT47DE_SourceBuffer;
  dynBuff  : PKDT47DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT47DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT47DE.GetData(const index: NativeInt): PKDT47DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT47DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT47DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT47DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT47DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT47DE.StoreBuffPtr: PKDT47DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT47DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT47DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT47DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT47DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT47DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT47DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT47DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT47DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT47DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT47DE.BuildKDTreeWithCluster(const inBuff: TKDT47DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT47DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT47DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT47DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT47DE.BuildKDTreeWithCluster(const inBuff: TKDT47DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT47DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DE_BuildCall);
var
  TempStoreBuff: TKDT47DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT47DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT47DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT47DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT47DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT47DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DE_BuildMethod);
var
  TempStoreBuff: TKDT47DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT47DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT47DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT47DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT47DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT47DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DE_BuildProc);
var
  TempStoreBuff: TKDT47DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT47DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT47DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT47DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT47DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT47DE.Search(const Buff: TKDT47DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT47DE_Node;

var
  NearestNeighbour: PKDT47DE_Node;

  function FindParentNode(const BuffPtr: PKDT47DE_Vec; NodePtr: PKDT47DE_Node): PKDT47DE_Node;
  var
    Next       : PKDT47DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT47DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT47DE_Node; const BuffPtr: PKDT47DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT47DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT47DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT47DE_Vec; const p1, p2: PKDT47DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT47DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT47DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT47DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT47DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT47DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT47DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT47DE_Node(NearestNodes[0]);
    end;
end;

function TKDT47DE.Search(const Buff: TKDT47DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT47DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT47DE.Search(const Buff: TKDT47DE_Vec; var SearchedDistanceMin: Double): PKDT47DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT47DE.Search(const Buff: TKDT47DE_Vec): PKDT47DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT47DE.Search(const inBuff: TKDT47DE_DynamicVecBuffer; var OutBuff: TKDT47DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT47DE_DynamicVecBuffer;
  outBuffPtr : PKDT47DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT47DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT47DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT47DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT47DE.Search(const inBuff: TKDT47DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT47DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT47DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT47DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT47DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT47DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT47DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT47DE_Source));
end;

procedure TKDT47DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT47DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT47DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT47DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT47DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT47DE.PrintNodeTree(const NodePtr: PKDT47DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT47DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT47DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT47DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT47DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT47DE.KDT47DEVec(const s: string): TKDT47DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT47DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT47DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT47DE.KDT47DEVec(const v: TKDT47DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT47DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT47DE.KDT47DEPow(const v: TKDT47DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT47DE.KDT47DEDistance(const v1, v2: TKDT47DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT47DE_Axis - 1 do
      Result := Result + KDT47DEPow(v2[i] - v1[i]);
end;

procedure TKDT47DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT47DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT47DE.Test;
var
  TKDT47DE_Test    : TKDT47DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT47DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT47DE_Test := TKDT47DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT47DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT47DE_Test.TestBuff) - 1 do
    for j := 0 to KDT47DE_Axis - 1 do
        TKDT47DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT47DE_Test.TestBuff), length(TKDT47DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT47DE_Test.BuildKDTreeM(length(TKDT47DE_Test.TestBuff), nil, @TKDT47DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT47DE_Test.BuildKDTreeM(length(TKDT47DE_Test.TestBuff), nil, TKDT47DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT47DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT47DE_Test.TestBuff));
  TKDT47DE_Test.Search(TKDT47DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT47DEDistance(TKDT47DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT47DE_Test.Clear;
  { kMean test }
  TKDT47DE_Test.BuildKDTreeWithCluster(TKDT47DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT47DE_Test.Search(TKDT47DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT47DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT47DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT47DE_Test);
end;


function TKDT48DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DE_Node;
  function SortCompare(const p1, p2: PKDT48DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT48DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT48DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT48DE_SourceBuffer;
  dynBuff  : PKDT48DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT48DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT48DE.GetData(const index: NativeInt): PKDT48DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT48DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT48DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT48DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT48DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT48DE.StoreBuffPtr: PKDT48DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT48DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT48DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT48DE.BuildKDTreeWithCluster(const inBuff: TKDT48DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT48DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT48DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT48DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT48DE.BuildKDTreeWithCluster(const inBuff: TKDT48DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DE_BuildCall);
var
  TempStoreBuff: TKDT48DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT48DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DE_BuildMethod);
var
  TempStoreBuff: TKDT48DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT48DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DE_BuildProc);
var
  TempStoreBuff: TKDT48DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT48DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT48DE.Search(const Buff: TKDT48DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DE_Node;

var
  NearestNeighbour: PKDT48DE_Node;

  function FindParentNode(const BuffPtr: PKDT48DE_Vec; NodePtr: PKDT48DE_Node): PKDT48DE_Node;
  var
    Next       : PKDT48DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT48DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT48DE_Node; const BuffPtr: PKDT48DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT48DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT48DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT48DE_Vec; const p1, p2: PKDT48DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT48DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT48DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT48DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT48DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT48DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT48DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT48DE_Node(NearestNodes[0]);
    end;
end;

function TKDT48DE.Search(const Buff: TKDT48DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT48DE.Search(const Buff: TKDT48DE_Vec; var SearchedDistanceMin: Double): PKDT48DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT48DE.Search(const Buff: TKDT48DE_Vec): PKDT48DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT48DE.Search(const inBuff: TKDT48DE_DynamicVecBuffer; var OutBuff: TKDT48DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT48DE_DynamicVecBuffer;
  outBuffPtr : PKDT48DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT48DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT48DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DE.Search(const inBuff: TKDT48DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT48DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT48DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT48DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT48DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT48DE_Source));
end;

procedure TKDT48DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT48DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT48DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT48DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DE.PrintNodeTree(const NodePtr: PKDT48DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT48DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT48DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT48DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT48DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT48DE.KDT48DEVec(const s: string): TKDT48DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT48DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT48DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT48DE.KDT48DEVec(const v: TKDT48DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT48DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT48DE.KDT48DEPow(const v: TKDT48DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT48DE.KDT48DEDistance(const v1, v2: TKDT48DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT48DE_Axis - 1 do
      Result := Result + KDT48DEPow(v2[i] - v1[i]);
end;

procedure TKDT48DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT48DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT48DE.Test;
var
  TKDT48DE_Test    : TKDT48DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT48DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT48DE_Test := TKDT48DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT48DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT48DE_Test.TestBuff) - 1 do
    for j := 0 to KDT48DE_Axis - 1 do
        TKDT48DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT48DE_Test.TestBuff), length(TKDT48DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT48DE_Test.BuildKDTreeM(length(TKDT48DE_Test.TestBuff), nil, @TKDT48DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT48DE_Test.BuildKDTreeM(length(TKDT48DE_Test.TestBuff), nil, TKDT48DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT48DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT48DE_Test.TestBuff));
  TKDT48DE_Test.Search(TKDT48DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT48DEDistance(TKDT48DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT48DE_Test.Clear;
  { kMean test }
  TKDT48DE_Test.BuildKDTreeWithCluster(TKDT48DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT48DE_Test.Search(TKDT48DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT48DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT48DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT48DE_Test);
end;


function TKDT49DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT49DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT49DE_Node;
  function SortCompare(const p1, p2: PKDT49DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT49DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT49DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT49DE_SourceBuffer;
  dynBuff  : PKDT49DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT49DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT49DE.GetData(const index: NativeInt): PKDT49DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT49DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT49DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT49DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT49DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT49DE.StoreBuffPtr: PKDT49DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT49DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT49DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT49DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT49DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT49DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT49DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT49DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT49DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT49DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT49DE.BuildKDTreeWithCluster(const inBuff: TKDT49DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT49DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT49DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT49DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT49DE.BuildKDTreeWithCluster(const inBuff: TKDT49DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT49DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DE_BuildCall);
var
  TempStoreBuff: TKDT49DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT49DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT49DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT49DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT49DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT49DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DE_BuildMethod);
var
  TempStoreBuff: TKDT49DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT49DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT49DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT49DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT49DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT49DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DE_BuildProc);
var
  TempStoreBuff: TKDT49DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT49DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT49DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT49DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT49DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT49DE.Search(const Buff: TKDT49DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT49DE_Node;

var
  NearestNeighbour: PKDT49DE_Node;

  function FindParentNode(const BuffPtr: PKDT49DE_Vec; NodePtr: PKDT49DE_Node): PKDT49DE_Node;
  var
    Next       : PKDT49DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT49DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT49DE_Node; const BuffPtr: PKDT49DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT49DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT49DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT49DE_Vec; const p1, p2: PKDT49DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT49DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT49DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT49DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT49DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT49DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT49DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT49DE_Node(NearestNodes[0]);
    end;
end;

function TKDT49DE.Search(const Buff: TKDT49DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT49DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT49DE.Search(const Buff: TKDT49DE_Vec; var SearchedDistanceMin: Double): PKDT49DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT49DE.Search(const Buff: TKDT49DE_Vec): PKDT49DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT49DE.Search(const inBuff: TKDT49DE_DynamicVecBuffer; var OutBuff: TKDT49DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT49DE_DynamicVecBuffer;
  outBuffPtr : PKDT49DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT49DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT49DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT49DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT49DE.Search(const inBuff: TKDT49DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT49DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT49DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT49DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT49DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT49DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT49DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT49DE_Source));
end;

procedure TKDT49DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT49DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT49DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT49DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT49DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT49DE.PrintNodeTree(const NodePtr: PKDT49DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT49DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT49DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT49DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT49DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT49DE.KDT49DEVec(const s: string): TKDT49DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT49DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT49DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT49DE.KDT49DEVec(const v: TKDT49DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT49DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT49DE.KDT49DEPow(const v: TKDT49DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT49DE.KDT49DEDistance(const v1, v2: TKDT49DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT49DE_Axis - 1 do
      Result := Result + KDT49DEPow(v2[i] - v1[i]);
end;

procedure TKDT49DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT49DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT49DE.Test;
var
  TKDT49DE_Test    : TKDT49DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT49DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT49DE_Test := TKDT49DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT49DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT49DE_Test.TestBuff) - 1 do
    for j := 0 to KDT49DE_Axis - 1 do
        TKDT49DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT49DE_Test.TestBuff), length(TKDT49DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT49DE_Test.BuildKDTreeM(length(TKDT49DE_Test.TestBuff), nil, @TKDT49DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT49DE_Test.BuildKDTreeM(length(TKDT49DE_Test.TestBuff), nil, TKDT49DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT49DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT49DE_Test.TestBuff));
  TKDT49DE_Test.Search(TKDT49DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT49DEDistance(TKDT49DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT49DE_Test.Clear;
  { kMean test }
  TKDT49DE_Test.BuildKDTreeWithCluster(TKDT49DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT49DE_Test.Search(TKDT49DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT49DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT49DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT49DE_Test);
end;


function TKDT50DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT50DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT50DE_Node;
  function SortCompare(const p1, p2: PKDT50DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT50DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT50DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT50DE_SourceBuffer;
  dynBuff  : PKDT50DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT50DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT50DE.GetData(const index: NativeInt): PKDT50DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT50DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT50DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT50DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT50DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT50DE.StoreBuffPtr: PKDT50DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT50DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT50DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT50DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT50DE.BuildKDTreeWithCluster(const inBuff: TKDT50DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT50DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT50DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT50DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT50DE.BuildKDTreeWithCluster(const inBuff: TKDT50DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT50DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DE_BuildCall);
var
  TempStoreBuff: TKDT50DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT50DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT50DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT50DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT50DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DE_BuildMethod);
var
  TempStoreBuff: TKDT50DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT50DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT50DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT50DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT50DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DE_BuildProc);
var
  TempStoreBuff: TKDT50DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT50DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT50DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT50DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT50DE.Search(const Buff: TKDT50DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT50DE_Node;

var
  NearestNeighbour: PKDT50DE_Node;

  function FindParentNode(const BuffPtr: PKDT50DE_Vec; NodePtr: PKDT50DE_Node): PKDT50DE_Node;
  var
    Next       : PKDT50DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT50DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT50DE_Node; const BuffPtr: PKDT50DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT50DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT50DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT50DE_Vec; const p1, p2: PKDT50DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT50DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT50DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT50DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT50DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT50DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT50DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT50DE_Node(NearestNodes[0]);
    end;
end;

function TKDT50DE.Search(const Buff: TKDT50DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT50DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT50DE.Search(const Buff: TKDT50DE_Vec; var SearchedDistanceMin: Double): PKDT50DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT50DE.Search(const Buff: TKDT50DE_Vec): PKDT50DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT50DE.Search(const inBuff: TKDT50DE_DynamicVecBuffer; var OutBuff: TKDT50DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT50DE_DynamicVecBuffer;
  outBuffPtr : PKDT50DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT50DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT50DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT50DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT50DE.Search(const inBuff: TKDT50DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT50DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT50DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT50DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT50DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT50DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT50DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT50DE_Source));
end;

procedure TKDT50DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT50DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT50DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT50DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT50DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT50DE.PrintNodeTree(const NodePtr: PKDT50DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT50DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT50DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT50DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT50DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT50DE.KDT50DEVec(const s: string): TKDT50DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT50DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT50DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT50DE.KDT50DEVec(const v: TKDT50DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT50DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT50DE.KDT50DEPow(const v: TKDT50DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT50DE.KDT50DEDistance(const v1, v2: TKDT50DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT50DE_Axis - 1 do
      Result := Result + KDT50DEPow(v2[i] - v1[i]);
end;

procedure TKDT50DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT50DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT50DE.Test;
var
  TKDT50DE_Test    : TKDT50DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT50DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT50DE_Test := TKDT50DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT50DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT50DE_Test.TestBuff) - 1 do
    for j := 0 to KDT50DE_Axis - 1 do
        TKDT50DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT50DE_Test.TestBuff), length(TKDT50DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT50DE_Test.BuildKDTreeM(length(TKDT50DE_Test.TestBuff), nil, @TKDT50DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT50DE_Test.BuildKDTreeM(length(TKDT50DE_Test.TestBuff), nil, TKDT50DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT50DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT50DE_Test.TestBuff));
  TKDT50DE_Test.Search(TKDT50DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT50DEDistance(TKDT50DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT50DE_Test.Clear;
  { kMean test }
  TKDT50DE_Test.BuildKDTreeWithCluster(TKDT50DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT50DE_Test.Search(TKDT50DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT50DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT50DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT50DE_Test);
end;


function TKDT51DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT51DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT51DE_Node;
  function SortCompare(const p1, p2: PKDT51DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT51DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT51DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT51DE_SourceBuffer;
  dynBuff  : PKDT51DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT51DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT51DE.GetData(const index: NativeInt): PKDT51DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT51DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT51DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT51DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT51DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT51DE.StoreBuffPtr: PKDT51DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT51DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT51DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT51DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT51DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT51DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT51DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT51DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT51DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT51DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT51DE.BuildKDTreeWithCluster(const inBuff: TKDT51DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT51DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT51DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT51DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT51DE.BuildKDTreeWithCluster(const inBuff: TKDT51DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT51DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DE_BuildCall);
var
  TempStoreBuff: TKDT51DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT51DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT51DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT51DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT51DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT51DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DE_BuildMethod);
var
  TempStoreBuff: TKDT51DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT51DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT51DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT51DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT51DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT51DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DE_BuildProc);
var
  TempStoreBuff: TKDT51DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT51DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT51DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT51DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT51DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT51DE.Search(const Buff: TKDT51DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT51DE_Node;

var
  NearestNeighbour: PKDT51DE_Node;

  function FindParentNode(const BuffPtr: PKDT51DE_Vec; NodePtr: PKDT51DE_Node): PKDT51DE_Node;
  var
    Next       : PKDT51DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT51DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT51DE_Node; const BuffPtr: PKDT51DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT51DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT51DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT51DE_Vec; const p1, p2: PKDT51DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT51DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT51DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT51DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT51DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT51DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT51DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT51DE_Node(NearestNodes[0]);
    end;
end;

function TKDT51DE.Search(const Buff: TKDT51DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT51DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT51DE.Search(const Buff: TKDT51DE_Vec; var SearchedDistanceMin: Double): PKDT51DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT51DE.Search(const Buff: TKDT51DE_Vec): PKDT51DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT51DE.Search(const inBuff: TKDT51DE_DynamicVecBuffer; var OutBuff: TKDT51DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT51DE_DynamicVecBuffer;
  outBuffPtr : PKDT51DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT51DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT51DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT51DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT51DE.Search(const inBuff: TKDT51DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT51DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT51DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT51DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT51DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT51DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT51DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT51DE_Source));
end;

procedure TKDT51DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT51DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT51DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT51DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT51DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT51DE.PrintNodeTree(const NodePtr: PKDT51DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT51DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT51DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT51DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT51DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT51DE.KDT51DEVec(const s: string): TKDT51DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT51DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT51DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT51DE.KDT51DEVec(const v: TKDT51DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT51DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT51DE.KDT51DEPow(const v: TKDT51DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT51DE.KDT51DEDistance(const v1, v2: TKDT51DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT51DE_Axis - 1 do
      Result := Result + KDT51DEPow(v2[i] - v1[i]);
end;

procedure TKDT51DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT51DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT51DE.Test;
var
  TKDT51DE_Test    : TKDT51DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT51DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT51DE_Test := TKDT51DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT51DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT51DE_Test.TestBuff) - 1 do
    for j := 0 to KDT51DE_Axis - 1 do
        TKDT51DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT51DE_Test.TestBuff), length(TKDT51DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT51DE_Test.BuildKDTreeM(length(TKDT51DE_Test.TestBuff), nil, @TKDT51DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT51DE_Test.BuildKDTreeM(length(TKDT51DE_Test.TestBuff), nil, TKDT51DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT51DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT51DE_Test.TestBuff));
  TKDT51DE_Test.Search(TKDT51DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT51DEDistance(TKDT51DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT51DE_Test.Clear;
  { kMean test }
  TKDT51DE_Test.BuildKDTreeWithCluster(TKDT51DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT51DE_Test.Search(TKDT51DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT51DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT51DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT51DE_Test);
end;


function TKDT52DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT52DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT52DE_Node;
  function SortCompare(const p1, p2: PKDT52DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT52DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT52DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT52DE_SourceBuffer;
  dynBuff  : PKDT52DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT52DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT52DE.GetData(const index: NativeInt): PKDT52DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT52DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT52DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT52DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT52DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT52DE.StoreBuffPtr: PKDT52DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT52DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT52DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT52DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT52DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT52DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT52DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT52DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT52DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT52DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT52DE.BuildKDTreeWithCluster(const inBuff: TKDT52DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT52DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT52DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT52DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT52DE.BuildKDTreeWithCluster(const inBuff: TKDT52DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT52DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DE_BuildCall);
var
  TempStoreBuff: TKDT52DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT52DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT52DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT52DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DE_BuildMethod);
var
  TempStoreBuff: TKDT52DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT52DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT52DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT52DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DE_BuildProc);
var
  TempStoreBuff: TKDT52DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT52DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT52DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT52DE.Search(const Buff: TKDT52DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT52DE_Node;

var
  NearestNeighbour: PKDT52DE_Node;

  function FindParentNode(const BuffPtr: PKDT52DE_Vec; NodePtr: PKDT52DE_Node): PKDT52DE_Node;
  var
    Next       : PKDT52DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT52DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT52DE_Node; const BuffPtr: PKDT52DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT52DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT52DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT52DE_Vec; const p1, p2: PKDT52DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT52DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT52DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT52DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT52DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT52DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT52DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT52DE_Node(NearestNodes[0]);
    end;
end;

function TKDT52DE.Search(const Buff: TKDT52DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT52DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT52DE.Search(const Buff: TKDT52DE_Vec; var SearchedDistanceMin: Double): PKDT52DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT52DE.Search(const Buff: TKDT52DE_Vec): PKDT52DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT52DE.Search(const inBuff: TKDT52DE_DynamicVecBuffer; var OutBuff: TKDT52DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT52DE_DynamicVecBuffer;
  outBuffPtr : PKDT52DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT52DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT52DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT52DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT52DE.Search(const inBuff: TKDT52DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT52DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT52DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT52DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT52DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT52DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT52DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT52DE_Source));
end;

procedure TKDT52DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT52DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT52DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT52DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT52DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT52DE.PrintNodeTree(const NodePtr: PKDT52DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT52DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT52DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT52DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT52DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT52DE.KDT52DEVec(const s: string): TKDT52DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT52DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT52DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT52DE.KDT52DEVec(const v: TKDT52DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT52DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT52DE.KDT52DEPow(const v: TKDT52DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT52DE.KDT52DEDistance(const v1, v2: TKDT52DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT52DE_Axis - 1 do
      Result := Result + KDT52DEPow(v2[i] - v1[i]);
end;

procedure TKDT52DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT52DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT52DE.Test;
var
  TKDT52DE_Test    : TKDT52DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT52DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT52DE_Test := TKDT52DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT52DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT52DE_Test.TestBuff) - 1 do
    for j := 0 to KDT52DE_Axis - 1 do
        TKDT52DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT52DE_Test.TestBuff), length(TKDT52DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT52DE_Test.BuildKDTreeM(length(TKDT52DE_Test.TestBuff), nil, @TKDT52DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT52DE_Test.BuildKDTreeM(length(TKDT52DE_Test.TestBuff), nil, TKDT52DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT52DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT52DE_Test.TestBuff));
  TKDT52DE_Test.Search(TKDT52DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT52DEDistance(TKDT52DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT52DE_Test.Clear;
  { kMean test }
  TKDT52DE_Test.BuildKDTreeWithCluster(TKDT52DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT52DE_Test.Search(TKDT52DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT52DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT52DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT52DE_Test);
end;


function TKDT53DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT53DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT53DE_Node;
  function SortCompare(const p1, p2: PKDT53DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT53DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT53DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT53DE_SourceBuffer;
  dynBuff  : PKDT53DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT53DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT53DE.GetData(const index: NativeInt): PKDT53DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT53DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT53DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT53DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT53DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT53DE.StoreBuffPtr: PKDT53DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT53DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT53DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT53DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT53DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT53DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT53DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT53DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT53DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT53DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT53DE.BuildKDTreeWithCluster(const inBuff: TKDT53DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT53DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT53DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT53DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT53DE.BuildKDTreeWithCluster(const inBuff: TKDT53DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT53DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DE_BuildCall);
var
  TempStoreBuff: TKDT53DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT53DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT53DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT53DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT53DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT53DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DE_BuildMethod);
var
  TempStoreBuff: TKDT53DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT53DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT53DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT53DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT53DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT53DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DE_BuildProc);
var
  TempStoreBuff: TKDT53DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT53DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT53DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT53DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT53DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT53DE.Search(const Buff: TKDT53DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT53DE_Node;

var
  NearestNeighbour: PKDT53DE_Node;

  function FindParentNode(const BuffPtr: PKDT53DE_Vec; NodePtr: PKDT53DE_Node): PKDT53DE_Node;
  var
    Next       : PKDT53DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT53DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT53DE_Node; const BuffPtr: PKDT53DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT53DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT53DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT53DE_Vec; const p1, p2: PKDT53DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT53DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT53DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT53DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT53DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT53DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT53DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT53DE_Node(NearestNodes[0]);
    end;
end;

function TKDT53DE.Search(const Buff: TKDT53DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT53DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT53DE.Search(const Buff: TKDT53DE_Vec; var SearchedDistanceMin: Double): PKDT53DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT53DE.Search(const Buff: TKDT53DE_Vec): PKDT53DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT53DE.Search(const inBuff: TKDT53DE_DynamicVecBuffer; var OutBuff: TKDT53DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT53DE_DynamicVecBuffer;
  outBuffPtr : PKDT53DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT53DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT53DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT53DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT53DE.Search(const inBuff: TKDT53DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT53DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT53DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT53DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT53DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT53DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT53DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT53DE_Source));
end;

procedure TKDT53DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT53DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT53DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT53DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT53DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT53DE.PrintNodeTree(const NodePtr: PKDT53DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT53DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT53DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT53DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT53DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT53DE.KDT53DEVec(const s: string): TKDT53DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT53DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT53DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT53DE.KDT53DEVec(const v: TKDT53DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT53DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT53DE.KDT53DEPow(const v: TKDT53DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT53DE.KDT53DEDistance(const v1, v2: TKDT53DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT53DE_Axis - 1 do
      Result := Result + KDT53DEPow(v2[i] - v1[i]);
end;

procedure TKDT53DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT53DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT53DE.Test;
var
  TKDT53DE_Test    : TKDT53DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT53DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT53DE_Test := TKDT53DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT53DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT53DE_Test.TestBuff) - 1 do
    for j := 0 to KDT53DE_Axis - 1 do
        TKDT53DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT53DE_Test.TestBuff), length(TKDT53DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT53DE_Test.BuildKDTreeM(length(TKDT53DE_Test.TestBuff), nil, @TKDT53DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT53DE_Test.BuildKDTreeM(length(TKDT53DE_Test.TestBuff), nil, TKDT53DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT53DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT53DE_Test.TestBuff));
  TKDT53DE_Test.Search(TKDT53DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT53DEDistance(TKDT53DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT53DE_Test.Clear;
  { kMean test }
  TKDT53DE_Test.BuildKDTreeWithCluster(TKDT53DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT53DE_Test.Search(TKDT53DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT53DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT53DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT53DE_Test);
end;


function TKDT54DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT54DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT54DE_Node;
  function SortCompare(const p1, p2: PKDT54DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT54DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT54DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT54DE_SourceBuffer;
  dynBuff  : PKDT54DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT54DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT54DE.GetData(const index: NativeInt): PKDT54DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT54DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT54DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT54DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT54DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT54DE.StoreBuffPtr: PKDT54DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT54DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT54DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT54DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT54DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT54DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT54DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT54DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT54DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT54DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT54DE.BuildKDTreeWithCluster(const inBuff: TKDT54DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT54DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT54DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT54DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT54DE.BuildKDTreeWithCluster(const inBuff: TKDT54DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT54DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DE_BuildCall);
var
  TempStoreBuff: TKDT54DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT54DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT54DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT54DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT54DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT54DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DE_BuildMethod);
var
  TempStoreBuff: TKDT54DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT54DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT54DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT54DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT54DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT54DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DE_BuildProc);
var
  TempStoreBuff: TKDT54DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT54DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT54DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT54DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT54DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT54DE.Search(const Buff: TKDT54DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT54DE_Node;

var
  NearestNeighbour: PKDT54DE_Node;

  function FindParentNode(const BuffPtr: PKDT54DE_Vec; NodePtr: PKDT54DE_Node): PKDT54DE_Node;
  var
    Next       : PKDT54DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT54DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT54DE_Node; const BuffPtr: PKDT54DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT54DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT54DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT54DE_Vec; const p1, p2: PKDT54DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT54DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT54DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT54DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT54DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT54DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT54DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT54DE_Node(NearestNodes[0]);
    end;
end;

function TKDT54DE.Search(const Buff: TKDT54DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT54DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT54DE.Search(const Buff: TKDT54DE_Vec; var SearchedDistanceMin: Double): PKDT54DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT54DE.Search(const Buff: TKDT54DE_Vec): PKDT54DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT54DE.Search(const inBuff: TKDT54DE_DynamicVecBuffer; var OutBuff: TKDT54DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT54DE_DynamicVecBuffer;
  outBuffPtr : PKDT54DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT54DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT54DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT54DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT54DE.Search(const inBuff: TKDT54DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT54DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT54DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT54DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT54DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT54DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT54DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT54DE_Source));
end;

procedure TKDT54DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT54DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT54DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT54DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT54DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT54DE.PrintNodeTree(const NodePtr: PKDT54DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT54DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT54DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT54DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT54DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT54DE.KDT54DEVec(const s: string): TKDT54DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT54DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT54DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT54DE.KDT54DEVec(const v: TKDT54DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT54DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT54DE.KDT54DEPow(const v: TKDT54DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT54DE.KDT54DEDistance(const v1, v2: TKDT54DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT54DE_Axis - 1 do
      Result := Result + KDT54DEPow(v2[i] - v1[i]);
end;

procedure TKDT54DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT54DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT54DE.Test;
var
  TKDT54DE_Test    : TKDT54DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT54DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT54DE_Test := TKDT54DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT54DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT54DE_Test.TestBuff) - 1 do
    for j := 0 to KDT54DE_Axis - 1 do
        TKDT54DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT54DE_Test.TestBuff), length(TKDT54DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT54DE_Test.BuildKDTreeM(length(TKDT54DE_Test.TestBuff), nil, @TKDT54DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT54DE_Test.BuildKDTreeM(length(TKDT54DE_Test.TestBuff), nil, TKDT54DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT54DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT54DE_Test.TestBuff));
  TKDT54DE_Test.Search(TKDT54DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT54DEDistance(TKDT54DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT54DE_Test.Clear;
  { kMean test }
  TKDT54DE_Test.BuildKDTreeWithCluster(TKDT54DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT54DE_Test.Search(TKDT54DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT54DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT54DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT54DE_Test);
end;


function TKDT55DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT55DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT55DE_Node;
  function SortCompare(const p1, p2: PKDT55DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT55DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT55DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT55DE_SourceBuffer;
  dynBuff  : PKDT55DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT55DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT55DE.GetData(const index: NativeInt): PKDT55DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT55DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT55DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT55DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT55DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT55DE.StoreBuffPtr: PKDT55DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT55DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT55DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT55DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT55DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT55DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT55DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT55DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT55DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT55DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT55DE.BuildKDTreeWithCluster(const inBuff: TKDT55DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT55DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT55DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT55DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT55DE.BuildKDTreeWithCluster(const inBuff: TKDT55DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT55DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DE_BuildCall);
var
  TempStoreBuff: TKDT55DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT55DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT55DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT55DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT55DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT55DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DE_BuildMethod);
var
  TempStoreBuff: TKDT55DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT55DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT55DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT55DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT55DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT55DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DE_BuildProc);
var
  TempStoreBuff: TKDT55DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT55DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT55DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT55DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT55DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT55DE.Search(const Buff: TKDT55DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT55DE_Node;

var
  NearestNeighbour: PKDT55DE_Node;

  function FindParentNode(const BuffPtr: PKDT55DE_Vec; NodePtr: PKDT55DE_Node): PKDT55DE_Node;
  var
    Next       : PKDT55DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT55DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT55DE_Node; const BuffPtr: PKDT55DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT55DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT55DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT55DE_Vec; const p1, p2: PKDT55DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT55DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT55DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT55DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT55DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT55DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT55DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT55DE_Node(NearestNodes[0]);
    end;
end;

function TKDT55DE.Search(const Buff: TKDT55DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT55DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT55DE.Search(const Buff: TKDT55DE_Vec; var SearchedDistanceMin: Double): PKDT55DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT55DE.Search(const Buff: TKDT55DE_Vec): PKDT55DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT55DE.Search(const inBuff: TKDT55DE_DynamicVecBuffer; var OutBuff: TKDT55DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT55DE_DynamicVecBuffer;
  outBuffPtr : PKDT55DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT55DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT55DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT55DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT55DE.Search(const inBuff: TKDT55DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT55DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT55DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT55DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT55DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT55DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT55DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT55DE_Source));
end;

procedure TKDT55DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT55DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT55DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT55DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT55DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT55DE.PrintNodeTree(const NodePtr: PKDT55DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT55DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT55DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT55DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT55DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT55DE.KDT55DEVec(const s: string): TKDT55DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT55DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT55DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT55DE.KDT55DEVec(const v: TKDT55DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT55DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT55DE.KDT55DEPow(const v: TKDT55DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT55DE.KDT55DEDistance(const v1, v2: TKDT55DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT55DE_Axis - 1 do
      Result := Result + KDT55DEPow(v2[i] - v1[i]);
end;

procedure TKDT55DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT55DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT55DE.Test;
var
  TKDT55DE_Test    : TKDT55DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT55DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT55DE_Test := TKDT55DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT55DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT55DE_Test.TestBuff) - 1 do
    for j := 0 to KDT55DE_Axis - 1 do
        TKDT55DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT55DE_Test.TestBuff), length(TKDT55DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT55DE_Test.BuildKDTreeM(length(TKDT55DE_Test.TestBuff), nil, @TKDT55DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT55DE_Test.BuildKDTreeM(length(TKDT55DE_Test.TestBuff), nil, TKDT55DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT55DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT55DE_Test.TestBuff));
  TKDT55DE_Test.Search(TKDT55DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT55DEDistance(TKDT55DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT55DE_Test.Clear;
  { kMean test }
  TKDT55DE_Test.BuildKDTreeWithCluster(TKDT55DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT55DE_Test.Search(TKDT55DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT55DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT55DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT55DE_Test);
end;


function TKDT56DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT56DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT56DE_Node;
  function SortCompare(const p1, p2: PKDT56DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT56DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT56DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT56DE_SourceBuffer;
  dynBuff  : PKDT56DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT56DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT56DE.GetData(const index: NativeInt): PKDT56DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT56DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT56DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT56DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT56DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT56DE.StoreBuffPtr: PKDT56DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT56DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT56DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT56DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT56DE.BuildKDTreeWithCluster(const inBuff: TKDT56DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT56DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT56DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT56DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT56DE.BuildKDTreeWithCluster(const inBuff: TKDT56DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT56DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DE_BuildCall);
var
  TempStoreBuff: TKDT56DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT56DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT56DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT56DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT56DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DE_BuildMethod);
var
  TempStoreBuff: TKDT56DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT56DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT56DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT56DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT56DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DE_BuildProc);
var
  TempStoreBuff: TKDT56DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT56DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT56DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT56DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT56DE.Search(const Buff: TKDT56DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT56DE_Node;

var
  NearestNeighbour: PKDT56DE_Node;

  function FindParentNode(const BuffPtr: PKDT56DE_Vec; NodePtr: PKDT56DE_Node): PKDT56DE_Node;
  var
    Next       : PKDT56DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT56DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT56DE_Node; const BuffPtr: PKDT56DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT56DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT56DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT56DE_Vec; const p1, p2: PKDT56DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT56DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT56DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT56DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT56DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT56DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT56DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT56DE_Node(NearestNodes[0]);
    end;
end;

function TKDT56DE.Search(const Buff: TKDT56DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT56DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT56DE.Search(const Buff: TKDT56DE_Vec; var SearchedDistanceMin: Double): PKDT56DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT56DE.Search(const Buff: TKDT56DE_Vec): PKDT56DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT56DE.Search(const inBuff: TKDT56DE_DynamicVecBuffer; var OutBuff: TKDT56DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT56DE_DynamicVecBuffer;
  outBuffPtr : PKDT56DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT56DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT56DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT56DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT56DE.Search(const inBuff: TKDT56DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT56DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT56DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT56DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT56DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT56DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT56DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT56DE_Source));
end;

procedure TKDT56DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT56DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT56DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT56DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT56DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT56DE.PrintNodeTree(const NodePtr: PKDT56DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT56DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT56DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT56DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT56DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT56DE.KDT56DEVec(const s: string): TKDT56DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT56DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT56DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT56DE.KDT56DEVec(const v: TKDT56DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT56DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT56DE.KDT56DEPow(const v: TKDT56DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT56DE.KDT56DEDistance(const v1, v2: TKDT56DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT56DE_Axis - 1 do
      Result := Result + KDT56DEPow(v2[i] - v1[i]);
end;

procedure TKDT56DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT56DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT56DE.Test;
var
  TKDT56DE_Test    : TKDT56DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT56DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT56DE_Test := TKDT56DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT56DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT56DE_Test.TestBuff) - 1 do
    for j := 0 to KDT56DE_Axis - 1 do
        TKDT56DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT56DE_Test.TestBuff), length(TKDT56DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT56DE_Test.BuildKDTreeM(length(TKDT56DE_Test.TestBuff), nil, @TKDT56DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT56DE_Test.BuildKDTreeM(length(TKDT56DE_Test.TestBuff), nil, TKDT56DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT56DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT56DE_Test.TestBuff));
  TKDT56DE_Test.Search(TKDT56DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT56DEDistance(TKDT56DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT56DE_Test.Clear;
  { kMean test }
  TKDT56DE_Test.BuildKDTreeWithCluster(TKDT56DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT56DE_Test.Search(TKDT56DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT56DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT56DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT56DE_Test);
end;


function TKDT57DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT57DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT57DE_Node;
  function SortCompare(const p1, p2: PKDT57DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT57DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT57DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT57DE_SourceBuffer;
  dynBuff  : PKDT57DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT57DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT57DE.GetData(const index: NativeInt): PKDT57DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT57DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT57DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT57DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT57DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT57DE.StoreBuffPtr: PKDT57DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT57DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT57DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT57DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT57DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT57DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT57DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT57DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT57DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT57DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT57DE.BuildKDTreeWithCluster(const inBuff: TKDT57DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT57DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT57DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT57DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT57DE.BuildKDTreeWithCluster(const inBuff: TKDT57DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT57DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DE_BuildCall);
var
  TempStoreBuff: TKDT57DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT57DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT57DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT57DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT57DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT57DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DE_BuildMethod);
var
  TempStoreBuff: TKDT57DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT57DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT57DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT57DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT57DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT57DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DE_BuildProc);
var
  TempStoreBuff: TKDT57DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT57DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT57DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT57DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT57DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT57DE.Search(const Buff: TKDT57DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT57DE_Node;

var
  NearestNeighbour: PKDT57DE_Node;

  function FindParentNode(const BuffPtr: PKDT57DE_Vec; NodePtr: PKDT57DE_Node): PKDT57DE_Node;
  var
    Next       : PKDT57DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT57DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT57DE_Node; const BuffPtr: PKDT57DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT57DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT57DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT57DE_Vec; const p1, p2: PKDT57DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT57DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT57DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT57DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT57DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT57DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT57DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT57DE_Node(NearestNodes[0]);
    end;
end;

function TKDT57DE.Search(const Buff: TKDT57DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT57DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT57DE.Search(const Buff: TKDT57DE_Vec; var SearchedDistanceMin: Double): PKDT57DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT57DE.Search(const Buff: TKDT57DE_Vec): PKDT57DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT57DE.Search(const inBuff: TKDT57DE_DynamicVecBuffer; var OutBuff: TKDT57DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT57DE_DynamicVecBuffer;
  outBuffPtr : PKDT57DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT57DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT57DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT57DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT57DE.Search(const inBuff: TKDT57DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT57DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT57DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT57DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT57DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT57DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT57DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT57DE_Source));
end;

procedure TKDT57DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT57DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT57DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT57DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT57DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT57DE.PrintNodeTree(const NodePtr: PKDT57DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT57DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT57DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT57DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT57DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT57DE.KDT57DEVec(const s: string): TKDT57DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT57DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT57DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT57DE.KDT57DEVec(const v: TKDT57DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT57DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT57DE.KDT57DEPow(const v: TKDT57DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT57DE.KDT57DEDistance(const v1, v2: TKDT57DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT57DE_Axis - 1 do
      Result := Result + KDT57DEPow(v2[i] - v1[i]);
end;

procedure TKDT57DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT57DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT57DE.Test;
var
  TKDT57DE_Test    : TKDT57DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT57DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT57DE_Test := TKDT57DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT57DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT57DE_Test.TestBuff) - 1 do
    for j := 0 to KDT57DE_Axis - 1 do
        TKDT57DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT57DE_Test.TestBuff), length(TKDT57DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT57DE_Test.BuildKDTreeM(length(TKDT57DE_Test.TestBuff), nil, @TKDT57DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT57DE_Test.BuildKDTreeM(length(TKDT57DE_Test.TestBuff), nil, TKDT57DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT57DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT57DE_Test.TestBuff));
  TKDT57DE_Test.Search(TKDT57DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT57DEDistance(TKDT57DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT57DE_Test.Clear;
  { kMean test }
  TKDT57DE_Test.BuildKDTreeWithCluster(TKDT57DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT57DE_Test.Search(TKDT57DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT57DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT57DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT57DE_Test);
end;


function TKDT58DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT58DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT58DE_Node;
  function SortCompare(const p1, p2: PKDT58DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT58DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT58DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT58DE_SourceBuffer;
  dynBuff  : PKDT58DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT58DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT58DE.GetData(const index: NativeInt): PKDT58DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT58DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT58DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT58DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT58DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT58DE.StoreBuffPtr: PKDT58DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT58DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT58DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT58DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT58DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT58DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT58DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT58DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT58DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT58DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT58DE.BuildKDTreeWithCluster(const inBuff: TKDT58DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT58DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT58DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT58DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT58DE.BuildKDTreeWithCluster(const inBuff: TKDT58DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT58DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DE_BuildCall);
var
  TempStoreBuff: TKDT58DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT58DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT58DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT58DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT58DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT58DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DE_BuildMethod);
var
  TempStoreBuff: TKDT58DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT58DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT58DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT58DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT58DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT58DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DE_BuildProc);
var
  TempStoreBuff: TKDT58DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT58DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT58DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT58DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT58DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT58DE.Search(const Buff: TKDT58DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT58DE_Node;

var
  NearestNeighbour: PKDT58DE_Node;

  function FindParentNode(const BuffPtr: PKDT58DE_Vec; NodePtr: PKDT58DE_Node): PKDT58DE_Node;
  var
    Next       : PKDT58DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT58DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT58DE_Node; const BuffPtr: PKDT58DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT58DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT58DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT58DE_Vec; const p1, p2: PKDT58DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT58DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT58DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT58DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT58DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT58DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT58DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT58DE_Node(NearestNodes[0]);
    end;
end;

function TKDT58DE.Search(const Buff: TKDT58DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT58DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT58DE.Search(const Buff: TKDT58DE_Vec; var SearchedDistanceMin: Double): PKDT58DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT58DE.Search(const Buff: TKDT58DE_Vec): PKDT58DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT58DE.Search(const inBuff: TKDT58DE_DynamicVecBuffer; var OutBuff: TKDT58DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT58DE_DynamicVecBuffer;
  outBuffPtr : PKDT58DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT58DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT58DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT58DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT58DE.Search(const inBuff: TKDT58DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT58DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT58DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT58DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT58DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT58DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT58DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT58DE_Source));
end;

procedure TKDT58DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT58DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT58DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT58DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT58DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT58DE.PrintNodeTree(const NodePtr: PKDT58DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT58DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT58DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT58DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT58DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT58DE.KDT58DEVec(const s: string): TKDT58DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT58DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT58DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT58DE.KDT58DEVec(const v: TKDT58DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT58DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT58DE.KDT58DEPow(const v: TKDT58DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT58DE.KDT58DEDistance(const v1, v2: TKDT58DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT58DE_Axis - 1 do
      Result := Result + KDT58DEPow(v2[i] - v1[i]);
end;

procedure TKDT58DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT58DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT58DE.Test;
var
  TKDT58DE_Test    : TKDT58DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT58DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT58DE_Test := TKDT58DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT58DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT58DE_Test.TestBuff) - 1 do
    for j := 0 to KDT58DE_Axis - 1 do
        TKDT58DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT58DE_Test.TestBuff), length(TKDT58DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT58DE_Test.BuildKDTreeM(length(TKDT58DE_Test.TestBuff), nil, @TKDT58DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT58DE_Test.BuildKDTreeM(length(TKDT58DE_Test.TestBuff), nil, TKDT58DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT58DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT58DE_Test.TestBuff));
  TKDT58DE_Test.Search(TKDT58DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT58DEDistance(TKDT58DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT58DE_Test.Clear;
  { kMean test }
  TKDT58DE_Test.BuildKDTreeWithCluster(TKDT58DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT58DE_Test.Search(TKDT58DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT58DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT58DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT58DE_Test);
end;


function TKDT59DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT59DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT59DE_Node;
  function SortCompare(const p1, p2: PKDT59DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT59DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT59DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT59DE_SourceBuffer;
  dynBuff  : PKDT59DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT59DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT59DE.GetData(const index: NativeInt): PKDT59DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT59DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT59DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT59DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT59DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT59DE.StoreBuffPtr: PKDT59DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT59DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT59DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT59DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT59DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT59DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT59DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT59DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT59DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT59DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT59DE.BuildKDTreeWithCluster(const inBuff: TKDT59DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT59DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT59DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT59DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT59DE.BuildKDTreeWithCluster(const inBuff: TKDT59DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT59DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DE_BuildCall);
var
  TempStoreBuff: TKDT59DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT59DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT59DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT59DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT59DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT59DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DE_BuildMethod);
var
  TempStoreBuff: TKDT59DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT59DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT59DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT59DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT59DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT59DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DE_BuildProc);
var
  TempStoreBuff: TKDT59DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT59DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT59DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT59DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT59DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT59DE.Search(const Buff: TKDT59DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT59DE_Node;

var
  NearestNeighbour: PKDT59DE_Node;

  function FindParentNode(const BuffPtr: PKDT59DE_Vec; NodePtr: PKDT59DE_Node): PKDT59DE_Node;
  var
    Next       : PKDT59DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT59DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT59DE_Node; const BuffPtr: PKDT59DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT59DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT59DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT59DE_Vec; const p1, p2: PKDT59DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT59DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT59DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT59DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT59DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT59DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT59DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT59DE_Node(NearestNodes[0]);
    end;
end;

function TKDT59DE.Search(const Buff: TKDT59DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT59DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT59DE.Search(const Buff: TKDT59DE_Vec; var SearchedDistanceMin: Double): PKDT59DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT59DE.Search(const Buff: TKDT59DE_Vec): PKDT59DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT59DE.Search(const inBuff: TKDT59DE_DynamicVecBuffer; var OutBuff: TKDT59DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT59DE_DynamicVecBuffer;
  outBuffPtr : PKDT59DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT59DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT59DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT59DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT59DE.Search(const inBuff: TKDT59DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT59DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT59DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT59DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT59DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT59DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT59DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT59DE_Source));
end;

procedure TKDT59DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT59DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT59DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT59DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT59DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT59DE.PrintNodeTree(const NodePtr: PKDT59DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT59DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT59DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT59DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT59DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT59DE.KDT59DEVec(const s: string): TKDT59DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT59DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT59DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT59DE.KDT59DEVec(const v: TKDT59DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT59DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT59DE.KDT59DEPow(const v: TKDT59DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT59DE.KDT59DEDistance(const v1, v2: TKDT59DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT59DE_Axis - 1 do
      Result := Result + KDT59DEPow(v2[i] - v1[i]);
end;

procedure TKDT59DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT59DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT59DE.Test;
var
  TKDT59DE_Test    : TKDT59DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT59DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT59DE_Test := TKDT59DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT59DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT59DE_Test.TestBuff) - 1 do
    for j := 0 to KDT59DE_Axis - 1 do
        TKDT59DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT59DE_Test.TestBuff), length(TKDT59DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT59DE_Test.BuildKDTreeM(length(TKDT59DE_Test.TestBuff), nil, @TKDT59DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT59DE_Test.BuildKDTreeM(length(TKDT59DE_Test.TestBuff), nil, TKDT59DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT59DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT59DE_Test.TestBuff));
  TKDT59DE_Test.Search(TKDT59DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT59DEDistance(TKDT59DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT59DE_Test.Clear;
  { kMean test }
  TKDT59DE_Test.BuildKDTreeWithCluster(TKDT59DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT59DE_Test.Search(TKDT59DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT59DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT59DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT59DE_Test);
end;


function TKDT60DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT60DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT60DE_Node;
  function SortCompare(const p1, p2: PKDT60DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT60DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT60DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT60DE_SourceBuffer;
  dynBuff  : PKDT60DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT60DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT60DE.GetData(const index: NativeInt): PKDT60DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT60DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT60DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT60DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT60DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT60DE.StoreBuffPtr: PKDT60DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT60DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT60DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT60DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT60DE.BuildKDTreeWithCluster(const inBuff: TKDT60DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT60DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT60DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT60DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT60DE.BuildKDTreeWithCluster(const inBuff: TKDT60DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT60DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DE_BuildCall);
var
  TempStoreBuff: TKDT60DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT60DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT60DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT60DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT60DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DE_BuildMethod);
var
  TempStoreBuff: TKDT60DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT60DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT60DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT60DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT60DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DE_BuildProc);
var
  TempStoreBuff: TKDT60DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT60DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT60DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT60DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT60DE.Search(const Buff: TKDT60DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT60DE_Node;

var
  NearestNeighbour: PKDT60DE_Node;

  function FindParentNode(const BuffPtr: PKDT60DE_Vec; NodePtr: PKDT60DE_Node): PKDT60DE_Node;
  var
    Next       : PKDT60DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT60DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT60DE_Node; const BuffPtr: PKDT60DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT60DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT60DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT60DE_Vec; const p1, p2: PKDT60DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT60DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT60DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT60DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT60DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT60DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT60DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT60DE_Node(NearestNodes[0]);
    end;
end;

function TKDT60DE.Search(const Buff: TKDT60DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT60DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT60DE.Search(const Buff: TKDT60DE_Vec; var SearchedDistanceMin: Double): PKDT60DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT60DE.Search(const Buff: TKDT60DE_Vec): PKDT60DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT60DE.Search(const inBuff: TKDT60DE_DynamicVecBuffer; var OutBuff: TKDT60DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT60DE_DynamicVecBuffer;
  outBuffPtr : PKDT60DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT60DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT60DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT60DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT60DE.Search(const inBuff: TKDT60DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT60DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT60DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT60DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT60DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT60DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT60DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT60DE_Source));
end;

procedure TKDT60DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT60DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT60DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT60DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT60DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT60DE.PrintNodeTree(const NodePtr: PKDT60DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT60DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT60DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT60DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT60DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT60DE.KDT60DEVec(const s: string): TKDT60DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT60DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT60DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT60DE.KDT60DEVec(const v: TKDT60DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT60DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT60DE.KDT60DEPow(const v: TKDT60DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT60DE.KDT60DEDistance(const v1, v2: TKDT60DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT60DE_Axis - 1 do
      Result := Result + KDT60DEPow(v2[i] - v1[i]);
end;

procedure TKDT60DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT60DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT60DE.Test;
var
  TKDT60DE_Test    : TKDT60DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT60DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT60DE_Test := TKDT60DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT60DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT60DE_Test.TestBuff) - 1 do
    for j := 0 to KDT60DE_Axis - 1 do
        TKDT60DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT60DE_Test.TestBuff), length(TKDT60DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT60DE_Test.BuildKDTreeM(length(TKDT60DE_Test.TestBuff), nil, @TKDT60DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT60DE_Test.BuildKDTreeM(length(TKDT60DE_Test.TestBuff), nil, TKDT60DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT60DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT60DE_Test.TestBuff));
  TKDT60DE_Test.Search(TKDT60DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT60DEDistance(TKDT60DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT60DE_Test.Clear;
  { kMean test }
  TKDT60DE_Test.BuildKDTreeWithCluster(TKDT60DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT60DE_Test.Search(TKDT60DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT60DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT60DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT60DE_Test);
end;


function TKDT61DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT61DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT61DE_Node;
  function SortCompare(const p1, p2: PKDT61DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT61DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT61DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT61DE_SourceBuffer;
  dynBuff  : PKDT61DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT61DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT61DE.GetData(const index: NativeInt): PKDT61DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT61DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT61DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT61DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT61DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT61DE.StoreBuffPtr: PKDT61DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT61DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT61DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT61DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT61DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT61DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT61DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT61DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT61DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT61DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT61DE.BuildKDTreeWithCluster(const inBuff: TKDT61DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT61DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT61DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT61DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT61DE.BuildKDTreeWithCluster(const inBuff: TKDT61DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT61DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DE_BuildCall);
var
  TempStoreBuff: TKDT61DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT61DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT61DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT61DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT61DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT61DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DE_BuildMethod);
var
  TempStoreBuff: TKDT61DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT61DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT61DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT61DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT61DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT61DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DE_BuildProc);
var
  TempStoreBuff: TKDT61DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT61DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT61DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT61DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT61DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT61DE.Search(const Buff: TKDT61DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT61DE_Node;

var
  NearestNeighbour: PKDT61DE_Node;

  function FindParentNode(const BuffPtr: PKDT61DE_Vec; NodePtr: PKDT61DE_Node): PKDT61DE_Node;
  var
    Next       : PKDT61DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT61DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT61DE_Node; const BuffPtr: PKDT61DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT61DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT61DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT61DE_Vec; const p1, p2: PKDT61DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT61DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT61DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT61DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT61DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT61DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT61DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT61DE_Node(NearestNodes[0]);
    end;
end;

function TKDT61DE.Search(const Buff: TKDT61DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT61DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT61DE.Search(const Buff: TKDT61DE_Vec; var SearchedDistanceMin: Double): PKDT61DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT61DE.Search(const Buff: TKDT61DE_Vec): PKDT61DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT61DE.Search(const inBuff: TKDT61DE_DynamicVecBuffer; var OutBuff: TKDT61DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT61DE_DynamicVecBuffer;
  outBuffPtr : PKDT61DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT61DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT61DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT61DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT61DE.Search(const inBuff: TKDT61DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT61DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT61DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT61DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT61DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT61DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT61DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT61DE_Source));
end;

procedure TKDT61DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT61DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT61DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT61DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT61DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT61DE.PrintNodeTree(const NodePtr: PKDT61DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT61DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT61DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT61DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT61DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT61DE.KDT61DEVec(const s: string): TKDT61DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT61DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT61DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT61DE.KDT61DEVec(const v: TKDT61DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT61DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT61DE.KDT61DEPow(const v: TKDT61DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT61DE.KDT61DEDistance(const v1, v2: TKDT61DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT61DE_Axis - 1 do
      Result := Result + KDT61DEPow(v2[i] - v1[i]);
end;

procedure TKDT61DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT61DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT61DE.Test;
var
  TKDT61DE_Test    : TKDT61DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT61DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT61DE_Test := TKDT61DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT61DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT61DE_Test.TestBuff) - 1 do
    for j := 0 to KDT61DE_Axis - 1 do
        TKDT61DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT61DE_Test.TestBuff), length(TKDT61DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT61DE_Test.BuildKDTreeM(length(TKDT61DE_Test.TestBuff), nil, @TKDT61DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT61DE_Test.BuildKDTreeM(length(TKDT61DE_Test.TestBuff), nil, TKDT61DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT61DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT61DE_Test.TestBuff));
  TKDT61DE_Test.Search(TKDT61DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT61DEDistance(TKDT61DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT61DE_Test.Clear;
  { kMean test }
  TKDT61DE_Test.BuildKDTreeWithCluster(TKDT61DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT61DE_Test.Search(TKDT61DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT61DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT61DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT61DE_Test);
end;


function TKDT62DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT62DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT62DE_Node;
  function SortCompare(const p1, p2: PKDT62DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT62DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT62DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT62DE_SourceBuffer;
  dynBuff  : PKDT62DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT62DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT62DE.GetData(const index: NativeInt): PKDT62DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT62DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT62DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT62DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT62DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT62DE.StoreBuffPtr: PKDT62DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT62DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT62DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT62DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT62DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT62DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT62DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT62DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT62DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT62DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT62DE.BuildKDTreeWithCluster(const inBuff: TKDT62DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT62DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT62DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT62DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT62DE.BuildKDTreeWithCluster(const inBuff: TKDT62DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT62DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DE_BuildCall);
var
  TempStoreBuff: TKDT62DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT62DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT62DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT62DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT62DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT62DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DE_BuildMethod);
var
  TempStoreBuff: TKDT62DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT62DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT62DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT62DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT62DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT62DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DE_BuildProc);
var
  TempStoreBuff: TKDT62DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT62DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT62DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT62DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT62DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT62DE.Search(const Buff: TKDT62DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT62DE_Node;

var
  NearestNeighbour: PKDT62DE_Node;

  function FindParentNode(const BuffPtr: PKDT62DE_Vec; NodePtr: PKDT62DE_Node): PKDT62DE_Node;
  var
    Next       : PKDT62DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT62DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT62DE_Node; const BuffPtr: PKDT62DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT62DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT62DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT62DE_Vec; const p1, p2: PKDT62DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT62DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT62DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT62DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT62DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT62DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT62DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT62DE_Node(NearestNodes[0]);
    end;
end;

function TKDT62DE.Search(const Buff: TKDT62DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT62DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT62DE.Search(const Buff: TKDT62DE_Vec; var SearchedDistanceMin: Double): PKDT62DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT62DE.Search(const Buff: TKDT62DE_Vec): PKDT62DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT62DE.Search(const inBuff: TKDT62DE_DynamicVecBuffer; var OutBuff: TKDT62DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT62DE_DynamicVecBuffer;
  outBuffPtr : PKDT62DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT62DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT62DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT62DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT62DE.Search(const inBuff: TKDT62DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT62DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT62DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT62DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT62DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT62DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT62DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT62DE_Source));
end;

procedure TKDT62DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT62DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT62DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT62DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT62DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT62DE.PrintNodeTree(const NodePtr: PKDT62DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT62DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT62DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT62DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT62DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT62DE.KDT62DEVec(const s: string): TKDT62DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT62DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT62DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT62DE.KDT62DEVec(const v: TKDT62DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT62DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT62DE.KDT62DEPow(const v: TKDT62DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT62DE.KDT62DEDistance(const v1, v2: TKDT62DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT62DE_Axis - 1 do
      Result := Result + KDT62DEPow(v2[i] - v1[i]);
end;

procedure TKDT62DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT62DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT62DE.Test;
var
  TKDT62DE_Test    : TKDT62DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT62DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT62DE_Test := TKDT62DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT62DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT62DE_Test.TestBuff) - 1 do
    for j := 0 to KDT62DE_Axis - 1 do
        TKDT62DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT62DE_Test.TestBuff), length(TKDT62DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT62DE_Test.BuildKDTreeM(length(TKDT62DE_Test.TestBuff), nil, @TKDT62DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT62DE_Test.BuildKDTreeM(length(TKDT62DE_Test.TestBuff), nil, TKDT62DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT62DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT62DE_Test.TestBuff));
  TKDT62DE_Test.Search(TKDT62DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT62DEDistance(TKDT62DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT62DE_Test.Clear;
  { kMean test }
  TKDT62DE_Test.BuildKDTreeWithCluster(TKDT62DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT62DE_Test.Search(TKDT62DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT62DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT62DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT62DE_Test);
end;


function TKDT63DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT63DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT63DE_Node;
  function SortCompare(const p1, p2: PKDT63DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT63DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT63DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT63DE_SourceBuffer;
  dynBuff  : PKDT63DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT63DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT63DE.GetData(const index: NativeInt): PKDT63DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT63DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT63DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT63DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT63DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT63DE.StoreBuffPtr: PKDT63DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT63DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT63DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT63DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT63DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT63DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT63DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT63DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT63DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT63DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT63DE.BuildKDTreeWithCluster(const inBuff: TKDT63DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT63DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT63DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT63DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT63DE.BuildKDTreeWithCluster(const inBuff: TKDT63DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT63DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DE_BuildCall);
var
  TempStoreBuff: TKDT63DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT63DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT63DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT63DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT63DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT63DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DE_BuildMethod);
var
  TempStoreBuff: TKDT63DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT63DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT63DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT63DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT63DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT63DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DE_BuildProc);
var
  TempStoreBuff: TKDT63DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT63DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT63DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT63DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT63DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT63DE.Search(const Buff: TKDT63DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT63DE_Node;

var
  NearestNeighbour: PKDT63DE_Node;

  function FindParentNode(const BuffPtr: PKDT63DE_Vec; NodePtr: PKDT63DE_Node): PKDT63DE_Node;
  var
    Next       : PKDT63DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT63DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT63DE_Node; const BuffPtr: PKDT63DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT63DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT63DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT63DE_Vec; const p1, p2: PKDT63DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT63DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT63DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT63DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT63DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT63DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT63DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT63DE_Node(NearestNodes[0]);
    end;
end;

function TKDT63DE.Search(const Buff: TKDT63DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT63DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT63DE.Search(const Buff: TKDT63DE_Vec; var SearchedDistanceMin: Double): PKDT63DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT63DE.Search(const Buff: TKDT63DE_Vec): PKDT63DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT63DE.Search(const inBuff: TKDT63DE_DynamicVecBuffer; var OutBuff: TKDT63DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT63DE_DynamicVecBuffer;
  outBuffPtr : PKDT63DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT63DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT63DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT63DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT63DE.Search(const inBuff: TKDT63DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT63DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT63DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT63DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT63DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT63DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT63DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT63DE_Source));
end;

procedure TKDT63DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT63DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT63DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT63DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT63DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT63DE.PrintNodeTree(const NodePtr: PKDT63DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT63DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT63DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT63DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT63DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT63DE.KDT63DEVec(const s: string): TKDT63DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT63DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT63DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT63DE.KDT63DEVec(const v: TKDT63DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT63DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT63DE.KDT63DEPow(const v: TKDT63DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT63DE.KDT63DEDistance(const v1, v2: TKDT63DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT63DE_Axis - 1 do
      Result := Result + KDT63DEPow(v2[i] - v1[i]);
end;

procedure TKDT63DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT63DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT63DE.Test;
var
  TKDT63DE_Test    : TKDT63DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT63DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT63DE_Test := TKDT63DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT63DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT63DE_Test.TestBuff) - 1 do
    for j := 0 to KDT63DE_Axis - 1 do
        TKDT63DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT63DE_Test.TestBuff), length(TKDT63DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT63DE_Test.BuildKDTreeM(length(TKDT63DE_Test.TestBuff), nil, @TKDT63DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT63DE_Test.BuildKDTreeM(length(TKDT63DE_Test.TestBuff), nil, TKDT63DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT63DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT63DE_Test.TestBuff));
  TKDT63DE_Test.Search(TKDT63DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT63DEDistance(TKDT63DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT63DE_Test.Clear;
  { kMean test }
  TKDT63DE_Test.BuildKDTreeWithCluster(TKDT63DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT63DE_Test.Search(TKDT63DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT63DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT63DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT63DE_Test);
end;


function TKDT64DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DE_Node;
  function SortCompare(const p1, p2: PKDT64DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT64DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT64DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT64DE_SourceBuffer;
  dynBuff  : PKDT64DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT64DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT64DE.GetData(const index: NativeInt): PKDT64DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT64DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT64DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT64DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT64DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT64DE.StoreBuffPtr: PKDT64DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT64DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT64DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT64DE.BuildKDTreeWithCluster(const inBuff: TKDT64DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT64DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT64DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT64DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT64DE.BuildKDTreeWithCluster(const inBuff: TKDT64DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DE_BuildCall);
var
  TempStoreBuff: TKDT64DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT64DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DE_BuildMethod);
var
  TempStoreBuff: TKDT64DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT64DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DE_BuildProc);
var
  TempStoreBuff: TKDT64DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT64DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT64DE.Search(const Buff: TKDT64DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DE_Node;

var
  NearestNeighbour: PKDT64DE_Node;

  function FindParentNode(const BuffPtr: PKDT64DE_Vec; NodePtr: PKDT64DE_Node): PKDT64DE_Node;
  var
    Next       : PKDT64DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT64DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT64DE_Node; const BuffPtr: PKDT64DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT64DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT64DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT64DE_Vec; const p1, p2: PKDT64DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT64DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT64DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT64DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT64DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT64DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT64DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT64DE_Node(NearestNodes[0]);
    end;
end;

function TKDT64DE.Search(const Buff: TKDT64DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT64DE.Search(const Buff: TKDT64DE_Vec; var SearchedDistanceMin: Double): PKDT64DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT64DE.Search(const Buff: TKDT64DE_Vec): PKDT64DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT64DE.Search(const inBuff: TKDT64DE_DynamicVecBuffer; var OutBuff: TKDT64DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT64DE_DynamicVecBuffer;
  outBuffPtr : PKDT64DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT64DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT64DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DE.Search(const inBuff: TKDT64DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT64DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT64DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT64DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT64DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT64DE_Source));
end;

procedure TKDT64DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT64DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT64DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT64DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DE.PrintNodeTree(const NodePtr: PKDT64DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT64DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT64DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT64DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT64DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT64DE.KDT64DEVec(const s: string): TKDT64DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT64DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT64DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT64DE.KDT64DEVec(const v: TKDT64DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT64DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT64DE.KDT64DEPow(const v: TKDT64DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT64DE.KDT64DEDistance(const v1, v2: TKDT64DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT64DE_Axis - 1 do
      Result := Result + KDT64DEPow(v2[i] - v1[i]);
end;

procedure TKDT64DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT64DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT64DE.Test;
var
  TKDT64DE_Test    : TKDT64DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT64DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT64DE_Test := TKDT64DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT64DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT64DE_Test.TestBuff) - 1 do
    for j := 0 to KDT64DE_Axis - 1 do
        TKDT64DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT64DE_Test.TestBuff), length(TKDT64DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT64DE_Test.BuildKDTreeM(length(TKDT64DE_Test.TestBuff), nil, @TKDT64DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT64DE_Test.BuildKDTreeM(length(TKDT64DE_Test.TestBuff), nil, TKDT64DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT64DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT64DE_Test.TestBuff));
  TKDT64DE_Test.Search(TKDT64DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT64DEDistance(TKDT64DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT64DE_Test.Clear;
  { kMean test }
  TKDT64DE_Test.BuildKDTreeWithCluster(TKDT64DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT64DE_Test.Search(TKDT64DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT64DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT64DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT64DE_Test);
end;


function TKDT65DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT65DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT65DE_Node;
  function SortCompare(const p1, p2: PKDT65DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT65DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT65DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT65DE_SourceBuffer;
  dynBuff  : PKDT65DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT65DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT65DE.GetData(const index: NativeInt): PKDT65DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT65DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT65DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT65DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT65DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT65DE.StoreBuffPtr: PKDT65DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT65DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT65DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT65DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT65DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT65DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT65DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT65DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT65DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT65DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT65DE.BuildKDTreeWithCluster(const inBuff: TKDT65DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT65DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT65DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT65DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT65DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT65DE.BuildKDTreeWithCluster(const inBuff: TKDT65DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT65DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DE_BuildCall);
var
  TempStoreBuff: TKDT65DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT65DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT65DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT65DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT65DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT65DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT65DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DE_BuildMethod);
var
  TempStoreBuff: TKDT65DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT65DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT65DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT65DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT65DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT65DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT65DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DE_BuildProc);
var
  TempStoreBuff: TKDT65DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT65DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT65DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT65DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT65DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT65DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT65DE.Search(const Buff: TKDT65DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT65DE_Node;

var
  NearestNeighbour: PKDT65DE_Node;

  function FindParentNode(const BuffPtr: PKDT65DE_Vec; NodePtr: PKDT65DE_Node): PKDT65DE_Node;
  var
    Next       : PKDT65DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT65DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT65DE_Node; const BuffPtr: PKDT65DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT65DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT65DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT65DE_Vec; const p1, p2: PKDT65DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT65DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT65DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT65DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT65DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT65DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT65DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT65DE_Node(NearestNodes[0]);
    end;
end;

function TKDT65DE.Search(const Buff: TKDT65DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT65DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT65DE.Search(const Buff: TKDT65DE_Vec; var SearchedDistanceMin: Double): PKDT65DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT65DE.Search(const Buff: TKDT65DE_Vec): PKDT65DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT65DE.Search(const inBuff: TKDT65DE_DynamicVecBuffer; var OutBuff: TKDT65DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT65DE_DynamicVecBuffer;
  outBuffPtr : PKDT65DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT65DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT65DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT65DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT65DE.Search(const inBuff: TKDT65DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT65DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT65DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT65DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT65DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT65DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT65DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT65DE_Source));
end;

procedure TKDT65DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT65DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT65DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT65DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT65DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT65DE.PrintNodeTree(const NodePtr: PKDT65DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT65DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT65DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT65DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT65DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT65DE.KDT65DEVec(const s: string): TKDT65DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT65DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT65DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT65DE.KDT65DEVec(const v: TKDT65DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT65DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT65DE.KDT65DEPow(const v: TKDT65DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT65DE.KDT65DEDistance(const v1, v2: TKDT65DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT65DE_Axis - 1 do
      Result := Result + KDT65DEPow(v2[i] - v1[i]);
end;

procedure TKDT65DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT65DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT65DE.Test;
var
  TKDT65DE_Test    : TKDT65DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT65DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT65DE_Test := TKDT65DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT65DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT65DE_Test.TestBuff) - 1 do
    for j := 0 to KDT65DE_Axis - 1 do
        TKDT65DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT65DE_Test.TestBuff), length(TKDT65DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT65DE_Test.BuildKDTreeM(length(TKDT65DE_Test.TestBuff), nil, @TKDT65DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT65DE_Test.BuildKDTreeM(length(TKDT65DE_Test.TestBuff), nil, TKDT65DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT65DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT65DE_Test.TestBuff));
  TKDT65DE_Test.Search(TKDT65DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT65DEDistance(TKDT65DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT65DE_Test.Clear;
  { kMean test }
  TKDT65DE_Test.BuildKDTreeWithCluster(TKDT65DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT65DE_Test.Search(TKDT65DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT65DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT65DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT65DE_Test);
end;


function TKDT66DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT66DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT66DE_Node;
  function SortCompare(const p1, p2: PKDT66DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT66DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT66DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT66DE_SourceBuffer;
  dynBuff  : PKDT66DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT66DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT66DE.GetData(const index: NativeInt): PKDT66DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT66DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT66DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT66DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT66DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT66DE.StoreBuffPtr: PKDT66DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT66DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT66DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT66DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT66DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT66DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT66DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT66DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT66DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT66DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT66DE.BuildKDTreeWithCluster(const inBuff: TKDT66DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT66DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT66DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT66DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT66DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT66DE.BuildKDTreeWithCluster(const inBuff: TKDT66DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT66DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DE_BuildCall);
var
  TempStoreBuff: TKDT66DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT66DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT66DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT66DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT66DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT66DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT66DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DE_BuildMethod);
var
  TempStoreBuff: TKDT66DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT66DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT66DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT66DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT66DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT66DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT66DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DE_BuildProc);
var
  TempStoreBuff: TKDT66DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT66DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT66DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT66DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT66DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT66DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT66DE.Search(const Buff: TKDT66DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT66DE_Node;

var
  NearestNeighbour: PKDT66DE_Node;

  function FindParentNode(const BuffPtr: PKDT66DE_Vec; NodePtr: PKDT66DE_Node): PKDT66DE_Node;
  var
    Next       : PKDT66DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT66DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT66DE_Node; const BuffPtr: PKDT66DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT66DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT66DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT66DE_Vec; const p1, p2: PKDT66DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT66DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT66DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT66DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT66DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT66DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT66DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT66DE_Node(NearestNodes[0]);
    end;
end;

function TKDT66DE.Search(const Buff: TKDT66DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT66DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT66DE.Search(const Buff: TKDT66DE_Vec; var SearchedDistanceMin: Double): PKDT66DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT66DE.Search(const Buff: TKDT66DE_Vec): PKDT66DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT66DE.Search(const inBuff: TKDT66DE_DynamicVecBuffer; var OutBuff: TKDT66DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT66DE_DynamicVecBuffer;
  outBuffPtr : PKDT66DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT66DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT66DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT66DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT66DE.Search(const inBuff: TKDT66DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT66DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT66DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT66DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT66DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT66DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT66DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT66DE_Source));
end;

procedure TKDT66DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT66DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT66DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT66DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT66DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT66DE.PrintNodeTree(const NodePtr: PKDT66DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT66DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT66DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT66DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT66DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT66DE.KDT66DEVec(const s: string): TKDT66DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT66DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT66DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT66DE.KDT66DEVec(const v: TKDT66DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT66DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT66DE.KDT66DEPow(const v: TKDT66DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT66DE.KDT66DEDistance(const v1, v2: TKDT66DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT66DE_Axis - 1 do
      Result := Result + KDT66DEPow(v2[i] - v1[i]);
end;

procedure TKDT66DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT66DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT66DE.Test;
var
  TKDT66DE_Test    : TKDT66DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT66DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT66DE_Test := TKDT66DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT66DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT66DE_Test.TestBuff) - 1 do
    for j := 0 to KDT66DE_Axis - 1 do
        TKDT66DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT66DE_Test.TestBuff), length(TKDT66DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT66DE_Test.BuildKDTreeM(length(TKDT66DE_Test.TestBuff), nil, @TKDT66DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT66DE_Test.BuildKDTreeM(length(TKDT66DE_Test.TestBuff), nil, TKDT66DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT66DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT66DE_Test.TestBuff));
  TKDT66DE_Test.Search(TKDT66DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT66DEDistance(TKDT66DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT66DE_Test.Clear;
  { kMean test }
  TKDT66DE_Test.BuildKDTreeWithCluster(TKDT66DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT66DE_Test.Search(TKDT66DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT66DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT66DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT66DE_Test);
end;


function TKDT67DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT67DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT67DE_Node;
  function SortCompare(const p1, p2: PKDT67DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT67DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT67DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT67DE_SourceBuffer;
  dynBuff  : PKDT67DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT67DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT67DE.GetData(const index: NativeInt): PKDT67DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT67DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT67DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT67DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT67DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT67DE.StoreBuffPtr: PKDT67DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT67DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT67DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT67DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT67DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT67DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT67DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT67DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT67DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT67DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT67DE.BuildKDTreeWithCluster(const inBuff: TKDT67DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT67DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT67DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT67DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT67DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT67DE.BuildKDTreeWithCluster(const inBuff: TKDT67DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT67DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DE_BuildCall);
var
  TempStoreBuff: TKDT67DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT67DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT67DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT67DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT67DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT67DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT67DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DE_BuildMethod);
var
  TempStoreBuff: TKDT67DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT67DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT67DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT67DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT67DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT67DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT67DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DE_BuildProc);
var
  TempStoreBuff: TKDT67DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT67DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT67DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT67DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT67DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT67DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT67DE.Search(const Buff: TKDT67DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT67DE_Node;

var
  NearestNeighbour: PKDT67DE_Node;

  function FindParentNode(const BuffPtr: PKDT67DE_Vec; NodePtr: PKDT67DE_Node): PKDT67DE_Node;
  var
    Next       : PKDT67DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT67DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT67DE_Node; const BuffPtr: PKDT67DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT67DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT67DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT67DE_Vec; const p1, p2: PKDT67DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT67DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT67DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT67DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT67DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT67DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT67DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT67DE_Node(NearestNodes[0]);
    end;
end;

function TKDT67DE.Search(const Buff: TKDT67DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT67DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT67DE.Search(const Buff: TKDT67DE_Vec; var SearchedDistanceMin: Double): PKDT67DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT67DE.Search(const Buff: TKDT67DE_Vec): PKDT67DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT67DE.Search(const inBuff: TKDT67DE_DynamicVecBuffer; var OutBuff: TKDT67DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT67DE_DynamicVecBuffer;
  outBuffPtr : PKDT67DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT67DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT67DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT67DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT67DE.Search(const inBuff: TKDT67DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT67DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT67DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT67DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT67DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT67DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT67DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT67DE_Source));
end;

procedure TKDT67DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT67DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT67DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT67DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT67DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT67DE.PrintNodeTree(const NodePtr: PKDT67DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT67DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT67DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT67DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT67DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT67DE.KDT67DEVec(const s: string): TKDT67DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT67DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT67DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT67DE.KDT67DEVec(const v: TKDT67DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT67DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT67DE.KDT67DEPow(const v: TKDT67DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT67DE.KDT67DEDistance(const v1, v2: TKDT67DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT67DE_Axis - 1 do
      Result := Result + KDT67DEPow(v2[i] - v1[i]);
end;

procedure TKDT67DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT67DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT67DE.Test;
var
  TKDT67DE_Test    : TKDT67DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT67DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT67DE_Test := TKDT67DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT67DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT67DE_Test.TestBuff) - 1 do
    for j := 0 to KDT67DE_Axis - 1 do
        TKDT67DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT67DE_Test.TestBuff), length(TKDT67DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT67DE_Test.BuildKDTreeM(length(TKDT67DE_Test.TestBuff), nil, @TKDT67DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT67DE_Test.BuildKDTreeM(length(TKDT67DE_Test.TestBuff), nil, TKDT67DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT67DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT67DE_Test.TestBuff));
  TKDT67DE_Test.Search(TKDT67DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT67DEDistance(TKDT67DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT67DE_Test.Clear;
  { kMean test }
  TKDT67DE_Test.BuildKDTreeWithCluster(TKDT67DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT67DE_Test.Search(TKDT67DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT67DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT67DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT67DE_Test);
end;


function TKDT68DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT68DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT68DE_Node;
  function SortCompare(const p1, p2: PKDT68DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT68DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT68DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT68DE_SourceBuffer;
  dynBuff  : PKDT68DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT68DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT68DE.GetData(const index: NativeInt): PKDT68DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT68DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT68DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT68DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT68DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT68DE.StoreBuffPtr: PKDT68DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT68DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT68DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT68DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT68DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT68DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT68DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT68DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT68DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT68DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT68DE.BuildKDTreeWithCluster(const inBuff: TKDT68DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT68DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT68DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT68DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT68DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT68DE.BuildKDTreeWithCluster(const inBuff: TKDT68DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT68DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DE_BuildCall);
var
  TempStoreBuff: TKDT68DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT68DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT68DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT68DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT68DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT68DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT68DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DE_BuildMethod);
var
  TempStoreBuff: TKDT68DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT68DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT68DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT68DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT68DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT68DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT68DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DE_BuildProc);
var
  TempStoreBuff: TKDT68DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT68DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT68DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT68DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT68DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT68DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT68DE.Search(const Buff: TKDT68DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT68DE_Node;

var
  NearestNeighbour: PKDT68DE_Node;

  function FindParentNode(const BuffPtr: PKDT68DE_Vec; NodePtr: PKDT68DE_Node): PKDT68DE_Node;
  var
    Next       : PKDT68DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT68DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT68DE_Node; const BuffPtr: PKDT68DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT68DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT68DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT68DE_Vec; const p1, p2: PKDT68DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT68DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT68DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT68DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT68DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT68DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT68DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT68DE_Node(NearestNodes[0]);
    end;
end;

function TKDT68DE.Search(const Buff: TKDT68DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT68DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT68DE.Search(const Buff: TKDT68DE_Vec; var SearchedDistanceMin: Double): PKDT68DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT68DE.Search(const Buff: TKDT68DE_Vec): PKDT68DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT68DE.Search(const inBuff: TKDT68DE_DynamicVecBuffer; var OutBuff: TKDT68DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT68DE_DynamicVecBuffer;
  outBuffPtr : PKDT68DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT68DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT68DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT68DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT68DE.Search(const inBuff: TKDT68DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT68DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT68DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT68DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT68DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT68DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT68DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT68DE_Source));
end;

procedure TKDT68DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT68DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT68DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT68DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT68DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT68DE.PrintNodeTree(const NodePtr: PKDT68DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT68DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT68DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT68DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT68DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT68DE.KDT68DEVec(const s: string): TKDT68DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT68DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT68DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT68DE.KDT68DEVec(const v: TKDT68DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT68DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT68DE.KDT68DEPow(const v: TKDT68DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT68DE.KDT68DEDistance(const v1, v2: TKDT68DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT68DE_Axis - 1 do
      Result := Result + KDT68DEPow(v2[i] - v1[i]);
end;

procedure TKDT68DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT68DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT68DE.Test;
var
  TKDT68DE_Test    : TKDT68DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT68DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT68DE_Test := TKDT68DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT68DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT68DE_Test.TestBuff) - 1 do
    for j := 0 to KDT68DE_Axis - 1 do
        TKDT68DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT68DE_Test.TestBuff), length(TKDT68DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT68DE_Test.BuildKDTreeM(length(TKDT68DE_Test.TestBuff), nil, @TKDT68DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT68DE_Test.BuildKDTreeM(length(TKDT68DE_Test.TestBuff), nil, TKDT68DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT68DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT68DE_Test.TestBuff));
  TKDT68DE_Test.Search(TKDT68DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT68DEDistance(TKDT68DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT68DE_Test.Clear;
  { kMean test }
  TKDT68DE_Test.BuildKDTreeWithCluster(TKDT68DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT68DE_Test.Search(TKDT68DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT68DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT68DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT68DE_Test);
end;


function TKDT69DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT69DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT69DE_Node;
  function SortCompare(const p1, p2: PKDT69DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT69DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT69DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT69DE_SourceBuffer;
  dynBuff  : PKDT69DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT69DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT69DE.GetData(const index: NativeInt): PKDT69DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT69DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT69DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT69DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT69DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT69DE.StoreBuffPtr: PKDT69DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT69DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT69DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT69DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT69DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT69DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT69DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT69DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT69DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT69DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT69DE.BuildKDTreeWithCluster(const inBuff: TKDT69DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT69DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT69DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT69DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT69DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT69DE.BuildKDTreeWithCluster(const inBuff: TKDT69DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT69DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DE_BuildCall);
var
  TempStoreBuff: TKDT69DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT69DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT69DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT69DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT69DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT69DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT69DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DE_BuildMethod);
var
  TempStoreBuff: TKDT69DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT69DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT69DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT69DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT69DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT69DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT69DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DE_BuildProc);
var
  TempStoreBuff: TKDT69DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT69DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT69DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT69DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT69DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT69DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT69DE.Search(const Buff: TKDT69DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT69DE_Node;

var
  NearestNeighbour: PKDT69DE_Node;

  function FindParentNode(const BuffPtr: PKDT69DE_Vec; NodePtr: PKDT69DE_Node): PKDT69DE_Node;
  var
    Next       : PKDT69DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT69DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT69DE_Node; const BuffPtr: PKDT69DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT69DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT69DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT69DE_Vec; const p1, p2: PKDT69DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT69DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT69DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT69DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT69DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT69DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT69DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT69DE_Node(NearestNodes[0]);
    end;
end;

function TKDT69DE.Search(const Buff: TKDT69DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT69DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT69DE.Search(const Buff: TKDT69DE_Vec; var SearchedDistanceMin: Double): PKDT69DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT69DE.Search(const Buff: TKDT69DE_Vec): PKDT69DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT69DE.Search(const inBuff: TKDT69DE_DynamicVecBuffer; var OutBuff: TKDT69DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT69DE_DynamicVecBuffer;
  outBuffPtr : PKDT69DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT69DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT69DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT69DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT69DE.Search(const inBuff: TKDT69DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT69DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT69DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT69DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT69DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT69DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT69DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT69DE_Source));
end;

procedure TKDT69DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT69DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT69DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT69DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT69DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT69DE.PrintNodeTree(const NodePtr: PKDT69DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT69DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT69DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT69DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT69DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT69DE.KDT69DEVec(const s: string): TKDT69DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT69DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT69DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT69DE.KDT69DEVec(const v: TKDT69DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT69DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT69DE.KDT69DEPow(const v: TKDT69DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT69DE.KDT69DEDistance(const v1, v2: TKDT69DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT69DE_Axis - 1 do
      Result := Result + KDT69DEPow(v2[i] - v1[i]);
end;

procedure TKDT69DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT69DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT69DE.Test;
var
  TKDT69DE_Test    : TKDT69DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT69DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT69DE_Test := TKDT69DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT69DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT69DE_Test.TestBuff) - 1 do
    for j := 0 to KDT69DE_Axis - 1 do
        TKDT69DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT69DE_Test.TestBuff), length(TKDT69DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT69DE_Test.BuildKDTreeM(length(TKDT69DE_Test.TestBuff), nil, @TKDT69DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT69DE_Test.BuildKDTreeM(length(TKDT69DE_Test.TestBuff), nil, TKDT69DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT69DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT69DE_Test.TestBuff));
  TKDT69DE_Test.Search(TKDT69DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT69DEDistance(TKDT69DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT69DE_Test.Clear;
  { kMean test }
  TKDT69DE_Test.BuildKDTreeWithCluster(TKDT69DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT69DE_Test.Search(TKDT69DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT69DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT69DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT69DE_Test);
end;


function TKDT70DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT70DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT70DE_Node;
  function SortCompare(const p1, p2: PKDT70DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT70DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT70DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT70DE_SourceBuffer;
  dynBuff  : PKDT70DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT70DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT70DE.GetData(const index: NativeInt): PKDT70DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT70DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT70DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT70DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT70DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT70DE.StoreBuffPtr: PKDT70DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT70DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT70DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT70DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT70DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT70DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT70DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT70DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT70DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT70DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT70DE.BuildKDTreeWithCluster(const inBuff: TKDT70DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT70DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT70DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT70DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT70DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT70DE.BuildKDTreeWithCluster(const inBuff: TKDT70DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT70DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DE_BuildCall);
var
  TempStoreBuff: TKDT70DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT70DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT70DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT70DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT70DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT70DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT70DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DE_BuildMethod);
var
  TempStoreBuff: TKDT70DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT70DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT70DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT70DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT70DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT70DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT70DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DE_BuildProc);
var
  TempStoreBuff: TKDT70DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT70DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT70DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT70DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT70DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT70DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT70DE.Search(const Buff: TKDT70DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT70DE_Node;

var
  NearestNeighbour: PKDT70DE_Node;

  function FindParentNode(const BuffPtr: PKDT70DE_Vec; NodePtr: PKDT70DE_Node): PKDT70DE_Node;
  var
    Next       : PKDT70DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT70DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT70DE_Node; const BuffPtr: PKDT70DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT70DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT70DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT70DE_Vec; const p1, p2: PKDT70DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT70DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT70DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT70DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT70DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT70DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT70DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT70DE_Node(NearestNodes[0]);
    end;
end;

function TKDT70DE.Search(const Buff: TKDT70DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT70DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT70DE.Search(const Buff: TKDT70DE_Vec; var SearchedDistanceMin: Double): PKDT70DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT70DE.Search(const Buff: TKDT70DE_Vec): PKDT70DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT70DE.Search(const inBuff: TKDT70DE_DynamicVecBuffer; var OutBuff: TKDT70DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT70DE_DynamicVecBuffer;
  outBuffPtr : PKDT70DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT70DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT70DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT70DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT70DE.Search(const inBuff: TKDT70DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT70DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT70DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT70DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT70DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT70DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT70DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT70DE_Source));
end;

procedure TKDT70DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT70DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT70DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT70DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT70DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT70DE.PrintNodeTree(const NodePtr: PKDT70DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT70DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT70DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT70DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT70DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT70DE.KDT70DEVec(const s: string): TKDT70DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT70DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT70DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT70DE.KDT70DEVec(const v: TKDT70DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT70DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT70DE.KDT70DEPow(const v: TKDT70DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT70DE.KDT70DEDistance(const v1, v2: TKDT70DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT70DE_Axis - 1 do
      Result := Result + KDT70DEPow(v2[i] - v1[i]);
end;

procedure TKDT70DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT70DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT70DE.Test;
var
  TKDT70DE_Test    : TKDT70DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT70DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT70DE_Test := TKDT70DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT70DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT70DE_Test.TestBuff) - 1 do
    for j := 0 to KDT70DE_Axis - 1 do
        TKDT70DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT70DE_Test.TestBuff), length(TKDT70DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT70DE_Test.BuildKDTreeM(length(TKDT70DE_Test.TestBuff), nil, @TKDT70DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT70DE_Test.BuildKDTreeM(length(TKDT70DE_Test.TestBuff), nil, TKDT70DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT70DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT70DE_Test.TestBuff));
  TKDT70DE_Test.Search(TKDT70DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT70DEDistance(TKDT70DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT70DE_Test.Clear;
  { kMean test }
  TKDT70DE_Test.BuildKDTreeWithCluster(TKDT70DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT70DE_Test.Search(TKDT70DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT70DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT70DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT70DE_Test);
end;


function TKDT71DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT71DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT71DE_Node;
  function SortCompare(const p1, p2: PKDT71DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT71DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT71DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT71DE_SourceBuffer;
  dynBuff  : PKDT71DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT71DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT71DE.GetData(const index: NativeInt): PKDT71DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT71DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT71DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT71DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT71DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT71DE.StoreBuffPtr: PKDT71DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT71DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT71DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT71DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT71DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT71DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT71DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT71DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT71DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT71DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT71DE.BuildKDTreeWithCluster(const inBuff: TKDT71DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT71DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT71DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT71DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT71DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT71DE.BuildKDTreeWithCluster(const inBuff: TKDT71DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT71DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DE_BuildCall);
var
  TempStoreBuff: TKDT71DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT71DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT71DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT71DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT71DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT71DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT71DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DE_BuildMethod);
var
  TempStoreBuff: TKDT71DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT71DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT71DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT71DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT71DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT71DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT71DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DE_BuildProc);
var
  TempStoreBuff: TKDT71DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT71DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT71DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT71DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT71DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT71DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT71DE.Search(const Buff: TKDT71DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT71DE_Node;

var
  NearestNeighbour: PKDT71DE_Node;

  function FindParentNode(const BuffPtr: PKDT71DE_Vec; NodePtr: PKDT71DE_Node): PKDT71DE_Node;
  var
    Next       : PKDT71DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT71DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT71DE_Node; const BuffPtr: PKDT71DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT71DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT71DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT71DE_Vec; const p1, p2: PKDT71DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT71DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT71DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT71DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT71DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT71DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT71DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT71DE_Node(NearestNodes[0]);
    end;
end;

function TKDT71DE.Search(const Buff: TKDT71DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT71DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT71DE.Search(const Buff: TKDT71DE_Vec; var SearchedDistanceMin: Double): PKDT71DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT71DE.Search(const Buff: TKDT71DE_Vec): PKDT71DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT71DE.Search(const inBuff: TKDT71DE_DynamicVecBuffer; var OutBuff: TKDT71DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT71DE_DynamicVecBuffer;
  outBuffPtr : PKDT71DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT71DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT71DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT71DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT71DE.Search(const inBuff: TKDT71DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT71DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT71DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT71DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT71DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT71DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT71DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT71DE_Source));
end;

procedure TKDT71DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT71DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT71DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT71DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT71DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT71DE.PrintNodeTree(const NodePtr: PKDT71DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT71DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT71DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT71DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT71DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT71DE.KDT71DEVec(const s: string): TKDT71DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT71DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT71DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT71DE.KDT71DEVec(const v: TKDT71DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT71DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT71DE.KDT71DEPow(const v: TKDT71DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT71DE.KDT71DEDistance(const v1, v2: TKDT71DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT71DE_Axis - 1 do
      Result := Result + KDT71DEPow(v2[i] - v1[i]);
end;

procedure TKDT71DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT71DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT71DE.Test;
var
  TKDT71DE_Test    : TKDT71DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT71DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT71DE_Test := TKDT71DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT71DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT71DE_Test.TestBuff) - 1 do
    for j := 0 to KDT71DE_Axis - 1 do
        TKDT71DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT71DE_Test.TestBuff), length(TKDT71DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT71DE_Test.BuildKDTreeM(length(TKDT71DE_Test.TestBuff), nil, @TKDT71DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT71DE_Test.BuildKDTreeM(length(TKDT71DE_Test.TestBuff), nil, TKDT71DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT71DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT71DE_Test.TestBuff));
  TKDT71DE_Test.Search(TKDT71DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT71DEDistance(TKDT71DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT71DE_Test.Clear;
  { kMean test }
  TKDT71DE_Test.BuildKDTreeWithCluster(TKDT71DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT71DE_Test.Search(TKDT71DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT71DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT71DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT71DE_Test);
end;


function TKDT72DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT72DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT72DE_Node;
  function SortCompare(const p1, p2: PKDT72DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT72DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT72DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT72DE_SourceBuffer;
  dynBuff  : PKDT72DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT72DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT72DE.GetData(const index: NativeInt): PKDT72DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT72DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT72DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT72DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT72DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT72DE.StoreBuffPtr: PKDT72DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT72DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT72DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT72DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT72DE.BuildKDTreeWithCluster(const inBuff: TKDT72DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT72DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT72DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT72DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT72DE.BuildKDTreeWithCluster(const inBuff: TKDT72DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT72DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DE_BuildCall);
var
  TempStoreBuff: TKDT72DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT72DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT72DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT72DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT72DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DE_BuildMethod);
var
  TempStoreBuff: TKDT72DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT72DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT72DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT72DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT72DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DE_BuildProc);
var
  TempStoreBuff: TKDT72DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT72DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT72DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT72DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT72DE.Search(const Buff: TKDT72DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT72DE_Node;

var
  NearestNeighbour: PKDT72DE_Node;

  function FindParentNode(const BuffPtr: PKDT72DE_Vec; NodePtr: PKDT72DE_Node): PKDT72DE_Node;
  var
    Next       : PKDT72DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT72DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT72DE_Node; const BuffPtr: PKDT72DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT72DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT72DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT72DE_Vec; const p1, p2: PKDT72DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT72DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT72DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT72DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT72DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT72DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT72DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT72DE_Node(NearestNodes[0]);
    end;
end;

function TKDT72DE.Search(const Buff: TKDT72DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT72DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT72DE.Search(const Buff: TKDT72DE_Vec; var SearchedDistanceMin: Double): PKDT72DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT72DE.Search(const Buff: TKDT72DE_Vec): PKDT72DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT72DE.Search(const inBuff: TKDT72DE_DynamicVecBuffer; var OutBuff: TKDT72DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT72DE_DynamicVecBuffer;
  outBuffPtr : PKDT72DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT72DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT72DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT72DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT72DE.Search(const inBuff: TKDT72DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT72DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT72DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT72DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT72DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT72DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT72DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT72DE_Source));
end;

procedure TKDT72DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT72DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT72DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT72DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT72DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT72DE.PrintNodeTree(const NodePtr: PKDT72DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT72DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT72DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT72DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT72DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT72DE.KDT72DEVec(const s: string): TKDT72DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT72DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT72DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT72DE.KDT72DEVec(const v: TKDT72DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT72DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT72DE.KDT72DEPow(const v: TKDT72DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT72DE.KDT72DEDistance(const v1, v2: TKDT72DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT72DE_Axis - 1 do
      Result := Result + KDT72DEPow(v2[i] - v1[i]);
end;

procedure TKDT72DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT72DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT72DE.Test;
var
  TKDT72DE_Test    : TKDT72DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT72DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT72DE_Test := TKDT72DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT72DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT72DE_Test.TestBuff) - 1 do
    for j := 0 to KDT72DE_Axis - 1 do
        TKDT72DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT72DE_Test.TestBuff), length(TKDT72DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT72DE_Test.BuildKDTreeM(length(TKDT72DE_Test.TestBuff), nil, @TKDT72DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT72DE_Test.BuildKDTreeM(length(TKDT72DE_Test.TestBuff), nil, TKDT72DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT72DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT72DE_Test.TestBuff));
  TKDT72DE_Test.Search(TKDT72DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT72DEDistance(TKDT72DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT72DE_Test.Clear;
  { kMean test }
  TKDT72DE_Test.BuildKDTreeWithCluster(TKDT72DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT72DE_Test.Search(TKDT72DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT72DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT72DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT72DE_Test);
end;


function TKDT84DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT84DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT84DE_Node;
  function SortCompare(const p1, p2: PKDT84DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT84DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT84DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT84DE_SourceBuffer;
  dynBuff  : PKDT84DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT84DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT84DE.GetData(const index: NativeInt): PKDT84DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT84DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT84DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT84DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT84DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT84DE.StoreBuffPtr: PKDT84DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT84DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT84DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT84DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT84DE.BuildKDTreeWithCluster(const inBuff: TKDT84DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT84DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT84DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT84DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT84DE.BuildKDTreeWithCluster(const inBuff: TKDT84DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT84DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DE_BuildCall);
var
  TempStoreBuff: TKDT84DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT84DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT84DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT84DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT84DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DE_BuildMethod);
var
  TempStoreBuff: TKDT84DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT84DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT84DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT84DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT84DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DE_BuildProc);
var
  TempStoreBuff: TKDT84DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT84DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT84DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT84DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT84DE.Search(const Buff: TKDT84DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT84DE_Node;

var
  NearestNeighbour: PKDT84DE_Node;

  function FindParentNode(const BuffPtr: PKDT84DE_Vec; NodePtr: PKDT84DE_Node): PKDT84DE_Node;
  var
    Next       : PKDT84DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT84DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT84DE_Node; const BuffPtr: PKDT84DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT84DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT84DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT84DE_Vec; const p1, p2: PKDT84DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT84DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT84DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT84DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT84DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT84DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT84DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT84DE_Node(NearestNodes[0]);
    end;
end;

function TKDT84DE.Search(const Buff: TKDT84DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT84DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT84DE.Search(const Buff: TKDT84DE_Vec; var SearchedDistanceMin: Double): PKDT84DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT84DE.Search(const Buff: TKDT84DE_Vec): PKDT84DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT84DE.Search(const inBuff: TKDT84DE_DynamicVecBuffer; var OutBuff: TKDT84DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT84DE_DynamicVecBuffer;
  outBuffPtr : PKDT84DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT84DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT84DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT84DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT84DE.Search(const inBuff: TKDT84DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT84DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT84DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT84DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT84DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT84DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT84DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT84DE_Source));
end;

procedure TKDT84DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT84DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT84DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT84DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT84DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT84DE.PrintNodeTree(const NodePtr: PKDT84DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT84DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT84DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT84DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT84DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT84DE.KDT84DEVec(const s: string): TKDT84DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT84DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT84DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT84DE.KDT84DEVec(const v: TKDT84DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT84DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT84DE.KDT84DEPow(const v: TKDT84DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT84DE.KDT84DEDistance(const v1, v2: TKDT84DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT84DE_Axis - 1 do
      Result := Result + KDT84DEPow(v2[i] - v1[i]);
end;

procedure TKDT84DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT84DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT84DE.Test;
var
  TKDT84DE_Test    : TKDT84DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT84DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT84DE_Test := TKDT84DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT84DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT84DE_Test.TestBuff) - 1 do
    for j := 0 to KDT84DE_Axis - 1 do
        TKDT84DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT84DE_Test.TestBuff), length(TKDT84DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT84DE_Test.BuildKDTreeM(length(TKDT84DE_Test.TestBuff), nil, @TKDT84DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT84DE_Test.BuildKDTreeM(length(TKDT84DE_Test.TestBuff), nil, TKDT84DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT84DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT84DE_Test.TestBuff));
  TKDT84DE_Test.Search(TKDT84DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT84DEDistance(TKDT84DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT84DE_Test.Clear;
  { kMean test }
  TKDT84DE_Test.BuildKDTreeWithCluster(TKDT84DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT84DE_Test.Search(TKDT84DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT84DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT84DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT84DE_Test);
end;


function TKDT96DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DE_Node;
  function SortCompare(const p1, p2: PKDT96DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT96DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT96DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT96DE_SourceBuffer;
  dynBuff  : PKDT96DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT96DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT96DE.GetData(const index: NativeInt): PKDT96DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT96DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT96DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT96DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT96DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT96DE.StoreBuffPtr: PKDT96DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT96DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT96DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT96DE.BuildKDTreeWithCluster(const inBuff: TKDT96DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT96DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT96DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT96DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT96DE.BuildKDTreeWithCluster(const inBuff: TKDT96DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DE_BuildCall);
var
  TempStoreBuff: TKDT96DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT96DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DE_BuildMethod);
var
  TempStoreBuff: TKDT96DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT96DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DE_BuildProc);
var
  TempStoreBuff: TKDT96DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT96DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT96DE.Search(const Buff: TKDT96DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DE_Node;

var
  NearestNeighbour: PKDT96DE_Node;

  function FindParentNode(const BuffPtr: PKDT96DE_Vec; NodePtr: PKDT96DE_Node): PKDT96DE_Node;
  var
    Next       : PKDT96DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT96DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT96DE_Node; const BuffPtr: PKDT96DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT96DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT96DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT96DE_Vec; const p1, p2: PKDT96DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT96DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT96DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT96DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT96DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT96DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT96DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT96DE_Node(NearestNodes[0]);
    end;
end;

function TKDT96DE.Search(const Buff: TKDT96DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT96DE.Search(const Buff: TKDT96DE_Vec; var SearchedDistanceMin: Double): PKDT96DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT96DE.Search(const Buff: TKDT96DE_Vec): PKDT96DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT96DE.Search(const inBuff: TKDT96DE_DynamicVecBuffer; var OutBuff: TKDT96DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT96DE_DynamicVecBuffer;
  outBuffPtr : PKDT96DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT96DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT96DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DE.Search(const inBuff: TKDT96DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT96DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT96DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT96DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT96DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT96DE_Source));
end;

procedure TKDT96DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT96DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT96DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT96DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DE.PrintNodeTree(const NodePtr: PKDT96DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT96DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT96DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT96DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT96DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT96DE.KDT96DEVec(const s: string): TKDT96DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT96DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT96DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT96DE.KDT96DEVec(const v: TKDT96DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT96DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT96DE.KDT96DEPow(const v: TKDT96DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT96DE.KDT96DEDistance(const v1, v2: TKDT96DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT96DE_Axis - 1 do
      Result := Result + KDT96DEPow(v2[i] - v1[i]);
end;

procedure TKDT96DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT96DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT96DE.Test;
var
  TKDT96DE_Test    : TKDT96DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT96DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT96DE_Test := TKDT96DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT96DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT96DE_Test.TestBuff) - 1 do
    for j := 0 to KDT96DE_Axis - 1 do
        TKDT96DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT96DE_Test.TestBuff), length(TKDT96DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT96DE_Test.BuildKDTreeM(length(TKDT96DE_Test.TestBuff), nil, @TKDT96DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT96DE_Test.BuildKDTreeM(length(TKDT96DE_Test.TestBuff), nil, TKDT96DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT96DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT96DE_Test.TestBuff));
  TKDT96DE_Test.Search(TKDT96DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT96DEDistance(TKDT96DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT96DE_Test.Clear;
  { kMean test }
  TKDT96DE_Test.BuildKDTreeWithCluster(TKDT96DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT96DE_Test.Search(TKDT96DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT96DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT96DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT96DE_Test);
end;


function TKDT128DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DE_Node;
  function SortCompare(const p1, p2: PKDT128DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT128DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT128DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT128DE_SourceBuffer;
  dynBuff  : PKDT128DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT128DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT128DE.GetData(const index: NativeInt): PKDT128DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT128DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT128DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT128DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT128DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT128DE.StoreBuffPtr: PKDT128DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT128DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT128DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT128DE.BuildKDTreeWithCluster(const inBuff: TKDT128DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT128DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT128DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT128DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT128DE.BuildKDTreeWithCluster(const inBuff: TKDT128DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DE_BuildCall);
var
  TempStoreBuff: TKDT128DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT128DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DE_BuildMethod);
var
  TempStoreBuff: TKDT128DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT128DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DE_BuildProc);
var
  TempStoreBuff: TKDT128DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT128DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT128DE.Search(const Buff: TKDT128DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DE_Node;

var
  NearestNeighbour: PKDT128DE_Node;

  function FindParentNode(const BuffPtr: PKDT128DE_Vec; NodePtr: PKDT128DE_Node): PKDT128DE_Node;
  var
    Next       : PKDT128DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT128DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT128DE_Node; const BuffPtr: PKDT128DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT128DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT128DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT128DE_Vec; const p1, p2: PKDT128DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT128DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT128DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT128DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT128DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT128DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT128DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT128DE_Node(NearestNodes[0]);
    end;
end;

function TKDT128DE.Search(const Buff: TKDT128DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT128DE.Search(const Buff: TKDT128DE_Vec; var SearchedDistanceMin: Double): PKDT128DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT128DE.Search(const Buff: TKDT128DE_Vec): PKDT128DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT128DE.Search(const inBuff: TKDT128DE_DynamicVecBuffer; var OutBuff: TKDT128DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT128DE_DynamicVecBuffer;
  outBuffPtr : PKDT128DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT128DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT128DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DE.Search(const inBuff: TKDT128DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT128DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT128DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT128DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT128DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT128DE_Source));
end;

procedure TKDT128DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT128DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT128DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT128DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DE.PrintNodeTree(const NodePtr: PKDT128DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT128DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT128DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT128DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT128DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT128DE.KDT128DEVec(const s: string): TKDT128DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT128DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT128DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT128DE.KDT128DEVec(const v: TKDT128DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT128DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT128DE.KDT128DEPow(const v: TKDT128DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT128DE.KDT128DEDistance(const v1, v2: TKDT128DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT128DE_Axis - 1 do
      Result := Result + KDT128DEPow(v2[i] - v1[i]);
end;

procedure TKDT128DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT128DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT128DE.Test;
var
  TKDT128DE_Test    : TKDT128DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT128DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT128DE_Test := TKDT128DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT128DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT128DE_Test.TestBuff) - 1 do
    for j := 0 to KDT128DE_Axis - 1 do
        TKDT128DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT128DE_Test.TestBuff), length(TKDT128DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT128DE_Test.BuildKDTreeM(length(TKDT128DE_Test.TestBuff), nil, @TKDT128DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT128DE_Test.BuildKDTreeM(length(TKDT128DE_Test.TestBuff), nil, TKDT128DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT128DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT128DE_Test.TestBuff));
  TKDT128DE_Test.Search(TKDT128DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT128DEDistance(TKDT128DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT128DE_Test.Clear;
  { kMean test }
  TKDT128DE_Test.BuildKDTreeWithCluster(TKDT128DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT128DE_Test.Search(TKDT128DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT128DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT128DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT128DE_Test);
end;


function TKDT140DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT140DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT140DE_Node;
  function SortCompare(const p1, p2: PKDT140DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT140DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT140DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT140DE_SourceBuffer;
  dynBuff  : PKDT140DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT140DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT140DE.GetData(const index: NativeInt): PKDT140DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT140DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT140DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT140DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT140DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT140DE.StoreBuffPtr: PKDT140DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT140DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT140DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT140DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT140DE.BuildKDTreeWithCluster(const inBuff: TKDT140DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT140DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT140DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT140DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT140DE.BuildKDTreeWithCluster(const inBuff: TKDT140DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT140DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DE_BuildCall);
var
  TempStoreBuff: TKDT140DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT140DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT140DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT140DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT140DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DE_BuildMethod);
var
  TempStoreBuff: TKDT140DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT140DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT140DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT140DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT140DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DE_BuildProc);
var
  TempStoreBuff: TKDT140DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT140DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT140DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT140DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT140DE.Search(const Buff: TKDT140DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT140DE_Node;

var
  NearestNeighbour: PKDT140DE_Node;

  function FindParentNode(const BuffPtr: PKDT140DE_Vec; NodePtr: PKDT140DE_Node): PKDT140DE_Node;
  var
    Next       : PKDT140DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT140DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT140DE_Node; const BuffPtr: PKDT140DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT140DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT140DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT140DE_Vec; const p1, p2: PKDT140DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT140DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT140DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT140DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT140DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT140DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT140DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT140DE_Node(NearestNodes[0]);
    end;
end;

function TKDT140DE.Search(const Buff: TKDT140DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT140DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT140DE.Search(const Buff: TKDT140DE_Vec; var SearchedDistanceMin: Double): PKDT140DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT140DE.Search(const Buff: TKDT140DE_Vec): PKDT140DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT140DE.Search(const inBuff: TKDT140DE_DynamicVecBuffer; var OutBuff: TKDT140DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT140DE_DynamicVecBuffer;
  outBuffPtr : PKDT140DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT140DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT140DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT140DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT140DE.Search(const inBuff: TKDT140DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT140DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT140DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT140DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT140DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT140DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT140DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT140DE_Source));
end;

procedure TKDT140DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT140DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT140DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT140DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT140DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT140DE.PrintNodeTree(const NodePtr: PKDT140DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT140DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT140DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT140DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT140DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT140DE.KDT140DEVec(const s: string): TKDT140DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT140DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT140DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT140DE.KDT140DEVec(const v: TKDT140DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT140DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT140DE.KDT140DEPow(const v: TKDT140DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT140DE.KDT140DEDistance(const v1, v2: TKDT140DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT140DE_Axis - 1 do
      Result := Result + KDT140DEPow(v2[i] - v1[i]);
end;

procedure TKDT140DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT140DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT140DE.Test;
var
  TKDT140DE_Test    : TKDT140DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT140DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT140DE_Test := TKDT140DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT140DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT140DE_Test.TestBuff) - 1 do
    for j := 0 to KDT140DE_Axis - 1 do
        TKDT140DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT140DE_Test.TestBuff), length(TKDT140DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT140DE_Test.BuildKDTreeM(length(TKDT140DE_Test.TestBuff), nil, @TKDT140DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT140DE_Test.BuildKDTreeM(length(TKDT140DE_Test.TestBuff), nil, TKDT140DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT140DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT140DE_Test.TestBuff));
  TKDT140DE_Test.Search(TKDT140DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT140DEDistance(TKDT140DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT140DE_Test.Clear;
  { kMean test }
  TKDT140DE_Test.BuildKDTreeWithCluster(TKDT140DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT140DE_Test.Search(TKDT140DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT140DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT140DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT140DE_Test);
end;


function TKDT160DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT160DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT160DE_Node;
  function SortCompare(const p1, p2: PKDT160DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT160DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT160DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT160DE_SourceBuffer;
  dynBuff  : PKDT160DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT160DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT160DE.GetData(const index: NativeInt): PKDT160DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT160DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT160DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT160DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT160DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT160DE.StoreBuffPtr: PKDT160DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT160DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT160DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT160DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT160DE.BuildKDTreeWithCluster(const inBuff: TKDT160DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT160DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT160DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT160DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT160DE.BuildKDTreeWithCluster(const inBuff: TKDT160DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT160DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DE_BuildCall);
var
  TempStoreBuff: TKDT160DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT160DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT160DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT160DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT160DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DE_BuildMethod);
var
  TempStoreBuff: TKDT160DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT160DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT160DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT160DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT160DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DE_BuildProc);
var
  TempStoreBuff: TKDT160DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT160DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT160DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT160DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT160DE.Search(const Buff: TKDT160DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT160DE_Node;

var
  NearestNeighbour: PKDT160DE_Node;

  function FindParentNode(const BuffPtr: PKDT160DE_Vec; NodePtr: PKDT160DE_Node): PKDT160DE_Node;
  var
    Next       : PKDT160DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT160DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT160DE_Node; const BuffPtr: PKDT160DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT160DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT160DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT160DE_Vec; const p1, p2: PKDT160DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT160DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT160DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT160DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT160DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT160DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT160DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT160DE_Node(NearestNodes[0]);
    end;
end;

function TKDT160DE.Search(const Buff: TKDT160DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT160DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT160DE.Search(const Buff: TKDT160DE_Vec; var SearchedDistanceMin: Double): PKDT160DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT160DE.Search(const Buff: TKDT160DE_Vec): PKDT160DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT160DE.Search(const inBuff: TKDT160DE_DynamicVecBuffer; var OutBuff: TKDT160DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT160DE_DynamicVecBuffer;
  outBuffPtr : PKDT160DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT160DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT160DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT160DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT160DE.Search(const inBuff: TKDT160DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT160DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT160DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT160DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT160DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT160DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT160DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT160DE_Source));
end;

procedure TKDT160DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT160DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT160DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT160DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT160DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT160DE.PrintNodeTree(const NodePtr: PKDT160DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT160DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT160DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT160DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT160DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT160DE.KDT160DEVec(const s: string): TKDT160DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT160DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT160DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT160DE.KDT160DEVec(const v: TKDT160DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT160DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT160DE.KDT160DEPow(const v: TKDT160DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT160DE.KDT160DEDistance(const v1, v2: TKDT160DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT160DE_Axis - 1 do
      Result := Result + KDT160DEPow(v2[i] - v1[i]);
end;

procedure TKDT160DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT160DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT160DE.Test;
var
  TKDT160DE_Test    : TKDT160DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT160DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT160DE_Test := TKDT160DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT160DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT160DE_Test.TestBuff) - 1 do
    for j := 0 to KDT160DE_Axis - 1 do
        TKDT160DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT160DE_Test.TestBuff), length(TKDT160DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT160DE_Test.BuildKDTreeM(length(TKDT160DE_Test.TestBuff), nil, @TKDT160DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT160DE_Test.BuildKDTreeM(length(TKDT160DE_Test.TestBuff), nil, TKDT160DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT160DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT160DE_Test.TestBuff));
  TKDT160DE_Test.Search(TKDT160DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT160DEDistance(TKDT160DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT160DE_Test.Clear;
  { kMean test }
  TKDT160DE_Test.BuildKDTreeWithCluster(TKDT160DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT160DE_Test.Search(TKDT160DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT160DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT160DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT160DE_Test);
end;


function TKDT196DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT196DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT196DE_Node;
  function SortCompare(const p1, p2: PKDT196DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT196DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT196DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT196DE_SourceBuffer;
  dynBuff  : PKDT196DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT196DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT196DE.GetData(const index: NativeInt): PKDT196DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT196DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT196DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT196DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT196DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT196DE.StoreBuffPtr: PKDT196DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT196DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT196DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT196DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT196DE.BuildKDTreeWithCluster(const inBuff: TKDT196DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT196DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT196DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT196DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT196DE.BuildKDTreeWithCluster(const inBuff: TKDT196DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT196DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DE_BuildCall);
var
  TempStoreBuff: TKDT196DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT196DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT196DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT196DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT196DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DE_BuildMethod);
var
  TempStoreBuff: TKDT196DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT196DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT196DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT196DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT196DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DE_BuildProc);
var
  TempStoreBuff: TKDT196DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT196DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT196DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT196DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT196DE.Search(const Buff: TKDT196DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT196DE_Node;

var
  NearestNeighbour: PKDT196DE_Node;

  function FindParentNode(const BuffPtr: PKDT196DE_Vec; NodePtr: PKDT196DE_Node): PKDT196DE_Node;
  var
    Next       : PKDT196DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT196DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT196DE_Node; const BuffPtr: PKDT196DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT196DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT196DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT196DE_Vec; const p1, p2: PKDT196DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT196DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT196DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT196DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT196DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT196DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT196DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT196DE_Node(NearestNodes[0]);
    end;
end;

function TKDT196DE.Search(const Buff: TKDT196DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT196DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT196DE.Search(const Buff: TKDT196DE_Vec; var SearchedDistanceMin: Double): PKDT196DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT196DE.Search(const Buff: TKDT196DE_Vec): PKDT196DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT196DE.Search(const inBuff: TKDT196DE_DynamicVecBuffer; var OutBuff: TKDT196DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT196DE_DynamicVecBuffer;
  outBuffPtr : PKDT196DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT196DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT196DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT196DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT196DE.Search(const inBuff: TKDT196DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT196DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT196DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT196DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT196DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT196DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT196DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT196DE_Source));
end;

procedure TKDT196DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT196DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT196DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT196DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT196DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT196DE.PrintNodeTree(const NodePtr: PKDT196DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT196DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT196DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT196DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT196DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT196DE.KDT196DEVec(const s: string): TKDT196DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT196DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT196DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT196DE.KDT196DEVec(const v: TKDT196DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT196DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT196DE.KDT196DEPow(const v: TKDT196DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT196DE.KDT196DEDistance(const v1, v2: TKDT196DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT196DE_Axis - 1 do
      Result := Result + KDT196DEPow(v2[i] - v1[i]);
end;

procedure TKDT196DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT196DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT196DE.Test;
var
  TKDT196DE_Test    : TKDT196DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT196DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT196DE_Test := TKDT196DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT196DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT196DE_Test.TestBuff) - 1 do
    for j := 0 to KDT196DE_Axis - 1 do
        TKDT196DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT196DE_Test.TestBuff), length(TKDT196DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT196DE_Test.BuildKDTreeM(length(TKDT196DE_Test.TestBuff), nil, @TKDT196DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT196DE_Test.BuildKDTreeM(length(TKDT196DE_Test.TestBuff), nil, TKDT196DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT196DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT196DE_Test.TestBuff));
  TKDT196DE_Test.Search(TKDT196DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT196DEDistance(TKDT196DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT196DE_Test.Clear;
  { kMean test }
  TKDT196DE_Test.BuildKDTreeWithCluster(TKDT196DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT196DE_Test.Search(TKDT196DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT196DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT196DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT196DE_Test);
end;


function TKDT256DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DE_Node;
  function SortCompare(const p1, p2: PKDT256DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT256DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT256DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT256DE_SourceBuffer;
  dynBuff  : PKDT256DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT256DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT256DE.GetData(const index: NativeInt): PKDT256DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT256DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT256DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT256DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT256DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT256DE.StoreBuffPtr: PKDT256DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT256DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT256DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT256DE.BuildKDTreeWithCluster(const inBuff: TKDT256DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT256DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT256DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT256DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT256DE.BuildKDTreeWithCluster(const inBuff: TKDT256DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DE_BuildCall);
var
  TempStoreBuff: TKDT256DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT256DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DE_BuildMethod);
var
  TempStoreBuff: TKDT256DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT256DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DE_BuildProc);
var
  TempStoreBuff: TKDT256DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT256DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT256DE.Search(const Buff: TKDT256DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DE_Node;

var
  NearestNeighbour: PKDT256DE_Node;

  function FindParentNode(const BuffPtr: PKDT256DE_Vec; NodePtr: PKDT256DE_Node): PKDT256DE_Node;
  var
    Next       : PKDT256DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT256DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT256DE_Node; const BuffPtr: PKDT256DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT256DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT256DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT256DE_Vec; const p1, p2: PKDT256DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT256DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT256DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT256DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT256DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT256DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT256DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT256DE_Node(NearestNodes[0]);
    end;
end;

function TKDT256DE.Search(const Buff: TKDT256DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT256DE.Search(const Buff: TKDT256DE_Vec; var SearchedDistanceMin: Double): PKDT256DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT256DE.Search(const Buff: TKDT256DE_Vec): PKDT256DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT256DE.Search(const inBuff: TKDT256DE_DynamicVecBuffer; var OutBuff: TKDT256DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT256DE_DynamicVecBuffer;
  outBuffPtr : PKDT256DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT256DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT256DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DE.Search(const inBuff: TKDT256DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT256DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT256DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT256DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT256DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT256DE_Source));
end;

procedure TKDT256DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT256DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT256DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT256DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DE.PrintNodeTree(const NodePtr: PKDT256DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT256DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT256DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT256DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT256DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT256DE.KDT256DEVec(const s: string): TKDT256DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT256DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT256DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT256DE.KDT256DEVec(const v: TKDT256DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT256DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT256DE.KDT256DEPow(const v: TKDT256DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT256DE.KDT256DEDistance(const v1, v2: TKDT256DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT256DE_Axis - 1 do
      Result := Result + KDT256DEPow(v2[i] - v1[i]);
end;

procedure TKDT256DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT256DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT256DE.Test;
var
  TKDT256DE_Test    : TKDT256DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT256DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT256DE_Test := TKDT256DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT256DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT256DE_Test.TestBuff) - 1 do
    for j := 0 to KDT256DE_Axis - 1 do
        TKDT256DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT256DE_Test.TestBuff), length(TKDT256DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT256DE_Test.BuildKDTreeM(length(TKDT256DE_Test.TestBuff), nil, @TKDT256DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT256DE_Test.BuildKDTreeM(length(TKDT256DE_Test.TestBuff), nil, TKDT256DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT256DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT256DE_Test.TestBuff));
  TKDT256DE_Test.Search(TKDT256DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT256DEDistance(TKDT256DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT256DE_Test.Clear;
  { kMean test }
  TKDT256DE_Test.BuildKDTreeWithCluster(TKDT256DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT256DE_Test.Search(TKDT256DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT256DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT256DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT256DE_Test);
end;


function TKDT272DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT272DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT272DE_Node;
  function SortCompare(const p1, p2: PKDT272DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT272DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT272DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT272DE_SourceBuffer;
  dynBuff  : PKDT272DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT272DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT272DE.GetData(const index: NativeInt): PKDT272DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT272DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT272DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT272DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT272DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT272DE.StoreBuffPtr: PKDT272DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT272DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT272DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT272DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT272DE.BuildKDTreeWithCluster(const inBuff: TKDT272DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT272DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT272DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT272DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT272DE.BuildKDTreeWithCluster(const inBuff: TKDT272DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT272DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DE_BuildCall);
var
  TempStoreBuff: TKDT272DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT272DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT272DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT272DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT272DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DE_BuildMethod);
var
  TempStoreBuff: TKDT272DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT272DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT272DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT272DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT272DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DE_BuildProc);
var
  TempStoreBuff: TKDT272DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT272DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT272DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT272DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT272DE.Search(const Buff: TKDT272DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT272DE_Node;

var
  NearestNeighbour: PKDT272DE_Node;

  function FindParentNode(const BuffPtr: PKDT272DE_Vec; NodePtr: PKDT272DE_Node): PKDT272DE_Node;
  var
    Next       : PKDT272DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT272DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT272DE_Node; const BuffPtr: PKDT272DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT272DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT272DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT272DE_Vec; const p1, p2: PKDT272DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT272DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT272DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT272DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT272DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT272DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT272DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT272DE_Node(NearestNodes[0]);
    end;
end;

function TKDT272DE.Search(const Buff: TKDT272DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT272DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT272DE.Search(const Buff: TKDT272DE_Vec; var SearchedDistanceMin: Double): PKDT272DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT272DE.Search(const Buff: TKDT272DE_Vec): PKDT272DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT272DE.Search(const inBuff: TKDT272DE_DynamicVecBuffer; var OutBuff: TKDT272DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT272DE_DynamicVecBuffer;
  outBuffPtr : PKDT272DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT272DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT272DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT272DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT272DE.Search(const inBuff: TKDT272DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT272DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT272DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT272DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT272DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT272DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT272DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT272DE_Source));
end;

procedure TKDT272DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT272DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT272DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT272DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT272DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT272DE.PrintNodeTree(const NodePtr: PKDT272DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT272DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT272DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT272DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT272DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT272DE.KDT272DEVec(const s: string): TKDT272DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT272DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT272DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT272DE.KDT272DEVec(const v: TKDT272DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT272DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT272DE.KDT272DEPow(const v: TKDT272DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT272DE.KDT272DEDistance(const v1, v2: TKDT272DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT272DE_Axis - 1 do
      Result := Result + KDT272DEPow(v2[i] - v1[i]);
end;

procedure TKDT272DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT272DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT272DE.Test;
var
  TKDT272DE_Test    : TKDT272DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT272DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT272DE_Test := TKDT272DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT272DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT272DE_Test.TestBuff) - 1 do
    for j := 0 to KDT272DE_Axis - 1 do
        TKDT272DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT272DE_Test.TestBuff), length(TKDT272DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT272DE_Test.BuildKDTreeM(length(TKDT272DE_Test.TestBuff), nil, @TKDT272DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT272DE_Test.BuildKDTreeM(length(TKDT272DE_Test.TestBuff), nil, TKDT272DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT272DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT272DE_Test.TestBuff));
  TKDT272DE_Test.Search(TKDT272DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT272DEDistance(TKDT272DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT272DE_Test.Clear;
  { kMean test }
  TKDT272DE_Test.BuildKDTreeWithCluster(TKDT272DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT272DE_Test.Search(TKDT272DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT272DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT272DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT272DE_Test);
end;


function TKDT288DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT288DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT288DE_Node;
  function SortCompare(const p1, p2: PKDT288DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT288DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT288DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT288DE_SourceBuffer;
  dynBuff  : PKDT288DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT288DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT288DE.GetData(const index: NativeInt): PKDT288DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT288DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT288DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT288DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT288DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT288DE.StoreBuffPtr: PKDT288DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT288DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT288DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT288DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT288DE.BuildKDTreeWithCluster(const inBuff: TKDT288DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT288DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT288DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT288DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT288DE.BuildKDTreeWithCluster(const inBuff: TKDT288DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT288DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DE_BuildCall);
var
  TempStoreBuff: TKDT288DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT288DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT288DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT288DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT288DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DE_BuildMethod);
var
  TempStoreBuff: TKDT288DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT288DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT288DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT288DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT288DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DE_BuildProc);
var
  TempStoreBuff: TKDT288DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT288DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT288DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT288DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT288DE.Search(const Buff: TKDT288DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT288DE_Node;

var
  NearestNeighbour: PKDT288DE_Node;

  function FindParentNode(const BuffPtr: PKDT288DE_Vec; NodePtr: PKDT288DE_Node): PKDT288DE_Node;
  var
    Next       : PKDT288DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT288DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT288DE_Node; const BuffPtr: PKDT288DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT288DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT288DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT288DE_Vec; const p1, p2: PKDT288DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT288DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT288DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT288DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT288DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT288DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT288DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT288DE_Node(NearestNodes[0]);
    end;
end;

function TKDT288DE.Search(const Buff: TKDT288DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT288DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT288DE.Search(const Buff: TKDT288DE_Vec; var SearchedDistanceMin: Double): PKDT288DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT288DE.Search(const Buff: TKDT288DE_Vec): PKDT288DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT288DE.Search(const inBuff: TKDT288DE_DynamicVecBuffer; var OutBuff: TKDT288DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT288DE_DynamicVecBuffer;
  outBuffPtr : PKDT288DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT288DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT288DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT288DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT288DE.Search(const inBuff: TKDT288DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT288DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT288DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT288DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT288DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT288DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT288DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT288DE_Source));
end;

procedure TKDT288DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT288DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT288DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT288DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT288DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT288DE.PrintNodeTree(const NodePtr: PKDT288DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT288DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT288DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT288DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT288DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT288DE.KDT288DEVec(const s: string): TKDT288DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT288DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT288DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT288DE.KDT288DEVec(const v: TKDT288DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT288DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT288DE.KDT288DEPow(const v: TKDT288DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT288DE.KDT288DEDistance(const v1, v2: TKDT288DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT288DE_Axis - 1 do
      Result := Result + KDT288DEPow(v2[i] - v1[i]);
end;

procedure TKDT288DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT288DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT288DE.Test;
var
  TKDT288DE_Test    : TKDT288DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT288DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT288DE_Test := TKDT288DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT288DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT288DE_Test.TestBuff) - 1 do
    for j := 0 to KDT288DE_Axis - 1 do
        TKDT288DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT288DE_Test.TestBuff), length(TKDT288DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT288DE_Test.BuildKDTreeM(length(TKDT288DE_Test.TestBuff), nil, @TKDT288DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT288DE_Test.BuildKDTreeM(length(TKDT288DE_Test.TestBuff), nil, TKDT288DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT288DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT288DE_Test.TestBuff));
  TKDT288DE_Test.Search(TKDT288DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT288DEDistance(TKDT288DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT288DE_Test.Clear;
  { kMean test }
  TKDT288DE_Test.BuildKDTreeWithCluster(TKDT288DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT288DE_Test.Search(TKDT288DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT288DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT288DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT288DE_Test);
end;


function TKDT372DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DE_Node;
  function SortCompare(const p1, p2: PKDT372DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT372DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT372DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT372DE_SourceBuffer;
  dynBuff  : PKDT372DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT372DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT372DE.GetData(const index: NativeInt): PKDT372DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT372DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT372DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT372DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT372DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT372DE.StoreBuffPtr: PKDT372DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT372DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT372DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT372DE.BuildKDTreeWithCluster(const inBuff: TKDT372DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT372DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT372DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT372DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT372DE.BuildKDTreeWithCluster(const inBuff: TKDT372DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DE_BuildCall);
var
  TempStoreBuff: TKDT372DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT372DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT372DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT372DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DE_BuildMethod);
var
  TempStoreBuff: TKDT372DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT372DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT372DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT372DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DE_BuildProc);
var
  TempStoreBuff: TKDT372DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT372DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT372DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT372DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT372DE.Search(const Buff: TKDT372DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DE_Node;

var
  NearestNeighbour: PKDT372DE_Node;

  function FindParentNode(const BuffPtr: PKDT372DE_Vec; NodePtr: PKDT372DE_Node): PKDT372DE_Node;
  var
    Next       : PKDT372DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT372DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT372DE_Node; const BuffPtr: PKDT372DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT372DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT372DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT372DE_Vec; const p1, p2: PKDT372DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT372DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT372DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT372DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT372DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT372DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT372DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT372DE_Node(NearestNodes[0]);
    end;
end;

function TKDT372DE.Search(const Buff: TKDT372DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT372DE.Search(const Buff: TKDT372DE_Vec; var SearchedDistanceMin: Double): PKDT372DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT372DE.Search(const Buff: TKDT372DE_Vec): PKDT372DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT372DE.Search(const inBuff: TKDT372DE_DynamicVecBuffer; var OutBuff: TKDT372DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT372DE_DynamicVecBuffer;
  outBuffPtr : PKDT372DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT372DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT372DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT372DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT372DE.Search(const inBuff: TKDT372DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT372DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT372DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT372DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT372DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT372DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT372DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT372DE_Source));
end;

procedure TKDT372DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT372DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT372DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT372DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT372DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT372DE.PrintNodeTree(const NodePtr: PKDT372DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT372DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT372DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT372DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT372DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT372DE.KDT372DEVec(const s: string): TKDT372DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT372DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT372DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT372DE.KDT372DEVec(const v: TKDT372DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT372DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT372DE.KDT372DEPow(const v: TKDT372DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT372DE.KDT372DEDistance(const v1, v2: TKDT372DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT372DE_Axis - 1 do
      Result := Result + KDT372DEPow(v2[i] - v1[i]);
end;

procedure TKDT372DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT372DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT372DE.Test;
var
  TKDT372DE_Test    : TKDT372DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT372DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT372DE_Test := TKDT372DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT372DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT372DE_Test.TestBuff) - 1 do
    for j := 0 to KDT372DE_Axis - 1 do
        TKDT372DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT372DE_Test.TestBuff), length(TKDT372DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT372DE_Test.BuildKDTreeM(length(TKDT372DE_Test.TestBuff), nil, @TKDT372DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT372DE_Test.BuildKDTreeM(length(TKDT372DE_Test.TestBuff), nil, TKDT372DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT372DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT372DE_Test.TestBuff));
  TKDT372DE_Test.Search(TKDT372DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT372DEDistance(TKDT372DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT372DE_Test.Clear;
  { kMean test }
  TKDT372DE_Test.BuildKDTreeWithCluster(TKDT372DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT372DE_Test.Search(TKDT372DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT372DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT372DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT372DE_Test);
end;


function TKDT512DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DE_Node;
  function SortCompare(const p1, p2: PKDT512DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT512DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT512DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT512DE_SourceBuffer;
  dynBuff  : PKDT512DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT512DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT512DE.GetData(const index: NativeInt): PKDT512DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT512DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT512DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT512DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT512DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT512DE.StoreBuffPtr: PKDT512DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT512DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT512DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT512DE.BuildKDTreeWithCluster(const inBuff: TKDT512DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT512DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT512DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT512DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT512DE.BuildKDTreeWithCluster(const inBuff: TKDT512DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DE_BuildCall);
var
  TempStoreBuff: TKDT512DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT512DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DE_BuildMethod);
var
  TempStoreBuff: TKDT512DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT512DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DE_BuildProc);
var
  TempStoreBuff: TKDT512DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT512DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT512DE.Search(const Buff: TKDT512DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DE_Node;

var
  NearestNeighbour: PKDT512DE_Node;

  function FindParentNode(const BuffPtr: PKDT512DE_Vec; NodePtr: PKDT512DE_Node): PKDT512DE_Node;
  var
    Next       : PKDT512DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT512DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT512DE_Node; const BuffPtr: PKDT512DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT512DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT512DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT512DE_Vec; const p1, p2: PKDT512DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT512DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT512DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT512DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT512DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT512DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT512DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT512DE_Node(NearestNodes[0]);
    end;
end;

function TKDT512DE.Search(const Buff: TKDT512DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT512DE.Search(const Buff: TKDT512DE_Vec; var SearchedDistanceMin: Double): PKDT512DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT512DE.Search(const Buff: TKDT512DE_Vec): PKDT512DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT512DE.Search(const inBuff: TKDT512DE_DynamicVecBuffer; var OutBuff: TKDT512DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT512DE_DynamicVecBuffer;
  outBuffPtr : PKDT512DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT512DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT512DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DE.Search(const inBuff: TKDT512DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT512DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT512DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT512DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT512DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT512DE_Source));
end;

procedure TKDT512DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT512DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT512DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT512DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DE.PrintNodeTree(const NodePtr: PKDT512DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT512DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT512DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT512DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT512DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT512DE.KDT512DEVec(const s: string): TKDT512DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT512DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT512DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT512DE.KDT512DEVec(const v: TKDT512DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT512DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT512DE.KDT512DEPow(const v: TKDT512DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT512DE.KDT512DEDistance(const v1, v2: TKDT512DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT512DE_Axis - 1 do
      Result := Result + KDT512DEPow(v2[i] - v1[i]);
end;

procedure TKDT512DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT512DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT512DE.Test;
var
  TKDT512DE_Test    : TKDT512DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT512DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT512DE_Test := TKDT512DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT512DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT512DE_Test.TestBuff) - 1 do
    for j := 0 to KDT512DE_Axis - 1 do
        TKDT512DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT512DE_Test.TestBuff), length(TKDT512DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT512DE_Test.BuildKDTreeM(length(TKDT512DE_Test.TestBuff), nil, @TKDT512DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT512DE_Test.BuildKDTreeM(length(TKDT512DE_Test.TestBuff), nil, TKDT512DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT512DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT512DE_Test.TestBuff));
  TKDT512DE_Test.Search(TKDT512DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT512DEDistance(TKDT512DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT512DE_Test.Clear;
  { kMean test }
  TKDT512DE_Test.BuildKDTreeWithCluster(TKDT512DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT512DE_Test.Search(TKDT512DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT512DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT512DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT512DE_Test);
end;


function TKDT576DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT576DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT576DE_Node;
  function SortCompare(const p1, p2: PKDT576DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT576DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT576DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT576DE_SourceBuffer;
  dynBuff  : PKDT576DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT576DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT576DE.GetData(const index: NativeInt): PKDT576DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT576DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT576DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT576DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT576DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT576DE.StoreBuffPtr: PKDT576DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT576DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT576DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT576DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT576DE.BuildKDTreeWithCluster(const inBuff: TKDT576DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT576DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT576DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT576DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT576DE.BuildKDTreeWithCluster(const inBuff: TKDT576DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT576DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DE_BuildCall);
var
  TempStoreBuff: TKDT576DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT576DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT576DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT576DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT576DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DE_BuildMethod);
var
  TempStoreBuff: TKDT576DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT576DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT576DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT576DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT576DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DE_BuildProc);
var
  TempStoreBuff: TKDT576DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT576DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT576DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT576DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT576DE.Search(const Buff: TKDT576DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT576DE_Node;

var
  NearestNeighbour: PKDT576DE_Node;

  function FindParentNode(const BuffPtr: PKDT576DE_Vec; NodePtr: PKDT576DE_Node): PKDT576DE_Node;
  var
    Next       : PKDT576DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT576DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT576DE_Node; const BuffPtr: PKDT576DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT576DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT576DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT576DE_Vec; const p1, p2: PKDT576DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT576DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT576DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT576DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT576DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT576DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT576DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT576DE_Node(NearestNodes[0]);
    end;
end;

function TKDT576DE.Search(const Buff: TKDT576DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT576DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT576DE.Search(const Buff: TKDT576DE_Vec; var SearchedDistanceMin: Double): PKDT576DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT576DE.Search(const Buff: TKDT576DE_Vec): PKDT576DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT576DE.Search(const inBuff: TKDT576DE_DynamicVecBuffer; var OutBuff: TKDT576DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT576DE_DynamicVecBuffer;
  outBuffPtr : PKDT576DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT576DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT576DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT576DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT576DE.Search(const inBuff: TKDT576DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT576DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT576DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT576DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT576DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT576DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT576DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT576DE_Source));
end;

procedure TKDT576DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT576DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT576DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT576DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT576DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT576DE.PrintNodeTree(const NodePtr: PKDT576DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT576DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT576DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT576DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT576DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT576DE.KDT576DEVec(const s: string): TKDT576DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT576DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT576DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT576DE.KDT576DEVec(const v: TKDT576DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT576DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT576DE.KDT576DEPow(const v: TKDT576DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT576DE.KDT576DEDistance(const v1, v2: TKDT576DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT576DE_Axis - 1 do
      Result := Result + KDT576DEPow(v2[i] - v1[i]);
end;

procedure TKDT576DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT576DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT576DE.Test;
var
  TKDT576DE_Test    : TKDT576DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT576DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT576DE_Test := TKDT576DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT576DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT576DE_Test.TestBuff) - 1 do
    for j := 0 to KDT576DE_Axis - 1 do
        TKDT576DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT576DE_Test.TestBuff), length(TKDT576DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT576DE_Test.BuildKDTreeM(length(TKDT576DE_Test.TestBuff), nil, @TKDT576DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT576DE_Test.BuildKDTreeM(length(TKDT576DE_Test.TestBuff), nil, TKDT576DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT576DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT576DE_Test.TestBuff));
  TKDT576DE_Test.Search(TKDT576DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT576DEDistance(TKDT576DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT576DE_Test.Clear;
  { kMean test }
  TKDT576DE_Test.BuildKDTreeWithCluster(TKDT576DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT576DE_Test.Search(TKDT576DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT576DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT576DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT576DE_Test);
end;


function TKDT768DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DE_Node;
  function SortCompare(const p1, p2: PKDT768DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT768DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT768DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT768DE_SourceBuffer;
  dynBuff  : PKDT768DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT768DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT768DE.GetData(const index: NativeInt): PKDT768DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT768DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT768DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT768DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT768DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT768DE.StoreBuffPtr: PKDT768DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT768DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT768DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT768DE.BuildKDTreeWithCluster(const inBuff: TKDT768DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT768DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT768DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT768DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT768DE.BuildKDTreeWithCluster(const inBuff: TKDT768DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DE_BuildCall);
var
  TempStoreBuff: TKDT768DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT768DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT768DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT768DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DE_BuildMethod);
var
  TempStoreBuff: TKDT768DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT768DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT768DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT768DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DE_BuildProc);
var
  TempStoreBuff: TKDT768DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT768DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT768DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT768DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT768DE.Search(const Buff: TKDT768DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DE_Node;

var
  NearestNeighbour: PKDT768DE_Node;

  function FindParentNode(const BuffPtr: PKDT768DE_Vec; NodePtr: PKDT768DE_Node): PKDT768DE_Node;
  var
    Next       : PKDT768DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT768DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT768DE_Node; const BuffPtr: PKDT768DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT768DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT768DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT768DE_Vec; const p1, p2: PKDT768DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT768DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT768DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT768DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT768DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT768DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT768DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT768DE_Node(NearestNodes[0]);
    end;
end;

function TKDT768DE.Search(const Buff: TKDT768DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT768DE.Search(const Buff: TKDT768DE_Vec; var SearchedDistanceMin: Double): PKDT768DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT768DE.Search(const Buff: TKDT768DE_Vec): PKDT768DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT768DE.Search(const inBuff: TKDT768DE_DynamicVecBuffer; var OutBuff: TKDT768DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT768DE_DynamicVecBuffer;
  outBuffPtr : PKDT768DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT768DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT768DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT768DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT768DE.Search(const inBuff: TKDT768DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT768DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT768DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT768DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT768DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT768DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT768DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT768DE_Source));
end;

procedure TKDT768DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT768DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT768DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT768DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT768DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT768DE.PrintNodeTree(const NodePtr: PKDT768DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT768DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT768DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT768DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT768DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT768DE.KDT768DEVec(const s: string): TKDT768DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT768DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT768DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT768DE.KDT768DEVec(const v: TKDT768DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT768DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT768DE.KDT768DEPow(const v: TKDT768DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT768DE.KDT768DEDistance(const v1, v2: TKDT768DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT768DE_Axis - 1 do
      Result := Result + KDT768DEPow(v2[i] - v1[i]);
end;

procedure TKDT768DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT768DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT768DE.Test;
var
  TKDT768DE_Test    : TKDT768DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT768DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT768DE_Test := TKDT768DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT768DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT768DE_Test.TestBuff) - 1 do
    for j := 0 to KDT768DE_Axis - 1 do
        TKDT768DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT768DE_Test.TestBuff), length(TKDT768DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT768DE_Test.BuildKDTreeM(length(TKDT768DE_Test.TestBuff), nil, @TKDT768DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT768DE_Test.BuildKDTreeM(length(TKDT768DE_Test.TestBuff), nil, TKDT768DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT768DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT768DE_Test.TestBuff));
  TKDT768DE_Test.Search(TKDT768DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT768DEDistance(TKDT768DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT768DE_Test.Clear;
  { kMean test }
  TKDT768DE_Test.BuildKDTreeWithCluster(TKDT768DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT768DE_Test.Search(TKDT768DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT768DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT768DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT768DE_Test);
end;


function TKDT1024DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DE_Node;
  function SortCompare(const p1, p2: PKDT1024DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1024DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1024DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1024DE_SourceBuffer;
  dynBuff  : PKDT1024DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1024DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1024DE.GetData(const index: NativeInt): PKDT1024DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1024DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1024DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1024DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1024DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1024DE.StoreBuffPtr: PKDT1024DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1024DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1024DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1024DE.BuildKDTreeWithCluster(const inBuff: TKDT1024DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1024DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1024DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1024DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1024DE.BuildKDTreeWithCluster(const inBuff: TKDT1024DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DE_BuildCall);
var
  TempStoreBuff: TKDT1024DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1024DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DE_BuildMethod);
var
  TempStoreBuff: TKDT1024DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1024DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DE_BuildProc);
var
  TempStoreBuff: TKDT1024DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1024DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1024DE.Search(const Buff: TKDT1024DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DE_Node;

var
  NearestNeighbour: PKDT1024DE_Node;

  function FindParentNode(const BuffPtr: PKDT1024DE_Vec; NodePtr: PKDT1024DE_Node): PKDT1024DE_Node;
  var
    Next       : PKDT1024DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1024DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1024DE_Node; const BuffPtr: PKDT1024DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1024DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1024DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1024DE_Vec; const p1, p2: PKDT1024DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1024DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1024DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1024DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1024DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1024DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1024DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1024DE_Node(NearestNodes[0]);
    end;
end;

function TKDT1024DE.Search(const Buff: TKDT1024DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1024DE.Search(const Buff: TKDT1024DE_Vec; var SearchedDistanceMin: Double): PKDT1024DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1024DE.Search(const Buff: TKDT1024DE_Vec): PKDT1024DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1024DE.Search(const inBuff: TKDT1024DE_DynamicVecBuffer; var OutBuff: TKDT1024DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1024DE_DynamicVecBuffer;
  outBuffPtr : PKDT1024DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1024DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1024DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DE.Search(const inBuff: TKDT1024DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1024DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1024DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1024DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1024DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1024DE_Source));
end;

procedure TKDT1024DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1024DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1024DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1024DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DE.PrintNodeTree(const NodePtr: PKDT1024DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1024DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1024DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1024DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1024DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1024DE.KDT1024DEVec(const s: string): TKDT1024DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1024DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1024DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1024DE.KDT1024DEVec(const v: TKDT1024DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1024DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1024DE.KDT1024DEPow(const v: TKDT1024DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1024DE.KDT1024DEDistance(const v1, v2: TKDT1024DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1024DE_Axis - 1 do
      Result := Result + KDT1024DEPow(v2[i] - v1[i]);
end;

procedure TKDT1024DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1024DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1024DE.Test;
var
  TKDT1024DE_Test    : TKDT1024DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1024DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1024DE_Test := TKDT1024DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1024DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT1024DE_Test.TestBuff) - 1 do
    for j := 0 to KDT1024DE_Axis - 1 do
        TKDT1024DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1024DE_Test.TestBuff), length(TKDT1024DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1024DE_Test.BuildKDTreeM(length(TKDT1024DE_Test.TestBuff), nil, @TKDT1024DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1024DE_Test.BuildKDTreeM(length(TKDT1024DE_Test.TestBuff), nil, TKDT1024DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1024DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1024DE_Test.TestBuff));
  TKDT1024DE_Test.Search(TKDT1024DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1024DEDistance(TKDT1024DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1024DE_Test.Clear;
  { kMean test }
  TKDT1024DE_Test.BuildKDTreeWithCluster(TKDT1024DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1024DE_Test.Search(TKDT1024DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1024DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1024DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1024DE_Test);
end;


function TKDT1040DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1040DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1040DE_Node;
  function SortCompare(const p1, p2: PKDT1040DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1040DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1040DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1040DE_SourceBuffer;
  dynBuff  : PKDT1040DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1040DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1040DE.GetData(const index: NativeInt): PKDT1040DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1040DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1040DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1040DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1040DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1040DE.StoreBuffPtr: PKDT1040DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1040DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1040DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1040DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1040DE.BuildKDTreeWithCluster(const inBuff: TKDT1040DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1040DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1040DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1040DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1040DE.BuildKDTreeWithCluster(const inBuff: TKDT1040DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1040DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DE_BuildCall);
var
  TempStoreBuff: TKDT1040DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1040DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1040DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1040DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1040DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DE_BuildMethod);
var
  TempStoreBuff: TKDT1040DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1040DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1040DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1040DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1040DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DE_BuildProc);
var
  TempStoreBuff: TKDT1040DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1040DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1040DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1040DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1040DE.Search(const Buff: TKDT1040DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1040DE_Node;

var
  NearestNeighbour: PKDT1040DE_Node;

  function FindParentNode(const BuffPtr: PKDT1040DE_Vec; NodePtr: PKDT1040DE_Node): PKDT1040DE_Node;
  var
    Next       : PKDT1040DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1040DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1040DE_Node; const BuffPtr: PKDT1040DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1040DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1040DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1040DE_Vec; const p1, p2: PKDT1040DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1040DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1040DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1040DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1040DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1040DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1040DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1040DE_Node(NearestNodes[0]);
    end;
end;

function TKDT1040DE.Search(const Buff: TKDT1040DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1040DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1040DE.Search(const Buff: TKDT1040DE_Vec; var SearchedDistanceMin: Double): PKDT1040DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1040DE.Search(const Buff: TKDT1040DE_Vec): PKDT1040DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1040DE.Search(const inBuff: TKDT1040DE_DynamicVecBuffer; var OutBuff: TKDT1040DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1040DE_DynamicVecBuffer;
  outBuffPtr : PKDT1040DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1040DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1040DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1040DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1040DE.Search(const inBuff: TKDT1040DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1040DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1040DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1040DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1040DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1040DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1040DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1040DE_Source));
end;

procedure TKDT1040DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1040DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1040DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1040DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1040DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1040DE.PrintNodeTree(const NodePtr: PKDT1040DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1040DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1040DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1040DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1040DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1040DE.KDT1040DEVec(const s: string): TKDT1040DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1040DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1040DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1040DE.KDT1040DEVec(const v: TKDT1040DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1040DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1040DE.KDT1040DEPow(const v: TKDT1040DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1040DE.KDT1040DEDistance(const v1, v2: TKDT1040DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1040DE_Axis - 1 do
      Result := Result + KDT1040DEPow(v2[i] - v1[i]);
end;

procedure TKDT1040DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1040DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1040DE.Test;
var
  TKDT1040DE_Test    : TKDT1040DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1040DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1040DE_Test := TKDT1040DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1040DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT1040DE_Test.TestBuff) - 1 do
    for j := 0 to KDT1040DE_Axis - 1 do
        TKDT1040DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1040DE_Test.TestBuff), length(TKDT1040DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1040DE_Test.BuildKDTreeM(length(TKDT1040DE_Test.TestBuff), nil, @TKDT1040DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1040DE_Test.BuildKDTreeM(length(TKDT1040DE_Test.TestBuff), nil, TKDT1040DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1040DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1040DE_Test.TestBuff));
  TKDT1040DE_Test.Search(TKDT1040DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1040DEDistance(TKDT1040DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1040DE_Test.Clear;
  { kMean test }
  TKDT1040DE_Test.BuildKDTreeWithCluster(TKDT1040DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1040DE_Test.Search(TKDT1040DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1040DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1040DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1040DE_Test);
end;


function TKDT1056DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1056DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1056DE_Node;
  function SortCompare(const p1, p2: PKDT1056DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1056DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1056DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1056DE_SourceBuffer;
  dynBuff  : PKDT1056DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1056DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1056DE.GetData(const index: NativeInt): PKDT1056DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1056DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1056DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1056DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1056DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1056DE.StoreBuffPtr: PKDT1056DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1056DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1056DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1056DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1056DE.BuildKDTreeWithCluster(const inBuff: TKDT1056DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1056DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1056DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1056DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1056DE.BuildKDTreeWithCluster(const inBuff: TKDT1056DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1056DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DE_BuildCall);
var
  TempStoreBuff: TKDT1056DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1056DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1056DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1056DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1056DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DE_BuildMethod);
var
  TempStoreBuff: TKDT1056DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1056DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1056DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1056DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1056DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DE_BuildProc);
var
  TempStoreBuff: TKDT1056DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1056DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1056DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1056DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1056DE.Search(const Buff: TKDT1056DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1056DE_Node;

var
  NearestNeighbour: PKDT1056DE_Node;

  function FindParentNode(const BuffPtr: PKDT1056DE_Vec; NodePtr: PKDT1056DE_Node): PKDT1056DE_Node;
  var
    Next       : PKDT1056DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1056DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1056DE_Node; const BuffPtr: PKDT1056DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1056DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1056DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1056DE_Vec; const p1, p2: PKDT1056DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1056DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1056DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1056DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1056DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1056DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1056DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1056DE_Node(NearestNodes[0]);
    end;
end;

function TKDT1056DE.Search(const Buff: TKDT1056DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1056DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1056DE.Search(const Buff: TKDT1056DE_Vec; var SearchedDistanceMin: Double): PKDT1056DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1056DE.Search(const Buff: TKDT1056DE_Vec): PKDT1056DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1056DE.Search(const inBuff: TKDT1056DE_DynamicVecBuffer; var OutBuff: TKDT1056DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1056DE_DynamicVecBuffer;
  outBuffPtr : PKDT1056DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1056DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1056DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1056DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1056DE.Search(const inBuff: TKDT1056DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1056DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1056DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1056DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1056DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1056DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1056DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1056DE_Source));
end;

procedure TKDT1056DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1056DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1056DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1056DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1056DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1056DE.PrintNodeTree(const NodePtr: PKDT1056DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1056DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1056DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1056DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1056DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1056DE.KDT1056DEVec(const s: string): TKDT1056DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1056DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1056DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1056DE.KDT1056DEVec(const v: TKDT1056DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1056DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1056DE.KDT1056DEPow(const v: TKDT1056DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1056DE.KDT1056DEDistance(const v1, v2: TKDT1056DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1056DE_Axis - 1 do
      Result := Result + KDT1056DEPow(v2[i] - v1[i]);
end;

procedure TKDT1056DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1056DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1056DE.Test;
var
  TKDT1056DE_Test    : TKDT1056DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1056DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1056DE_Test := TKDT1056DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1056DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT1056DE_Test.TestBuff) - 1 do
    for j := 0 to KDT1056DE_Axis - 1 do
        TKDT1056DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1056DE_Test.TestBuff), length(TKDT1056DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1056DE_Test.BuildKDTreeM(length(TKDT1056DE_Test.TestBuff), nil, @TKDT1056DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1056DE_Test.BuildKDTreeM(length(TKDT1056DE_Test.TestBuff), nil, TKDT1056DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1056DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1056DE_Test.TestBuff));
  TKDT1056DE_Test.Search(TKDT1056DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1056DEDistance(TKDT1056DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1056DE_Test.Clear;
  { kMean test }
  TKDT1056DE_Test.BuildKDTreeWithCluster(TKDT1056DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1056DE_Test.Search(TKDT1056DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1056DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1056DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1056DE_Test);
end;


function TKDT1536DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DE_Node;
  function SortCompare(const p1, p2: PKDT1536DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1536DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1536DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1536DE_SourceBuffer;
  dynBuff  : PKDT1536DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1536DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1536DE.GetData(const index: NativeInt): PKDT1536DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1536DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1536DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1536DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1536DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1536DE.StoreBuffPtr: PKDT1536DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1536DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1536DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1536DE.BuildKDTreeWithCluster(const inBuff: TKDT1536DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1536DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1536DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1536DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1536DE.BuildKDTreeWithCluster(const inBuff: TKDT1536DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DE_BuildCall);
var
  TempStoreBuff: TKDT1536DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1536DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1536DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1536DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DE_BuildMethod);
var
  TempStoreBuff: TKDT1536DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1536DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1536DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1536DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DE_BuildProc);
var
  TempStoreBuff: TKDT1536DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1536DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1536DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1536DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1536DE.Search(const Buff: TKDT1536DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DE_Node;

var
  NearestNeighbour: PKDT1536DE_Node;

  function FindParentNode(const BuffPtr: PKDT1536DE_Vec; NodePtr: PKDT1536DE_Node): PKDT1536DE_Node;
  var
    Next       : PKDT1536DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1536DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1536DE_Node; const BuffPtr: PKDT1536DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1536DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1536DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1536DE_Vec; const p1, p2: PKDT1536DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1536DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1536DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1536DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1536DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1536DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1536DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1536DE_Node(NearestNodes[0]);
    end;
end;

function TKDT1536DE.Search(const Buff: TKDT1536DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1536DE.Search(const Buff: TKDT1536DE_Vec; var SearchedDistanceMin: Double): PKDT1536DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1536DE.Search(const Buff: TKDT1536DE_Vec): PKDT1536DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1536DE.Search(const inBuff: TKDT1536DE_DynamicVecBuffer; var OutBuff: TKDT1536DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1536DE_DynamicVecBuffer;
  outBuffPtr : PKDT1536DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1536DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1536DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1536DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1536DE.Search(const inBuff: TKDT1536DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1536DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1536DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1536DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1536DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1536DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1536DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1536DE_Source));
end;

procedure TKDT1536DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1536DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1536DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1536DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1536DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1536DE.PrintNodeTree(const NodePtr: PKDT1536DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1536DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1536DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1536DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1536DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1536DE.KDT1536DEVec(const s: string): TKDT1536DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1536DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1536DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1536DE.KDT1536DEVec(const v: TKDT1536DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1536DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1536DE.KDT1536DEPow(const v: TKDT1536DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1536DE.KDT1536DEDistance(const v1, v2: TKDT1536DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1536DE_Axis - 1 do
      Result := Result + KDT1536DEPow(v2[i] - v1[i]);
end;

procedure TKDT1536DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1536DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1536DE.Test;
var
  TKDT1536DE_Test    : TKDT1536DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1536DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1536DE_Test := TKDT1536DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1536DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT1536DE_Test.TestBuff) - 1 do
    for j := 0 to KDT1536DE_Axis - 1 do
        TKDT1536DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1536DE_Test.TestBuff), length(TKDT1536DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1536DE_Test.BuildKDTreeM(length(TKDT1536DE_Test.TestBuff), nil, @TKDT1536DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1536DE_Test.BuildKDTreeM(length(TKDT1536DE_Test.TestBuff), nil, TKDT1536DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1536DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1536DE_Test.TestBuff));
  TKDT1536DE_Test.Search(TKDT1536DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1536DEDistance(TKDT1536DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1536DE_Test.Clear;
  { kMean test }
  TKDT1536DE_Test.BuildKDTreeWithCluster(TKDT1536DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1536DE_Test.Search(TKDT1536DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1536DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1536DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1536DE_Test);
end;


function TKDT1920DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DE_Node;
  function SortCompare(const p1, p2: PKDT1920DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1920DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1920DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1920DE_SourceBuffer;
  dynBuff  : PKDT1920DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1920DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1920DE.GetData(const index: NativeInt): PKDT1920DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1920DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1920DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1920DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1920DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1920DE.StoreBuffPtr: PKDT1920DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1920DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1920DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1920DE.BuildKDTreeWithCluster(const inBuff: TKDT1920DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1920DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1920DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1920DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1920DE.BuildKDTreeWithCluster(const inBuff: TKDT1920DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DE_BuildCall);
var
  TempStoreBuff: TKDT1920DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1920DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1920DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1920DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DE_BuildMethod);
var
  TempStoreBuff: TKDT1920DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1920DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1920DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1920DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DE_BuildProc);
var
  TempStoreBuff: TKDT1920DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1920DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1920DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1920DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1920DE.Search(const Buff: TKDT1920DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DE_Node;

var
  NearestNeighbour: PKDT1920DE_Node;

  function FindParentNode(const BuffPtr: PKDT1920DE_Vec; NodePtr: PKDT1920DE_Node): PKDT1920DE_Node;
  var
    Next       : PKDT1920DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1920DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1920DE_Node; const BuffPtr: PKDT1920DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1920DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1920DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1920DE_Vec; const p1, p2: PKDT1920DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1920DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1920DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1920DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1920DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1920DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1920DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1920DE_Node(NearestNodes[0]);
    end;
end;

function TKDT1920DE.Search(const Buff: TKDT1920DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1920DE.Search(const Buff: TKDT1920DE_Vec; var SearchedDistanceMin: Double): PKDT1920DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1920DE.Search(const Buff: TKDT1920DE_Vec): PKDT1920DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1920DE.Search(const inBuff: TKDT1920DE_DynamicVecBuffer; var OutBuff: TKDT1920DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1920DE_DynamicVecBuffer;
  outBuffPtr : PKDT1920DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1920DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1920DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1920DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1920DE.Search(const inBuff: TKDT1920DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1920DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1920DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1920DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1920DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1920DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1920DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1920DE_Source));
end;

procedure TKDT1920DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1920DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1920DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1920DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1920DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1920DE.PrintNodeTree(const NodePtr: PKDT1920DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1920DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1920DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1920DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1920DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1920DE.KDT1920DEVec(const s: string): TKDT1920DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1920DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1920DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1920DE.KDT1920DEVec(const v: TKDT1920DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1920DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1920DE.KDT1920DEPow(const v: TKDT1920DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1920DE.KDT1920DEDistance(const v1, v2: TKDT1920DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1920DE_Axis - 1 do
      Result := Result + KDT1920DEPow(v2[i] - v1[i]);
end;

procedure TKDT1920DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1920DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1920DE.Test;
var
  TKDT1920DE_Test    : TKDT1920DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1920DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1920DE_Test := TKDT1920DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1920DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT1920DE_Test.TestBuff) - 1 do
    for j := 0 to KDT1920DE_Axis - 1 do
        TKDT1920DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1920DE_Test.TestBuff), length(TKDT1920DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1920DE_Test.BuildKDTreeM(length(TKDT1920DE_Test.TestBuff), nil, @TKDT1920DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1920DE_Test.BuildKDTreeM(length(TKDT1920DE_Test.TestBuff), nil, TKDT1920DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1920DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1920DE_Test.TestBuff));
  TKDT1920DE_Test.Search(TKDT1920DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1920DEDistance(TKDT1920DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1920DE_Test.Clear;
  { kMean test }
  TKDT1920DE_Test.BuildKDTreeWithCluster(TKDT1920DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1920DE_Test.Search(TKDT1920DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1920DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1920DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1920DE_Test);
end;


function TKDT1980DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1980DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1980DE_Node;
  function SortCompare(const p1, p2: PKDT1980DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1980DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1980DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1980DE_SourceBuffer;
  dynBuff  : PKDT1980DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1980DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1980DE.GetData(const index: NativeInt): PKDT1980DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1980DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1980DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1980DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1980DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1980DE.StoreBuffPtr: PKDT1980DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1980DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1980DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1980DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1980DE.BuildKDTreeWithCluster(const inBuff: TKDT1980DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1980DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1980DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1980DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1980DE.BuildKDTreeWithCluster(const inBuff: TKDT1980DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1980DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DE_BuildCall);
var
  TempStoreBuff: TKDT1980DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1980DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1980DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1980DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1980DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DE_BuildMethod);
var
  TempStoreBuff: TKDT1980DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1980DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1980DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1980DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1980DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DE_BuildProc);
var
  TempStoreBuff: TKDT1980DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1980DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1980DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1980DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1980DE.Search(const Buff: TKDT1980DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1980DE_Node;

var
  NearestNeighbour: PKDT1980DE_Node;

  function FindParentNode(const BuffPtr: PKDT1980DE_Vec; NodePtr: PKDT1980DE_Node): PKDT1980DE_Node;
  var
    Next       : PKDT1980DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1980DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1980DE_Node; const BuffPtr: PKDT1980DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1980DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1980DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1980DE_Vec; const p1, p2: PKDT1980DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1980DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1980DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1980DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1980DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1980DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1980DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1980DE_Node(NearestNodes[0]);
    end;
end;

function TKDT1980DE.Search(const Buff: TKDT1980DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1980DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1980DE.Search(const Buff: TKDT1980DE_Vec; var SearchedDistanceMin: Double): PKDT1980DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1980DE.Search(const Buff: TKDT1980DE_Vec): PKDT1980DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1980DE.Search(const inBuff: TKDT1980DE_DynamicVecBuffer; var OutBuff: TKDT1980DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1980DE_DynamicVecBuffer;
  outBuffPtr : PKDT1980DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1980DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1980DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1980DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1980DE.Search(const inBuff: TKDT1980DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1980DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1980DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1980DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1980DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1980DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1980DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1980DE_Source));
end;

procedure TKDT1980DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1980DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1980DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1980DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1980DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1980DE.PrintNodeTree(const NodePtr: PKDT1980DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1980DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1980DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1980DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1980DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1980DE.KDT1980DEVec(const s: string): TKDT1980DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1980DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1980DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1980DE.KDT1980DEVec(const v: TKDT1980DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1980DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1980DE.KDT1980DEPow(const v: TKDT1980DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1980DE.KDT1980DEDistance(const v1, v2: TKDT1980DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1980DE_Axis - 1 do
      Result := Result + KDT1980DEPow(v2[i] - v1[i]);
end;

procedure TKDT1980DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1980DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1980DE.Test;
var
  TKDT1980DE_Test    : TKDT1980DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1980DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1980DE_Test := TKDT1980DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1980DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT1980DE_Test.TestBuff) - 1 do
    for j := 0 to KDT1980DE_Axis - 1 do
        TKDT1980DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1980DE_Test.TestBuff), length(TKDT1980DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1980DE_Test.BuildKDTreeM(length(TKDT1980DE_Test.TestBuff), nil, @TKDT1980DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1980DE_Test.BuildKDTreeM(length(TKDT1980DE_Test.TestBuff), nil, TKDT1980DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1980DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1980DE_Test.TestBuff));
  TKDT1980DE_Test.Search(TKDT1980DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1980DEDistance(TKDT1980DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1980DE_Test.Clear;
  { kMean test }
  TKDT1980DE_Test.BuildKDTreeWithCluster(TKDT1980DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1980DE_Test.Search(TKDT1980DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1980DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1980DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1980DE_Test);
end;


function TKDT2048DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DE_Node;
  function SortCompare(const p1, p2: PKDT2048DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2048DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2048DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2048DE_SourceBuffer;
  dynBuff  : PKDT2048DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT2048DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2048DE.GetData(const index: NativeInt): PKDT2048DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2048DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2048DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2048DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2048DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2048DE.StoreBuffPtr: PKDT2048DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2048DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2048DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2048DE.BuildKDTreeWithCluster(const inBuff: TKDT2048DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT2048DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT2048DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT2048DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2048DE.BuildKDTreeWithCluster(const inBuff: TKDT2048DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DE_BuildCall);
var
  TempStoreBuff: TKDT2048DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2048DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2048DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2048DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DE_BuildMethod);
var
  TempStoreBuff: TKDT2048DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2048DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2048DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2048DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DE_BuildProc);
var
  TempStoreBuff: TKDT2048DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2048DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2048DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2048DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT2048DE.Search(const Buff: TKDT2048DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DE_Node;

var
  NearestNeighbour: PKDT2048DE_Node;

  function FindParentNode(const BuffPtr: PKDT2048DE_Vec; NodePtr: PKDT2048DE_Node): PKDT2048DE_Node;
  var
    Next       : PKDT2048DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT2048DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2048DE_Node; const BuffPtr: PKDT2048DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2048DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT2048DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2048DE_Vec; const p1, p2: PKDT2048DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2048DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2048DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2048DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2048DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2048DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2048DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2048DE_Node(NearestNodes[0]);
    end;
end;

function TKDT2048DE.Search(const Buff: TKDT2048DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2048DE.Search(const Buff: TKDT2048DE_Vec; var SearchedDistanceMin: Double): PKDT2048DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2048DE.Search(const Buff: TKDT2048DE_Vec): PKDT2048DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2048DE.Search(const inBuff: TKDT2048DE_DynamicVecBuffer; var OutBuff: TKDT2048DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2048DE_DynamicVecBuffer;
  outBuffPtr : PKDT2048DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2048DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2048DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2048DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2048DE.Search(const inBuff: TKDT2048DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2048DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2048DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2048DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2048DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2048DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT2048DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2048DE_Source));
end;

procedure TKDT2048DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT2048DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2048DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2048DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2048DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2048DE.PrintNodeTree(const NodePtr: PKDT2048DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2048DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2048DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2048DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2048DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT2048DE.KDT2048DEVec(const s: string): TKDT2048DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT2048DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT2048DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT2048DE.KDT2048DEVec(const v: TKDT2048DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT2048DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT2048DE.KDT2048DEPow(const v: TKDT2048DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT2048DE.KDT2048DEDistance(const v1, v2: TKDT2048DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT2048DE_Axis - 1 do
      Result := Result + KDT2048DEPow(v2[i] - v1[i]);
end;

procedure TKDT2048DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2048DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2048DE.Test;
var
  TKDT2048DE_Test    : TKDT2048DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2048DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2048DE_Test := TKDT2048DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2048DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT2048DE_Test.TestBuff) - 1 do
    for j := 0 to KDT2048DE_Axis - 1 do
        TKDT2048DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT2048DE_Test.TestBuff), length(TKDT2048DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2048DE_Test.BuildKDTreeM(length(TKDT2048DE_Test.TestBuff), nil, @TKDT2048DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2048DE_Test.BuildKDTreeM(length(TKDT2048DE_Test.TestBuff), nil, TKDT2048DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2048DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2048DE_Test.TestBuff));
  TKDT2048DE_Test.Search(TKDT2048DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2048DEDistance(TKDT2048DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2048DE_Test.Clear;
  { kMean test }
  TKDT2048DE_Test.BuildKDTreeWithCluster(TKDT2048DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2048DE_Test.Search(TKDT2048DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2048DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2048DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2048DE_Test);
end;


function TKDT3072DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DE_Node;
  function SortCompare(const p1, p2: PKDT3072DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3072DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3072DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3072DE_SourceBuffer;
  dynBuff  : PKDT3072DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3072DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3072DE.GetData(const index: NativeInt): PKDT3072DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3072DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3072DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3072DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3072DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3072DE.StoreBuffPtr: PKDT3072DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3072DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3072DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3072DE.BuildKDTreeWithCluster(const inBuff: TKDT3072DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3072DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3072DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3072DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3072DE.BuildKDTreeWithCluster(const inBuff: TKDT3072DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DE_BuildCall);
var
  TempStoreBuff: TKDT3072DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3072DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3072DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3072DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DE_BuildMethod);
var
  TempStoreBuff: TKDT3072DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3072DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3072DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3072DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DE_BuildProc);
var
  TempStoreBuff: TKDT3072DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3072DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3072DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3072DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT3072DE.Search(const Buff: TKDT3072DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DE_Node;

var
  NearestNeighbour: PKDT3072DE_Node;

  function FindParentNode(const BuffPtr: PKDT3072DE_Vec; NodePtr: PKDT3072DE_Node): PKDT3072DE_Node;
  var
    Next       : PKDT3072DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3072DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3072DE_Node; const BuffPtr: PKDT3072DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3072DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3072DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3072DE_Vec; const p1, p2: PKDT3072DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3072DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3072DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3072DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3072DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3072DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3072DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3072DE_Node(NearestNodes[0]);
    end;
end;

function TKDT3072DE.Search(const Buff: TKDT3072DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3072DE.Search(const Buff: TKDT3072DE_Vec; var SearchedDistanceMin: Double): PKDT3072DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3072DE.Search(const Buff: TKDT3072DE_Vec): PKDT3072DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3072DE.Search(const inBuff: TKDT3072DE_DynamicVecBuffer; var OutBuff: TKDT3072DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3072DE_DynamicVecBuffer;
  outBuffPtr : PKDT3072DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3072DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3072DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3072DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3072DE.Search(const inBuff: TKDT3072DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3072DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3072DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3072DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3072DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3072DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3072DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3072DE_Source));
end;

procedure TKDT3072DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3072DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3072DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3072DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3072DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3072DE.PrintNodeTree(const NodePtr: PKDT3072DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3072DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3072DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3072DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3072DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3072DE.KDT3072DEVec(const s: string): TKDT3072DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3072DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3072DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3072DE.KDT3072DEVec(const v: TKDT3072DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3072DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT3072DE.KDT3072DEPow(const v: TKDT3072DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3072DE.KDT3072DEDistance(const v1, v2: TKDT3072DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3072DE_Axis - 1 do
      Result := Result + KDT3072DEPow(v2[i] - v1[i]);
end;

procedure TKDT3072DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3072DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3072DE.Test;
var
  TKDT3072DE_Test    : TKDT3072DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3072DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3072DE_Test := TKDT3072DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3072DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT3072DE_Test.TestBuff) - 1 do
    for j := 0 to KDT3072DE_Axis - 1 do
        TKDT3072DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3072DE_Test.TestBuff), length(TKDT3072DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3072DE_Test.BuildKDTreeM(length(TKDT3072DE_Test.TestBuff), nil, @TKDT3072DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3072DE_Test.BuildKDTreeM(length(TKDT3072DE_Test.TestBuff), nil, TKDT3072DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3072DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3072DE_Test.TestBuff));
  TKDT3072DE_Test.Search(TKDT3072DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3072DEDistance(TKDT3072DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3072DE_Test.Clear;
  { kMean test }
  TKDT3072DE_Test.BuildKDTreeWithCluster(TKDT3072DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3072DE_Test.Search(TKDT3072DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3072DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3072DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3072DE_Test);
end;


function TKDT3088DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3088DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3088DE_Node;
  function SortCompare(const p1, p2: PKDT3088DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3088DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3088DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3088DE_SourceBuffer;
  dynBuff  : PKDT3088DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3088DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3088DE.GetData(const index: NativeInt): PKDT3088DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3088DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3088DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3088DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3088DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3088DE.StoreBuffPtr: PKDT3088DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3088DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3088DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3088DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3088DE.BuildKDTreeWithCluster(const inBuff: TKDT3088DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3088DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3088DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3088DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3088DE.BuildKDTreeWithCluster(const inBuff: TKDT3088DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3088DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DE_BuildCall);
var
  TempStoreBuff: TKDT3088DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3088DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3088DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3088DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3088DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DE_BuildMethod);
var
  TempStoreBuff: TKDT3088DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3088DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3088DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3088DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT3088DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DE_BuildProc);
var
  TempStoreBuff: TKDT3088DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3088DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3088DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3088DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT3088DE.Search(const Buff: TKDT3088DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3088DE_Node;

var
  NearestNeighbour: PKDT3088DE_Node;

  function FindParentNode(const BuffPtr: PKDT3088DE_Vec; NodePtr: PKDT3088DE_Node): PKDT3088DE_Node;
  var
    Next       : PKDT3088DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3088DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3088DE_Node; const BuffPtr: PKDT3088DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3088DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3088DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3088DE_Vec; const p1, p2: PKDT3088DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3088DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3088DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3088DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3088DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3088DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3088DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3088DE_Node(NearestNodes[0]);
    end;
end;

function TKDT3088DE.Search(const Buff: TKDT3088DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3088DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3088DE.Search(const Buff: TKDT3088DE_Vec; var SearchedDistanceMin: Double): PKDT3088DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3088DE.Search(const Buff: TKDT3088DE_Vec): PKDT3088DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3088DE.Search(const inBuff: TKDT3088DE_DynamicVecBuffer; var OutBuff: TKDT3088DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3088DE_DynamicVecBuffer;
  outBuffPtr : PKDT3088DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3088DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3088DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3088DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3088DE.Search(const inBuff: TKDT3088DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3088DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3088DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3088DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3088DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3088DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3088DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3088DE_Source));
end;

procedure TKDT3088DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3088DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3088DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3088DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3088DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3088DE.PrintNodeTree(const NodePtr: PKDT3088DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3088DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3088DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3088DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3088DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3088DE.KDT3088DEVec(const s: string): TKDT3088DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3088DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3088DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3088DE.KDT3088DEVec(const v: TKDT3088DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3088DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT3088DE.KDT3088DEPow(const v: TKDT3088DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3088DE.KDT3088DEDistance(const v1, v2: TKDT3088DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3088DE_Axis - 1 do
      Result := Result + KDT3088DEPow(v2[i] - v1[i]);
end;

procedure TKDT3088DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3088DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3088DE.Test;
var
  TKDT3088DE_Test    : TKDT3088DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3088DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3088DE_Test := TKDT3088DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3088DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT3088DE_Test.TestBuff) - 1 do
    for j := 0 to KDT3088DE_Axis - 1 do
        TKDT3088DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3088DE_Test.TestBuff), length(TKDT3088DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3088DE_Test.BuildKDTreeM(length(TKDT3088DE_Test.TestBuff), nil, @TKDT3088DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3088DE_Test.BuildKDTreeM(length(TKDT3088DE_Test.TestBuff), nil, TKDT3088DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3088DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3088DE_Test.TestBuff));
  TKDT3088DE_Test.Search(TKDT3088DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3088DEDistance(TKDT3088DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3088DE_Test.Clear;
  { kMean test }
  TKDT3088DE_Test.BuildKDTreeWithCluster(TKDT3088DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3088DE_Test.Search(TKDT3088DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3088DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3088DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3088DE_Test);
end;


function TKDT3104DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3104DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3104DE_Node;
  function SortCompare(const p1, p2: PKDT3104DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3104DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3104DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3104DE_SourceBuffer;
  dynBuff  : PKDT3104DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3104DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3104DE.GetData(const index: NativeInt): PKDT3104DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3104DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3104DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3104DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3104DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3104DE.StoreBuffPtr: PKDT3104DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3104DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3104DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3104DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3104DE.BuildKDTreeWithCluster(const inBuff: TKDT3104DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3104DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3104DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3104DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3104DE.BuildKDTreeWithCluster(const inBuff: TKDT3104DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3104DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DE_BuildCall);
var
  TempStoreBuff: TKDT3104DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3104DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3104DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3104DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3104DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DE_BuildMethod);
var
  TempStoreBuff: TKDT3104DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3104DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3104DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3104DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT3104DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DE_BuildProc);
var
  TempStoreBuff: TKDT3104DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3104DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3104DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3104DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT3104DE.Search(const Buff: TKDT3104DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3104DE_Node;

var
  NearestNeighbour: PKDT3104DE_Node;

  function FindParentNode(const BuffPtr: PKDT3104DE_Vec; NodePtr: PKDT3104DE_Node): PKDT3104DE_Node;
  var
    Next       : PKDT3104DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3104DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3104DE_Node; const BuffPtr: PKDT3104DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3104DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3104DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3104DE_Vec; const p1, p2: PKDT3104DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3104DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3104DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3104DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3104DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3104DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3104DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3104DE_Node(NearestNodes[0]);
    end;
end;

function TKDT3104DE.Search(const Buff: TKDT3104DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3104DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3104DE.Search(const Buff: TKDT3104DE_Vec; var SearchedDistanceMin: Double): PKDT3104DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3104DE.Search(const Buff: TKDT3104DE_Vec): PKDT3104DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3104DE.Search(const inBuff: TKDT3104DE_DynamicVecBuffer; var OutBuff: TKDT3104DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3104DE_DynamicVecBuffer;
  outBuffPtr : PKDT3104DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3104DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3104DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3104DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3104DE.Search(const inBuff: TKDT3104DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3104DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3104DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3104DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3104DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3104DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3104DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3104DE_Source));
end;

procedure TKDT3104DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3104DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3104DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3104DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3104DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3104DE.PrintNodeTree(const NodePtr: PKDT3104DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3104DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3104DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3104DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3104DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3104DE.KDT3104DEVec(const s: string): TKDT3104DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3104DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3104DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3104DE.KDT3104DEVec(const v: TKDT3104DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3104DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT3104DE.KDT3104DEPow(const v: TKDT3104DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3104DE.KDT3104DEDistance(const v1, v2: TKDT3104DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3104DE_Axis - 1 do
      Result := Result + KDT3104DEPow(v2[i] - v1[i]);
end;

procedure TKDT3104DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3104DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3104DE.Test;
var
  TKDT3104DE_Test    : TKDT3104DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3104DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3104DE_Test := TKDT3104DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3104DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT3104DE_Test.TestBuff) - 1 do
    for j := 0 to KDT3104DE_Axis - 1 do
        TKDT3104DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3104DE_Test.TestBuff), length(TKDT3104DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3104DE_Test.BuildKDTreeM(length(TKDT3104DE_Test.TestBuff), nil, @TKDT3104DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3104DE_Test.BuildKDTreeM(length(TKDT3104DE_Test.TestBuff), nil, TKDT3104DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3104DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3104DE_Test.TestBuff));
  TKDT3104DE_Test.Search(TKDT3104DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3104DEDistance(TKDT3104DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3104DE_Test.Clear;
  { kMean test }
  TKDT3104DE_Test.BuildKDTreeWithCluster(TKDT3104DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3104DE_Test.Search(TKDT3104DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3104DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3104DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3104DE_Test);
end;


function TKDT4096DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4096DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4096DE_Node;
  function SortCompare(const p1, p2: PKDT4096DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4096DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4096DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4096DE_SourceBuffer;
  dynBuff  : PKDT4096DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT4096DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4096DE.GetData(const index: NativeInt): PKDT4096DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4096DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4096DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4096DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4096DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4096DE.StoreBuffPtr: PKDT4096DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4096DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4096DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4096DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4096DE.BuildKDTreeWithCluster(const inBuff: TKDT4096DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT4096DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT4096DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT4096DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4096DE.BuildKDTreeWithCluster(const inBuff: TKDT4096DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4096DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DE_BuildCall);
var
  TempStoreBuff: TKDT4096DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4096DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4096DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4096DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4096DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DE_BuildMethod);
var
  TempStoreBuff: TKDT4096DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4096DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4096DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4096DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT4096DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DE_BuildProc);
var
  TempStoreBuff: TKDT4096DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4096DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4096DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4096DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT4096DE.Search(const Buff: TKDT4096DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4096DE_Node;

var
  NearestNeighbour: PKDT4096DE_Node;

  function FindParentNode(const BuffPtr: PKDT4096DE_Vec; NodePtr: PKDT4096DE_Node): PKDT4096DE_Node;
  var
    Next       : PKDT4096DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT4096DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4096DE_Node; const BuffPtr: PKDT4096DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4096DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT4096DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4096DE_Vec; const p1, p2: PKDT4096DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4096DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4096DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4096DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4096DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4096DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4096DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4096DE_Node(NearestNodes[0]);
    end;
end;

function TKDT4096DE.Search(const Buff: TKDT4096DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4096DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4096DE.Search(const Buff: TKDT4096DE_Vec; var SearchedDistanceMin: Double): PKDT4096DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4096DE.Search(const Buff: TKDT4096DE_Vec): PKDT4096DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4096DE.Search(const inBuff: TKDT4096DE_DynamicVecBuffer; var OutBuff: TKDT4096DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4096DE_DynamicVecBuffer;
  outBuffPtr : PKDT4096DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4096DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4096DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4096DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4096DE.Search(const inBuff: TKDT4096DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4096DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4096DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4096DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4096DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4096DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT4096DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4096DE_Source));
end;

procedure TKDT4096DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT4096DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4096DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4096DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4096DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4096DE.PrintNodeTree(const NodePtr: PKDT4096DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT4096DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4096DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4096DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4096DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT4096DE.KDT4096DEVec(const s: string): TKDT4096DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT4096DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT4096DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT4096DE.KDT4096DEVec(const v: TKDT4096DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT4096DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT4096DE.KDT4096DEPow(const v: TKDT4096DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT4096DE.KDT4096DEDistance(const v1, v2: TKDT4096DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT4096DE_Axis - 1 do
      Result := Result + KDT4096DEPow(v2[i] - v1[i]);
end;

procedure TKDT4096DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4096DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4096DE.Test;
var
  TKDT4096DE_Test    : TKDT4096DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4096DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4096DE_Test := TKDT4096DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4096DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT4096DE_Test.TestBuff) - 1 do
    for j := 0 to KDT4096DE_Axis - 1 do
        TKDT4096DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT4096DE_Test.TestBuff), length(TKDT4096DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4096DE_Test.BuildKDTreeM(length(TKDT4096DE_Test.TestBuff), nil, @TKDT4096DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4096DE_Test.BuildKDTreeM(length(TKDT4096DE_Test.TestBuff), nil, TKDT4096DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4096DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4096DE_Test.TestBuff));
  TKDT4096DE_Test.Search(TKDT4096DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4096DEDistance(TKDT4096DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4096DE_Test.Clear;
  { kMean test }
  TKDT4096DE_Test.BuildKDTreeWithCluster(TKDT4096DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4096DE_Test.Search(TKDT4096DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4096DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4096DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4096DE_Test);
end;


function TKDT8192DE.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8192DE_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8192DE_Node;
  function SortCompare(const p1, p2: PKDT8192DE_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8192DE_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8192DE_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8192DE_SourceBuffer;
  dynBuff  : PKDT8192DEyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT8192DE_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8192DE.GetData(const index: NativeInt): PKDT8192DE_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8192DE.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8192DE.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8192DE.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8192DE_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8192DE.StoreBuffPtr: PKDT8192DEyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8192DE.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DE_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8192DE.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DE_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8192DE.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DE_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DEyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8192DE.BuildKDTreeWithCluster(const inBuff: TKDT8192DE_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT8192DE_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT8192DE_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT8192DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8192DE.BuildKDTreeWithCluster(const inBuff: TKDT8192DE_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8192DE.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DE_BuildCall);
var
  TempStoreBuff: TKDT8192DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8192DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8192DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8192DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8192DE.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DE_BuildMethod);
var
  TempStoreBuff: TKDT8192DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8192DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8192DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8192DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT8192DE.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DE_BuildProc);
var
  TempStoreBuff: TKDT8192DEyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DE_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8192DE_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8192DE_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8192DE_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DE_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT8192DE.Search(const Buff: TKDT8192DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8192DE_Node;

var
  NearestNeighbour: PKDT8192DE_Node;

  function FindParentNode(const BuffPtr: PKDT8192DE_Vec; NodePtr: PKDT8192DE_Node): PKDT8192DE_Node;
  var
    Next       : PKDT8192DE_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT8192DE_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8192DE_Node; const BuffPtr: PKDT8192DE_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8192DEDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT8192DE_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8192DE_Vec; const p1, p2: PKDT8192DE_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8192DEDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8192DEDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8192DE_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8192DE_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8192DE_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8192DEDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8192DE_Node(NearestNodes[0]);
    end;
end;

function TKDT8192DE.Search(const Buff: TKDT8192DE_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8192DE_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8192DE.Search(const Buff: TKDT8192DE_Vec; var SearchedDistanceMin: Double): PKDT8192DE_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8192DE.Search(const Buff: TKDT8192DE_Vec): PKDT8192DE_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8192DE.Search(const inBuff: TKDT8192DE_DynamicVecBuffer; var OutBuff: TKDT8192DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8192DE_DynamicVecBuffer;
  outBuffPtr : PKDT8192DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8192DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8192DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8192DE_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8192DE.Search(const inBuff: TKDT8192DE_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8192DE_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8192DE_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8192DE_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8192DE_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8192DE.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT8192DE_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8192DE_Source));
end;

procedure TKDT8192DE.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT8192DE_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8192DE_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8192DE.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8192DE.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8192DE.PrintNodeTree(const NodePtr: PKDT8192DE_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT8192DE_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8192DEVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8192DE.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8192DEVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT8192DE.KDT8192DEVec(const s: string): TKDT8192DE_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT8192DE_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT8192DE_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT8192DE.KDT8192DEVec(const v: TKDT8192DE_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT8192DE_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT8192DE.KDT8192DEPow(const v: TKDT8192DE_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT8192DE.KDT8192DEDistance(const v1, v2: TKDT8192DE_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT8192DE_Axis - 1 do
      Result := Result + KDT8192DEPow(v2[i] - v1[i]);
end;

procedure TKDT8192DE.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8192DE_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8192DE.Test;
var
  TKDT8192DE_Test    : TKDT8192DE;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8192DE_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8192DE_Test := TKDT8192DE.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8192DE_Test.TestBuff, 100);
  for i := 0 to length(TKDT8192DE_Test.TestBuff) - 1 do
    for j := 0 to KDT8192DE_Axis - 1 do
        TKDT8192DE_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT8192DE_Test.TestBuff), length(TKDT8192DE_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8192DE_Test.BuildKDTreeM(length(TKDT8192DE_Test.TestBuff), nil, @TKDT8192DE_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8192DE_Test.BuildKDTreeM(length(TKDT8192DE_Test.TestBuff), nil, TKDT8192DE_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8192DE_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8192DE_Test.TestBuff));
  TKDT8192DE_Test.Search(TKDT8192DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8192DEDistance(TKDT8192DE_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8192DE_Test.Clear;
  { kMean test }
  TKDT8192DE_Test.BuildKDTreeWithCluster(TKDT8192DE_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8192DE_Test.Search(TKDT8192DE_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8192DE_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8192DE_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8192DE_Test);
end;


procedure Test_All;
begin
  TKDT1DE.Test();
  TKDT2DE.Test();
  TKDT3DE.Test();
  TKDT4DE.Test();
  TKDT5DE.Test();
  TKDT6DE.Test();
  TKDT7DE.Test();
  TKDT8DE.Test();
  TKDT9DE.Test();
  TKDT10DE.Test();
  TKDT11DE.Test();
  TKDT12DE.Test();
  TKDT13DE.Test();
  TKDT14DE.Test();
  TKDT15DE.Test();
  TKDT16DE.Test();
  TKDT17DE.Test();
  TKDT18DE.Test();
  TKDT19DE.Test();
  TKDT20DE.Test();
  TKDT21DE.Test();
  TKDT22DE.Test();
  TKDT23DE.Test();
  TKDT24DE.Test();
  TKDT25DE.Test();
  TKDT26DE.Test();
  TKDT27DE.Test();
  TKDT28DE.Test();
  TKDT29DE.Test();
  TKDT30DE.Test();
  TKDT31DE.Test();
  TKDT32DE.Test();
  TKDT33DE.Test();
  TKDT34DE.Test();
  TKDT35DE.Test();
  TKDT36DE.Test();
  TKDT37DE.Test();
  TKDT38DE.Test();
  TKDT39DE.Test();
  TKDT40DE.Test();
  TKDT41DE.Test();
  TKDT42DE.Test();
  TKDT43DE.Test();
  TKDT44DE.Test();
  TKDT45DE.Test();
  TKDT46DE.Test();
  TKDT47DE.Test();
  TKDT48DE.Test();
  TKDT49DE.Test();
  TKDT50DE.Test();
  TKDT51DE.Test();
  TKDT52DE.Test();
  TKDT53DE.Test();
  TKDT54DE.Test();
  TKDT55DE.Test();
  TKDT56DE.Test();
  TKDT57DE.Test();
  TKDT58DE.Test();
  TKDT59DE.Test();
  TKDT60DE.Test();
  TKDT61DE.Test();
  TKDT62DE.Test();
  TKDT63DE.Test();
  TKDT64DE.Test();
  TKDT65DE.Test();
  TKDT66DE.Test();
  TKDT67DE.Test();
  TKDT68DE.Test();
  TKDT69DE.Test();
  TKDT70DE.Test();
  TKDT71DE.Test();
  TKDT72DE.Test();
  TKDT84DE.Test();
  TKDT96DE.Test();
  TKDT128DE.Test();
  TKDT140DE.Test();
  TKDT160DE.Test();
  TKDT196DE.Test();
  TKDT256DE.Test();
  TKDT272DE.Test();
  TKDT288DE.Test();
  TKDT372DE.Test();
  TKDT512DE.Test();
  TKDT576DE.Test();
  TKDT768DE.Test();
  TKDT1024DE.Test();
  TKDT1040DE.Test();
  TKDT1056DE.Test();
  TKDT1536DE.Test();
  TKDT1920DE.Test();
  TKDT1980DE.Test();
  TKDT2048DE.Test();
  TKDT3072DE.Test();
  TKDT3088DE.Test();
  TKDT3104DE.Test();
  TKDT4096DE.Test();
  TKDT8192DE.Test();
  DoStatus('All Test Finished');
end;





initialization

finalization

end.

