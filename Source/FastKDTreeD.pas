{ Fast KDTree Double Type support                                                }
{ ****************************************************************************** }
{ * fast KDTree Support,writen by QQ 600585@qq.com                             * }
{ * https://github.com/PassByYou888/CoreCipher                                 * }
{ * https://github.com/PassByYou888/ZServer4D                                  * }
{ * https://github.com/PassByYou888/zExpression                                * }
{ * https://github.com/PassByYou888/zTranslate                                 * }
{ * https://github.com/PassByYou888/zSound                                     * }
{ * https://github.com/PassByYou888/zAnalysis                                  * }
{ ****************************************************************************** }

unit FastKDTreeD;

interface

uses CoreClasses, KM;

{$I zDefine.inc}

{$IFDEF FPC}
{$DEFINE DEBUG}
{$ENDIF FPC}

const

  // Double float: KDTree
  TKDT1DD_AxisCount = 1;
  TKDT2DD_AxisCount = 2;
  TKDT3DD_AxisCount = 3;
  TKDT4DD_AxisCount = 4;
  TKDT6DD_AxisCount = 6;
  TKDT8DD_AxisCount = 8;
  TKDT10DD_AxisCount = 10;
  TKDT12DD_AxisCount = 12;
  TKDT14DD_AxisCount = 14;
  TKDT16DD_AxisCount = 16;
  TKDT18DD_AxisCount = 18;
  TKDT20DD_AxisCount = 20;
  TKDT22DD_AxisCount = 22;
  TKDT24DD_AxisCount = 24;
  TKDT28DD_AxisCount = 28;
  TKDT30DD_AxisCount = 30;
  TKDT32DD_AxisCount = 32;
  TKDT34DD_AxisCount = 34;
  TKDT36DD_AxisCount = 36;
  TKDT40DD_AxisCount = 40;
  TKDT48DD_AxisCount = 48;
  TKDT64DD_AxisCount = 64;
  TKDT96DD_AxisCount = 96;
  TKDT128DD_AxisCount = 128;
  TKDT256DD_AxisCount = 256;
  TKDT372DD_AxisCount = 372;
  TKDT512DD_AxisCount = 512;
  TKDT640DD_AxisCount = 640;
  TKDT768DD_AxisCount = 768;
  TKDT1024DD_AxisCount = 1024;
  TKDT1080DD_AxisCount = 1080;
  TKDT1536DD_AxisCount = 1536;
  TKDT1920DD_AxisCount = 1920;
  TKDT2048DD_AxisCount = 2048;
  TKDT3072DD_AxisCount = 3072;

type

  // Double float: KDTree
  TKDT1DD = class;  TKDT1DD_VecType = Double; // 1D
  TKDT2DD = class;  TKDT2DD_VecType = Double; // 2D
  TKDT3DD = class;  TKDT3DD_VecType = Double; // 3D
  TKDT4DD = class;  TKDT4DD_VecType = Double; // 4D
  TKDT6DD = class;  TKDT6DD_VecType = Double; // 6D
  TKDT8DD = class;  TKDT8DD_VecType = Double; // 8D
  TKDT10DD = class;  TKDT10DD_VecType = Double; // 10D
  TKDT12DD = class;  TKDT12DD_VecType = Double; // 12D
  TKDT14DD = class;  TKDT14DD_VecType = Double; // 14D
  TKDT16DD = class;  TKDT16DD_VecType = Double; // 16D
  TKDT18DD = class;  TKDT18DD_VecType = Double; // 18D
  TKDT20DD = class;  TKDT20DD_VecType = Double; // 20D
  TKDT22DD = class;  TKDT22DD_VecType = Double; // 22D
  TKDT24DD = class;  TKDT24DD_VecType = Double; // 24D
  TKDT28DD = class;  TKDT28DD_VecType = Double; // 28D
  TKDT30DD = class;  TKDT30DD_VecType = Double; // 30D
  TKDT32DD = class;  TKDT32DD_VecType = Double; // 32D
  TKDT34DD = class;  TKDT34DD_VecType = Double; // 34D
  TKDT36DD = class;  TKDT36DD_VecType = Double; // 36D
  TKDT40DD = class;  TKDT40DD_VecType = Double; // 40D
  TKDT48DD = class;  TKDT48DD_VecType = Double; // 48D
  TKDT64DD = class;  TKDT64DD_VecType = Double; // 64D
  TKDT96DD = class;  TKDT96DD_VecType = Double; // 96D
  TKDT128DD = class;  TKDT128DD_VecType = Double; // 128D
  TKDT256DD = class;  TKDT256DD_VecType = Double; // 256D
  TKDT372DD = class;  TKDT372DD_VecType = Double; // 372D
  TKDT512DD = class;  TKDT512DD_VecType = Double; // 512D
  TKDT640DD = class;  TKDT640DD_VecType = Double; // 640D
  TKDT768DD = class;  TKDT768DD_VecType = Double; // 768D
  TKDT1024DD = class;  TKDT1024DD_VecType = Double; // 1024D
  TKDT1080DD = class;  TKDT1080DD_VecType = Double; // 1080D
  TKDT1536DD = class;  TKDT1536DD_VecType = Double; // 1536D
  TKDT1920DD = class;  TKDT1920DD_VecType = Double; // 1920D
  TKDT2048DD = class;  TKDT2048DD_VecType = Double; // 2048D
  TKDT3072DD = class;  TKDT3072DD_VecType = Double; // 3072D










  // Double float: KDTree


  TKDT1DD_Vec = array [0 .. TKDT1DD_AxisCount - 1] of TKDT1DD_VecType;
  PKDT1DD_Vec = ^TKDT1DD_Vec;

  TKDT1DD_DynamicVecBuffer = array of TKDT1DD_Vec;
  PKDT1DD_DynamicVecBuffer = ^TKDT1DD_DynamicVecBuffer;

  TKDT1DD_Source = packed record
    Buff: TKDT1DD_Vec;
    index: Int64;
  end;

  PKDT1DD_Source       = ^TKDT1DD_Source;
  TKDT1DD_SourceBuffer = array [0 .. 0] of PKDT1DD_Source;
  PKDT1DD_SourceBuffer = ^TKDT1DD_SourceBuffer;

  TKDT1DDyanmicSourceBuffer = array of PKDT1DD_Source;
  PKDT1DDyanmicSourceBuffer = ^TKDT1DDyanmicSourceBuffer;

  TKDT1DDyanmicStoreBuffer = array of TKDT1DD_Source;
  PKDT1DDyanmicStoreBuffer = ^TKDT1DDyanmicStoreBuffer;

  PKDT1DD_Node = ^TKDT1DD_Node;

  TKDT1DD_Node = packed record
    Parent, Right, Left: PKDT1DD_Node;
    vec: PKDT1DD_Source;
  end;

  TKDT1DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1DD_Source);
  TKDT1DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1DD_Source) of object;
  {$IFNDEF FPC}
  TKDT1DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1DD_Source);
  {$ENDIF}

  TKDT1DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1DDyanmicStoreBuffer;
    KDBuff     : TKDT1DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1DDyanmicStoreBuffer; const Buff: TKDT1DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DD_Node; overload;
    function Search(const Buff: TKDT1DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DD_Node; overload;
    function Search(const Buff: TKDT1DD_Vec; var SearchedDistanceMin: Double): PKDT1DD_Node; overload;
    function Search(const Buff: TKDT1DD_Vec): PKDT1DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1DD_DynamicVecBuffer; var OutBuff: TKDT1DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT2DD_Vec = array [0 .. TKDT2DD_AxisCount - 1] of TKDT2DD_VecType;
  PKDT2DD_Vec = ^TKDT2DD_Vec;

  TKDT2DD_DynamicVecBuffer = array of TKDT2DD_Vec;
  PKDT2DD_DynamicVecBuffer = ^TKDT2DD_DynamicVecBuffer;

  TKDT2DD_Source = packed record
    Buff: TKDT2DD_Vec;
    index: Int64;
  end;

  PKDT2DD_Source       = ^TKDT2DD_Source;
  TKDT2DD_SourceBuffer = array [0 .. 0] of PKDT2DD_Source;
  PKDT2DD_SourceBuffer = ^TKDT2DD_SourceBuffer;

  TKDT2DDyanmicSourceBuffer = array of PKDT2DD_Source;
  PKDT2DDyanmicSourceBuffer = ^TKDT2DDyanmicSourceBuffer;

  TKDT2DDyanmicStoreBuffer = array of TKDT2DD_Source;
  PKDT2DDyanmicStoreBuffer = ^TKDT2DDyanmicStoreBuffer;

  PKDT2DD_Node = ^TKDT2DD_Node;

  TKDT2DD_Node = packed record
    Parent, Right, Left: PKDT2DD_Node;
    vec: PKDT2DD_Source;
  end;

  TKDT2DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT2DD_Source);
  TKDT2DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT2DD_Source) of object;
  {$IFNDEF FPC}
  TKDT2DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT2DD_Source);
  {$ENDIF}

  TKDT2DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT2DDyanmicStoreBuffer;
    KDBuff     : TKDT2DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT2DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT2DDyanmicStoreBuffer; const Buff: TKDT2DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT2DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT2DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DD_Node; overload;
    function Search(const Buff: TKDT2DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DD_Node; overload;
    function Search(const Buff: TKDT2DD_Vec; var SearchedDistanceMin: Double): PKDT2DD_Node; overload;
    function Search(const Buff: TKDT2DD_Vec): PKDT2DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2DD_DynamicVecBuffer; var OutBuff: TKDT2DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT2DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT2DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT3DD_Vec = array [0 .. TKDT3DD_AxisCount - 1] of TKDT3DD_VecType;
  PKDT3DD_Vec = ^TKDT3DD_Vec;

  TKDT3DD_DynamicVecBuffer = array of TKDT3DD_Vec;
  PKDT3DD_DynamicVecBuffer = ^TKDT3DD_DynamicVecBuffer;

  TKDT3DD_Source = packed record
    Buff: TKDT3DD_Vec;
    index: Int64;
  end;

  PKDT3DD_Source       = ^TKDT3DD_Source;
  TKDT3DD_SourceBuffer = array [0 .. 0] of PKDT3DD_Source;
  PKDT3DD_SourceBuffer = ^TKDT3DD_SourceBuffer;

  TKDT3DDyanmicSourceBuffer = array of PKDT3DD_Source;
  PKDT3DDyanmicSourceBuffer = ^TKDT3DDyanmicSourceBuffer;

  TKDT3DDyanmicStoreBuffer = array of TKDT3DD_Source;
  PKDT3DDyanmicStoreBuffer = ^TKDT3DDyanmicStoreBuffer;

  PKDT3DD_Node = ^TKDT3DD_Node;

  TKDT3DD_Node = packed record
    Parent, Right, Left: PKDT3DD_Node;
    vec: PKDT3DD_Source;
  end;

  TKDT3DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT3DD_Source);
  TKDT3DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT3DD_Source) of object;
  {$IFNDEF FPC}
  TKDT3DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT3DD_Source);
  {$ENDIF}

  TKDT3DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3DDyanmicStoreBuffer;
    KDBuff     : TKDT3DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT3DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT3DDyanmicStoreBuffer; const Buff: TKDT3DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT3DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DD_Node; overload;
    function Search(const Buff: TKDT3DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DD_Node; overload;
    function Search(const Buff: TKDT3DD_Vec; var SearchedDistanceMin: Double): PKDT3DD_Node; overload;
    function Search(const Buff: TKDT3DD_Vec): PKDT3DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3DD_DynamicVecBuffer; var OutBuff: TKDT3DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT3DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT3DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT4DD_Vec = array [0 .. TKDT4DD_AxisCount - 1] of TKDT4DD_VecType;
  PKDT4DD_Vec = ^TKDT4DD_Vec;

  TKDT4DD_DynamicVecBuffer = array of TKDT4DD_Vec;
  PKDT4DD_DynamicVecBuffer = ^TKDT4DD_DynamicVecBuffer;

  TKDT4DD_Source = packed record
    Buff: TKDT4DD_Vec;
    index: Int64;
  end;

  PKDT4DD_Source       = ^TKDT4DD_Source;
  TKDT4DD_SourceBuffer = array [0 .. 0] of PKDT4DD_Source;
  PKDT4DD_SourceBuffer = ^TKDT4DD_SourceBuffer;

  TKDT4DDyanmicSourceBuffer = array of PKDT4DD_Source;
  PKDT4DDyanmicSourceBuffer = ^TKDT4DDyanmicSourceBuffer;

  TKDT4DDyanmicStoreBuffer = array of TKDT4DD_Source;
  PKDT4DDyanmicStoreBuffer = ^TKDT4DDyanmicStoreBuffer;

  PKDT4DD_Node = ^TKDT4DD_Node;

  TKDT4DD_Node = packed record
    Parent, Right, Left: PKDT4DD_Node;
    vec: PKDT4DD_Source;
  end;

  TKDT4DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT4DD_Source);
  TKDT4DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT4DD_Source) of object;
  {$IFNDEF FPC}
  TKDT4DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT4DD_Source);
  {$ENDIF}

  TKDT4DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT4DDyanmicStoreBuffer;
    KDBuff     : TKDT4DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT4DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT4DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT4DDyanmicStoreBuffer; const Buff: TKDT4DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT4DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT4DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DD_Node; overload;
    function Search(const Buff: TKDT4DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DD_Node; overload;
    function Search(const Buff: TKDT4DD_Vec; var SearchedDistanceMin: Double): PKDT4DD_Node; overload;
    function Search(const Buff: TKDT4DD_Vec): PKDT4DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4DD_DynamicVecBuffer; var OutBuff: TKDT4DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT4DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT4DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT6DD_Vec = array [0 .. TKDT6DD_AxisCount - 1] of TKDT6DD_VecType;
  PKDT6DD_Vec = ^TKDT6DD_Vec;

  TKDT6DD_DynamicVecBuffer = array of TKDT6DD_Vec;
  PKDT6DD_DynamicVecBuffer = ^TKDT6DD_DynamicVecBuffer;

  TKDT6DD_Source = packed record
    Buff: TKDT6DD_Vec;
    index: Int64;
  end;

  PKDT6DD_Source       = ^TKDT6DD_Source;
  TKDT6DD_SourceBuffer = array [0 .. 0] of PKDT6DD_Source;
  PKDT6DD_SourceBuffer = ^TKDT6DD_SourceBuffer;

  TKDT6DDyanmicSourceBuffer = array of PKDT6DD_Source;
  PKDT6DDyanmicSourceBuffer = ^TKDT6DDyanmicSourceBuffer;

  TKDT6DDyanmicStoreBuffer = array of TKDT6DD_Source;
  PKDT6DDyanmicStoreBuffer = ^TKDT6DDyanmicStoreBuffer;

  PKDT6DD_Node = ^TKDT6DD_Node;

  TKDT6DD_Node = packed record
    Parent, Right, Left: PKDT6DD_Node;
    vec: PKDT6DD_Source;
  end;

  TKDT6DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT6DD_Source);
  TKDT6DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT6DD_Source) of object;
  {$IFNDEF FPC}
  TKDT6DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT6DD_Source);
  {$ENDIF}

  TKDT6DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT6DDyanmicStoreBuffer;
    KDBuff     : TKDT6DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT6DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT6DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT6DDyanmicStoreBuffer; const Buff: TKDT6DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT6DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT6DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT6DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT6DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT6DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DD_Node; overload;
    function Search(const Buff: TKDT6DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DD_Node; overload;
    function Search(const Buff: TKDT6DD_Vec; var SearchedDistanceMin: Double): PKDT6DD_Node; overload;
    function Search(const Buff: TKDT6DD_Vec): PKDT6DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT6DD_DynamicVecBuffer; var OutBuff: TKDT6DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT6DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT6DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT8DD_Vec = array [0 .. TKDT8DD_AxisCount - 1] of TKDT8DD_VecType;
  PKDT8DD_Vec = ^TKDT8DD_Vec;

  TKDT8DD_DynamicVecBuffer = array of TKDT8DD_Vec;
  PKDT8DD_DynamicVecBuffer = ^TKDT8DD_DynamicVecBuffer;

  TKDT8DD_Source = packed record
    Buff: TKDT8DD_Vec;
    index: Int64;
  end;

  PKDT8DD_Source       = ^TKDT8DD_Source;
  TKDT8DD_SourceBuffer = array [0 .. 0] of PKDT8DD_Source;
  PKDT8DD_SourceBuffer = ^TKDT8DD_SourceBuffer;

  TKDT8DDyanmicSourceBuffer = array of PKDT8DD_Source;
  PKDT8DDyanmicSourceBuffer = ^TKDT8DDyanmicSourceBuffer;

  TKDT8DDyanmicStoreBuffer = array of TKDT8DD_Source;
  PKDT8DDyanmicStoreBuffer = ^TKDT8DDyanmicStoreBuffer;

  PKDT8DD_Node = ^TKDT8DD_Node;

  TKDT8DD_Node = packed record
    Parent, Right, Left: PKDT8DD_Node;
    vec: PKDT8DD_Source;
  end;

  TKDT8DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT8DD_Source);
  TKDT8DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT8DD_Source) of object;
  {$IFNDEF FPC}
  TKDT8DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT8DD_Source);
  {$ENDIF}

  TKDT8DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT8DDyanmicStoreBuffer;
    KDBuff     : TKDT8DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT8DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT8DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT8DDyanmicStoreBuffer; const Buff: TKDT8DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT8DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT8DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DD_Node; overload;
    function Search(const Buff: TKDT8DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DD_Node; overload;
    function Search(const Buff: TKDT8DD_Vec; var SearchedDistanceMin: Double): PKDT8DD_Node; overload;
    function Search(const Buff: TKDT8DD_Vec): PKDT8DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8DD_DynamicVecBuffer; var OutBuff: TKDT8DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT8DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT8DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT10DD_Vec = array [0 .. TKDT10DD_AxisCount - 1] of TKDT10DD_VecType;
  PKDT10DD_Vec = ^TKDT10DD_Vec;

  TKDT10DD_DynamicVecBuffer = array of TKDT10DD_Vec;
  PKDT10DD_DynamicVecBuffer = ^TKDT10DD_DynamicVecBuffer;

  TKDT10DD_Source = packed record
    Buff: TKDT10DD_Vec;
    index: Int64;
  end;

  PKDT10DD_Source       = ^TKDT10DD_Source;
  TKDT10DD_SourceBuffer = array [0 .. 0] of PKDT10DD_Source;
  PKDT10DD_SourceBuffer = ^TKDT10DD_SourceBuffer;

  TKDT10DDyanmicSourceBuffer = array of PKDT10DD_Source;
  PKDT10DDyanmicSourceBuffer = ^TKDT10DDyanmicSourceBuffer;

  TKDT10DDyanmicStoreBuffer = array of TKDT10DD_Source;
  PKDT10DDyanmicStoreBuffer = ^TKDT10DDyanmicStoreBuffer;

  PKDT10DD_Node = ^TKDT10DD_Node;

  TKDT10DD_Node = packed record
    Parent, Right, Left: PKDT10DD_Node;
    vec: PKDT10DD_Source;
  end;

  TKDT10DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT10DD_Source);
  TKDT10DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT10DD_Source) of object;
  {$IFNDEF FPC}
  TKDT10DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT10DD_Source);
  {$ENDIF}

  TKDT10DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT10DDyanmicStoreBuffer;
    KDBuff     : TKDT10DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT10DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT10DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT10DDyanmicStoreBuffer; const Buff: TKDT10DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT10DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT10DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT10DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT10DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT10DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DD_Node; overload;
    function Search(const Buff: TKDT10DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DD_Node; overload;
    function Search(const Buff: TKDT10DD_Vec; var SearchedDistanceMin: Double): PKDT10DD_Node; overload;
    function Search(const Buff: TKDT10DD_Vec): PKDT10DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT10DD_DynamicVecBuffer; var OutBuff: TKDT10DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT10DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT10DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT12DD_Vec = array [0 .. TKDT12DD_AxisCount - 1] of TKDT12DD_VecType;
  PKDT12DD_Vec = ^TKDT12DD_Vec;

  TKDT12DD_DynamicVecBuffer = array of TKDT12DD_Vec;
  PKDT12DD_DynamicVecBuffer = ^TKDT12DD_DynamicVecBuffer;

  TKDT12DD_Source = packed record
    Buff: TKDT12DD_Vec;
    index: Int64;
  end;

  PKDT12DD_Source       = ^TKDT12DD_Source;
  TKDT12DD_SourceBuffer = array [0 .. 0] of PKDT12DD_Source;
  PKDT12DD_SourceBuffer = ^TKDT12DD_SourceBuffer;

  TKDT12DDyanmicSourceBuffer = array of PKDT12DD_Source;
  PKDT12DDyanmicSourceBuffer = ^TKDT12DDyanmicSourceBuffer;

  TKDT12DDyanmicStoreBuffer = array of TKDT12DD_Source;
  PKDT12DDyanmicStoreBuffer = ^TKDT12DDyanmicStoreBuffer;

  PKDT12DD_Node = ^TKDT12DD_Node;

  TKDT12DD_Node = packed record
    Parent, Right, Left: PKDT12DD_Node;
    vec: PKDT12DD_Source;
  end;

  TKDT12DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT12DD_Source);
  TKDT12DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT12DD_Source) of object;
  {$IFNDEF FPC}
  TKDT12DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT12DD_Source);
  {$ENDIF}

  TKDT12DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT12DDyanmicStoreBuffer;
    KDBuff     : TKDT12DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT12DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT12DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT12DDyanmicStoreBuffer; const Buff: TKDT12DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT12DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT12DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT12DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT12DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT12DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DD_Node; overload;
    function Search(const Buff: TKDT12DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DD_Node; overload;
    function Search(const Buff: TKDT12DD_Vec; var SearchedDistanceMin: Double): PKDT12DD_Node; overload;
    function Search(const Buff: TKDT12DD_Vec): PKDT12DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT12DD_DynamicVecBuffer; var OutBuff: TKDT12DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT12DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT12DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT14DD_Vec = array [0 .. TKDT14DD_AxisCount - 1] of TKDT14DD_VecType;
  PKDT14DD_Vec = ^TKDT14DD_Vec;

  TKDT14DD_DynamicVecBuffer = array of TKDT14DD_Vec;
  PKDT14DD_DynamicVecBuffer = ^TKDT14DD_DynamicVecBuffer;

  TKDT14DD_Source = packed record
    Buff: TKDT14DD_Vec;
    index: Int64;
  end;

  PKDT14DD_Source       = ^TKDT14DD_Source;
  TKDT14DD_SourceBuffer = array [0 .. 0] of PKDT14DD_Source;
  PKDT14DD_SourceBuffer = ^TKDT14DD_SourceBuffer;

  TKDT14DDyanmicSourceBuffer = array of PKDT14DD_Source;
  PKDT14DDyanmicSourceBuffer = ^TKDT14DDyanmicSourceBuffer;

  TKDT14DDyanmicStoreBuffer = array of TKDT14DD_Source;
  PKDT14DDyanmicStoreBuffer = ^TKDT14DDyanmicStoreBuffer;

  PKDT14DD_Node = ^TKDT14DD_Node;

  TKDT14DD_Node = packed record
    Parent, Right, Left: PKDT14DD_Node;
    vec: PKDT14DD_Source;
  end;

  TKDT14DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT14DD_Source);
  TKDT14DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT14DD_Source) of object;
  {$IFNDEF FPC}
  TKDT14DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT14DD_Source);
  {$ENDIF}

  TKDT14DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT14DDyanmicStoreBuffer;
    KDBuff     : TKDT14DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT14DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT14DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT14DDyanmicStoreBuffer; const Buff: TKDT14DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT14DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT14DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT14DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT14DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT14DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DD_Node; overload;
    function Search(const Buff: TKDT14DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DD_Node; overload;
    function Search(const Buff: TKDT14DD_Vec; var SearchedDistanceMin: Double): PKDT14DD_Node; overload;
    function Search(const Buff: TKDT14DD_Vec): PKDT14DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT14DD_DynamicVecBuffer; var OutBuff: TKDT14DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT14DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT14DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT16DD_Vec = array [0 .. TKDT16DD_AxisCount - 1] of TKDT16DD_VecType;
  PKDT16DD_Vec = ^TKDT16DD_Vec;

  TKDT16DD_DynamicVecBuffer = array of TKDT16DD_Vec;
  PKDT16DD_DynamicVecBuffer = ^TKDT16DD_DynamicVecBuffer;

  TKDT16DD_Source = packed record
    Buff: TKDT16DD_Vec;
    index: Int64;
  end;

  PKDT16DD_Source       = ^TKDT16DD_Source;
  TKDT16DD_SourceBuffer = array [0 .. 0] of PKDT16DD_Source;
  PKDT16DD_SourceBuffer = ^TKDT16DD_SourceBuffer;

  TKDT16DDyanmicSourceBuffer = array of PKDT16DD_Source;
  PKDT16DDyanmicSourceBuffer = ^TKDT16DDyanmicSourceBuffer;

  TKDT16DDyanmicStoreBuffer = array of TKDT16DD_Source;
  PKDT16DDyanmicStoreBuffer = ^TKDT16DDyanmicStoreBuffer;

  PKDT16DD_Node = ^TKDT16DD_Node;

  TKDT16DD_Node = packed record
    Parent, Right, Left: PKDT16DD_Node;
    vec: PKDT16DD_Source;
  end;

  TKDT16DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT16DD_Source);
  TKDT16DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT16DD_Source) of object;
  {$IFNDEF FPC}
  TKDT16DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT16DD_Source);
  {$ENDIF}

  TKDT16DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT16DDyanmicStoreBuffer;
    KDBuff     : TKDT16DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT16DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT16DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT16DDyanmicStoreBuffer; const Buff: TKDT16DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT16DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT16DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT16DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT16DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT16DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DD_Node; overload;
    function Search(const Buff: TKDT16DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DD_Node; overload;
    function Search(const Buff: TKDT16DD_Vec; var SearchedDistanceMin: Double): PKDT16DD_Node; overload;
    function Search(const Buff: TKDT16DD_Vec): PKDT16DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT16DD_DynamicVecBuffer; var OutBuff: TKDT16DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT16DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT16DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT18DD_Vec = array [0 .. TKDT18DD_AxisCount - 1] of TKDT18DD_VecType;
  PKDT18DD_Vec = ^TKDT18DD_Vec;

  TKDT18DD_DynamicVecBuffer = array of TKDT18DD_Vec;
  PKDT18DD_DynamicVecBuffer = ^TKDT18DD_DynamicVecBuffer;

  TKDT18DD_Source = packed record
    Buff: TKDT18DD_Vec;
    index: Int64;
  end;

  PKDT18DD_Source       = ^TKDT18DD_Source;
  TKDT18DD_SourceBuffer = array [0 .. 0] of PKDT18DD_Source;
  PKDT18DD_SourceBuffer = ^TKDT18DD_SourceBuffer;

  TKDT18DDyanmicSourceBuffer = array of PKDT18DD_Source;
  PKDT18DDyanmicSourceBuffer = ^TKDT18DDyanmicSourceBuffer;

  TKDT18DDyanmicStoreBuffer = array of TKDT18DD_Source;
  PKDT18DDyanmicStoreBuffer = ^TKDT18DDyanmicStoreBuffer;

  PKDT18DD_Node = ^TKDT18DD_Node;

  TKDT18DD_Node = packed record
    Parent, Right, Left: PKDT18DD_Node;
    vec: PKDT18DD_Source;
  end;

  TKDT18DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT18DD_Source);
  TKDT18DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT18DD_Source) of object;
  {$IFNDEF FPC}
  TKDT18DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT18DD_Source);
  {$ENDIF}

  TKDT18DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT18DDyanmicStoreBuffer;
    KDBuff     : TKDT18DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT18DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT18DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT18DDyanmicStoreBuffer; const Buff: TKDT18DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT18DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT18DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT18DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT18DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT18DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DD_Node; overload;
    function Search(const Buff: TKDT18DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DD_Node; overload;
    function Search(const Buff: TKDT18DD_Vec; var SearchedDistanceMin: Double): PKDT18DD_Node; overload;
    function Search(const Buff: TKDT18DD_Vec): PKDT18DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT18DD_DynamicVecBuffer; var OutBuff: TKDT18DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT18DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT18DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT20DD_Vec = array [0 .. TKDT20DD_AxisCount - 1] of TKDT20DD_VecType;
  PKDT20DD_Vec = ^TKDT20DD_Vec;

  TKDT20DD_DynamicVecBuffer = array of TKDT20DD_Vec;
  PKDT20DD_DynamicVecBuffer = ^TKDT20DD_DynamicVecBuffer;

  TKDT20DD_Source = packed record
    Buff: TKDT20DD_Vec;
    index: Int64;
  end;

  PKDT20DD_Source       = ^TKDT20DD_Source;
  TKDT20DD_SourceBuffer = array [0 .. 0] of PKDT20DD_Source;
  PKDT20DD_SourceBuffer = ^TKDT20DD_SourceBuffer;

  TKDT20DDyanmicSourceBuffer = array of PKDT20DD_Source;
  PKDT20DDyanmicSourceBuffer = ^TKDT20DDyanmicSourceBuffer;

  TKDT20DDyanmicStoreBuffer = array of TKDT20DD_Source;
  PKDT20DDyanmicStoreBuffer = ^TKDT20DDyanmicStoreBuffer;

  PKDT20DD_Node = ^TKDT20DD_Node;

  TKDT20DD_Node = packed record
    Parent, Right, Left: PKDT20DD_Node;
    vec: PKDT20DD_Source;
  end;

  TKDT20DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT20DD_Source);
  TKDT20DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT20DD_Source) of object;
  {$IFNDEF FPC}
  TKDT20DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT20DD_Source);
  {$ENDIF}

  TKDT20DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT20DDyanmicStoreBuffer;
    KDBuff     : TKDT20DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT20DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT20DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT20DDyanmicStoreBuffer; const Buff: TKDT20DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT20DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT20DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT20DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT20DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT20DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DD_Node; overload;
    function Search(const Buff: TKDT20DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DD_Node; overload;
    function Search(const Buff: TKDT20DD_Vec; var SearchedDistanceMin: Double): PKDT20DD_Node; overload;
    function Search(const Buff: TKDT20DD_Vec): PKDT20DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT20DD_DynamicVecBuffer; var OutBuff: TKDT20DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT20DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT20DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT22DD_Vec = array [0 .. TKDT22DD_AxisCount - 1] of TKDT22DD_VecType;
  PKDT22DD_Vec = ^TKDT22DD_Vec;

  TKDT22DD_DynamicVecBuffer = array of TKDT22DD_Vec;
  PKDT22DD_DynamicVecBuffer = ^TKDT22DD_DynamicVecBuffer;

  TKDT22DD_Source = packed record
    Buff: TKDT22DD_Vec;
    index: Int64;
  end;

  PKDT22DD_Source       = ^TKDT22DD_Source;
  TKDT22DD_SourceBuffer = array [0 .. 0] of PKDT22DD_Source;
  PKDT22DD_SourceBuffer = ^TKDT22DD_SourceBuffer;

  TKDT22DDyanmicSourceBuffer = array of PKDT22DD_Source;
  PKDT22DDyanmicSourceBuffer = ^TKDT22DDyanmicSourceBuffer;

  TKDT22DDyanmicStoreBuffer = array of TKDT22DD_Source;
  PKDT22DDyanmicStoreBuffer = ^TKDT22DDyanmicStoreBuffer;

  PKDT22DD_Node = ^TKDT22DD_Node;

  TKDT22DD_Node = packed record
    Parent, Right, Left: PKDT22DD_Node;
    vec: PKDT22DD_Source;
  end;

  TKDT22DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT22DD_Source);
  TKDT22DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT22DD_Source) of object;
  {$IFNDEF FPC}
  TKDT22DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT22DD_Source);
  {$ENDIF}

  TKDT22DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT22DDyanmicStoreBuffer;
    KDBuff     : TKDT22DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT22DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT22DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT22DDyanmicStoreBuffer; const Buff: TKDT22DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT22DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT22DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT22DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT22DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT22DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DD_Node; overload;
    function Search(const Buff: TKDT22DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DD_Node; overload;
    function Search(const Buff: TKDT22DD_Vec; var SearchedDistanceMin: Double): PKDT22DD_Node; overload;
    function Search(const Buff: TKDT22DD_Vec): PKDT22DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT22DD_DynamicVecBuffer; var OutBuff: TKDT22DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT22DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT22DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT24DD_Vec = array [0 .. TKDT24DD_AxisCount - 1] of TKDT24DD_VecType;
  PKDT24DD_Vec = ^TKDT24DD_Vec;

  TKDT24DD_DynamicVecBuffer = array of TKDT24DD_Vec;
  PKDT24DD_DynamicVecBuffer = ^TKDT24DD_DynamicVecBuffer;

  TKDT24DD_Source = packed record
    Buff: TKDT24DD_Vec;
    index: Int64;
  end;

  PKDT24DD_Source       = ^TKDT24DD_Source;
  TKDT24DD_SourceBuffer = array [0 .. 0] of PKDT24DD_Source;
  PKDT24DD_SourceBuffer = ^TKDT24DD_SourceBuffer;

  TKDT24DDyanmicSourceBuffer = array of PKDT24DD_Source;
  PKDT24DDyanmicSourceBuffer = ^TKDT24DDyanmicSourceBuffer;

  TKDT24DDyanmicStoreBuffer = array of TKDT24DD_Source;
  PKDT24DDyanmicStoreBuffer = ^TKDT24DDyanmicStoreBuffer;

  PKDT24DD_Node = ^TKDT24DD_Node;

  TKDT24DD_Node = packed record
    Parent, Right, Left: PKDT24DD_Node;
    vec: PKDT24DD_Source;
  end;

  TKDT24DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT24DD_Source);
  TKDT24DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT24DD_Source) of object;
  {$IFNDEF FPC}
  TKDT24DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT24DD_Source);
  {$ENDIF}

  TKDT24DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT24DDyanmicStoreBuffer;
    KDBuff     : TKDT24DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT24DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT24DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT24DDyanmicStoreBuffer; const Buff: TKDT24DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT24DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT24DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT24DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT24DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT24DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DD_Node; overload;
    function Search(const Buff: TKDT24DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DD_Node; overload;
    function Search(const Buff: TKDT24DD_Vec; var SearchedDistanceMin: Double): PKDT24DD_Node; overload;
    function Search(const Buff: TKDT24DD_Vec): PKDT24DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT24DD_DynamicVecBuffer; var OutBuff: TKDT24DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT24DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT24DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT28DD_Vec = array [0 .. TKDT28DD_AxisCount - 1] of TKDT28DD_VecType;
  PKDT28DD_Vec = ^TKDT28DD_Vec;

  TKDT28DD_DynamicVecBuffer = array of TKDT28DD_Vec;
  PKDT28DD_DynamicVecBuffer = ^TKDT28DD_DynamicVecBuffer;

  TKDT28DD_Source = packed record
    Buff: TKDT28DD_Vec;
    index: Int64;
  end;

  PKDT28DD_Source       = ^TKDT28DD_Source;
  TKDT28DD_SourceBuffer = array [0 .. 0] of PKDT28DD_Source;
  PKDT28DD_SourceBuffer = ^TKDT28DD_SourceBuffer;

  TKDT28DDyanmicSourceBuffer = array of PKDT28DD_Source;
  PKDT28DDyanmicSourceBuffer = ^TKDT28DDyanmicSourceBuffer;

  TKDT28DDyanmicStoreBuffer = array of TKDT28DD_Source;
  PKDT28DDyanmicStoreBuffer = ^TKDT28DDyanmicStoreBuffer;

  PKDT28DD_Node = ^TKDT28DD_Node;

  TKDT28DD_Node = packed record
    Parent, Right, Left: PKDT28DD_Node;
    vec: PKDT28DD_Source;
  end;

  TKDT28DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT28DD_Source);
  TKDT28DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT28DD_Source) of object;
  {$IFNDEF FPC}
  TKDT28DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT28DD_Source);
  {$ENDIF}

  TKDT28DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT28DDyanmicStoreBuffer;
    KDBuff     : TKDT28DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT28DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT28DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT28DDyanmicStoreBuffer; const Buff: TKDT28DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT28DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT28DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT28DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT28DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT28DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DD_Node; overload;
    function Search(const Buff: TKDT28DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DD_Node; overload;
    function Search(const Buff: TKDT28DD_Vec; var SearchedDistanceMin: Double): PKDT28DD_Node; overload;
    function Search(const Buff: TKDT28DD_Vec): PKDT28DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT28DD_DynamicVecBuffer; var OutBuff: TKDT28DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT28DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT28DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT30DD_Vec = array [0 .. TKDT30DD_AxisCount - 1] of TKDT30DD_VecType;
  PKDT30DD_Vec = ^TKDT30DD_Vec;

  TKDT30DD_DynamicVecBuffer = array of TKDT30DD_Vec;
  PKDT30DD_DynamicVecBuffer = ^TKDT30DD_DynamicVecBuffer;

  TKDT30DD_Source = packed record
    Buff: TKDT30DD_Vec;
    index: Int64;
  end;

  PKDT30DD_Source       = ^TKDT30DD_Source;
  TKDT30DD_SourceBuffer = array [0 .. 0] of PKDT30DD_Source;
  PKDT30DD_SourceBuffer = ^TKDT30DD_SourceBuffer;

  TKDT30DDyanmicSourceBuffer = array of PKDT30DD_Source;
  PKDT30DDyanmicSourceBuffer = ^TKDT30DDyanmicSourceBuffer;

  TKDT30DDyanmicStoreBuffer = array of TKDT30DD_Source;
  PKDT30DDyanmicStoreBuffer = ^TKDT30DDyanmicStoreBuffer;

  PKDT30DD_Node = ^TKDT30DD_Node;

  TKDT30DD_Node = packed record
    Parent, Right, Left: PKDT30DD_Node;
    vec: PKDT30DD_Source;
  end;

  TKDT30DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT30DD_Source);
  TKDT30DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT30DD_Source) of object;
  {$IFNDEF FPC}
  TKDT30DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT30DD_Source);
  {$ENDIF}

  TKDT30DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT30DDyanmicStoreBuffer;
    KDBuff     : TKDT30DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT30DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT30DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT30DDyanmicStoreBuffer; const Buff: TKDT30DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT30DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT30DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT30DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT30DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT30DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DD_Node; overload;
    function Search(const Buff: TKDT30DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DD_Node; overload;
    function Search(const Buff: TKDT30DD_Vec; var SearchedDistanceMin: Double): PKDT30DD_Node; overload;
    function Search(const Buff: TKDT30DD_Vec): PKDT30DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT30DD_DynamicVecBuffer; var OutBuff: TKDT30DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT30DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT30DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT32DD_Vec = array [0 .. TKDT32DD_AxisCount - 1] of TKDT32DD_VecType;
  PKDT32DD_Vec = ^TKDT32DD_Vec;

  TKDT32DD_DynamicVecBuffer = array of TKDT32DD_Vec;
  PKDT32DD_DynamicVecBuffer = ^TKDT32DD_DynamicVecBuffer;

  TKDT32DD_Source = packed record
    Buff: TKDT32DD_Vec;
    index: Int64;
  end;

  PKDT32DD_Source       = ^TKDT32DD_Source;
  TKDT32DD_SourceBuffer = array [0 .. 0] of PKDT32DD_Source;
  PKDT32DD_SourceBuffer = ^TKDT32DD_SourceBuffer;

  TKDT32DDyanmicSourceBuffer = array of PKDT32DD_Source;
  PKDT32DDyanmicSourceBuffer = ^TKDT32DDyanmicSourceBuffer;

  TKDT32DDyanmicStoreBuffer = array of TKDT32DD_Source;
  PKDT32DDyanmicStoreBuffer = ^TKDT32DDyanmicStoreBuffer;

  PKDT32DD_Node = ^TKDT32DD_Node;

  TKDT32DD_Node = packed record
    Parent, Right, Left: PKDT32DD_Node;
    vec: PKDT32DD_Source;
  end;

  TKDT32DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT32DD_Source);
  TKDT32DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT32DD_Source) of object;
  {$IFNDEF FPC}
  TKDT32DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT32DD_Source);
  {$ENDIF}

  TKDT32DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT32DDyanmicStoreBuffer;
    KDBuff     : TKDT32DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT32DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT32DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT32DDyanmicStoreBuffer; const Buff: TKDT32DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT32DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT32DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT32DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT32DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT32DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DD_Node; overload;
    function Search(const Buff: TKDT32DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DD_Node; overload;
    function Search(const Buff: TKDT32DD_Vec; var SearchedDistanceMin: Double): PKDT32DD_Node; overload;
    function Search(const Buff: TKDT32DD_Vec): PKDT32DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT32DD_DynamicVecBuffer; var OutBuff: TKDT32DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT32DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT32DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT34DD_Vec = array [0 .. TKDT34DD_AxisCount - 1] of TKDT34DD_VecType;
  PKDT34DD_Vec = ^TKDT34DD_Vec;

  TKDT34DD_DynamicVecBuffer = array of TKDT34DD_Vec;
  PKDT34DD_DynamicVecBuffer = ^TKDT34DD_DynamicVecBuffer;

  TKDT34DD_Source = packed record
    Buff: TKDT34DD_Vec;
    index: Int64;
  end;

  PKDT34DD_Source       = ^TKDT34DD_Source;
  TKDT34DD_SourceBuffer = array [0 .. 0] of PKDT34DD_Source;
  PKDT34DD_SourceBuffer = ^TKDT34DD_SourceBuffer;

  TKDT34DDyanmicSourceBuffer = array of PKDT34DD_Source;
  PKDT34DDyanmicSourceBuffer = ^TKDT34DDyanmicSourceBuffer;

  TKDT34DDyanmicStoreBuffer = array of TKDT34DD_Source;
  PKDT34DDyanmicStoreBuffer = ^TKDT34DDyanmicStoreBuffer;

  PKDT34DD_Node = ^TKDT34DD_Node;

  TKDT34DD_Node = packed record
    Parent, Right, Left: PKDT34DD_Node;
    vec: PKDT34DD_Source;
  end;

  TKDT34DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT34DD_Source);
  TKDT34DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT34DD_Source) of object;
  {$IFNDEF FPC}
  TKDT34DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT34DD_Source);
  {$ENDIF}

  TKDT34DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT34DDyanmicStoreBuffer;
    KDBuff     : TKDT34DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT34DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT34DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT34DDyanmicStoreBuffer; const Buff: TKDT34DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT34DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT34DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT34DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT34DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT34DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DD_Node; overload;
    function Search(const Buff: TKDT34DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DD_Node; overload;
    function Search(const Buff: TKDT34DD_Vec; var SearchedDistanceMin: Double): PKDT34DD_Node; overload;
    function Search(const Buff: TKDT34DD_Vec): PKDT34DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT34DD_DynamicVecBuffer; var OutBuff: TKDT34DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT34DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT34DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT36DD_Vec = array [0 .. TKDT36DD_AxisCount - 1] of TKDT36DD_VecType;
  PKDT36DD_Vec = ^TKDT36DD_Vec;

  TKDT36DD_DynamicVecBuffer = array of TKDT36DD_Vec;
  PKDT36DD_DynamicVecBuffer = ^TKDT36DD_DynamicVecBuffer;

  TKDT36DD_Source = packed record
    Buff: TKDT36DD_Vec;
    index: Int64;
  end;

  PKDT36DD_Source       = ^TKDT36DD_Source;
  TKDT36DD_SourceBuffer = array [0 .. 0] of PKDT36DD_Source;
  PKDT36DD_SourceBuffer = ^TKDT36DD_SourceBuffer;

  TKDT36DDyanmicSourceBuffer = array of PKDT36DD_Source;
  PKDT36DDyanmicSourceBuffer = ^TKDT36DDyanmicSourceBuffer;

  TKDT36DDyanmicStoreBuffer = array of TKDT36DD_Source;
  PKDT36DDyanmicStoreBuffer = ^TKDT36DDyanmicStoreBuffer;

  PKDT36DD_Node = ^TKDT36DD_Node;

  TKDT36DD_Node = packed record
    Parent, Right, Left: PKDT36DD_Node;
    vec: PKDT36DD_Source;
  end;

  TKDT36DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT36DD_Source);
  TKDT36DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT36DD_Source) of object;
  {$IFNDEF FPC}
  TKDT36DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT36DD_Source);
  {$ENDIF}

  TKDT36DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT36DDyanmicStoreBuffer;
    KDBuff     : TKDT36DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT36DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT36DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT36DDyanmicStoreBuffer; const Buff: TKDT36DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT36DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT36DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT36DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT36DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT36DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DD_Node; overload;
    function Search(const Buff: TKDT36DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DD_Node; overload;
    function Search(const Buff: TKDT36DD_Vec; var SearchedDistanceMin: Double): PKDT36DD_Node; overload;
    function Search(const Buff: TKDT36DD_Vec): PKDT36DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT36DD_DynamicVecBuffer; var OutBuff: TKDT36DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT36DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT36DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT40DD_Vec = array [0 .. TKDT40DD_AxisCount - 1] of TKDT40DD_VecType;
  PKDT40DD_Vec = ^TKDT40DD_Vec;

  TKDT40DD_DynamicVecBuffer = array of TKDT40DD_Vec;
  PKDT40DD_DynamicVecBuffer = ^TKDT40DD_DynamicVecBuffer;

  TKDT40DD_Source = packed record
    Buff: TKDT40DD_Vec;
    index: Int64;
  end;

  PKDT40DD_Source       = ^TKDT40DD_Source;
  TKDT40DD_SourceBuffer = array [0 .. 0] of PKDT40DD_Source;
  PKDT40DD_SourceBuffer = ^TKDT40DD_SourceBuffer;

  TKDT40DDyanmicSourceBuffer = array of PKDT40DD_Source;
  PKDT40DDyanmicSourceBuffer = ^TKDT40DDyanmicSourceBuffer;

  TKDT40DDyanmicStoreBuffer = array of TKDT40DD_Source;
  PKDT40DDyanmicStoreBuffer = ^TKDT40DDyanmicStoreBuffer;

  PKDT40DD_Node = ^TKDT40DD_Node;

  TKDT40DD_Node = packed record
    Parent, Right, Left: PKDT40DD_Node;
    vec: PKDT40DD_Source;
  end;

  TKDT40DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT40DD_Source);
  TKDT40DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT40DD_Source) of object;
  {$IFNDEF FPC}
  TKDT40DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT40DD_Source);
  {$ENDIF}

  TKDT40DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT40DDyanmicStoreBuffer;
    KDBuff     : TKDT40DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT40DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT40DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT40DDyanmicStoreBuffer; const Buff: TKDT40DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT40DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT40DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT40DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT40DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT40DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DD_Node; overload;
    function Search(const Buff: TKDT40DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DD_Node; overload;
    function Search(const Buff: TKDT40DD_Vec; var SearchedDistanceMin: Double): PKDT40DD_Node; overload;
    function Search(const Buff: TKDT40DD_Vec): PKDT40DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT40DD_DynamicVecBuffer; var OutBuff: TKDT40DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT40DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT40DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT48DD_Vec = array [0 .. TKDT48DD_AxisCount - 1] of TKDT48DD_VecType;
  PKDT48DD_Vec = ^TKDT48DD_Vec;

  TKDT48DD_DynamicVecBuffer = array of TKDT48DD_Vec;
  PKDT48DD_DynamicVecBuffer = ^TKDT48DD_DynamicVecBuffer;

  TKDT48DD_Source = packed record
    Buff: TKDT48DD_Vec;
    index: Int64;
  end;

  PKDT48DD_Source       = ^TKDT48DD_Source;
  TKDT48DD_SourceBuffer = array [0 .. 0] of PKDT48DD_Source;
  PKDT48DD_SourceBuffer = ^TKDT48DD_SourceBuffer;

  TKDT48DDyanmicSourceBuffer = array of PKDT48DD_Source;
  PKDT48DDyanmicSourceBuffer = ^TKDT48DDyanmicSourceBuffer;

  TKDT48DDyanmicStoreBuffer = array of TKDT48DD_Source;
  PKDT48DDyanmicStoreBuffer = ^TKDT48DDyanmicStoreBuffer;

  PKDT48DD_Node = ^TKDT48DD_Node;

  TKDT48DD_Node = packed record
    Parent, Right, Left: PKDT48DD_Node;
    vec: PKDT48DD_Source;
  end;

  TKDT48DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT48DD_Source);
  TKDT48DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT48DD_Source) of object;
  {$IFNDEF FPC}
  TKDT48DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT48DD_Source);
  {$ENDIF}

  TKDT48DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT48DDyanmicStoreBuffer;
    KDBuff     : TKDT48DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT48DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT48DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT48DDyanmicStoreBuffer; const Buff: TKDT48DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT48DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT48DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT48DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT48DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT48DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DD_Node; overload;
    function Search(const Buff: TKDT48DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DD_Node; overload;
    function Search(const Buff: TKDT48DD_Vec; var SearchedDistanceMin: Double): PKDT48DD_Node; overload;
    function Search(const Buff: TKDT48DD_Vec): PKDT48DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT48DD_DynamicVecBuffer; var OutBuff: TKDT48DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT48DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT48DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT64DD_Vec = array [0 .. TKDT64DD_AxisCount - 1] of TKDT64DD_VecType;
  PKDT64DD_Vec = ^TKDT64DD_Vec;

  TKDT64DD_DynamicVecBuffer = array of TKDT64DD_Vec;
  PKDT64DD_DynamicVecBuffer = ^TKDT64DD_DynamicVecBuffer;

  TKDT64DD_Source = packed record
    Buff: TKDT64DD_Vec;
    index: Int64;
  end;

  PKDT64DD_Source       = ^TKDT64DD_Source;
  TKDT64DD_SourceBuffer = array [0 .. 0] of PKDT64DD_Source;
  PKDT64DD_SourceBuffer = ^TKDT64DD_SourceBuffer;

  TKDT64DDyanmicSourceBuffer = array of PKDT64DD_Source;
  PKDT64DDyanmicSourceBuffer = ^TKDT64DDyanmicSourceBuffer;

  TKDT64DDyanmicStoreBuffer = array of TKDT64DD_Source;
  PKDT64DDyanmicStoreBuffer = ^TKDT64DDyanmicStoreBuffer;

  PKDT64DD_Node = ^TKDT64DD_Node;

  TKDT64DD_Node = packed record
    Parent, Right, Left: PKDT64DD_Node;
    vec: PKDT64DD_Source;
  end;

  TKDT64DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT64DD_Source);
  TKDT64DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT64DD_Source) of object;
  {$IFNDEF FPC}
  TKDT64DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT64DD_Source);
  {$ENDIF}

  TKDT64DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT64DDyanmicStoreBuffer;
    KDBuff     : TKDT64DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT64DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT64DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT64DDyanmicStoreBuffer; const Buff: TKDT64DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT64DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT64DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT64DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT64DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT64DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DD_Node; overload;
    function Search(const Buff: TKDT64DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DD_Node; overload;
    function Search(const Buff: TKDT64DD_Vec; var SearchedDistanceMin: Double): PKDT64DD_Node; overload;
    function Search(const Buff: TKDT64DD_Vec): PKDT64DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT64DD_DynamicVecBuffer; var OutBuff: TKDT64DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT64DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT64DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT96DD_Vec = array [0 .. TKDT96DD_AxisCount - 1] of TKDT96DD_VecType;
  PKDT96DD_Vec = ^TKDT96DD_Vec;

  TKDT96DD_DynamicVecBuffer = array of TKDT96DD_Vec;
  PKDT96DD_DynamicVecBuffer = ^TKDT96DD_DynamicVecBuffer;

  TKDT96DD_Source = packed record
    Buff: TKDT96DD_Vec;
    index: Int64;
  end;

  PKDT96DD_Source       = ^TKDT96DD_Source;
  TKDT96DD_SourceBuffer = array [0 .. 0] of PKDT96DD_Source;
  PKDT96DD_SourceBuffer = ^TKDT96DD_SourceBuffer;

  TKDT96DDyanmicSourceBuffer = array of PKDT96DD_Source;
  PKDT96DDyanmicSourceBuffer = ^TKDT96DDyanmicSourceBuffer;

  TKDT96DDyanmicStoreBuffer = array of TKDT96DD_Source;
  PKDT96DDyanmicStoreBuffer = ^TKDT96DDyanmicStoreBuffer;

  PKDT96DD_Node = ^TKDT96DD_Node;

  TKDT96DD_Node = packed record
    Parent, Right, Left: PKDT96DD_Node;
    vec: PKDT96DD_Source;
  end;

  TKDT96DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT96DD_Source);
  TKDT96DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT96DD_Source) of object;
  {$IFNDEF FPC}
  TKDT96DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT96DD_Source);
  {$ENDIF}

  TKDT96DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT96DDyanmicStoreBuffer;
    KDBuff     : TKDT96DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT96DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT96DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT96DDyanmicStoreBuffer; const Buff: TKDT96DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT96DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT96DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT96DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT96DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT96DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DD_Node; overload;
    function Search(const Buff: TKDT96DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DD_Node; overload;
    function Search(const Buff: TKDT96DD_Vec; var SearchedDistanceMin: Double): PKDT96DD_Node; overload;
    function Search(const Buff: TKDT96DD_Vec): PKDT96DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT96DD_DynamicVecBuffer; var OutBuff: TKDT96DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT96DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT96DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT128DD_Vec = array [0 .. TKDT128DD_AxisCount - 1] of TKDT128DD_VecType;
  PKDT128DD_Vec = ^TKDT128DD_Vec;

  TKDT128DD_DynamicVecBuffer = array of TKDT128DD_Vec;
  PKDT128DD_DynamicVecBuffer = ^TKDT128DD_DynamicVecBuffer;

  TKDT128DD_Source = packed record
    Buff: TKDT128DD_Vec;
    index: Int64;
  end;

  PKDT128DD_Source       = ^TKDT128DD_Source;
  TKDT128DD_SourceBuffer = array [0 .. 0] of PKDT128DD_Source;
  PKDT128DD_SourceBuffer = ^TKDT128DD_SourceBuffer;

  TKDT128DDyanmicSourceBuffer = array of PKDT128DD_Source;
  PKDT128DDyanmicSourceBuffer = ^TKDT128DDyanmicSourceBuffer;

  TKDT128DDyanmicStoreBuffer = array of TKDT128DD_Source;
  PKDT128DDyanmicStoreBuffer = ^TKDT128DDyanmicStoreBuffer;

  PKDT128DD_Node = ^TKDT128DD_Node;

  TKDT128DD_Node = packed record
    Parent, Right, Left: PKDT128DD_Node;
    vec: PKDT128DD_Source;
  end;

  TKDT128DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT128DD_Source);
  TKDT128DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT128DD_Source) of object;
  {$IFNDEF FPC}
  TKDT128DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT128DD_Source);
  {$ENDIF}

  TKDT128DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT128DDyanmicStoreBuffer;
    KDBuff     : TKDT128DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT128DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT128DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT128DDyanmicStoreBuffer; const Buff: TKDT128DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT128DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT128DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT128DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT128DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT128DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DD_Node; overload;
    function Search(const Buff: TKDT128DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DD_Node; overload;
    function Search(const Buff: TKDT128DD_Vec; var SearchedDistanceMin: Double): PKDT128DD_Node; overload;
    function Search(const Buff: TKDT128DD_Vec): PKDT128DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT128DD_DynamicVecBuffer; var OutBuff: TKDT128DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT128DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT128DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT256DD_Vec = array [0 .. TKDT256DD_AxisCount - 1] of TKDT256DD_VecType;
  PKDT256DD_Vec = ^TKDT256DD_Vec;

  TKDT256DD_DynamicVecBuffer = array of TKDT256DD_Vec;
  PKDT256DD_DynamicVecBuffer = ^TKDT256DD_DynamicVecBuffer;

  TKDT256DD_Source = packed record
    Buff: TKDT256DD_Vec;
    index: Int64;
  end;

  PKDT256DD_Source       = ^TKDT256DD_Source;
  TKDT256DD_SourceBuffer = array [0 .. 0] of PKDT256DD_Source;
  PKDT256DD_SourceBuffer = ^TKDT256DD_SourceBuffer;

  TKDT256DDyanmicSourceBuffer = array of PKDT256DD_Source;
  PKDT256DDyanmicSourceBuffer = ^TKDT256DDyanmicSourceBuffer;

  TKDT256DDyanmicStoreBuffer = array of TKDT256DD_Source;
  PKDT256DDyanmicStoreBuffer = ^TKDT256DDyanmicStoreBuffer;

  PKDT256DD_Node = ^TKDT256DD_Node;

  TKDT256DD_Node = packed record
    Parent, Right, Left: PKDT256DD_Node;
    vec: PKDT256DD_Source;
  end;

  TKDT256DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT256DD_Source);
  TKDT256DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT256DD_Source) of object;
  {$IFNDEF FPC}
  TKDT256DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT256DD_Source);
  {$ENDIF}

  TKDT256DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT256DDyanmicStoreBuffer;
    KDBuff     : TKDT256DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT256DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT256DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT256DDyanmicStoreBuffer; const Buff: TKDT256DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT256DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT256DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT256DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT256DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT256DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DD_Node; overload;
    function Search(const Buff: TKDT256DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DD_Node; overload;
    function Search(const Buff: TKDT256DD_Vec; var SearchedDistanceMin: Double): PKDT256DD_Node; overload;
    function Search(const Buff: TKDT256DD_Vec): PKDT256DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT256DD_DynamicVecBuffer; var OutBuff: TKDT256DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT256DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT256DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT372DD_Vec = array [0 .. TKDT372DD_AxisCount - 1] of TKDT372DD_VecType;
  PKDT372DD_Vec = ^TKDT372DD_Vec;

  TKDT372DD_DynamicVecBuffer = array of TKDT372DD_Vec;
  PKDT372DD_DynamicVecBuffer = ^TKDT372DD_DynamicVecBuffer;

  TKDT372DD_Source = packed record
    Buff: TKDT372DD_Vec;
    index: Int64;
  end;

  PKDT372DD_Source       = ^TKDT372DD_Source;
  TKDT372DD_SourceBuffer = array [0 .. 0] of PKDT372DD_Source;
  PKDT372DD_SourceBuffer = ^TKDT372DD_SourceBuffer;

  TKDT372DDyanmicSourceBuffer = array of PKDT372DD_Source;
  PKDT372DDyanmicSourceBuffer = ^TKDT372DDyanmicSourceBuffer;

  TKDT372DDyanmicStoreBuffer = array of TKDT372DD_Source;
  PKDT372DDyanmicStoreBuffer = ^TKDT372DDyanmicStoreBuffer;

  PKDT372DD_Node = ^TKDT372DD_Node;

  TKDT372DD_Node = packed record
    Parent, Right, Left: PKDT372DD_Node;
    vec: PKDT372DD_Source;
  end;

  TKDT372DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT372DD_Source);
  TKDT372DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT372DD_Source) of object;
  {$IFNDEF FPC}
  TKDT372DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT372DD_Source);
  {$ENDIF}

  TKDT372DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT372DDyanmicStoreBuffer;
    KDBuff     : TKDT372DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT372DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT372DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT372DDyanmicStoreBuffer; const Buff: TKDT372DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT372DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT372DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT372DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT372DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT372DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DD_Node; overload;
    function Search(const Buff: TKDT372DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DD_Node; overload;
    function Search(const Buff: TKDT372DD_Vec; var SearchedDistanceMin: Double): PKDT372DD_Node; overload;
    function Search(const Buff: TKDT372DD_Vec): PKDT372DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT372DD_DynamicVecBuffer; var OutBuff: TKDT372DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT372DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT372DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT512DD_Vec = array [0 .. TKDT512DD_AxisCount - 1] of TKDT512DD_VecType;
  PKDT512DD_Vec = ^TKDT512DD_Vec;

  TKDT512DD_DynamicVecBuffer = array of TKDT512DD_Vec;
  PKDT512DD_DynamicVecBuffer = ^TKDT512DD_DynamicVecBuffer;

  TKDT512DD_Source = packed record
    Buff: TKDT512DD_Vec;
    index: Int64;
  end;

  PKDT512DD_Source       = ^TKDT512DD_Source;
  TKDT512DD_SourceBuffer = array [0 .. 0] of PKDT512DD_Source;
  PKDT512DD_SourceBuffer = ^TKDT512DD_SourceBuffer;

  TKDT512DDyanmicSourceBuffer = array of PKDT512DD_Source;
  PKDT512DDyanmicSourceBuffer = ^TKDT512DDyanmicSourceBuffer;

  TKDT512DDyanmicStoreBuffer = array of TKDT512DD_Source;
  PKDT512DDyanmicStoreBuffer = ^TKDT512DDyanmicStoreBuffer;

  PKDT512DD_Node = ^TKDT512DD_Node;

  TKDT512DD_Node = packed record
    Parent, Right, Left: PKDT512DD_Node;
    vec: PKDT512DD_Source;
  end;

  TKDT512DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT512DD_Source);
  TKDT512DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT512DD_Source) of object;
  {$IFNDEF FPC}
  TKDT512DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT512DD_Source);
  {$ENDIF}

  TKDT512DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT512DDyanmicStoreBuffer;
    KDBuff     : TKDT512DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT512DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT512DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT512DDyanmicStoreBuffer; const Buff: TKDT512DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT512DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT512DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT512DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT512DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT512DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DD_Node; overload;
    function Search(const Buff: TKDT512DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DD_Node; overload;
    function Search(const Buff: TKDT512DD_Vec; var SearchedDistanceMin: Double): PKDT512DD_Node; overload;
    function Search(const Buff: TKDT512DD_Vec): PKDT512DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT512DD_DynamicVecBuffer; var OutBuff: TKDT512DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT512DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT512DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT640DD_Vec = array [0 .. TKDT640DD_AxisCount - 1] of TKDT640DD_VecType;
  PKDT640DD_Vec = ^TKDT640DD_Vec;

  TKDT640DD_DynamicVecBuffer = array of TKDT640DD_Vec;
  PKDT640DD_DynamicVecBuffer = ^TKDT640DD_DynamicVecBuffer;

  TKDT640DD_Source = packed record
    Buff: TKDT640DD_Vec;
    index: Int64;
  end;

  PKDT640DD_Source       = ^TKDT640DD_Source;
  TKDT640DD_SourceBuffer = array [0 .. 0] of PKDT640DD_Source;
  PKDT640DD_SourceBuffer = ^TKDT640DD_SourceBuffer;

  TKDT640DDyanmicSourceBuffer = array of PKDT640DD_Source;
  PKDT640DDyanmicSourceBuffer = ^TKDT640DDyanmicSourceBuffer;

  TKDT640DDyanmicStoreBuffer = array of TKDT640DD_Source;
  PKDT640DDyanmicStoreBuffer = ^TKDT640DDyanmicStoreBuffer;

  PKDT640DD_Node = ^TKDT640DD_Node;

  TKDT640DD_Node = packed record
    Parent, Right, Left: PKDT640DD_Node;
    vec: PKDT640DD_Source;
  end;

  TKDT640DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT640DD_Source);
  TKDT640DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT640DD_Source) of object;
  {$IFNDEF FPC}
  TKDT640DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT640DD_Source);
  {$ENDIF}

  TKDT640DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT640DDyanmicStoreBuffer;
    KDBuff     : TKDT640DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT640DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT640DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT640DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT640DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT640DDyanmicStoreBuffer; const Buff: TKDT640DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT640DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT640DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT640DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT640DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT640DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT640DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT640DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT640DD_Node; overload;
    function Search(const Buff: TKDT640DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT640DD_Node; overload;
    function Search(const Buff: TKDT640DD_Vec; var SearchedDistanceMin: Double): PKDT640DD_Node; overload;
    function Search(const Buff: TKDT640DD_Vec): PKDT640DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT640DD_DynamicVecBuffer; var OutBuff: TKDT640DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT640DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT640DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT768DD_Vec = array [0 .. TKDT768DD_AxisCount - 1] of TKDT768DD_VecType;
  PKDT768DD_Vec = ^TKDT768DD_Vec;

  TKDT768DD_DynamicVecBuffer = array of TKDT768DD_Vec;
  PKDT768DD_DynamicVecBuffer = ^TKDT768DD_DynamicVecBuffer;

  TKDT768DD_Source = packed record
    Buff: TKDT768DD_Vec;
    index: Int64;
  end;

  PKDT768DD_Source       = ^TKDT768DD_Source;
  TKDT768DD_SourceBuffer = array [0 .. 0] of PKDT768DD_Source;
  PKDT768DD_SourceBuffer = ^TKDT768DD_SourceBuffer;

  TKDT768DDyanmicSourceBuffer = array of PKDT768DD_Source;
  PKDT768DDyanmicSourceBuffer = ^TKDT768DDyanmicSourceBuffer;

  TKDT768DDyanmicStoreBuffer = array of TKDT768DD_Source;
  PKDT768DDyanmicStoreBuffer = ^TKDT768DDyanmicStoreBuffer;

  PKDT768DD_Node = ^TKDT768DD_Node;

  TKDT768DD_Node = packed record
    Parent, Right, Left: PKDT768DD_Node;
    vec: PKDT768DD_Source;
  end;

  TKDT768DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT768DD_Source);
  TKDT768DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT768DD_Source) of object;
  {$IFNDEF FPC}
  TKDT768DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT768DD_Source);
  {$ENDIF}

  TKDT768DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT768DDyanmicStoreBuffer;
    KDBuff     : TKDT768DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT768DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT768DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT768DDyanmicStoreBuffer; const Buff: TKDT768DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT768DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT768DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT768DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT768DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT768DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DD_Node; overload;
    function Search(const Buff: TKDT768DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DD_Node; overload;
    function Search(const Buff: TKDT768DD_Vec; var SearchedDistanceMin: Double): PKDT768DD_Node; overload;
    function Search(const Buff: TKDT768DD_Vec): PKDT768DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT768DD_DynamicVecBuffer; var OutBuff: TKDT768DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT768DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT768DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1024DD_Vec = array [0 .. TKDT1024DD_AxisCount - 1] of TKDT1024DD_VecType;
  PKDT1024DD_Vec = ^TKDT1024DD_Vec;

  TKDT1024DD_DynamicVecBuffer = array of TKDT1024DD_Vec;
  PKDT1024DD_DynamicVecBuffer = ^TKDT1024DD_DynamicVecBuffer;

  TKDT1024DD_Source = packed record
    Buff: TKDT1024DD_Vec;
    index: Int64;
  end;

  PKDT1024DD_Source       = ^TKDT1024DD_Source;
  TKDT1024DD_SourceBuffer = array [0 .. 0] of PKDT1024DD_Source;
  PKDT1024DD_SourceBuffer = ^TKDT1024DD_SourceBuffer;

  TKDT1024DDyanmicSourceBuffer = array of PKDT1024DD_Source;
  PKDT1024DDyanmicSourceBuffer = ^TKDT1024DDyanmicSourceBuffer;

  TKDT1024DDyanmicStoreBuffer = array of TKDT1024DD_Source;
  PKDT1024DDyanmicStoreBuffer = ^TKDT1024DDyanmicStoreBuffer;

  PKDT1024DD_Node = ^TKDT1024DD_Node;

  TKDT1024DD_Node = packed record
    Parent, Right, Left: PKDT1024DD_Node;
    vec: PKDT1024DD_Source;
  end;

  TKDT1024DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1024DD_Source);
  TKDT1024DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1024DD_Source) of object;
  {$IFNDEF FPC}
  TKDT1024DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1024DD_Source);
  {$ENDIF}

  TKDT1024DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1024DDyanmicStoreBuffer;
    KDBuff     : TKDT1024DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1024DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1024DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1024DDyanmicStoreBuffer; const Buff: TKDT1024DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1024DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1024DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1024DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1024DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1024DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DD_Node; overload;
    function Search(const Buff: TKDT1024DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DD_Node; overload;
    function Search(const Buff: TKDT1024DD_Vec; var SearchedDistanceMin: Double): PKDT1024DD_Node; overload;
    function Search(const Buff: TKDT1024DD_Vec): PKDT1024DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1024DD_DynamicVecBuffer; var OutBuff: TKDT1024DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1024DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1024DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1080DD_Vec = array [0 .. TKDT1080DD_AxisCount - 1] of TKDT1080DD_VecType;
  PKDT1080DD_Vec = ^TKDT1080DD_Vec;

  TKDT1080DD_DynamicVecBuffer = array of TKDT1080DD_Vec;
  PKDT1080DD_DynamicVecBuffer = ^TKDT1080DD_DynamicVecBuffer;

  TKDT1080DD_Source = packed record
    Buff: TKDT1080DD_Vec;
    index: Int64;
  end;

  PKDT1080DD_Source       = ^TKDT1080DD_Source;
  TKDT1080DD_SourceBuffer = array [0 .. 0] of PKDT1080DD_Source;
  PKDT1080DD_SourceBuffer = ^TKDT1080DD_SourceBuffer;

  TKDT1080DDyanmicSourceBuffer = array of PKDT1080DD_Source;
  PKDT1080DDyanmicSourceBuffer = ^TKDT1080DDyanmicSourceBuffer;

  TKDT1080DDyanmicStoreBuffer = array of TKDT1080DD_Source;
  PKDT1080DDyanmicStoreBuffer = ^TKDT1080DDyanmicStoreBuffer;

  PKDT1080DD_Node = ^TKDT1080DD_Node;

  TKDT1080DD_Node = packed record
    Parent, Right, Left: PKDT1080DD_Node;
    vec: PKDT1080DD_Source;
  end;

  TKDT1080DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1080DD_Source);
  TKDT1080DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1080DD_Source) of object;
  {$IFNDEF FPC}
  TKDT1080DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1080DD_Source);
  {$ENDIF}

  TKDT1080DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1080DDyanmicStoreBuffer;
    KDBuff     : TKDT1080DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1080DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1080DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1080DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1080DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1080DDyanmicStoreBuffer; const Buff: TKDT1080DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1080DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1080DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1080DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1080DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1080DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1080DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1080DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1080DD_Node; overload;
    function Search(const Buff: TKDT1080DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1080DD_Node; overload;
    function Search(const Buff: TKDT1080DD_Vec; var SearchedDistanceMin: Double): PKDT1080DD_Node; overload;
    function Search(const Buff: TKDT1080DD_Vec): PKDT1080DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1080DD_DynamicVecBuffer; var OutBuff: TKDT1080DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1080DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1080DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1536DD_Vec = array [0 .. TKDT1536DD_AxisCount - 1] of TKDT1536DD_VecType;
  PKDT1536DD_Vec = ^TKDT1536DD_Vec;

  TKDT1536DD_DynamicVecBuffer = array of TKDT1536DD_Vec;
  PKDT1536DD_DynamicVecBuffer = ^TKDT1536DD_DynamicVecBuffer;

  TKDT1536DD_Source = packed record
    Buff: TKDT1536DD_Vec;
    index: Int64;
  end;

  PKDT1536DD_Source       = ^TKDT1536DD_Source;
  TKDT1536DD_SourceBuffer = array [0 .. 0] of PKDT1536DD_Source;
  PKDT1536DD_SourceBuffer = ^TKDT1536DD_SourceBuffer;

  TKDT1536DDyanmicSourceBuffer = array of PKDT1536DD_Source;
  PKDT1536DDyanmicSourceBuffer = ^TKDT1536DDyanmicSourceBuffer;

  TKDT1536DDyanmicStoreBuffer = array of TKDT1536DD_Source;
  PKDT1536DDyanmicStoreBuffer = ^TKDT1536DDyanmicStoreBuffer;

  PKDT1536DD_Node = ^TKDT1536DD_Node;

  TKDT1536DD_Node = packed record
    Parent, Right, Left: PKDT1536DD_Node;
    vec: PKDT1536DD_Source;
  end;

  TKDT1536DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1536DD_Source);
  TKDT1536DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1536DD_Source) of object;
  {$IFNDEF FPC}
  TKDT1536DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1536DD_Source);
  {$ENDIF}

  TKDT1536DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1536DDyanmicStoreBuffer;
    KDBuff     : TKDT1536DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1536DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1536DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1536DDyanmicStoreBuffer; const Buff: TKDT1536DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1536DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1536DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1536DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1536DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1536DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DD_Node; overload;
    function Search(const Buff: TKDT1536DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DD_Node; overload;
    function Search(const Buff: TKDT1536DD_Vec; var SearchedDistanceMin: Double): PKDT1536DD_Node; overload;
    function Search(const Buff: TKDT1536DD_Vec): PKDT1536DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1536DD_DynamicVecBuffer; var OutBuff: TKDT1536DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1536DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1536DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT1920DD_Vec = array [0 .. TKDT1920DD_AxisCount - 1] of TKDT1920DD_VecType;
  PKDT1920DD_Vec = ^TKDT1920DD_Vec;

  TKDT1920DD_DynamicVecBuffer = array of TKDT1920DD_Vec;
  PKDT1920DD_DynamicVecBuffer = ^TKDT1920DD_DynamicVecBuffer;

  TKDT1920DD_Source = packed record
    Buff: TKDT1920DD_Vec;
    index: Int64;
  end;

  PKDT1920DD_Source       = ^TKDT1920DD_Source;
  TKDT1920DD_SourceBuffer = array [0 .. 0] of PKDT1920DD_Source;
  PKDT1920DD_SourceBuffer = ^TKDT1920DD_SourceBuffer;

  TKDT1920DDyanmicSourceBuffer = array of PKDT1920DD_Source;
  PKDT1920DDyanmicSourceBuffer = ^TKDT1920DDyanmicSourceBuffer;

  TKDT1920DDyanmicStoreBuffer = array of TKDT1920DD_Source;
  PKDT1920DDyanmicStoreBuffer = ^TKDT1920DDyanmicStoreBuffer;

  PKDT1920DD_Node = ^TKDT1920DD_Node;

  TKDT1920DD_Node = packed record
    Parent, Right, Left: PKDT1920DD_Node;
    vec: PKDT1920DD_Source;
  end;

  TKDT1920DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT1920DD_Source);
  TKDT1920DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT1920DD_Source) of object;
  {$IFNDEF FPC}
  TKDT1920DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT1920DD_Source);
  {$ENDIF}

  TKDT1920DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1920DDyanmicStoreBuffer;
    KDBuff     : TKDT1920DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1920DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT1920DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT1920DDyanmicStoreBuffer; const Buff: TKDT1920DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT1920DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1920DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1920DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1920DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1920DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DD_Node; overload;
    function Search(const Buff: TKDT1920DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DD_Node; overload;
    function Search(const Buff: TKDT1920DD_Vec; var SearchedDistanceMin: Double): PKDT1920DD_Node; overload;
    function Search(const Buff: TKDT1920DD_Vec): PKDT1920DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1920DD_DynamicVecBuffer; var OutBuff: TKDT1920DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT1920DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT1920DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT2048DD_Vec = array [0 .. TKDT2048DD_AxisCount - 1] of TKDT2048DD_VecType;
  PKDT2048DD_Vec = ^TKDT2048DD_Vec;

  TKDT2048DD_DynamicVecBuffer = array of TKDT2048DD_Vec;
  PKDT2048DD_DynamicVecBuffer = ^TKDT2048DD_DynamicVecBuffer;

  TKDT2048DD_Source = packed record
    Buff: TKDT2048DD_Vec;
    index: Int64;
  end;

  PKDT2048DD_Source       = ^TKDT2048DD_Source;
  TKDT2048DD_SourceBuffer = array [0 .. 0] of PKDT2048DD_Source;
  PKDT2048DD_SourceBuffer = ^TKDT2048DD_SourceBuffer;

  TKDT2048DDyanmicSourceBuffer = array of PKDT2048DD_Source;
  PKDT2048DDyanmicSourceBuffer = ^TKDT2048DDyanmicSourceBuffer;

  TKDT2048DDyanmicStoreBuffer = array of TKDT2048DD_Source;
  PKDT2048DDyanmicStoreBuffer = ^TKDT2048DDyanmicStoreBuffer;

  PKDT2048DD_Node = ^TKDT2048DD_Node;

  TKDT2048DD_Node = packed record
    Parent, Right, Left: PKDT2048DD_Node;
    vec: PKDT2048DD_Source;
  end;

  TKDT2048DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT2048DD_Source);
  TKDT2048DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT2048DD_Source) of object;
  {$IFNDEF FPC}
  TKDT2048DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT2048DD_Source);
  {$ENDIF}

  TKDT2048DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT2048DDyanmicStoreBuffer;
    KDBuff     : TKDT2048DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2048DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT2048DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT2048DDyanmicStoreBuffer; const Buff: TKDT2048DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT2048DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2048DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2048DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT2048DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2048DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DD_Node; overload;
    function Search(const Buff: TKDT2048DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DD_Node; overload;
    function Search(const Buff: TKDT2048DD_Vec; var SearchedDistanceMin: Double): PKDT2048DD_Node; overload;
    function Search(const Buff: TKDT2048DD_Vec): PKDT2048DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2048DD_DynamicVecBuffer; var OutBuff: TKDT2048DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT2048DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT2048DD_Source);
    class procedure Test;
    {$ENDIF}
  end;



  TKDT3072DD_Vec = array [0 .. TKDT3072DD_AxisCount - 1] of TKDT3072DD_VecType;
  PKDT3072DD_Vec = ^TKDT3072DD_Vec;

  TKDT3072DD_DynamicVecBuffer = array of TKDT3072DD_Vec;
  PKDT3072DD_DynamicVecBuffer = ^TKDT3072DD_DynamicVecBuffer;

  TKDT3072DD_Source = packed record
    Buff: TKDT3072DD_Vec;
    index: Int64;
  end;

  PKDT3072DD_Source       = ^TKDT3072DD_Source;
  TKDT3072DD_SourceBuffer = array [0 .. 0] of PKDT3072DD_Source;
  PKDT3072DD_SourceBuffer = ^TKDT3072DD_SourceBuffer;

  TKDT3072DDyanmicSourceBuffer = array of PKDT3072DD_Source;
  PKDT3072DDyanmicSourceBuffer = ^TKDT3072DDyanmicSourceBuffer;

  TKDT3072DDyanmicStoreBuffer = array of TKDT3072DD_Source;
  PKDT3072DDyanmicStoreBuffer = ^TKDT3072DDyanmicStoreBuffer;

  PKDT3072DD_Node = ^TKDT3072DD_Node;

  TKDT3072DD_Node = packed record
    Parent, Right, Left: PKDT3072DD_Node;
    vec: PKDT3072DD_Source;
  end;

  TKDT3072DD_BuildCall   = procedure(IndexFor: NativeInt; var Source: TKDT3072DD_Source);
  TKDT3072DD_BuildMethod = procedure(IndexFor: NativeInt; var Source: TKDT3072DD_Source) of object;
  {$IFNDEF FPC}
  TKDT3072DD_BuildProc = reference to procedure(IndexFor: NativeInt; var Source: TKDT3072DD_Source);
  {$ENDIF}

  TKDT3072DD = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3072DDyanmicStoreBuffer;
    KDBuff     : TKDT3072DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3072DD_Node;
    {$IFDEF DEBUG}
    TestBuff: TKDT3072DD_DynamicVecBuffer;
    {$ENDIF}
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DD_Node;
    function SearchStoreBuff(const StoreBuffPtr: PKDT3072DDyanmicStoreBuffer; const Buff: TKDT3072DD_Vec; const PlanCount: NativeInt): Boolean;
    function GetData(const index: NativeInt): PKDT3072DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3072DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3072DDyanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3072DD_Source read GetData; default;

    procedure BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DD_BuildCall);
    procedure BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DD_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DD_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3072DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DD_Node; overload;
    function Search(const Buff: TKDT3072DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DD_Node; overload;
    function Search(const Buff: TKDT3072DD_Vec; var SearchedDistanceMin: Double): PKDT3072DD_Node; overload;
    function Search(const Buff: TKDT3072DD_Vec): PKDT3072DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3072DD_DynamicVecBuffer; var OutBuff: TKDT3072DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    {$IFDEF DEBUG}
    procedure PrintNodeTree(const NodePtr: PKDT3072DD_Node);
    procedure PrintBuffer;
    procedure Test_BuildM(IndexFor: NativeInt; var Source: TKDT3072DD_Source);
    class procedure Test;
    {$ENDIF}
  end;






  // Double float: KDTree
function KDT1DDVec(const s: string): TKDT1DD_Vec; overload;
function KDT1DDVec(const v: TKDT1DD_Vec): string; overload;
function KDT1DDPow(const v: TKDT1DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1DDDistance(const v1, v2: TKDT1DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1DDCmpare(const v1, v2: TKDT1DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT2DDVec(const s: string): TKDT2DD_Vec; overload;
function KDT2DDVec(const v: TKDT2DD_Vec): string; overload;
function KDT2DDPow(const v: TKDT2DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2DDDistance(const v1, v2: TKDT2DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2DDCmpare(const v1, v2: TKDT2DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT3DDVec(const s: string): TKDT3DD_Vec; overload;
function KDT3DDVec(const v: TKDT3DD_Vec): string; overload;
function KDT3DDPow(const v: TKDT3DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3DDDistance(const v1, v2: TKDT3DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3DDCmpare(const v1, v2: TKDT3DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT4DDVec(const s: string): TKDT4DD_Vec; overload;
function KDT4DDVec(const v: TKDT4DD_Vec): string; overload;
function KDT4DDPow(const v: TKDT4DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT4DDDistance(const v1, v2: TKDT4DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT4DDCmpare(const v1, v2: TKDT4DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT6DDVec(const s: string): TKDT6DD_Vec; overload;
function KDT6DDVec(const v: TKDT6DD_Vec): string; overload;
function KDT6DDPow(const v: TKDT6DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT6DDDistance(const v1, v2: TKDT6DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT6DDCmpare(const v1, v2: TKDT6DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT8DDVec(const s: string): TKDT8DD_Vec; overload;
function KDT8DDVec(const v: TKDT8DD_Vec): string; overload;
function KDT8DDPow(const v: TKDT8DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT8DDDistance(const v1, v2: TKDT8DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT8DDCmpare(const v1, v2: TKDT8DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT10DDVec(const s: string): TKDT10DD_Vec; overload;
function KDT10DDVec(const v: TKDT10DD_Vec): string; overload;
function KDT10DDPow(const v: TKDT10DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT10DDDistance(const v1, v2: TKDT10DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT10DDCmpare(const v1, v2: TKDT10DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT12DDVec(const s: string): TKDT12DD_Vec; overload;
function KDT12DDVec(const v: TKDT12DD_Vec): string; overload;
function KDT12DDPow(const v: TKDT12DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT12DDDistance(const v1, v2: TKDT12DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT12DDCmpare(const v1, v2: TKDT12DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT14DDVec(const s: string): TKDT14DD_Vec; overload;
function KDT14DDVec(const v: TKDT14DD_Vec): string; overload;
function KDT14DDPow(const v: TKDT14DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT14DDDistance(const v1, v2: TKDT14DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT14DDCmpare(const v1, v2: TKDT14DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT16DDVec(const s: string): TKDT16DD_Vec; overload;
function KDT16DDVec(const v: TKDT16DD_Vec): string; overload;
function KDT16DDPow(const v: TKDT16DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT16DDDistance(const v1, v2: TKDT16DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT16DDCmpare(const v1, v2: TKDT16DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT18DDVec(const s: string): TKDT18DD_Vec; overload;
function KDT18DDVec(const v: TKDT18DD_Vec): string; overload;
function KDT18DDPow(const v: TKDT18DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT18DDDistance(const v1, v2: TKDT18DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT18DDCmpare(const v1, v2: TKDT18DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT20DDVec(const s: string): TKDT20DD_Vec; overload;
function KDT20DDVec(const v: TKDT20DD_Vec): string; overload;
function KDT20DDPow(const v: TKDT20DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT20DDDistance(const v1, v2: TKDT20DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT20DDCmpare(const v1, v2: TKDT20DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT22DDVec(const s: string): TKDT22DD_Vec; overload;
function KDT22DDVec(const v: TKDT22DD_Vec): string; overload;
function KDT22DDPow(const v: TKDT22DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT22DDDistance(const v1, v2: TKDT22DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT22DDCmpare(const v1, v2: TKDT22DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT24DDVec(const s: string): TKDT24DD_Vec; overload;
function KDT24DDVec(const v: TKDT24DD_Vec): string; overload;
function KDT24DDPow(const v: TKDT24DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT24DDDistance(const v1, v2: TKDT24DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT24DDCmpare(const v1, v2: TKDT24DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT28DDVec(const s: string): TKDT28DD_Vec; overload;
function KDT28DDVec(const v: TKDT28DD_Vec): string; overload;
function KDT28DDPow(const v: TKDT28DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT28DDDistance(const v1, v2: TKDT28DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT28DDCmpare(const v1, v2: TKDT28DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT30DDVec(const s: string): TKDT30DD_Vec; overload;
function KDT30DDVec(const v: TKDT30DD_Vec): string; overload;
function KDT30DDPow(const v: TKDT30DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT30DDDistance(const v1, v2: TKDT30DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT30DDCmpare(const v1, v2: TKDT30DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT32DDVec(const s: string): TKDT32DD_Vec; overload;
function KDT32DDVec(const v: TKDT32DD_Vec): string; overload;
function KDT32DDPow(const v: TKDT32DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT32DDDistance(const v1, v2: TKDT32DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT32DDCmpare(const v1, v2: TKDT32DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT34DDVec(const s: string): TKDT34DD_Vec; overload;
function KDT34DDVec(const v: TKDT34DD_Vec): string; overload;
function KDT34DDPow(const v: TKDT34DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT34DDDistance(const v1, v2: TKDT34DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT34DDCmpare(const v1, v2: TKDT34DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT36DDVec(const s: string): TKDT36DD_Vec; overload;
function KDT36DDVec(const v: TKDT36DD_Vec): string; overload;
function KDT36DDPow(const v: TKDT36DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT36DDDistance(const v1, v2: TKDT36DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT36DDCmpare(const v1, v2: TKDT36DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT40DDVec(const s: string): TKDT40DD_Vec; overload;
function KDT40DDVec(const v: TKDT40DD_Vec): string; overload;
function KDT40DDPow(const v: TKDT40DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT40DDDistance(const v1, v2: TKDT40DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT40DDCmpare(const v1, v2: TKDT40DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT48DDVec(const s: string): TKDT48DD_Vec; overload;
function KDT48DDVec(const v: TKDT48DD_Vec): string; overload;
function KDT48DDPow(const v: TKDT48DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT48DDDistance(const v1, v2: TKDT48DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT48DDCmpare(const v1, v2: TKDT48DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT64DDVec(const s: string): TKDT64DD_Vec; overload;
function KDT64DDVec(const v: TKDT64DD_Vec): string; overload;
function KDT64DDPow(const v: TKDT64DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT64DDDistance(const v1, v2: TKDT64DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT64DDCmpare(const v1, v2: TKDT64DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT96DDVec(const s: string): TKDT96DD_Vec; overload;
function KDT96DDVec(const v: TKDT96DD_Vec): string; overload;
function KDT96DDPow(const v: TKDT96DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT96DDDistance(const v1, v2: TKDT96DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT96DDCmpare(const v1, v2: TKDT96DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT128DDVec(const s: string): TKDT128DD_Vec; overload;
function KDT128DDVec(const v: TKDT128DD_Vec): string; overload;
function KDT128DDPow(const v: TKDT128DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT128DDDistance(const v1, v2: TKDT128DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT128DDCmpare(const v1, v2: TKDT128DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT256DDVec(const s: string): TKDT256DD_Vec; overload;
function KDT256DDVec(const v: TKDT256DD_Vec): string; overload;
function KDT256DDPow(const v: TKDT256DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT256DDDistance(const v1, v2: TKDT256DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT256DDCmpare(const v1, v2: TKDT256DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT372DDVec(const s: string): TKDT372DD_Vec; overload;
function KDT372DDVec(const v: TKDT372DD_Vec): string; overload;
function KDT372DDPow(const v: TKDT372DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT372DDDistance(const v1, v2: TKDT372DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT372DDCmpare(const v1, v2: TKDT372DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT512DDVec(const s: string): TKDT512DD_Vec; overload;
function KDT512DDVec(const v: TKDT512DD_Vec): string; overload;
function KDT512DDPow(const v: TKDT512DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT512DDDistance(const v1, v2: TKDT512DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT512DDCmpare(const v1, v2: TKDT512DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT640DDVec(const s: string): TKDT640DD_Vec; overload;
function KDT640DDVec(const v: TKDT640DD_Vec): string; overload;
function KDT640DDPow(const v: TKDT640DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT640DDDistance(const v1, v2: TKDT640DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT640DDCmpare(const v1, v2: TKDT640DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT768DDVec(const s: string): TKDT768DD_Vec; overload;
function KDT768DDVec(const v: TKDT768DD_Vec): string; overload;
function KDT768DDPow(const v: TKDT768DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT768DDDistance(const v1, v2: TKDT768DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT768DDCmpare(const v1, v2: TKDT768DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1024DDVec(const s: string): TKDT1024DD_Vec; overload;
function KDT1024DDVec(const v: TKDT1024DD_Vec): string; overload;
function KDT1024DDPow(const v: TKDT1024DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1024DDDistance(const v1, v2: TKDT1024DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1024DDCmpare(const v1, v2: TKDT1024DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1080DDVec(const s: string): TKDT1080DD_Vec; overload;
function KDT1080DDVec(const v: TKDT1080DD_Vec): string; overload;
function KDT1080DDPow(const v: TKDT1080DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1080DDDistance(const v1, v2: TKDT1080DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1080DDCmpare(const v1, v2: TKDT1080DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1536DDVec(const s: string): TKDT1536DD_Vec; overload;
function KDT1536DDVec(const v: TKDT1536DD_Vec): string; overload;
function KDT1536DDPow(const v: TKDT1536DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1536DDDistance(const v1, v2: TKDT1536DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1536DDCmpare(const v1, v2: TKDT1536DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT1920DDVec(const s: string): TKDT1920DD_Vec; overload;
function KDT1920DDVec(const v: TKDT1920DD_Vec): string; overload;
function KDT1920DDPow(const v: TKDT1920DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1920DDDistance(const v1, v2: TKDT1920DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT1920DDCmpare(const v1, v2: TKDT1920DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT2048DDVec(const s: string): TKDT2048DD_Vec; overload;
function KDT2048DDVec(const v: TKDT2048DD_Vec): string; overload;
function KDT2048DDPow(const v: TKDT2048DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2048DDDistance(const v1, v2: TKDT2048DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT2048DDCmpare(const v1, v2: TKDT2048DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

function KDT3072DDVec(const s: string): TKDT3072DD_Vec; overload;
function KDT3072DDVec(const v: TKDT3072DD_Vec): string; overload;
function KDT3072DDPow(const v: TKDT3072DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3072DDDistance(const v1, v2: TKDT3072DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
function KDT3072DDCmpare(const v1, v2: TKDT3072DD_Vec): Boolean; {$IFDEF INLINE_ASM} inline; {$ENDIF}

{$IFDEF DEBUG}
procedure Test_All;
{$ENDIF}


implementation

uses
  {$IFDEF FPC}
  mtprocs,
  {$ELSE FPC}
  Threading,
  {$ENDIF FPC}
  PascalStrings, TextParsing, UnicodeMixedLib, DoStatusIO;






function KDT1DDVec(const s: string): TKDT1DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1DDVec(const v: TKDT1DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1DDPow(const v: TKDT1DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT1DDDistance(const v1, v2: TKDT1DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1DD_AxisCount - 1 do
      Result := Result + KDT1DDPow(v2[i] - v1[i]);
end;

function KDT1DDCmpare(const v1, v2: TKDT1DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1DD_Vec));
end;

function TKDT1DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DD_Node;
  function SortCompare(const p1, p2: PKDT1DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1DD_SourceBuffer;
  dynBuff  : PKDT1DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1DD.SearchStoreBuff(const StoreBuffPtr: PKDT1DDyanmicStoreBuffer; const Buff: TKDT1DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1DD.GetData(const index: NativeInt): PKDT1DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1DD.StoreBuffPtr: PKDT1DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1DD.BuildKDTreeWithCluster(const inBuff: TKDT1DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1DD.BuildKDTreeWithCluster(const inBuff: TKDT1DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DD_BuildCall);
var
  TempStoreBuff: TKDT1DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DD_BuildMethod);
var
  TempStoreBuff: TKDT1DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DD_BuildProc);
var
  TempStoreBuff: TKDT1DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1DD.Search(const Buff: TKDT1DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DD_Node;

var
  NearestNeighbour: PKDT1DD_Node;

  function FindParentNode(const BuffPtr: PKDT1DD_Vec; NodePtr: PKDT1DD_Node): PKDT1DD_Node;
  var
    Next       : PKDT1DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1DD_Node; const BuffPtr: PKDT1DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1DD_Vec; const p1, p2: PKDT1DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1DD_Node(NearestNodes[0]);
    end;
end;

function TKDT1DD.Search(const Buff: TKDT1DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1DD.Search(const Buff: TKDT1DD_Vec; var SearchedDistanceMin: Double): PKDT1DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1DD.Search(const Buff: TKDT1DD_Vec): PKDT1DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1DD.Search(const inBuff: TKDT1DD_DynamicVecBuffer; var OutBuff: TKDT1DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1DD_DynamicVecBuffer;
  outBuffPtr : PKDT1DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1DD_Source));
end;

procedure TKDT1DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1DD.PrintNodeTree(const NodePtr: PKDT1DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1DD.Test;
var
  TKDT1DD_Test    : TKDT1DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1DD_Test := TKDT1DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT1DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT1DD_AxisCount - 1 do
        TKDT1DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1DD_Test.TestBuff), length(TKDT1DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1DD_Test.BuildKDTreeM(False, length(TKDT1DD_Test.TestBuff), @TKDT1DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1DD_Test.BuildKDTreeM(False, length(TKDT1DD_Test.TestBuff), TKDT1DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1DD_Test.TestBuff));
  TKDT1DD_Test.Search(TKDT1DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1DDDistance(TKDT1DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1DD_Test.Clear;
  { kMean test }
  TKDT1DD_Test.BuildKDTreeWithCluster(TKDT1DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1DD_Test.Search(TKDT1DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1DD_Test);
end;

{$ENDIF DEBUG}


function KDT2DDVec(const s: string): TKDT2DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT2DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT2DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT2DDVec(const v: TKDT2DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT2DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT2DDPow(const v: TKDT2DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT2DDDistance(const v1, v2: TKDT2DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT2DD_AxisCount - 1 do
      Result := Result + KDT2DDPow(v2[i] - v1[i]);
end;

function KDT2DDCmpare(const v1, v2: TKDT2DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT2DD_Vec));
end;

function TKDT2DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DD_Node;
  function SortCompare(const p1, p2: PKDT2DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2DD_SourceBuffer;
  dynBuff  : PKDT2DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT2DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2DD.SearchStoreBuff(const StoreBuffPtr: PKDT2DDyanmicStoreBuffer; const Buff: TKDT2DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT2DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT2DD.GetData(const index: NativeInt): PKDT2DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2DD.StoreBuffPtr: PKDT2DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2DD.BuildKDTreeWithCluster(const inBuff: TKDT2DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT2DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT2DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT2DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2DD.BuildKDTreeWithCluster(const inBuff: TKDT2DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DD_BuildCall);
var
  TempStoreBuff: TKDT2DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DD_BuildMethod);
var
  TempStoreBuff: TKDT2DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DD_BuildProc);
var
  TempStoreBuff: TKDT2DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT2DD.Search(const Buff: TKDT2DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DD_Node;

var
  NearestNeighbour: PKDT2DD_Node;

  function FindParentNode(const BuffPtr: PKDT2DD_Vec; NodePtr: PKDT2DD_Node): PKDT2DD_Node;
  var
    Next       : PKDT2DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT2DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2DD_Node; const BuffPtr: PKDT2DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT2DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2DD_Vec; const p1, p2: PKDT2DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2DD_Node(NearestNodes[0]);
    end;
end;

function TKDT2DD.Search(const Buff: TKDT2DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2DD.Search(const Buff: TKDT2DD_Vec; var SearchedDistanceMin: Double): PKDT2DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2DD.Search(const Buff: TKDT2DD_Vec): PKDT2DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2DD.Search(const inBuff: TKDT2DD_DynamicVecBuffer; var OutBuff: TKDT2DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2DD_DynamicVecBuffer;
  outBuffPtr : PKDT2DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2DD_Source));
end;

procedure TKDT2DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT2DD.PrintNodeTree(const NodePtr: PKDT2DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT2DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT2DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2DD.Test;
var
  TKDT2DD_Test    : TKDT2DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2DD_Test := TKDT2DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT2DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT2DD_AxisCount - 1 do
        TKDT2DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT2DD_Test.TestBuff), length(TKDT2DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2DD_Test.BuildKDTreeM(False, length(TKDT2DD_Test.TestBuff), @TKDT2DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2DD_Test.BuildKDTreeM(False, length(TKDT2DD_Test.TestBuff), TKDT2DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2DD_Test.TestBuff));
  TKDT2DD_Test.Search(TKDT2DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2DDDistance(TKDT2DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2DD_Test.Clear;
  { kMean test }
  TKDT2DD_Test.BuildKDTreeWithCluster(TKDT2DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2DD_Test.Search(TKDT2DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2DD_Test);
end;

{$ENDIF DEBUG}


function KDT3DDVec(const s: string): TKDT3DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT3DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT3DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT3DDVec(const v: TKDT3DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT3DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT3DDPow(const v: TKDT3DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT3DDDistance(const v1, v2: TKDT3DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT3DD_AxisCount - 1 do
      Result := Result + KDT3DDPow(v2[i] - v1[i]);
end;

function KDT3DDCmpare(const v1, v2: TKDT3DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT3DD_Vec));
end;

function TKDT3DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DD_Node;
  function SortCompare(const p1, p2: PKDT3DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3DD_SourceBuffer;
  dynBuff  : PKDT3DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT3DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3DD.SearchStoreBuff(const StoreBuffPtr: PKDT3DDyanmicStoreBuffer; const Buff: TKDT3DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT3DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT3DD.GetData(const index: NativeInt): PKDT3DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3DD.StoreBuffPtr: PKDT3DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3DD.BuildKDTreeWithCluster(const inBuff: TKDT3DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT3DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT3DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT3DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3DD.BuildKDTreeWithCluster(const inBuff: TKDT3DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DD_BuildCall);
var
  TempStoreBuff: TKDT3DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DD_BuildMethod);
var
  TempStoreBuff: TKDT3DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DD_BuildProc);
var
  TempStoreBuff: TKDT3DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3DD.Search(const Buff: TKDT3DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DD_Node;

var
  NearestNeighbour: PKDT3DD_Node;

  function FindParentNode(const BuffPtr: PKDT3DD_Vec; NodePtr: PKDT3DD_Node): PKDT3DD_Node;
  var
    Next       : PKDT3DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT3DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3DD_Node; const BuffPtr: PKDT3DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT3DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3DD_Vec; const p1, p2: PKDT3DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3DD_Node(NearestNodes[0]);
    end;
end;

function TKDT3DD.Search(const Buff: TKDT3DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3DD.Search(const Buff: TKDT3DD_Vec; var SearchedDistanceMin: Double): PKDT3DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3DD.Search(const Buff: TKDT3DD_Vec): PKDT3DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3DD.Search(const inBuff: TKDT3DD_DynamicVecBuffer; var OutBuff: TKDT3DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3DD_DynamicVecBuffer;
  outBuffPtr : PKDT3DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3DD_Source));
end;

procedure TKDT3DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT3DD.PrintNodeTree(const NodePtr: PKDT3DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT3DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT3DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3DD.Test;
var
  TKDT3DD_Test    : TKDT3DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3DD_Test := TKDT3DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT3DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT3DD_AxisCount - 1 do
        TKDT3DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3DD_Test.TestBuff), length(TKDT3DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3DD_Test.BuildKDTreeM(False, length(TKDT3DD_Test.TestBuff), @TKDT3DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3DD_Test.BuildKDTreeM(False, length(TKDT3DD_Test.TestBuff), TKDT3DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3DD_Test.TestBuff));
  TKDT3DD_Test.Search(TKDT3DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3DDDistance(TKDT3DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3DD_Test.Clear;
  { kMean test }
  TKDT3DD_Test.BuildKDTreeWithCluster(TKDT3DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3DD_Test.Search(TKDT3DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3DD_Test);
end;

{$ENDIF DEBUG}


function KDT4DDVec(const s: string): TKDT4DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT4DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT4DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT4DDVec(const v: TKDT4DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT4DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT4DDPow(const v: TKDT4DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT4DDDistance(const v1, v2: TKDT4DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT4DD_AxisCount - 1 do
      Result := Result + KDT4DDPow(v2[i] - v1[i]);
end;

function KDT4DDCmpare(const v1, v2: TKDT4DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT4DD_Vec));
end;

function TKDT4DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DD_Node;
  function SortCompare(const p1, p2: PKDT4DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4DD_SourceBuffer;
  dynBuff  : PKDT4DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT4DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4DD.SearchStoreBuff(const StoreBuffPtr: PKDT4DDyanmicStoreBuffer; const Buff: TKDT4DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT4DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT4DD.GetData(const index: NativeInt): PKDT4DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4DD.StoreBuffPtr: PKDT4DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT4DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT4DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT4DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4DD.BuildKDTreeWithCluster(const inBuff: TKDT4DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT4DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT4DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT4DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4DD.BuildKDTreeWithCluster(const inBuff: TKDT4DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DD_BuildCall);
var
  TempStoreBuff: TKDT4DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DD_BuildMethod);
var
  TempStoreBuff: TKDT4DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DD_BuildProc);
var
  TempStoreBuff: TKDT4DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT4DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT4DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT4DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT4DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT4DD.Search(const Buff: TKDT4DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DD_Node;

var
  NearestNeighbour: PKDT4DD_Node;

  function FindParentNode(const BuffPtr: PKDT4DD_Vec; NodePtr: PKDT4DD_Node): PKDT4DD_Node;
  var
    Next       : PKDT4DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT4DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4DD_Node; const BuffPtr: PKDT4DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT4DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4DD_Vec; const p1, p2: PKDT4DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4DD_Node(NearestNodes[0]);
    end;
end;

function TKDT4DD.Search(const Buff: TKDT4DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4DD.Search(const Buff: TKDT4DD_Vec; var SearchedDistanceMin: Double): PKDT4DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4DD.Search(const Buff: TKDT4DD_Vec): PKDT4DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4DD.Search(const inBuff: TKDT4DD_DynamicVecBuffer; var OutBuff: TKDT4DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4DD_DynamicVecBuffer;
  outBuffPtr : PKDT4DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4DD_Source));
end;

procedure TKDT4DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT4DD.PrintNodeTree(const NodePtr: PKDT4DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT4DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT4DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT4DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4DD.Test;
var
  TKDT4DD_Test    : TKDT4DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4DD_Test := TKDT4DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT4DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT4DD_AxisCount - 1 do
        TKDT4DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT4DD_Test.TestBuff), length(TKDT4DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4DD_Test.BuildKDTreeM(False, length(TKDT4DD_Test.TestBuff), @TKDT4DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4DD_Test.BuildKDTreeM(False, length(TKDT4DD_Test.TestBuff), TKDT4DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4DD_Test.TestBuff));
  TKDT4DD_Test.Search(TKDT4DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4DDDistance(TKDT4DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4DD_Test.Clear;
  { kMean test }
  TKDT4DD_Test.BuildKDTreeWithCluster(TKDT4DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4DD_Test.Search(TKDT4DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4DD_Test);
end;

{$ENDIF DEBUG}


function KDT6DDVec(const s: string): TKDT6DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT6DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT6DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT6DDVec(const v: TKDT6DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT6DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT6DDPow(const v: TKDT6DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT6DDDistance(const v1, v2: TKDT6DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT6DD_AxisCount - 1 do
      Result := Result + KDT6DDPow(v2[i] - v1[i]);
end;

function KDT6DDCmpare(const v1, v2: TKDT6DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT6DD_Vec));
end;

function TKDT6DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DD_Node;
  function SortCompare(const p1, p2: PKDT6DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT6DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT6DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT6DD_SourceBuffer;
  dynBuff  : PKDT6DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT6DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT6DD.SearchStoreBuff(const StoreBuffPtr: PKDT6DDyanmicStoreBuffer; const Buff: TKDT6DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT6DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT6DD.GetData(const index: NativeInt): PKDT6DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT6DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT6DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT6DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT6DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT6DD.StoreBuffPtr: PKDT6DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT6DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT6DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT6DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT6DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT6DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT6DD.BuildKDTreeWithCluster(const inBuff: TKDT6DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT6DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT6DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT6DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT6DD.BuildKDTreeWithCluster(const inBuff: TKDT6DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DD_BuildCall);
var
  TempStoreBuff: TKDT6DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DD_BuildMethod);
var
  TempStoreBuff: TKDT6DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DD_BuildProc);
var
  TempStoreBuff: TKDT6DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT6DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT6DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT6DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT6DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT6DD.Search(const Buff: TKDT6DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DD_Node;

var
  NearestNeighbour: PKDT6DD_Node;

  function FindParentNode(const BuffPtr: PKDT6DD_Vec; NodePtr: PKDT6DD_Node): PKDT6DD_Node;
  var
    Next       : PKDT6DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT6DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT6DD_Node; const BuffPtr: PKDT6DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT6DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT6DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT6DD_Vec; const p1, p2: PKDT6DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT6DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT6DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT6DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT6DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT6DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT6DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT6DD_Node(NearestNodes[0]);
    end;
end;

function TKDT6DD.Search(const Buff: TKDT6DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT6DD.Search(const Buff: TKDT6DD_Vec; var SearchedDistanceMin: Double): PKDT6DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT6DD.Search(const Buff: TKDT6DD_Vec): PKDT6DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT6DD.Search(const inBuff: TKDT6DD_DynamicVecBuffer; var OutBuff: TKDT6DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT6DD_DynamicVecBuffer;
  outBuffPtr : PKDT6DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT6DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT6DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT6DD_Source));
end;

procedure TKDT6DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT6DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT6DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT6DD.PrintNodeTree(const NodePtr: PKDT6DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT6DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT6DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT6DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT6DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT6DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT6DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT6DD.Test;
var
  TKDT6DD_Test    : TKDT6DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT6DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT6DD_Test := TKDT6DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT6DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT6DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT6DD_AxisCount - 1 do
        TKDT6DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT6DD_Test.TestBuff), length(TKDT6DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT6DD_Test.BuildKDTreeM(False, length(TKDT6DD_Test.TestBuff), @TKDT6DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT6DD_Test.BuildKDTreeM(False, length(TKDT6DD_Test.TestBuff), TKDT6DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT6DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT6DD_Test.TestBuff));
  TKDT6DD_Test.Search(TKDT6DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT6DDDistance(TKDT6DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT6DD_Test.Clear;
  { kMean test }
  TKDT6DD_Test.BuildKDTreeWithCluster(TKDT6DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT6DD_Test.Search(TKDT6DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT6DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT6DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT6DD_Test);
end;

{$ENDIF DEBUG}


function KDT8DDVec(const s: string): TKDT8DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT8DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT8DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT8DDVec(const v: TKDT8DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT8DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT8DDPow(const v: TKDT8DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT8DDDistance(const v1, v2: TKDT8DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT8DD_AxisCount - 1 do
      Result := Result + KDT8DDPow(v2[i] - v1[i]);
end;

function KDT8DDCmpare(const v1, v2: TKDT8DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT8DD_Vec));
end;

function TKDT8DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DD_Node;
  function SortCompare(const p1, p2: PKDT8DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8DD_SourceBuffer;
  dynBuff  : PKDT8DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT8DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8DD.SearchStoreBuff(const StoreBuffPtr: PKDT8DDyanmicStoreBuffer; const Buff: TKDT8DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT8DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT8DD.GetData(const index: NativeInt): PKDT8DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8DD.StoreBuffPtr: PKDT8DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT8DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT8DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT8DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8DD.BuildKDTreeWithCluster(const inBuff: TKDT8DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT8DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT8DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT8DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8DD.BuildKDTreeWithCluster(const inBuff: TKDT8DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DD_BuildCall);
var
  TempStoreBuff: TKDT8DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DD_BuildMethod);
var
  TempStoreBuff: TKDT8DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DD_BuildProc);
var
  TempStoreBuff: TKDT8DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT8DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT8DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT8DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT8DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT8DD.Search(const Buff: TKDT8DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DD_Node;

var
  NearestNeighbour: PKDT8DD_Node;

  function FindParentNode(const BuffPtr: PKDT8DD_Vec; NodePtr: PKDT8DD_Node): PKDT8DD_Node;
  var
    Next       : PKDT8DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT8DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8DD_Node; const BuffPtr: PKDT8DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT8DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8DD_Vec; const p1, p2: PKDT8DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8DD_Node(NearestNodes[0]);
    end;
end;

function TKDT8DD.Search(const Buff: TKDT8DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8DD.Search(const Buff: TKDT8DD_Vec; var SearchedDistanceMin: Double): PKDT8DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8DD.Search(const Buff: TKDT8DD_Vec): PKDT8DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8DD.Search(const inBuff: TKDT8DD_DynamicVecBuffer; var OutBuff: TKDT8DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8DD_DynamicVecBuffer;
  outBuffPtr : PKDT8DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8DD_Source));
end;

procedure TKDT8DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT8DD.PrintNodeTree(const NodePtr: PKDT8DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT8DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT8DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT8DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8DD.Test;
var
  TKDT8DD_Test    : TKDT8DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8DD_Test := TKDT8DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT8DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT8DD_AxisCount - 1 do
        TKDT8DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT8DD_Test.TestBuff), length(TKDT8DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8DD_Test.BuildKDTreeM(False, length(TKDT8DD_Test.TestBuff), @TKDT8DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8DD_Test.BuildKDTreeM(False, length(TKDT8DD_Test.TestBuff), TKDT8DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8DD_Test.TestBuff));
  TKDT8DD_Test.Search(TKDT8DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8DDDistance(TKDT8DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8DD_Test.Clear;
  { kMean test }
  TKDT8DD_Test.BuildKDTreeWithCluster(TKDT8DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8DD_Test.Search(TKDT8DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8DD_Test);
end;

{$ENDIF DEBUG}


function KDT10DDVec(const s: string): TKDT10DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT10DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT10DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT10DDVec(const v: TKDT10DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT10DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT10DDPow(const v: TKDT10DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT10DDDistance(const v1, v2: TKDT10DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT10DD_AxisCount - 1 do
      Result := Result + KDT10DDPow(v2[i] - v1[i]);
end;

function KDT10DDCmpare(const v1, v2: TKDT10DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT10DD_Vec));
end;

function TKDT10DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DD_Node;
  function SortCompare(const p1, p2: PKDT10DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT10DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT10DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT10DD_SourceBuffer;
  dynBuff  : PKDT10DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT10DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT10DD.SearchStoreBuff(const StoreBuffPtr: PKDT10DDyanmicStoreBuffer; const Buff: TKDT10DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT10DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT10DD.GetData(const index: NativeInt): PKDT10DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT10DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT10DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT10DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT10DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT10DD.StoreBuffPtr: PKDT10DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT10DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT10DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT10DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT10DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT10DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT10DD.BuildKDTreeWithCluster(const inBuff: TKDT10DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT10DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT10DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT10DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT10DD.BuildKDTreeWithCluster(const inBuff: TKDT10DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DD_BuildCall);
var
  TempStoreBuff: TKDT10DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DD_BuildMethod);
var
  TempStoreBuff: TKDT10DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DD_BuildProc);
var
  TempStoreBuff: TKDT10DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT10DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT10DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT10DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT10DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT10DD.Search(const Buff: TKDT10DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DD_Node;

var
  NearestNeighbour: PKDT10DD_Node;

  function FindParentNode(const BuffPtr: PKDT10DD_Vec; NodePtr: PKDT10DD_Node): PKDT10DD_Node;
  var
    Next       : PKDT10DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT10DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT10DD_Node; const BuffPtr: PKDT10DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT10DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT10DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT10DD_Vec; const p1, p2: PKDT10DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT10DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT10DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT10DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT10DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT10DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT10DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT10DD_Node(NearestNodes[0]);
    end;
end;

function TKDT10DD.Search(const Buff: TKDT10DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT10DD.Search(const Buff: TKDT10DD_Vec; var SearchedDistanceMin: Double): PKDT10DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT10DD.Search(const Buff: TKDT10DD_Vec): PKDT10DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT10DD.Search(const inBuff: TKDT10DD_DynamicVecBuffer; var OutBuff: TKDT10DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT10DD_DynamicVecBuffer;
  outBuffPtr : PKDT10DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT10DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT10DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT10DD_Source));
end;

procedure TKDT10DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT10DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT10DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT10DD.PrintNodeTree(const NodePtr: PKDT10DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT10DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT10DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT10DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT10DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT10DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT10DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT10DD.Test;
var
  TKDT10DD_Test    : TKDT10DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT10DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT10DD_Test := TKDT10DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT10DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT10DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT10DD_AxisCount - 1 do
        TKDT10DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT10DD_Test.TestBuff), length(TKDT10DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT10DD_Test.BuildKDTreeM(False, length(TKDT10DD_Test.TestBuff), @TKDT10DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT10DD_Test.BuildKDTreeM(False, length(TKDT10DD_Test.TestBuff), TKDT10DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT10DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT10DD_Test.TestBuff));
  TKDT10DD_Test.Search(TKDT10DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT10DDDistance(TKDT10DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT10DD_Test.Clear;
  { kMean test }
  TKDT10DD_Test.BuildKDTreeWithCluster(TKDT10DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT10DD_Test.Search(TKDT10DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT10DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT10DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT10DD_Test);
end;

{$ENDIF DEBUG}


function KDT12DDVec(const s: string): TKDT12DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT12DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT12DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT12DDVec(const v: TKDT12DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT12DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT12DDPow(const v: TKDT12DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT12DDDistance(const v1, v2: TKDT12DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT12DD_AxisCount - 1 do
      Result := Result + KDT12DDPow(v2[i] - v1[i]);
end;

function KDT12DDCmpare(const v1, v2: TKDT12DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT12DD_Vec));
end;

function TKDT12DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DD_Node;
  function SortCompare(const p1, p2: PKDT12DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT12DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT12DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT12DD_SourceBuffer;
  dynBuff  : PKDT12DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT12DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT12DD.SearchStoreBuff(const StoreBuffPtr: PKDT12DDyanmicStoreBuffer; const Buff: TKDT12DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT12DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT12DD.GetData(const index: NativeInt): PKDT12DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT12DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT12DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT12DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT12DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT12DD.StoreBuffPtr: PKDT12DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT12DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT12DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT12DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT12DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT12DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT12DD.BuildKDTreeWithCluster(const inBuff: TKDT12DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT12DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT12DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT12DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT12DD.BuildKDTreeWithCluster(const inBuff: TKDT12DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DD_BuildCall);
var
  TempStoreBuff: TKDT12DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DD_BuildMethod);
var
  TempStoreBuff: TKDT12DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DD_BuildProc);
var
  TempStoreBuff: TKDT12DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT12DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT12DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT12DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT12DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT12DD.Search(const Buff: TKDT12DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DD_Node;

var
  NearestNeighbour: PKDT12DD_Node;

  function FindParentNode(const BuffPtr: PKDT12DD_Vec; NodePtr: PKDT12DD_Node): PKDT12DD_Node;
  var
    Next       : PKDT12DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT12DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT12DD_Node; const BuffPtr: PKDT12DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT12DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT12DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT12DD_Vec; const p1, p2: PKDT12DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT12DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT12DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT12DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT12DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT12DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT12DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT12DD_Node(NearestNodes[0]);
    end;
end;

function TKDT12DD.Search(const Buff: TKDT12DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT12DD.Search(const Buff: TKDT12DD_Vec; var SearchedDistanceMin: Double): PKDT12DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT12DD.Search(const Buff: TKDT12DD_Vec): PKDT12DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT12DD.Search(const inBuff: TKDT12DD_DynamicVecBuffer; var OutBuff: TKDT12DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT12DD_DynamicVecBuffer;
  outBuffPtr : PKDT12DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT12DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT12DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT12DD_Source));
end;

procedure TKDT12DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT12DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT12DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT12DD.PrintNodeTree(const NodePtr: PKDT12DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT12DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT12DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT12DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT12DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT12DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT12DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT12DD.Test;
var
  TKDT12DD_Test    : TKDT12DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT12DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT12DD_Test := TKDT12DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT12DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT12DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT12DD_AxisCount - 1 do
        TKDT12DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT12DD_Test.TestBuff), length(TKDT12DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT12DD_Test.BuildKDTreeM(False, length(TKDT12DD_Test.TestBuff), @TKDT12DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT12DD_Test.BuildKDTreeM(False, length(TKDT12DD_Test.TestBuff), TKDT12DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT12DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT12DD_Test.TestBuff));
  TKDT12DD_Test.Search(TKDT12DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT12DDDistance(TKDT12DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT12DD_Test.Clear;
  { kMean test }
  TKDT12DD_Test.BuildKDTreeWithCluster(TKDT12DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT12DD_Test.Search(TKDT12DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT12DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT12DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT12DD_Test);
end;

{$ENDIF DEBUG}


function KDT14DDVec(const s: string): TKDT14DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT14DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT14DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT14DDVec(const v: TKDT14DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT14DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT14DDPow(const v: TKDT14DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT14DDDistance(const v1, v2: TKDT14DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT14DD_AxisCount - 1 do
      Result := Result + KDT14DDPow(v2[i] - v1[i]);
end;

function KDT14DDCmpare(const v1, v2: TKDT14DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT14DD_Vec));
end;

function TKDT14DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DD_Node;
  function SortCompare(const p1, p2: PKDT14DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT14DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT14DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT14DD_SourceBuffer;
  dynBuff  : PKDT14DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT14DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT14DD.SearchStoreBuff(const StoreBuffPtr: PKDT14DDyanmicStoreBuffer; const Buff: TKDT14DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT14DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT14DD.GetData(const index: NativeInt): PKDT14DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT14DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT14DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT14DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT14DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT14DD.StoreBuffPtr: PKDT14DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT14DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT14DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT14DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT14DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT14DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT14DD.BuildKDTreeWithCluster(const inBuff: TKDT14DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT14DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT14DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT14DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT14DD.BuildKDTreeWithCluster(const inBuff: TKDT14DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DD_BuildCall);
var
  TempStoreBuff: TKDT14DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DD_BuildMethod);
var
  TempStoreBuff: TKDT14DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DD_BuildProc);
var
  TempStoreBuff: TKDT14DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT14DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT14DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT14DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT14DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT14DD.Search(const Buff: TKDT14DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DD_Node;

var
  NearestNeighbour: PKDT14DD_Node;

  function FindParentNode(const BuffPtr: PKDT14DD_Vec; NodePtr: PKDT14DD_Node): PKDT14DD_Node;
  var
    Next       : PKDT14DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT14DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT14DD_Node; const BuffPtr: PKDT14DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT14DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT14DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT14DD_Vec; const p1, p2: PKDT14DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT14DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT14DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT14DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT14DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT14DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT14DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT14DD_Node(NearestNodes[0]);
    end;
end;

function TKDT14DD.Search(const Buff: TKDT14DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT14DD.Search(const Buff: TKDT14DD_Vec; var SearchedDistanceMin: Double): PKDT14DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT14DD.Search(const Buff: TKDT14DD_Vec): PKDT14DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT14DD.Search(const inBuff: TKDT14DD_DynamicVecBuffer; var OutBuff: TKDT14DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT14DD_DynamicVecBuffer;
  outBuffPtr : PKDT14DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT14DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT14DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT14DD_Source));
end;

procedure TKDT14DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT14DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT14DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT14DD.PrintNodeTree(const NodePtr: PKDT14DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT14DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT14DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT14DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT14DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT14DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT14DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT14DD.Test;
var
  TKDT14DD_Test    : TKDT14DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT14DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT14DD_Test := TKDT14DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT14DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT14DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT14DD_AxisCount - 1 do
        TKDT14DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT14DD_Test.TestBuff), length(TKDT14DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT14DD_Test.BuildKDTreeM(False, length(TKDT14DD_Test.TestBuff), @TKDT14DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT14DD_Test.BuildKDTreeM(False, length(TKDT14DD_Test.TestBuff), TKDT14DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT14DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT14DD_Test.TestBuff));
  TKDT14DD_Test.Search(TKDT14DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT14DDDistance(TKDT14DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT14DD_Test.Clear;
  { kMean test }
  TKDT14DD_Test.BuildKDTreeWithCluster(TKDT14DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT14DD_Test.Search(TKDT14DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT14DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT14DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT14DD_Test);
end;

{$ENDIF DEBUG}


function KDT16DDVec(const s: string): TKDT16DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT16DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT16DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT16DDVec(const v: TKDT16DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT16DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT16DDPow(const v: TKDT16DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT16DDDistance(const v1, v2: TKDT16DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT16DD_AxisCount - 1 do
      Result := Result + KDT16DDPow(v2[i] - v1[i]);
end;

function KDT16DDCmpare(const v1, v2: TKDT16DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT16DD_Vec));
end;

function TKDT16DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DD_Node;
  function SortCompare(const p1, p2: PKDT16DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT16DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT16DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT16DD_SourceBuffer;
  dynBuff  : PKDT16DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT16DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT16DD.SearchStoreBuff(const StoreBuffPtr: PKDT16DDyanmicStoreBuffer; const Buff: TKDT16DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT16DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT16DD.GetData(const index: NativeInt): PKDT16DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT16DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT16DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT16DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT16DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT16DD.StoreBuffPtr: PKDT16DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT16DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT16DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT16DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT16DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT16DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT16DD.BuildKDTreeWithCluster(const inBuff: TKDT16DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT16DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT16DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT16DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT16DD.BuildKDTreeWithCluster(const inBuff: TKDT16DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DD_BuildCall);
var
  TempStoreBuff: TKDT16DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DD_BuildMethod);
var
  TempStoreBuff: TKDT16DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DD_BuildProc);
var
  TempStoreBuff: TKDT16DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT16DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT16DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT16DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT16DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT16DD.Search(const Buff: TKDT16DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DD_Node;

var
  NearestNeighbour: PKDT16DD_Node;

  function FindParentNode(const BuffPtr: PKDT16DD_Vec; NodePtr: PKDT16DD_Node): PKDT16DD_Node;
  var
    Next       : PKDT16DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT16DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT16DD_Node; const BuffPtr: PKDT16DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT16DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT16DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT16DD_Vec; const p1, p2: PKDT16DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT16DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT16DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT16DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT16DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT16DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT16DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT16DD_Node(NearestNodes[0]);
    end;
end;

function TKDT16DD.Search(const Buff: TKDT16DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT16DD.Search(const Buff: TKDT16DD_Vec; var SearchedDistanceMin: Double): PKDT16DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT16DD.Search(const Buff: TKDT16DD_Vec): PKDT16DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT16DD.Search(const inBuff: TKDT16DD_DynamicVecBuffer; var OutBuff: TKDT16DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT16DD_DynamicVecBuffer;
  outBuffPtr : PKDT16DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT16DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT16DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT16DD_Source));
end;

procedure TKDT16DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT16DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT16DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT16DD.PrintNodeTree(const NodePtr: PKDT16DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT16DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT16DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT16DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT16DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT16DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT16DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT16DD.Test;
var
  TKDT16DD_Test    : TKDT16DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT16DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT16DD_Test := TKDT16DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT16DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT16DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT16DD_AxisCount - 1 do
        TKDT16DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT16DD_Test.TestBuff), length(TKDT16DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT16DD_Test.BuildKDTreeM(False, length(TKDT16DD_Test.TestBuff), @TKDT16DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT16DD_Test.BuildKDTreeM(False, length(TKDT16DD_Test.TestBuff), TKDT16DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT16DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT16DD_Test.TestBuff));
  TKDT16DD_Test.Search(TKDT16DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT16DDDistance(TKDT16DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT16DD_Test.Clear;
  { kMean test }
  TKDT16DD_Test.BuildKDTreeWithCluster(TKDT16DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT16DD_Test.Search(TKDT16DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT16DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT16DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT16DD_Test);
end;

{$ENDIF DEBUG}


function KDT18DDVec(const s: string): TKDT18DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT18DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT18DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT18DDVec(const v: TKDT18DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT18DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT18DDPow(const v: TKDT18DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT18DDDistance(const v1, v2: TKDT18DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT18DD_AxisCount - 1 do
      Result := Result + KDT18DDPow(v2[i] - v1[i]);
end;

function KDT18DDCmpare(const v1, v2: TKDT18DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT18DD_Vec));
end;

function TKDT18DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DD_Node;
  function SortCompare(const p1, p2: PKDT18DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT18DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT18DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT18DD_SourceBuffer;
  dynBuff  : PKDT18DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT18DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT18DD.SearchStoreBuff(const StoreBuffPtr: PKDT18DDyanmicStoreBuffer; const Buff: TKDT18DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT18DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT18DD.GetData(const index: NativeInt): PKDT18DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT18DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT18DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT18DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT18DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT18DD.StoreBuffPtr: PKDT18DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT18DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT18DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT18DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT18DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT18DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT18DD.BuildKDTreeWithCluster(const inBuff: TKDT18DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT18DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT18DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT18DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT18DD.BuildKDTreeWithCluster(const inBuff: TKDT18DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DD_BuildCall);
var
  TempStoreBuff: TKDT18DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DD_BuildMethod);
var
  TempStoreBuff: TKDT18DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DD_BuildProc);
var
  TempStoreBuff: TKDT18DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT18DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT18DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT18DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT18DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT18DD.Search(const Buff: TKDT18DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DD_Node;

var
  NearestNeighbour: PKDT18DD_Node;

  function FindParentNode(const BuffPtr: PKDT18DD_Vec; NodePtr: PKDT18DD_Node): PKDT18DD_Node;
  var
    Next       : PKDT18DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT18DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT18DD_Node; const BuffPtr: PKDT18DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT18DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT18DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT18DD_Vec; const p1, p2: PKDT18DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT18DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT18DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT18DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT18DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT18DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT18DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT18DD_Node(NearestNodes[0]);
    end;
end;

function TKDT18DD.Search(const Buff: TKDT18DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT18DD.Search(const Buff: TKDT18DD_Vec; var SearchedDistanceMin: Double): PKDT18DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT18DD.Search(const Buff: TKDT18DD_Vec): PKDT18DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT18DD.Search(const inBuff: TKDT18DD_DynamicVecBuffer; var OutBuff: TKDT18DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT18DD_DynamicVecBuffer;
  outBuffPtr : PKDT18DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT18DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT18DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT18DD_Source));
end;

procedure TKDT18DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT18DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT18DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT18DD.PrintNodeTree(const NodePtr: PKDT18DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT18DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT18DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT18DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT18DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT18DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT18DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT18DD.Test;
var
  TKDT18DD_Test    : TKDT18DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT18DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT18DD_Test := TKDT18DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT18DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT18DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT18DD_AxisCount - 1 do
        TKDT18DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT18DD_Test.TestBuff), length(TKDT18DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT18DD_Test.BuildKDTreeM(False, length(TKDT18DD_Test.TestBuff), @TKDT18DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT18DD_Test.BuildKDTreeM(False, length(TKDT18DD_Test.TestBuff), TKDT18DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT18DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT18DD_Test.TestBuff));
  TKDT18DD_Test.Search(TKDT18DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT18DDDistance(TKDT18DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT18DD_Test.Clear;
  { kMean test }
  TKDT18DD_Test.BuildKDTreeWithCluster(TKDT18DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT18DD_Test.Search(TKDT18DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT18DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT18DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT18DD_Test);
end;

{$ENDIF DEBUG}


function KDT20DDVec(const s: string): TKDT20DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT20DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT20DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT20DDVec(const v: TKDT20DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT20DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT20DDPow(const v: TKDT20DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT20DDDistance(const v1, v2: TKDT20DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT20DD_AxisCount - 1 do
      Result := Result + KDT20DDPow(v2[i] - v1[i]);
end;

function KDT20DDCmpare(const v1, v2: TKDT20DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT20DD_Vec));
end;

function TKDT20DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DD_Node;
  function SortCompare(const p1, p2: PKDT20DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT20DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT20DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT20DD_SourceBuffer;
  dynBuff  : PKDT20DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT20DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT20DD.SearchStoreBuff(const StoreBuffPtr: PKDT20DDyanmicStoreBuffer; const Buff: TKDT20DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT20DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT20DD.GetData(const index: NativeInt): PKDT20DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT20DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT20DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT20DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT20DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT20DD.StoreBuffPtr: PKDT20DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT20DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT20DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT20DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT20DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT20DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT20DD.BuildKDTreeWithCluster(const inBuff: TKDT20DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT20DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT20DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT20DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT20DD.BuildKDTreeWithCluster(const inBuff: TKDT20DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DD_BuildCall);
var
  TempStoreBuff: TKDT20DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DD_BuildMethod);
var
  TempStoreBuff: TKDT20DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DD_BuildProc);
var
  TempStoreBuff: TKDT20DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT20DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT20DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT20DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT20DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT20DD.Search(const Buff: TKDT20DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DD_Node;

var
  NearestNeighbour: PKDT20DD_Node;

  function FindParentNode(const BuffPtr: PKDT20DD_Vec; NodePtr: PKDT20DD_Node): PKDT20DD_Node;
  var
    Next       : PKDT20DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT20DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT20DD_Node; const BuffPtr: PKDT20DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT20DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT20DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT20DD_Vec; const p1, p2: PKDT20DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT20DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT20DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT20DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT20DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT20DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT20DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT20DD_Node(NearestNodes[0]);
    end;
end;

function TKDT20DD.Search(const Buff: TKDT20DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT20DD.Search(const Buff: TKDT20DD_Vec; var SearchedDistanceMin: Double): PKDT20DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT20DD.Search(const Buff: TKDT20DD_Vec): PKDT20DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT20DD.Search(const inBuff: TKDT20DD_DynamicVecBuffer; var OutBuff: TKDT20DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT20DD_DynamicVecBuffer;
  outBuffPtr : PKDT20DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT20DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT20DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT20DD_Source));
end;

procedure TKDT20DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT20DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT20DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT20DD.PrintNodeTree(const NodePtr: PKDT20DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT20DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT20DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT20DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT20DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT20DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT20DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT20DD.Test;
var
  TKDT20DD_Test    : TKDT20DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT20DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT20DD_Test := TKDT20DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT20DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT20DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT20DD_AxisCount - 1 do
        TKDT20DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT20DD_Test.TestBuff), length(TKDT20DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT20DD_Test.BuildKDTreeM(False, length(TKDT20DD_Test.TestBuff), @TKDT20DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT20DD_Test.BuildKDTreeM(False, length(TKDT20DD_Test.TestBuff), TKDT20DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT20DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT20DD_Test.TestBuff));
  TKDT20DD_Test.Search(TKDT20DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT20DDDistance(TKDT20DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT20DD_Test.Clear;
  { kMean test }
  TKDT20DD_Test.BuildKDTreeWithCluster(TKDT20DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT20DD_Test.Search(TKDT20DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT20DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT20DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT20DD_Test);
end;

{$ENDIF DEBUG}


function KDT22DDVec(const s: string): TKDT22DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT22DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT22DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT22DDVec(const v: TKDT22DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT22DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT22DDPow(const v: TKDT22DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT22DDDistance(const v1, v2: TKDT22DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT22DD_AxisCount - 1 do
      Result := Result + KDT22DDPow(v2[i] - v1[i]);
end;

function KDT22DDCmpare(const v1, v2: TKDT22DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT22DD_Vec));
end;

function TKDT22DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DD_Node;
  function SortCompare(const p1, p2: PKDT22DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT22DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT22DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT22DD_SourceBuffer;
  dynBuff  : PKDT22DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT22DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT22DD.SearchStoreBuff(const StoreBuffPtr: PKDT22DDyanmicStoreBuffer; const Buff: TKDT22DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT22DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT22DD.GetData(const index: NativeInt): PKDT22DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT22DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT22DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT22DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT22DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT22DD.StoreBuffPtr: PKDT22DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT22DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT22DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT22DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT22DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT22DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT22DD.BuildKDTreeWithCluster(const inBuff: TKDT22DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT22DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT22DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT22DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT22DD.BuildKDTreeWithCluster(const inBuff: TKDT22DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DD_BuildCall);
var
  TempStoreBuff: TKDT22DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DD_BuildMethod);
var
  TempStoreBuff: TKDT22DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DD_BuildProc);
var
  TempStoreBuff: TKDT22DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT22DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT22DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT22DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT22DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT22DD.Search(const Buff: TKDT22DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DD_Node;

var
  NearestNeighbour: PKDT22DD_Node;

  function FindParentNode(const BuffPtr: PKDT22DD_Vec; NodePtr: PKDT22DD_Node): PKDT22DD_Node;
  var
    Next       : PKDT22DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT22DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT22DD_Node; const BuffPtr: PKDT22DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT22DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT22DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT22DD_Vec; const p1, p2: PKDT22DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT22DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT22DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT22DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT22DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT22DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT22DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT22DD_Node(NearestNodes[0]);
    end;
end;

function TKDT22DD.Search(const Buff: TKDT22DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT22DD.Search(const Buff: TKDT22DD_Vec; var SearchedDistanceMin: Double): PKDT22DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT22DD.Search(const Buff: TKDT22DD_Vec): PKDT22DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT22DD.Search(const inBuff: TKDT22DD_DynamicVecBuffer; var OutBuff: TKDT22DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT22DD_DynamicVecBuffer;
  outBuffPtr : PKDT22DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT22DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT22DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT22DD_Source));
end;

procedure TKDT22DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT22DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT22DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT22DD.PrintNodeTree(const NodePtr: PKDT22DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT22DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT22DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT22DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT22DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT22DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT22DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT22DD.Test;
var
  TKDT22DD_Test    : TKDT22DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT22DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT22DD_Test := TKDT22DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT22DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT22DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT22DD_AxisCount - 1 do
        TKDT22DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT22DD_Test.TestBuff), length(TKDT22DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT22DD_Test.BuildKDTreeM(False, length(TKDT22DD_Test.TestBuff), @TKDT22DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT22DD_Test.BuildKDTreeM(False, length(TKDT22DD_Test.TestBuff), TKDT22DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT22DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT22DD_Test.TestBuff));
  TKDT22DD_Test.Search(TKDT22DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT22DDDistance(TKDT22DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT22DD_Test.Clear;
  { kMean test }
  TKDT22DD_Test.BuildKDTreeWithCluster(TKDT22DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT22DD_Test.Search(TKDT22DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT22DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT22DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT22DD_Test);
end;

{$ENDIF DEBUG}


function KDT24DDVec(const s: string): TKDT24DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT24DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT24DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT24DDVec(const v: TKDT24DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT24DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT24DDPow(const v: TKDT24DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT24DDDistance(const v1, v2: TKDT24DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT24DD_AxisCount - 1 do
      Result := Result + KDT24DDPow(v2[i] - v1[i]);
end;

function KDT24DDCmpare(const v1, v2: TKDT24DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT24DD_Vec));
end;

function TKDT24DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DD_Node;
  function SortCompare(const p1, p2: PKDT24DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT24DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT24DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT24DD_SourceBuffer;
  dynBuff  : PKDT24DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT24DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT24DD.SearchStoreBuff(const StoreBuffPtr: PKDT24DDyanmicStoreBuffer; const Buff: TKDT24DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT24DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT24DD.GetData(const index: NativeInt): PKDT24DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT24DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT24DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT24DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT24DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT24DD.StoreBuffPtr: PKDT24DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT24DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT24DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT24DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT24DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT24DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT24DD.BuildKDTreeWithCluster(const inBuff: TKDT24DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT24DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT24DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT24DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT24DD.BuildKDTreeWithCluster(const inBuff: TKDT24DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DD_BuildCall);
var
  TempStoreBuff: TKDT24DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DD_BuildMethod);
var
  TempStoreBuff: TKDT24DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DD_BuildProc);
var
  TempStoreBuff: TKDT24DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT24DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT24DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT24DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT24DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT24DD.Search(const Buff: TKDT24DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DD_Node;

var
  NearestNeighbour: PKDT24DD_Node;

  function FindParentNode(const BuffPtr: PKDT24DD_Vec; NodePtr: PKDT24DD_Node): PKDT24DD_Node;
  var
    Next       : PKDT24DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT24DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT24DD_Node; const BuffPtr: PKDT24DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT24DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT24DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT24DD_Vec; const p1, p2: PKDT24DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT24DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT24DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT24DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT24DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT24DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT24DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT24DD_Node(NearestNodes[0]);
    end;
end;

function TKDT24DD.Search(const Buff: TKDT24DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT24DD.Search(const Buff: TKDT24DD_Vec; var SearchedDistanceMin: Double): PKDT24DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT24DD.Search(const Buff: TKDT24DD_Vec): PKDT24DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT24DD.Search(const inBuff: TKDT24DD_DynamicVecBuffer; var OutBuff: TKDT24DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT24DD_DynamicVecBuffer;
  outBuffPtr : PKDT24DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT24DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT24DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT24DD_Source));
end;

procedure TKDT24DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT24DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT24DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT24DD.PrintNodeTree(const NodePtr: PKDT24DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT24DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT24DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT24DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT24DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT24DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT24DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT24DD.Test;
var
  TKDT24DD_Test    : TKDT24DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT24DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT24DD_Test := TKDT24DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT24DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT24DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT24DD_AxisCount - 1 do
        TKDT24DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT24DD_Test.TestBuff), length(TKDT24DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT24DD_Test.BuildKDTreeM(False, length(TKDT24DD_Test.TestBuff), @TKDT24DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT24DD_Test.BuildKDTreeM(False, length(TKDT24DD_Test.TestBuff), TKDT24DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT24DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT24DD_Test.TestBuff));
  TKDT24DD_Test.Search(TKDT24DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT24DDDistance(TKDT24DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT24DD_Test.Clear;
  { kMean test }
  TKDT24DD_Test.BuildKDTreeWithCluster(TKDT24DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT24DD_Test.Search(TKDT24DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT24DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT24DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT24DD_Test);
end;

{$ENDIF DEBUG}


function KDT28DDVec(const s: string): TKDT28DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT28DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT28DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT28DDVec(const v: TKDT28DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT28DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT28DDPow(const v: TKDT28DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT28DDDistance(const v1, v2: TKDT28DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT28DD_AxisCount - 1 do
      Result := Result + KDT28DDPow(v2[i] - v1[i]);
end;

function KDT28DDCmpare(const v1, v2: TKDT28DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT28DD_Vec));
end;

function TKDT28DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DD_Node;
  function SortCompare(const p1, p2: PKDT28DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT28DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT28DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT28DD_SourceBuffer;
  dynBuff  : PKDT28DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT28DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT28DD.SearchStoreBuff(const StoreBuffPtr: PKDT28DDyanmicStoreBuffer; const Buff: TKDT28DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT28DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT28DD.GetData(const index: NativeInt): PKDT28DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT28DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT28DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT28DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT28DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT28DD.StoreBuffPtr: PKDT28DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT28DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT28DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT28DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT28DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT28DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT28DD.BuildKDTreeWithCluster(const inBuff: TKDT28DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT28DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT28DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT28DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT28DD.BuildKDTreeWithCluster(const inBuff: TKDT28DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DD_BuildCall);
var
  TempStoreBuff: TKDT28DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DD_BuildMethod);
var
  TempStoreBuff: TKDT28DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DD_BuildProc);
var
  TempStoreBuff: TKDT28DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT28DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT28DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT28DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT28DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT28DD.Search(const Buff: TKDT28DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DD_Node;

var
  NearestNeighbour: PKDT28DD_Node;

  function FindParentNode(const BuffPtr: PKDT28DD_Vec; NodePtr: PKDT28DD_Node): PKDT28DD_Node;
  var
    Next       : PKDT28DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT28DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT28DD_Node; const BuffPtr: PKDT28DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT28DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT28DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT28DD_Vec; const p1, p2: PKDT28DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT28DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT28DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT28DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT28DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT28DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT28DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT28DD_Node(NearestNodes[0]);
    end;
end;

function TKDT28DD.Search(const Buff: TKDT28DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT28DD.Search(const Buff: TKDT28DD_Vec; var SearchedDistanceMin: Double): PKDT28DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT28DD.Search(const Buff: TKDT28DD_Vec): PKDT28DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT28DD.Search(const inBuff: TKDT28DD_DynamicVecBuffer; var OutBuff: TKDT28DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT28DD_DynamicVecBuffer;
  outBuffPtr : PKDT28DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT28DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT28DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT28DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT28DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT28DD_Source));
end;

procedure TKDT28DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT28DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT28DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT28DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT28DD.PrintNodeTree(const NodePtr: PKDT28DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT28DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT28DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT28DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT28DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT28DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT28DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT28DD.Test;
var
  TKDT28DD_Test    : TKDT28DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT28DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT28DD_Test := TKDT28DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT28DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT28DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT28DD_AxisCount - 1 do
        TKDT28DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT28DD_Test.TestBuff), length(TKDT28DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT28DD_Test.BuildKDTreeM(False, length(TKDT28DD_Test.TestBuff), @TKDT28DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT28DD_Test.BuildKDTreeM(False, length(TKDT28DD_Test.TestBuff), TKDT28DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT28DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT28DD_Test.TestBuff));
  TKDT28DD_Test.Search(TKDT28DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT28DDDistance(TKDT28DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT28DD_Test.Clear;
  { kMean test }
  TKDT28DD_Test.BuildKDTreeWithCluster(TKDT28DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT28DD_Test.Search(TKDT28DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT28DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT28DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT28DD_Test);
end;

{$ENDIF DEBUG}


function KDT30DDVec(const s: string): TKDT30DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT30DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT30DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT30DDVec(const v: TKDT30DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT30DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT30DDPow(const v: TKDT30DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT30DDDistance(const v1, v2: TKDT30DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT30DD_AxisCount - 1 do
      Result := Result + KDT30DDPow(v2[i] - v1[i]);
end;

function KDT30DDCmpare(const v1, v2: TKDT30DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT30DD_Vec));
end;

function TKDT30DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DD_Node;
  function SortCompare(const p1, p2: PKDT30DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT30DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT30DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT30DD_SourceBuffer;
  dynBuff  : PKDT30DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT30DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT30DD.SearchStoreBuff(const StoreBuffPtr: PKDT30DDyanmicStoreBuffer; const Buff: TKDT30DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT30DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT30DD.GetData(const index: NativeInt): PKDT30DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT30DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT30DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT30DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT30DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT30DD.StoreBuffPtr: PKDT30DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT30DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT30DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT30DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT30DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT30DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT30DD.BuildKDTreeWithCluster(const inBuff: TKDT30DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT30DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT30DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT30DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT30DD.BuildKDTreeWithCluster(const inBuff: TKDT30DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DD_BuildCall);
var
  TempStoreBuff: TKDT30DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DD_BuildMethod);
var
  TempStoreBuff: TKDT30DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DD_BuildProc);
var
  TempStoreBuff: TKDT30DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT30DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT30DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT30DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT30DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT30DD.Search(const Buff: TKDT30DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DD_Node;

var
  NearestNeighbour: PKDT30DD_Node;

  function FindParentNode(const BuffPtr: PKDT30DD_Vec; NodePtr: PKDT30DD_Node): PKDT30DD_Node;
  var
    Next       : PKDT30DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT30DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT30DD_Node; const BuffPtr: PKDT30DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT30DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT30DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT30DD_Vec; const p1, p2: PKDT30DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT30DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT30DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT30DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT30DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT30DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT30DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT30DD_Node(NearestNodes[0]);
    end;
end;

function TKDT30DD.Search(const Buff: TKDT30DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT30DD.Search(const Buff: TKDT30DD_Vec; var SearchedDistanceMin: Double): PKDT30DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT30DD.Search(const Buff: TKDT30DD_Vec): PKDT30DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT30DD.Search(const inBuff: TKDT30DD_DynamicVecBuffer; var OutBuff: TKDT30DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT30DD_DynamicVecBuffer;
  outBuffPtr : PKDT30DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT30DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT30DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT30DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT30DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT30DD_Source));
end;

procedure TKDT30DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT30DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT30DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT30DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT30DD.PrintNodeTree(const NodePtr: PKDT30DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT30DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT30DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT30DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT30DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT30DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT30DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT30DD.Test;
var
  TKDT30DD_Test    : TKDT30DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT30DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT30DD_Test := TKDT30DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT30DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT30DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT30DD_AxisCount - 1 do
        TKDT30DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT30DD_Test.TestBuff), length(TKDT30DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT30DD_Test.BuildKDTreeM(False, length(TKDT30DD_Test.TestBuff), @TKDT30DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT30DD_Test.BuildKDTreeM(False, length(TKDT30DD_Test.TestBuff), TKDT30DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT30DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT30DD_Test.TestBuff));
  TKDT30DD_Test.Search(TKDT30DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT30DDDistance(TKDT30DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT30DD_Test.Clear;
  { kMean test }
  TKDT30DD_Test.BuildKDTreeWithCluster(TKDT30DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT30DD_Test.Search(TKDT30DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT30DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT30DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT30DD_Test);
end;

{$ENDIF DEBUG}


function KDT32DDVec(const s: string): TKDT32DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT32DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT32DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT32DDVec(const v: TKDT32DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT32DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT32DDPow(const v: TKDT32DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT32DDDistance(const v1, v2: TKDT32DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT32DD_AxisCount - 1 do
      Result := Result + KDT32DDPow(v2[i] - v1[i]);
end;

function KDT32DDCmpare(const v1, v2: TKDT32DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT32DD_Vec));
end;

function TKDT32DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DD_Node;
  function SortCompare(const p1, p2: PKDT32DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT32DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT32DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT32DD_SourceBuffer;
  dynBuff  : PKDT32DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT32DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT32DD.SearchStoreBuff(const StoreBuffPtr: PKDT32DDyanmicStoreBuffer; const Buff: TKDT32DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT32DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT32DD.GetData(const index: NativeInt): PKDT32DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT32DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT32DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT32DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT32DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT32DD.StoreBuffPtr: PKDT32DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT32DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT32DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT32DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT32DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT32DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT32DD.BuildKDTreeWithCluster(const inBuff: TKDT32DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT32DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT32DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT32DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT32DD.BuildKDTreeWithCluster(const inBuff: TKDT32DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DD_BuildCall);
var
  TempStoreBuff: TKDT32DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DD_BuildMethod);
var
  TempStoreBuff: TKDT32DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DD_BuildProc);
var
  TempStoreBuff: TKDT32DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT32DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT32DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT32DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT32DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT32DD.Search(const Buff: TKDT32DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DD_Node;

var
  NearestNeighbour: PKDT32DD_Node;

  function FindParentNode(const BuffPtr: PKDT32DD_Vec; NodePtr: PKDT32DD_Node): PKDT32DD_Node;
  var
    Next       : PKDT32DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT32DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT32DD_Node; const BuffPtr: PKDT32DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT32DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT32DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT32DD_Vec; const p1, p2: PKDT32DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT32DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT32DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT32DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT32DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT32DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT32DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT32DD_Node(NearestNodes[0]);
    end;
end;

function TKDT32DD.Search(const Buff: TKDT32DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT32DD.Search(const Buff: TKDT32DD_Vec; var SearchedDistanceMin: Double): PKDT32DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT32DD.Search(const Buff: TKDT32DD_Vec): PKDT32DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT32DD.Search(const inBuff: TKDT32DD_DynamicVecBuffer; var OutBuff: TKDT32DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT32DD_DynamicVecBuffer;
  outBuffPtr : PKDT32DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT32DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT32DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT32DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT32DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT32DD_Source));
end;

procedure TKDT32DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT32DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT32DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT32DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT32DD.PrintNodeTree(const NodePtr: PKDT32DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT32DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT32DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT32DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT32DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT32DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT32DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT32DD.Test;
var
  TKDT32DD_Test    : TKDT32DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT32DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT32DD_Test := TKDT32DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT32DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT32DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT32DD_AxisCount - 1 do
        TKDT32DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT32DD_Test.TestBuff), length(TKDT32DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT32DD_Test.BuildKDTreeM(False, length(TKDT32DD_Test.TestBuff), @TKDT32DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT32DD_Test.BuildKDTreeM(False, length(TKDT32DD_Test.TestBuff), TKDT32DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT32DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT32DD_Test.TestBuff));
  TKDT32DD_Test.Search(TKDT32DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT32DDDistance(TKDT32DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT32DD_Test.Clear;
  { kMean test }
  TKDT32DD_Test.BuildKDTreeWithCluster(TKDT32DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT32DD_Test.Search(TKDT32DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT32DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT32DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT32DD_Test);
end;

{$ENDIF DEBUG}


function KDT34DDVec(const s: string): TKDT34DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT34DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT34DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT34DDVec(const v: TKDT34DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT34DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT34DDPow(const v: TKDT34DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT34DDDistance(const v1, v2: TKDT34DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT34DD_AxisCount - 1 do
      Result := Result + KDT34DDPow(v2[i] - v1[i]);
end;

function KDT34DDCmpare(const v1, v2: TKDT34DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT34DD_Vec));
end;

function TKDT34DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DD_Node;
  function SortCompare(const p1, p2: PKDT34DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT34DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT34DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT34DD_SourceBuffer;
  dynBuff  : PKDT34DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT34DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT34DD.SearchStoreBuff(const StoreBuffPtr: PKDT34DDyanmicStoreBuffer; const Buff: TKDT34DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT34DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT34DD.GetData(const index: NativeInt): PKDT34DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT34DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT34DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT34DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT34DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT34DD.StoreBuffPtr: PKDT34DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT34DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT34DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT34DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT34DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT34DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT34DD.BuildKDTreeWithCluster(const inBuff: TKDT34DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT34DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT34DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT34DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT34DD.BuildKDTreeWithCluster(const inBuff: TKDT34DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DD_BuildCall);
var
  TempStoreBuff: TKDT34DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DD_BuildMethod);
var
  TempStoreBuff: TKDT34DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DD_BuildProc);
var
  TempStoreBuff: TKDT34DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT34DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT34DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT34DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT34DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT34DD.Search(const Buff: TKDT34DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DD_Node;

var
  NearestNeighbour: PKDT34DD_Node;

  function FindParentNode(const BuffPtr: PKDT34DD_Vec; NodePtr: PKDT34DD_Node): PKDT34DD_Node;
  var
    Next       : PKDT34DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT34DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT34DD_Node; const BuffPtr: PKDT34DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT34DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT34DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT34DD_Vec; const p1, p2: PKDT34DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT34DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT34DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT34DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT34DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT34DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT34DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT34DD_Node(NearestNodes[0]);
    end;
end;

function TKDT34DD.Search(const Buff: TKDT34DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT34DD.Search(const Buff: TKDT34DD_Vec; var SearchedDistanceMin: Double): PKDT34DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT34DD.Search(const Buff: TKDT34DD_Vec): PKDT34DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT34DD.Search(const inBuff: TKDT34DD_DynamicVecBuffer; var OutBuff: TKDT34DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT34DD_DynamicVecBuffer;
  outBuffPtr : PKDT34DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT34DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT34DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT34DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT34DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT34DD_Source));
end;

procedure TKDT34DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT34DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT34DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT34DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT34DD.PrintNodeTree(const NodePtr: PKDT34DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT34DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT34DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT34DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT34DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT34DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT34DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT34DD.Test;
var
  TKDT34DD_Test    : TKDT34DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT34DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT34DD_Test := TKDT34DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT34DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT34DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT34DD_AxisCount - 1 do
        TKDT34DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT34DD_Test.TestBuff), length(TKDT34DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT34DD_Test.BuildKDTreeM(False, length(TKDT34DD_Test.TestBuff), @TKDT34DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT34DD_Test.BuildKDTreeM(False, length(TKDT34DD_Test.TestBuff), TKDT34DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT34DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT34DD_Test.TestBuff));
  TKDT34DD_Test.Search(TKDT34DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT34DDDistance(TKDT34DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT34DD_Test.Clear;
  { kMean test }
  TKDT34DD_Test.BuildKDTreeWithCluster(TKDT34DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT34DD_Test.Search(TKDT34DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT34DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT34DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT34DD_Test);
end;

{$ENDIF DEBUG}


function KDT36DDVec(const s: string): TKDT36DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT36DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT36DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT36DDVec(const v: TKDT36DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT36DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT36DDPow(const v: TKDT36DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT36DDDistance(const v1, v2: TKDT36DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT36DD_AxisCount - 1 do
      Result := Result + KDT36DDPow(v2[i] - v1[i]);
end;

function KDT36DDCmpare(const v1, v2: TKDT36DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT36DD_Vec));
end;

function TKDT36DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DD_Node;
  function SortCompare(const p1, p2: PKDT36DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT36DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT36DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT36DD_SourceBuffer;
  dynBuff  : PKDT36DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT36DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT36DD.SearchStoreBuff(const StoreBuffPtr: PKDT36DDyanmicStoreBuffer; const Buff: TKDT36DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT36DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT36DD.GetData(const index: NativeInt): PKDT36DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT36DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT36DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT36DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT36DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT36DD.StoreBuffPtr: PKDT36DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT36DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT36DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT36DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT36DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT36DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT36DD.BuildKDTreeWithCluster(const inBuff: TKDT36DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT36DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT36DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT36DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT36DD.BuildKDTreeWithCluster(const inBuff: TKDT36DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DD_BuildCall);
var
  TempStoreBuff: TKDT36DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DD_BuildMethod);
var
  TempStoreBuff: TKDT36DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DD_BuildProc);
var
  TempStoreBuff: TKDT36DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT36DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT36DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT36DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT36DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT36DD.Search(const Buff: TKDT36DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DD_Node;

var
  NearestNeighbour: PKDT36DD_Node;

  function FindParentNode(const BuffPtr: PKDT36DD_Vec; NodePtr: PKDT36DD_Node): PKDT36DD_Node;
  var
    Next       : PKDT36DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT36DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT36DD_Node; const BuffPtr: PKDT36DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT36DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT36DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT36DD_Vec; const p1, p2: PKDT36DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT36DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT36DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT36DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT36DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT36DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT36DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT36DD_Node(NearestNodes[0]);
    end;
end;

function TKDT36DD.Search(const Buff: TKDT36DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT36DD.Search(const Buff: TKDT36DD_Vec; var SearchedDistanceMin: Double): PKDT36DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT36DD.Search(const Buff: TKDT36DD_Vec): PKDT36DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT36DD.Search(const inBuff: TKDT36DD_DynamicVecBuffer; var OutBuff: TKDT36DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT36DD_DynamicVecBuffer;
  outBuffPtr : PKDT36DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT36DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT36DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT36DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT36DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT36DD_Source));
end;

procedure TKDT36DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT36DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT36DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT36DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT36DD.PrintNodeTree(const NodePtr: PKDT36DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT36DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT36DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT36DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT36DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT36DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT36DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT36DD.Test;
var
  TKDT36DD_Test    : TKDT36DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT36DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT36DD_Test := TKDT36DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT36DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT36DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT36DD_AxisCount - 1 do
        TKDT36DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT36DD_Test.TestBuff), length(TKDT36DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT36DD_Test.BuildKDTreeM(False, length(TKDT36DD_Test.TestBuff), @TKDT36DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT36DD_Test.BuildKDTreeM(False, length(TKDT36DD_Test.TestBuff), TKDT36DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT36DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT36DD_Test.TestBuff));
  TKDT36DD_Test.Search(TKDT36DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT36DDDistance(TKDT36DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT36DD_Test.Clear;
  { kMean test }
  TKDT36DD_Test.BuildKDTreeWithCluster(TKDT36DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT36DD_Test.Search(TKDT36DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT36DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT36DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT36DD_Test);
end;

{$ENDIF DEBUG}


function KDT40DDVec(const s: string): TKDT40DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT40DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT40DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT40DDVec(const v: TKDT40DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT40DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT40DDPow(const v: TKDT40DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT40DDDistance(const v1, v2: TKDT40DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT40DD_AxisCount - 1 do
      Result := Result + KDT40DDPow(v2[i] - v1[i]);
end;

function KDT40DDCmpare(const v1, v2: TKDT40DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT40DD_Vec));
end;

function TKDT40DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DD_Node;
  function SortCompare(const p1, p2: PKDT40DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT40DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT40DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT40DD_SourceBuffer;
  dynBuff  : PKDT40DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT40DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT40DD.SearchStoreBuff(const StoreBuffPtr: PKDT40DDyanmicStoreBuffer; const Buff: TKDT40DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT40DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT40DD.GetData(const index: NativeInt): PKDT40DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT40DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT40DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT40DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT40DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT40DD.StoreBuffPtr: PKDT40DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT40DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT40DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT40DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT40DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT40DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT40DD.BuildKDTreeWithCluster(const inBuff: TKDT40DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT40DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT40DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT40DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT40DD.BuildKDTreeWithCluster(const inBuff: TKDT40DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DD_BuildCall);
var
  TempStoreBuff: TKDT40DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DD_BuildMethod);
var
  TempStoreBuff: TKDT40DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DD_BuildProc);
var
  TempStoreBuff: TKDT40DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT40DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT40DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT40DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT40DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT40DD.Search(const Buff: TKDT40DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DD_Node;

var
  NearestNeighbour: PKDT40DD_Node;

  function FindParentNode(const BuffPtr: PKDT40DD_Vec; NodePtr: PKDT40DD_Node): PKDT40DD_Node;
  var
    Next       : PKDT40DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT40DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT40DD_Node; const BuffPtr: PKDT40DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT40DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT40DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT40DD_Vec; const p1, p2: PKDT40DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT40DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT40DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT40DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT40DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT40DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT40DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT40DD_Node(NearestNodes[0]);
    end;
end;

function TKDT40DD.Search(const Buff: TKDT40DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT40DD.Search(const Buff: TKDT40DD_Vec; var SearchedDistanceMin: Double): PKDT40DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT40DD.Search(const Buff: TKDT40DD_Vec): PKDT40DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT40DD.Search(const inBuff: TKDT40DD_DynamicVecBuffer; var OutBuff: TKDT40DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT40DD_DynamicVecBuffer;
  outBuffPtr : PKDT40DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT40DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT40DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT40DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT40DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT40DD_Source));
end;

procedure TKDT40DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT40DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT40DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT40DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT40DD.PrintNodeTree(const NodePtr: PKDT40DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT40DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT40DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT40DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT40DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT40DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT40DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT40DD.Test;
var
  TKDT40DD_Test    : TKDT40DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT40DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT40DD_Test := TKDT40DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT40DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT40DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT40DD_AxisCount - 1 do
        TKDT40DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT40DD_Test.TestBuff), length(TKDT40DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT40DD_Test.BuildKDTreeM(False, length(TKDT40DD_Test.TestBuff), @TKDT40DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT40DD_Test.BuildKDTreeM(False, length(TKDT40DD_Test.TestBuff), TKDT40DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT40DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT40DD_Test.TestBuff));
  TKDT40DD_Test.Search(TKDT40DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT40DDDistance(TKDT40DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT40DD_Test.Clear;
  { kMean test }
  TKDT40DD_Test.BuildKDTreeWithCluster(TKDT40DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT40DD_Test.Search(TKDT40DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT40DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT40DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT40DD_Test);
end;

{$ENDIF DEBUG}


function KDT48DDVec(const s: string): TKDT48DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT48DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT48DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT48DDVec(const v: TKDT48DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT48DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT48DDPow(const v: TKDT48DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT48DDDistance(const v1, v2: TKDT48DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT48DD_AxisCount - 1 do
      Result := Result + KDT48DDPow(v2[i] - v1[i]);
end;

function KDT48DDCmpare(const v1, v2: TKDT48DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT48DD_Vec));
end;

function TKDT48DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DD_Node;
  function SortCompare(const p1, p2: PKDT48DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT48DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT48DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT48DD_SourceBuffer;
  dynBuff  : PKDT48DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT48DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT48DD.SearchStoreBuff(const StoreBuffPtr: PKDT48DDyanmicStoreBuffer; const Buff: TKDT48DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT48DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT48DD.GetData(const index: NativeInt): PKDT48DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT48DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT48DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT48DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT48DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT48DD.StoreBuffPtr: PKDT48DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT48DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT48DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT48DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT48DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT48DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT48DD.BuildKDTreeWithCluster(const inBuff: TKDT48DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT48DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT48DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT48DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT48DD.BuildKDTreeWithCluster(const inBuff: TKDT48DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DD_BuildCall);
var
  TempStoreBuff: TKDT48DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DD_BuildMethod);
var
  TempStoreBuff: TKDT48DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DD_BuildProc);
var
  TempStoreBuff: TKDT48DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT48DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT48DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT48DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT48DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT48DD.Search(const Buff: TKDT48DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DD_Node;

var
  NearestNeighbour: PKDT48DD_Node;

  function FindParentNode(const BuffPtr: PKDT48DD_Vec; NodePtr: PKDT48DD_Node): PKDT48DD_Node;
  var
    Next       : PKDT48DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT48DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT48DD_Node; const BuffPtr: PKDT48DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT48DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT48DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT48DD_Vec; const p1, p2: PKDT48DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT48DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT48DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT48DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT48DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT48DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT48DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT48DD_Node(NearestNodes[0]);
    end;
end;

function TKDT48DD.Search(const Buff: TKDT48DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT48DD.Search(const Buff: TKDT48DD_Vec; var SearchedDistanceMin: Double): PKDT48DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT48DD.Search(const Buff: TKDT48DD_Vec): PKDT48DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT48DD.Search(const inBuff: TKDT48DD_DynamicVecBuffer; var OutBuff: TKDT48DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT48DD_DynamicVecBuffer;
  outBuffPtr : PKDT48DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT48DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT48DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT48DD_Source));
end;

procedure TKDT48DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT48DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT48DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT48DD.PrintNodeTree(const NodePtr: PKDT48DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT48DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT48DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT48DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT48DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT48DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT48DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT48DD.Test;
var
  TKDT48DD_Test    : TKDT48DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT48DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT48DD_Test := TKDT48DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT48DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT48DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT48DD_AxisCount - 1 do
        TKDT48DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT48DD_Test.TestBuff), length(TKDT48DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT48DD_Test.BuildKDTreeM(False, length(TKDT48DD_Test.TestBuff), @TKDT48DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT48DD_Test.BuildKDTreeM(False, length(TKDT48DD_Test.TestBuff), TKDT48DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT48DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT48DD_Test.TestBuff));
  TKDT48DD_Test.Search(TKDT48DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT48DDDistance(TKDT48DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT48DD_Test.Clear;
  { kMean test }
  TKDT48DD_Test.BuildKDTreeWithCluster(TKDT48DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT48DD_Test.Search(TKDT48DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT48DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT48DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT48DD_Test);
end;

{$ENDIF DEBUG}


function KDT64DDVec(const s: string): TKDT64DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT64DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT64DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT64DDVec(const v: TKDT64DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT64DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT64DDPow(const v: TKDT64DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT64DDDistance(const v1, v2: TKDT64DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT64DD_AxisCount - 1 do
      Result := Result + KDT64DDPow(v2[i] - v1[i]);
end;

function KDT64DDCmpare(const v1, v2: TKDT64DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT64DD_Vec));
end;

function TKDT64DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DD_Node;
  function SortCompare(const p1, p2: PKDT64DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT64DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT64DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT64DD_SourceBuffer;
  dynBuff  : PKDT64DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT64DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT64DD.SearchStoreBuff(const StoreBuffPtr: PKDT64DDyanmicStoreBuffer; const Buff: TKDT64DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT64DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT64DD.GetData(const index: NativeInt): PKDT64DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT64DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT64DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT64DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT64DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT64DD.StoreBuffPtr: PKDT64DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT64DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT64DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT64DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT64DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT64DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT64DD.BuildKDTreeWithCluster(const inBuff: TKDT64DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT64DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT64DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT64DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT64DD.BuildKDTreeWithCluster(const inBuff: TKDT64DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DD_BuildCall);
var
  TempStoreBuff: TKDT64DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DD_BuildMethod);
var
  TempStoreBuff: TKDT64DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DD_BuildProc);
var
  TempStoreBuff: TKDT64DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT64DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT64DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT64DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT64DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT64DD.Search(const Buff: TKDT64DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DD_Node;

var
  NearestNeighbour: PKDT64DD_Node;

  function FindParentNode(const BuffPtr: PKDT64DD_Vec; NodePtr: PKDT64DD_Node): PKDT64DD_Node;
  var
    Next       : PKDT64DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT64DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT64DD_Node; const BuffPtr: PKDT64DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT64DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT64DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT64DD_Vec; const p1, p2: PKDT64DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT64DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT64DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT64DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT64DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT64DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT64DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT64DD_Node(NearestNodes[0]);
    end;
end;

function TKDT64DD.Search(const Buff: TKDT64DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT64DD.Search(const Buff: TKDT64DD_Vec; var SearchedDistanceMin: Double): PKDT64DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT64DD.Search(const Buff: TKDT64DD_Vec): PKDT64DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT64DD.Search(const inBuff: TKDT64DD_DynamicVecBuffer; var OutBuff: TKDT64DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT64DD_DynamicVecBuffer;
  outBuffPtr : PKDT64DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT64DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT64DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT64DD_Source));
end;

procedure TKDT64DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT64DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT64DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT64DD.PrintNodeTree(const NodePtr: PKDT64DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT64DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT64DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT64DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT64DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT64DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT64DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT64DD.Test;
var
  TKDT64DD_Test    : TKDT64DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT64DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT64DD_Test := TKDT64DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT64DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT64DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT64DD_AxisCount - 1 do
        TKDT64DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT64DD_Test.TestBuff), length(TKDT64DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT64DD_Test.BuildKDTreeM(False, length(TKDT64DD_Test.TestBuff), @TKDT64DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT64DD_Test.BuildKDTreeM(False, length(TKDT64DD_Test.TestBuff), TKDT64DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT64DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT64DD_Test.TestBuff));
  TKDT64DD_Test.Search(TKDT64DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT64DDDistance(TKDT64DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT64DD_Test.Clear;
  { kMean test }
  TKDT64DD_Test.BuildKDTreeWithCluster(TKDT64DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT64DD_Test.Search(TKDT64DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT64DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT64DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT64DD_Test);
end;

{$ENDIF DEBUG}


function KDT96DDVec(const s: string): TKDT96DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT96DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT96DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT96DDVec(const v: TKDT96DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT96DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT96DDPow(const v: TKDT96DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT96DDDistance(const v1, v2: TKDT96DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT96DD_AxisCount - 1 do
      Result := Result + KDT96DDPow(v2[i] - v1[i]);
end;

function KDT96DDCmpare(const v1, v2: TKDT96DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT96DD_Vec));
end;

function TKDT96DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DD_Node;
  function SortCompare(const p1, p2: PKDT96DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT96DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT96DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT96DD_SourceBuffer;
  dynBuff  : PKDT96DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT96DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT96DD.SearchStoreBuff(const StoreBuffPtr: PKDT96DDyanmicStoreBuffer; const Buff: TKDT96DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT96DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT96DD.GetData(const index: NativeInt): PKDT96DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT96DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT96DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT96DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT96DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT96DD.StoreBuffPtr: PKDT96DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT96DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT96DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT96DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT96DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT96DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT96DD.BuildKDTreeWithCluster(const inBuff: TKDT96DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT96DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT96DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT96DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT96DD.BuildKDTreeWithCluster(const inBuff: TKDT96DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DD_BuildCall);
var
  TempStoreBuff: TKDT96DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DD_BuildMethod);
var
  TempStoreBuff: TKDT96DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DD_BuildProc);
var
  TempStoreBuff: TKDT96DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT96DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT96DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT96DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT96DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT96DD.Search(const Buff: TKDT96DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DD_Node;

var
  NearestNeighbour: PKDT96DD_Node;

  function FindParentNode(const BuffPtr: PKDT96DD_Vec; NodePtr: PKDT96DD_Node): PKDT96DD_Node;
  var
    Next       : PKDT96DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT96DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT96DD_Node; const BuffPtr: PKDT96DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT96DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT96DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT96DD_Vec; const p1, p2: PKDT96DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT96DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT96DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT96DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT96DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT96DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT96DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT96DD_Node(NearestNodes[0]);
    end;
end;

function TKDT96DD.Search(const Buff: TKDT96DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT96DD.Search(const Buff: TKDT96DD_Vec; var SearchedDistanceMin: Double): PKDT96DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT96DD.Search(const Buff: TKDT96DD_Vec): PKDT96DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT96DD.Search(const inBuff: TKDT96DD_DynamicVecBuffer; var OutBuff: TKDT96DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT96DD_DynamicVecBuffer;
  outBuffPtr : PKDT96DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT96DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT96DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT96DD_Source));
end;

procedure TKDT96DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT96DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT96DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT96DD.PrintNodeTree(const NodePtr: PKDT96DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT96DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT96DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT96DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT96DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT96DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT96DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT96DD.Test;
var
  TKDT96DD_Test    : TKDT96DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT96DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT96DD_Test := TKDT96DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT96DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT96DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT96DD_AxisCount - 1 do
        TKDT96DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT96DD_Test.TestBuff), length(TKDT96DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT96DD_Test.BuildKDTreeM(False, length(TKDT96DD_Test.TestBuff), @TKDT96DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT96DD_Test.BuildKDTreeM(False, length(TKDT96DD_Test.TestBuff), TKDT96DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT96DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT96DD_Test.TestBuff));
  TKDT96DD_Test.Search(TKDT96DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT96DDDistance(TKDT96DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT96DD_Test.Clear;
  { kMean test }
  TKDT96DD_Test.BuildKDTreeWithCluster(TKDT96DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT96DD_Test.Search(TKDT96DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT96DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT96DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT96DD_Test);
end;

{$ENDIF DEBUG}


function KDT128DDVec(const s: string): TKDT128DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT128DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT128DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT128DDVec(const v: TKDT128DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT128DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT128DDPow(const v: TKDT128DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT128DDDistance(const v1, v2: TKDT128DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT128DD_AxisCount - 1 do
      Result := Result + KDT128DDPow(v2[i] - v1[i]);
end;

function KDT128DDCmpare(const v1, v2: TKDT128DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT128DD_Vec));
end;

function TKDT128DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DD_Node;
  function SortCompare(const p1, p2: PKDT128DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT128DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT128DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT128DD_SourceBuffer;
  dynBuff  : PKDT128DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT128DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT128DD.SearchStoreBuff(const StoreBuffPtr: PKDT128DDyanmicStoreBuffer; const Buff: TKDT128DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT128DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT128DD.GetData(const index: NativeInt): PKDT128DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT128DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT128DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT128DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT128DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT128DD.StoreBuffPtr: PKDT128DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT128DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT128DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT128DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT128DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT128DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT128DD.BuildKDTreeWithCluster(const inBuff: TKDT128DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT128DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT128DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT128DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT128DD.BuildKDTreeWithCluster(const inBuff: TKDT128DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DD_BuildCall);
var
  TempStoreBuff: TKDT128DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DD_BuildMethod);
var
  TempStoreBuff: TKDT128DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DD_BuildProc);
var
  TempStoreBuff: TKDT128DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT128DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT128DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT128DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT128DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT128DD.Search(const Buff: TKDT128DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DD_Node;

var
  NearestNeighbour: PKDT128DD_Node;

  function FindParentNode(const BuffPtr: PKDT128DD_Vec; NodePtr: PKDT128DD_Node): PKDT128DD_Node;
  var
    Next       : PKDT128DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT128DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT128DD_Node; const BuffPtr: PKDT128DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT128DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT128DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT128DD_Vec; const p1, p2: PKDT128DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT128DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT128DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT128DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT128DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT128DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT128DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT128DD_Node(NearestNodes[0]);
    end;
end;

function TKDT128DD.Search(const Buff: TKDT128DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT128DD.Search(const Buff: TKDT128DD_Vec; var SearchedDistanceMin: Double): PKDT128DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT128DD.Search(const Buff: TKDT128DD_Vec): PKDT128DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT128DD.Search(const inBuff: TKDT128DD_DynamicVecBuffer; var OutBuff: TKDT128DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT128DD_DynamicVecBuffer;
  outBuffPtr : PKDT128DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT128DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT128DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT128DD_Source));
end;

procedure TKDT128DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT128DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT128DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT128DD.PrintNodeTree(const NodePtr: PKDT128DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT128DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT128DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT128DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT128DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT128DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT128DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT128DD.Test;
var
  TKDT128DD_Test    : TKDT128DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT128DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT128DD_Test := TKDT128DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT128DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT128DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT128DD_AxisCount - 1 do
        TKDT128DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT128DD_Test.TestBuff), length(TKDT128DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT128DD_Test.BuildKDTreeM(False, length(TKDT128DD_Test.TestBuff), @TKDT128DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT128DD_Test.BuildKDTreeM(False, length(TKDT128DD_Test.TestBuff), TKDT128DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT128DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT128DD_Test.TestBuff));
  TKDT128DD_Test.Search(TKDT128DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT128DDDistance(TKDT128DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT128DD_Test.Clear;
  { kMean test }
  TKDT128DD_Test.BuildKDTreeWithCluster(TKDT128DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT128DD_Test.Search(TKDT128DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT128DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT128DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT128DD_Test);
end;

{$ENDIF DEBUG}


function KDT256DDVec(const s: string): TKDT256DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT256DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT256DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT256DDVec(const v: TKDT256DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT256DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT256DDPow(const v: TKDT256DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT256DDDistance(const v1, v2: TKDT256DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT256DD_AxisCount - 1 do
      Result := Result + KDT256DDPow(v2[i] - v1[i]);
end;

function KDT256DDCmpare(const v1, v2: TKDT256DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT256DD_Vec));
end;

function TKDT256DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DD_Node;
  function SortCompare(const p1, p2: PKDT256DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT256DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT256DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT256DD_SourceBuffer;
  dynBuff  : PKDT256DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT256DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT256DD.SearchStoreBuff(const StoreBuffPtr: PKDT256DDyanmicStoreBuffer; const Buff: TKDT256DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT256DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT256DD.GetData(const index: NativeInt): PKDT256DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT256DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT256DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT256DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT256DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT256DD.StoreBuffPtr: PKDT256DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT256DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT256DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT256DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT256DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT256DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT256DD.BuildKDTreeWithCluster(const inBuff: TKDT256DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT256DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT256DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT256DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT256DD.BuildKDTreeWithCluster(const inBuff: TKDT256DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DD_BuildCall);
var
  TempStoreBuff: TKDT256DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DD_BuildMethod);
var
  TempStoreBuff: TKDT256DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DD_BuildProc);
var
  TempStoreBuff: TKDT256DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT256DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT256DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT256DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT256DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT256DD.Search(const Buff: TKDT256DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DD_Node;

var
  NearestNeighbour: PKDT256DD_Node;

  function FindParentNode(const BuffPtr: PKDT256DD_Vec; NodePtr: PKDT256DD_Node): PKDT256DD_Node;
  var
    Next       : PKDT256DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT256DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT256DD_Node; const BuffPtr: PKDT256DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT256DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT256DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT256DD_Vec; const p1, p2: PKDT256DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT256DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT256DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT256DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT256DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT256DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT256DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT256DD_Node(NearestNodes[0]);
    end;
end;

function TKDT256DD.Search(const Buff: TKDT256DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT256DD.Search(const Buff: TKDT256DD_Vec; var SearchedDistanceMin: Double): PKDT256DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT256DD.Search(const Buff: TKDT256DD_Vec): PKDT256DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT256DD.Search(const inBuff: TKDT256DD_DynamicVecBuffer; var OutBuff: TKDT256DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT256DD_DynamicVecBuffer;
  outBuffPtr : PKDT256DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT256DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT256DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT256DD_Source));
end;

procedure TKDT256DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT256DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT256DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT256DD.PrintNodeTree(const NodePtr: PKDT256DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT256DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT256DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT256DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT256DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT256DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT256DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT256DD.Test;
var
  TKDT256DD_Test    : TKDT256DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT256DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT256DD_Test := TKDT256DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT256DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT256DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT256DD_AxisCount - 1 do
        TKDT256DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT256DD_Test.TestBuff), length(TKDT256DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT256DD_Test.BuildKDTreeM(False, length(TKDT256DD_Test.TestBuff), @TKDT256DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT256DD_Test.BuildKDTreeM(False, length(TKDT256DD_Test.TestBuff), TKDT256DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT256DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT256DD_Test.TestBuff));
  TKDT256DD_Test.Search(TKDT256DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT256DDDistance(TKDT256DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT256DD_Test.Clear;
  { kMean test }
  TKDT256DD_Test.BuildKDTreeWithCluster(TKDT256DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT256DD_Test.Search(TKDT256DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT256DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT256DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT256DD_Test);
end;

{$ENDIF DEBUG}


function KDT372DDVec(const s: string): TKDT372DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT372DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT372DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT372DDVec(const v: TKDT372DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT372DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT372DDPow(const v: TKDT372DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT372DDDistance(const v1, v2: TKDT372DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT372DD_AxisCount - 1 do
      Result := Result + KDT372DDPow(v2[i] - v1[i]);
end;

function KDT372DDCmpare(const v1, v2: TKDT372DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT372DD_Vec));
end;

function TKDT372DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DD_Node;
  function SortCompare(const p1, p2: PKDT372DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT372DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT372DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT372DD_SourceBuffer;
  dynBuff  : PKDT372DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT372DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT372DD.SearchStoreBuff(const StoreBuffPtr: PKDT372DDyanmicStoreBuffer; const Buff: TKDT372DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT372DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT372DD.GetData(const index: NativeInt): PKDT372DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT372DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT372DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT372DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT372DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT372DD.StoreBuffPtr: PKDT372DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT372DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT372DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT372DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT372DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT372DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT372DD.BuildKDTreeWithCluster(const inBuff: TKDT372DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT372DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT372DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT372DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT372DD.BuildKDTreeWithCluster(const inBuff: TKDT372DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DD_BuildCall);
var
  TempStoreBuff: TKDT372DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DD_BuildMethod);
var
  TempStoreBuff: TKDT372DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DD_BuildProc);
var
  TempStoreBuff: TKDT372DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT372DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT372DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT372DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT372DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT372DD.Search(const Buff: TKDT372DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DD_Node;

var
  NearestNeighbour: PKDT372DD_Node;

  function FindParentNode(const BuffPtr: PKDT372DD_Vec; NodePtr: PKDT372DD_Node): PKDT372DD_Node;
  var
    Next       : PKDT372DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT372DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT372DD_Node; const BuffPtr: PKDT372DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT372DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT372DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT372DD_Vec; const p1, p2: PKDT372DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT372DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT372DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT372DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT372DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT372DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT372DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT372DD_Node(NearestNodes[0]);
    end;
end;

function TKDT372DD.Search(const Buff: TKDT372DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT372DD.Search(const Buff: TKDT372DD_Vec; var SearchedDistanceMin: Double): PKDT372DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT372DD.Search(const Buff: TKDT372DD_Vec): PKDT372DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT372DD.Search(const inBuff: TKDT372DD_DynamicVecBuffer; var OutBuff: TKDT372DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT372DD_DynamicVecBuffer;
  outBuffPtr : PKDT372DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT372DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT372DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT372DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT372DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT372DD_Source));
end;

procedure TKDT372DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT372DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT372DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT372DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT372DD.PrintNodeTree(const NodePtr: PKDT372DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT372DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT372DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT372DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT372DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT372DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT372DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT372DD.Test;
var
  TKDT372DD_Test    : TKDT372DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT372DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT372DD_Test := TKDT372DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT372DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT372DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT372DD_AxisCount - 1 do
        TKDT372DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT372DD_Test.TestBuff), length(TKDT372DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT372DD_Test.BuildKDTreeM(False, length(TKDT372DD_Test.TestBuff), @TKDT372DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT372DD_Test.BuildKDTreeM(False, length(TKDT372DD_Test.TestBuff), TKDT372DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT372DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT372DD_Test.TestBuff));
  TKDT372DD_Test.Search(TKDT372DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT372DDDistance(TKDT372DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT372DD_Test.Clear;
  { kMean test }
  TKDT372DD_Test.BuildKDTreeWithCluster(TKDT372DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT372DD_Test.Search(TKDT372DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT372DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT372DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT372DD_Test);
end;

{$ENDIF DEBUG}


function KDT512DDVec(const s: string): TKDT512DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT512DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT512DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT512DDVec(const v: TKDT512DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT512DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT512DDPow(const v: TKDT512DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT512DDDistance(const v1, v2: TKDT512DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT512DD_AxisCount - 1 do
      Result := Result + KDT512DDPow(v2[i] - v1[i]);
end;

function KDT512DDCmpare(const v1, v2: TKDT512DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT512DD_Vec));
end;

function TKDT512DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DD_Node;
  function SortCompare(const p1, p2: PKDT512DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT512DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT512DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT512DD_SourceBuffer;
  dynBuff  : PKDT512DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT512DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT512DD.SearchStoreBuff(const StoreBuffPtr: PKDT512DDyanmicStoreBuffer; const Buff: TKDT512DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT512DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT512DD.GetData(const index: NativeInt): PKDT512DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT512DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT512DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT512DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT512DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT512DD.StoreBuffPtr: PKDT512DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT512DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT512DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT512DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT512DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT512DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT512DD.BuildKDTreeWithCluster(const inBuff: TKDT512DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT512DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT512DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT512DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT512DD.BuildKDTreeWithCluster(const inBuff: TKDT512DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DD_BuildCall);
var
  TempStoreBuff: TKDT512DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DD_BuildMethod);
var
  TempStoreBuff: TKDT512DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DD_BuildProc);
var
  TempStoreBuff: TKDT512DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT512DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT512DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT512DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT512DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT512DD.Search(const Buff: TKDT512DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DD_Node;

var
  NearestNeighbour: PKDT512DD_Node;

  function FindParentNode(const BuffPtr: PKDT512DD_Vec; NodePtr: PKDT512DD_Node): PKDT512DD_Node;
  var
    Next       : PKDT512DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT512DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT512DD_Node; const BuffPtr: PKDT512DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT512DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT512DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT512DD_Vec; const p1, p2: PKDT512DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT512DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT512DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT512DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT512DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT512DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT512DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT512DD_Node(NearestNodes[0]);
    end;
end;

function TKDT512DD.Search(const Buff: TKDT512DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT512DD.Search(const Buff: TKDT512DD_Vec; var SearchedDistanceMin: Double): PKDT512DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT512DD.Search(const Buff: TKDT512DD_Vec): PKDT512DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT512DD.Search(const inBuff: TKDT512DD_DynamicVecBuffer; var OutBuff: TKDT512DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT512DD_DynamicVecBuffer;
  outBuffPtr : PKDT512DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT512DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT512DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT512DD_Source));
end;

procedure TKDT512DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT512DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT512DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT512DD.PrintNodeTree(const NodePtr: PKDT512DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT512DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT512DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT512DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT512DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT512DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT512DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT512DD.Test;
var
  TKDT512DD_Test    : TKDT512DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT512DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT512DD_Test := TKDT512DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT512DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT512DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT512DD_AxisCount - 1 do
        TKDT512DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT512DD_Test.TestBuff), length(TKDT512DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT512DD_Test.BuildKDTreeM(False, length(TKDT512DD_Test.TestBuff), @TKDT512DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT512DD_Test.BuildKDTreeM(False, length(TKDT512DD_Test.TestBuff), TKDT512DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT512DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT512DD_Test.TestBuff));
  TKDT512DD_Test.Search(TKDT512DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT512DDDistance(TKDT512DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT512DD_Test.Clear;
  { kMean test }
  TKDT512DD_Test.BuildKDTreeWithCluster(TKDT512DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT512DD_Test.Search(TKDT512DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT512DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT512DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT512DD_Test);
end;

{$ENDIF DEBUG}


function KDT640DDVec(const s: string): TKDT640DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT640DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT640DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT640DDVec(const v: TKDT640DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT640DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT640DDPow(const v: TKDT640DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT640DDDistance(const v1, v2: TKDT640DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT640DD_AxisCount - 1 do
      Result := Result + KDT640DDPow(v2[i] - v1[i]);
end;

function KDT640DDCmpare(const v1, v2: TKDT640DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT640DD_Vec));
end;

function TKDT640DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT640DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT640DD_Node;
  function SortCompare(const p1, p2: PKDT640DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT640DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT640DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT640DD_SourceBuffer;
  dynBuff  : PKDT640DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT640DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT640DD.SearchStoreBuff(const StoreBuffPtr: PKDT640DDyanmicStoreBuffer; const Buff: TKDT640DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT640DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT640DD.GetData(const index: NativeInt): PKDT640DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT640DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT640DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT640DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT640DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT640DD.StoreBuffPtr: PKDT640DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT640DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT640DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT640DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT640DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT640DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT640DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT640DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT640DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT640DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT640DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT640DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT640DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT640DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT640DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT640DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT640DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT640DD.BuildKDTreeWithCluster(const inBuff: TKDT640DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT640DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT640DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT640DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT640DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT640DD.BuildKDTreeWithCluster(const inBuff: TKDT640DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT640DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DD_BuildCall);
var
  TempStoreBuff: TKDT640DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT640DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT640DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT640DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT640DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT640DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT640DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT640DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DD_BuildMethod);
var
  TempStoreBuff: TKDT640DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT640DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT640DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT640DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT640DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT640DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT640DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT640DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT640DD_BuildProc);
var
  TempStoreBuff: TKDT640DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT640DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT640DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT640DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT640DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT640DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT640DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT640DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT640DD.Search(const Buff: TKDT640DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT640DD_Node;

var
  NearestNeighbour: PKDT640DD_Node;

  function FindParentNode(const BuffPtr: PKDT640DD_Vec; NodePtr: PKDT640DD_Node): PKDT640DD_Node;
  var
    Next       : PKDT640DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT640DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT640DD_Node; const BuffPtr: PKDT640DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT640DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT640DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT640DD_Vec; const p1, p2: PKDT640DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT640DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT640DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT640DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT640DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT640DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT640DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT640DD_Node(NearestNodes[0]);
    end;
end;

function TKDT640DD.Search(const Buff: TKDT640DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT640DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT640DD.Search(const Buff: TKDT640DD_Vec; var SearchedDistanceMin: Double): PKDT640DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT640DD.Search(const Buff: TKDT640DD_Vec): PKDT640DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT640DD.Search(const inBuff: TKDT640DD_DynamicVecBuffer; var OutBuff: TKDT640DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT640DD_DynamicVecBuffer;
  outBuffPtr : PKDT640DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT640DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT640DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT640DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT640DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT640DD_Source));
end;

procedure TKDT640DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT640DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT640DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT640DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT640DD.PrintNodeTree(const NodePtr: PKDT640DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT640DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT640DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT640DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT640DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT640DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT640DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT640DD.Test;
var
  TKDT640DD_Test    : TKDT640DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT640DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT640DD_Test := TKDT640DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT640DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT640DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT640DD_AxisCount - 1 do
        TKDT640DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT640DD_Test.TestBuff), length(TKDT640DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT640DD_Test.BuildKDTreeM(False, length(TKDT640DD_Test.TestBuff), @TKDT640DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT640DD_Test.BuildKDTreeM(False, length(TKDT640DD_Test.TestBuff), TKDT640DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT640DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT640DD_Test.TestBuff));
  TKDT640DD_Test.Search(TKDT640DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT640DDDistance(TKDT640DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT640DD_Test.Clear;
  { kMean test }
  TKDT640DD_Test.BuildKDTreeWithCluster(TKDT640DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT640DD_Test.Search(TKDT640DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT640DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT640DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT640DD_Test);
end;

{$ENDIF DEBUG}


function KDT768DDVec(const s: string): TKDT768DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT768DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT768DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT768DDVec(const v: TKDT768DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT768DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT768DDPow(const v: TKDT768DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT768DDDistance(const v1, v2: TKDT768DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT768DD_AxisCount - 1 do
      Result := Result + KDT768DDPow(v2[i] - v1[i]);
end;

function KDT768DDCmpare(const v1, v2: TKDT768DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT768DD_Vec));
end;

function TKDT768DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DD_Node;
  function SortCompare(const p1, p2: PKDT768DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT768DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT768DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT768DD_SourceBuffer;
  dynBuff  : PKDT768DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT768DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT768DD.SearchStoreBuff(const StoreBuffPtr: PKDT768DDyanmicStoreBuffer; const Buff: TKDT768DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT768DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT768DD.GetData(const index: NativeInt): PKDT768DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT768DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT768DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT768DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT768DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT768DD.StoreBuffPtr: PKDT768DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT768DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT768DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT768DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT768DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT768DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT768DD.BuildKDTreeWithCluster(const inBuff: TKDT768DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT768DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT768DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT768DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT768DD.BuildKDTreeWithCluster(const inBuff: TKDT768DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DD_BuildCall);
var
  TempStoreBuff: TKDT768DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DD_BuildMethod);
var
  TempStoreBuff: TKDT768DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DD_BuildProc);
var
  TempStoreBuff: TKDT768DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT768DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT768DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT768DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT768DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT768DD.Search(const Buff: TKDT768DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DD_Node;

var
  NearestNeighbour: PKDT768DD_Node;

  function FindParentNode(const BuffPtr: PKDT768DD_Vec; NodePtr: PKDT768DD_Node): PKDT768DD_Node;
  var
    Next       : PKDT768DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT768DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT768DD_Node; const BuffPtr: PKDT768DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT768DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT768DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT768DD_Vec; const p1, p2: PKDT768DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT768DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT768DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT768DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT768DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT768DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT768DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT768DD_Node(NearestNodes[0]);
    end;
end;

function TKDT768DD.Search(const Buff: TKDT768DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT768DD.Search(const Buff: TKDT768DD_Vec; var SearchedDistanceMin: Double): PKDT768DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT768DD.Search(const Buff: TKDT768DD_Vec): PKDT768DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT768DD.Search(const inBuff: TKDT768DD_DynamicVecBuffer; var OutBuff: TKDT768DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT768DD_DynamicVecBuffer;
  outBuffPtr : PKDT768DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT768DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT768DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT768DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT768DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT768DD_Source));
end;

procedure TKDT768DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT768DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT768DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT768DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT768DD.PrintNodeTree(const NodePtr: PKDT768DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT768DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT768DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT768DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT768DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT768DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT768DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT768DD.Test;
var
  TKDT768DD_Test    : TKDT768DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT768DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT768DD_Test := TKDT768DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT768DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT768DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT768DD_AxisCount - 1 do
        TKDT768DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT768DD_Test.TestBuff), length(TKDT768DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT768DD_Test.BuildKDTreeM(False, length(TKDT768DD_Test.TestBuff), @TKDT768DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT768DD_Test.BuildKDTreeM(False, length(TKDT768DD_Test.TestBuff), TKDT768DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT768DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT768DD_Test.TestBuff));
  TKDT768DD_Test.Search(TKDT768DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT768DDDistance(TKDT768DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT768DD_Test.Clear;
  { kMean test }
  TKDT768DD_Test.BuildKDTreeWithCluster(TKDT768DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT768DD_Test.Search(TKDT768DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT768DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT768DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT768DD_Test);
end;

{$ENDIF DEBUG}


function KDT1024DDVec(const s: string): TKDT1024DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1024DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1024DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1024DDVec(const v: TKDT1024DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1024DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1024DDPow(const v: TKDT1024DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT1024DDDistance(const v1, v2: TKDT1024DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1024DD_AxisCount - 1 do
      Result := Result + KDT1024DDPow(v2[i] - v1[i]);
end;

function KDT1024DDCmpare(const v1, v2: TKDT1024DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1024DD_Vec));
end;

function TKDT1024DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DD_Node;
  function SortCompare(const p1, p2: PKDT1024DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1024DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1024DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1024DD_SourceBuffer;
  dynBuff  : PKDT1024DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1024DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1024DD.SearchStoreBuff(const StoreBuffPtr: PKDT1024DDyanmicStoreBuffer; const Buff: TKDT1024DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1024DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1024DD.GetData(const index: NativeInt): PKDT1024DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1024DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1024DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1024DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1024DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1024DD.StoreBuffPtr: PKDT1024DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1024DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1024DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1024DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1024DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1024DD.BuildKDTreeWithCluster(const inBuff: TKDT1024DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1024DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1024DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1024DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1024DD.BuildKDTreeWithCluster(const inBuff: TKDT1024DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DD_BuildCall);
var
  TempStoreBuff: TKDT1024DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DD_BuildMethod);
var
  TempStoreBuff: TKDT1024DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DD_BuildProc);
var
  TempStoreBuff: TKDT1024DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1024DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1024DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1024DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1024DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1024DD.Search(const Buff: TKDT1024DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DD_Node;

var
  NearestNeighbour: PKDT1024DD_Node;

  function FindParentNode(const BuffPtr: PKDT1024DD_Vec; NodePtr: PKDT1024DD_Node): PKDT1024DD_Node;
  var
    Next       : PKDT1024DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1024DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1024DD_Node; const BuffPtr: PKDT1024DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1024DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1024DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1024DD_Vec; const p1, p2: PKDT1024DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1024DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1024DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1024DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1024DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1024DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1024DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1024DD_Node(NearestNodes[0]);
    end;
end;

function TKDT1024DD.Search(const Buff: TKDT1024DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1024DD.Search(const Buff: TKDT1024DD_Vec; var SearchedDistanceMin: Double): PKDT1024DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1024DD.Search(const Buff: TKDT1024DD_Vec): PKDT1024DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1024DD.Search(const inBuff: TKDT1024DD_DynamicVecBuffer; var OutBuff: TKDT1024DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1024DD_DynamicVecBuffer;
  outBuffPtr : PKDT1024DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1024DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1024DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1024DD_Source));
end;

procedure TKDT1024DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1024DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1024DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1024DD.PrintNodeTree(const NodePtr: PKDT1024DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1024DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1024DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1024DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1024DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1024DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1024DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1024DD.Test;
var
  TKDT1024DD_Test    : TKDT1024DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1024DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1024DD_Test := TKDT1024DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1024DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT1024DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT1024DD_AxisCount - 1 do
        TKDT1024DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1024DD_Test.TestBuff), length(TKDT1024DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1024DD_Test.BuildKDTreeM(False, length(TKDT1024DD_Test.TestBuff), @TKDT1024DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1024DD_Test.BuildKDTreeM(False, length(TKDT1024DD_Test.TestBuff), TKDT1024DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1024DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1024DD_Test.TestBuff));
  TKDT1024DD_Test.Search(TKDT1024DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1024DDDistance(TKDT1024DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1024DD_Test.Clear;
  { kMean test }
  TKDT1024DD_Test.BuildKDTreeWithCluster(TKDT1024DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1024DD_Test.Search(TKDT1024DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1024DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1024DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1024DD_Test);
end;

{$ENDIF DEBUG}


function KDT1080DDVec(const s: string): TKDT1080DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1080DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1080DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1080DDVec(const v: TKDT1080DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1080DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1080DDPow(const v: TKDT1080DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT1080DDDistance(const v1, v2: TKDT1080DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1080DD_AxisCount - 1 do
      Result := Result + KDT1080DDPow(v2[i] - v1[i]);
end;

function KDT1080DDCmpare(const v1, v2: TKDT1080DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1080DD_Vec));
end;

function TKDT1080DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1080DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1080DD_Node;
  function SortCompare(const p1, p2: PKDT1080DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1080DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1080DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1080DD_SourceBuffer;
  dynBuff  : PKDT1080DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1080DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1080DD.SearchStoreBuff(const StoreBuffPtr: PKDT1080DDyanmicStoreBuffer; const Buff: TKDT1080DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1080DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1080DD.GetData(const index: NativeInt): PKDT1080DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1080DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1080DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1080DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1080DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1080DD.StoreBuffPtr: PKDT1080DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1080DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1080DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1080DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1080DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1080DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1080DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1080DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1080DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1080DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1080DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1080DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1080DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1080DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1080DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1080DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1080DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1080DD.BuildKDTreeWithCluster(const inBuff: TKDT1080DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1080DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1080DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1080DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1080DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1080DD.BuildKDTreeWithCluster(const inBuff: TKDT1080DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1080DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DD_BuildCall);
var
  TempStoreBuff: TKDT1080DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1080DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1080DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1080DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1080DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1080DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1080DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1080DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DD_BuildMethod);
var
  TempStoreBuff: TKDT1080DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1080DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1080DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1080DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1080DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1080DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1080DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1080DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1080DD_BuildProc);
var
  TempStoreBuff: TKDT1080DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1080DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1080DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1080DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1080DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1080DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1080DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1080DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1080DD.Search(const Buff: TKDT1080DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1080DD_Node;

var
  NearestNeighbour: PKDT1080DD_Node;

  function FindParentNode(const BuffPtr: PKDT1080DD_Vec; NodePtr: PKDT1080DD_Node): PKDT1080DD_Node;
  var
    Next       : PKDT1080DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1080DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1080DD_Node; const BuffPtr: PKDT1080DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1080DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1080DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1080DD_Vec; const p1, p2: PKDT1080DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1080DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1080DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1080DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1080DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1080DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1080DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1080DD_Node(NearestNodes[0]);
    end;
end;

function TKDT1080DD.Search(const Buff: TKDT1080DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1080DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1080DD.Search(const Buff: TKDT1080DD_Vec; var SearchedDistanceMin: Double): PKDT1080DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1080DD.Search(const Buff: TKDT1080DD_Vec): PKDT1080DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1080DD.Search(const inBuff: TKDT1080DD_DynamicVecBuffer; var OutBuff: TKDT1080DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1080DD_DynamicVecBuffer;
  outBuffPtr : PKDT1080DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1080DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1080DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1080DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1080DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1080DD_Source));
end;

procedure TKDT1080DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1080DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1080DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1080DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1080DD.PrintNodeTree(const NodePtr: PKDT1080DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1080DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1080DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1080DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1080DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1080DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1080DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1080DD.Test;
var
  TKDT1080DD_Test    : TKDT1080DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1080DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1080DD_Test := TKDT1080DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1080DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT1080DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT1080DD_AxisCount - 1 do
        TKDT1080DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1080DD_Test.TestBuff), length(TKDT1080DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1080DD_Test.BuildKDTreeM(False, length(TKDT1080DD_Test.TestBuff), @TKDT1080DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1080DD_Test.BuildKDTreeM(False, length(TKDT1080DD_Test.TestBuff), TKDT1080DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1080DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1080DD_Test.TestBuff));
  TKDT1080DD_Test.Search(TKDT1080DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1080DDDistance(TKDT1080DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1080DD_Test.Clear;
  { kMean test }
  TKDT1080DD_Test.BuildKDTreeWithCluster(TKDT1080DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1080DD_Test.Search(TKDT1080DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1080DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1080DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1080DD_Test);
end;

{$ENDIF DEBUG}


function KDT1536DDVec(const s: string): TKDT1536DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1536DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1536DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1536DDVec(const v: TKDT1536DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1536DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1536DDPow(const v: TKDT1536DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT1536DDDistance(const v1, v2: TKDT1536DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1536DD_AxisCount - 1 do
      Result := Result + KDT1536DDPow(v2[i] - v1[i]);
end;

function KDT1536DDCmpare(const v1, v2: TKDT1536DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1536DD_Vec));
end;

function TKDT1536DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DD_Node;
  function SortCompare(const p1, p2: PKDT1536DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1536DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1536DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1536DD_SourceBuffer;
  dynBuff  : PKDT1536DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1536DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1536DD.SearchStoreBuff(const StoreBuffPtr: PKDT1536DDyanmicStoreBuffer; const Buff: TKDT1536DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1536DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1536DD.GetData(const index: NativeInt): PKDT1536DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1536DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1536DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1536DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1536DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1536DD.StoreBuffPtr: PKDT1536DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1536DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1536DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1536DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1536DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1536DD.BuildKDTreeWithCluster(const inBuff: TKDT1536DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1536DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1536DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1536DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1536DD.BuildKDTreeWithCluster(const inBuff: TKDT1536DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DD_BuildCall);
var
  TempStoreBuff: TKDT1536DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DD_BuildMethod);
var
  TempStoreBuff: TKDT1536DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DD_BuildProc);
var
  TempStoreBuff: TKDT1536DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1536DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1536DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1536DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1536DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1536DD.Search(const Buff: TKDT1536DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DD_Node;

var
  NearestNeighbour: PKDT1536DD_Node;

  function FindParentNode(const BuffPtr: PKDT1536DD_Vec; NodePtr: PKDT1536DD_Node): PKDT1536DD_Node;
  var
    Next       : PKDT1536DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1536DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1536DD_Node; const BuffPtr: PKDT1536DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1536DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1536DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1536DD_Vec; const p1, p2: PKDT1536DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1536DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1536DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1536DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1536DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1536DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1536DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1536DD_Node(NearestNodes[0]);
    end;
end;

function TKDT1536DD.Search(const Buff: TKDT1536DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1536DD.Search(const Buff: TKDT1536DD_Vec; var SearchedDistanceMin: Double): PKDT1536DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1536DD.Search(const Buff: TKDT1536DD_Vec): PKDT1536DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1536DD.Search(const inBuff: TKDT1536DD_DynamicVecBuffer; var OutBuff: TKDT1536DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1536DD_DynamicVecBuffer;
  outBuffPtr : PKDT1536DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1536DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1536DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1536DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1536DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1536DD_Source));
end;

procedure TKDT1536DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1536DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1536DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1536DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1536DD.PrintNodeTree(const NodePtr: PKDT1536DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1536DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1536DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1536DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1536DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1536DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1536DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1536DD.Test;
var
  TKDT1536DD_Test    : TKDT1536DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1536DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1536DD_Test := TKDT1536DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1536DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT1536DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT1536DD_AxisCount - 1 do
        TKDT1536DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1536DD_Test.TestBuff), length(TKDT1536DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1536DD_Test.BuildKDTreeM(False, length(TKDT1536DD_Test.TestBuff), @TKDT1536DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1536DD_Test.BuildKDTreeM(False, length(TKDT1536DD_Test.TestBuff), TKDT1536DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1536DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1536DD_Test.TestBuff));
  TKDT1536DD_Test.Search(TKDT1536DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1536DDDistance(TKDT1536DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1536DD_Test.Clear;
  { kMean test }
  TKDT1536DD_Test.BuildKDTreeWithCluster(TKDT1536DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1536DD_Test.Search(TKDT1536DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1536DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1536DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1536DD_Test);
end;

{$ENDIF DEBUG}


function KDT1920DDVec(const s: string): TKDT1920DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT1920DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT1920DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT1920DDVec(const v: TKDT1920DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT1920DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT1920DDPow(const v: TKDT1920DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT1920DDDistance(const v1, v2: TKDT1920DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT1920DD_AxisCount - 1 do
      Result := Result + KDT1920DDPow(v2[i] - v1[i]);
end;

function KDT1920DDCmpare(const v1, v2: TKDT1920DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT1920DD_Vec));
end;

function TKDT1920DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DD_Node;
  function SortCompare(const p1, p2: PKDT1920DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1920DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1920DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1920DD_SourceBuffer;
  dynBuff  : PKDT1920DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT1920DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1920DD.SearchStoreBuff(const StoreBuffPtr: PKDT1920DDyanmicStoreBuffer; const Buff: TKDT1920DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT1920DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT1920DD.GetData(const index: NativeInt): PKDT1920DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1920DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1920DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1920DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1920DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1920DD.StoreBuffPtr: PKDT1920DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1920DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1920DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT1920DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT1920DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1920DD.BuildKDTreeWithCluster(const inBuff: TKDT1920DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT1920DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT1920DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT1920DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1920DD.BuildKDTreeWithCluster(const inBuff: TKDT1920DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DD_BuildCall);
var
  TempStoreBuff: TKDT1920DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DD_BuildMethod);
var
  TempStoreBuff: TKDT1920DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DD_BuildProc);
var
  TempStoreBuff: TKDT1920DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT1920DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT1920DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT1920DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT1920DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1920DD.Search(const Buff: TKDT1920DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DD_Node;

var
  NearestNeighbour: PKDT1920DD_Node;

  function FindParentNode(const BuffPtr: PKDT1920DD_Vec; NodePtr: PKDT1920DD_Node): PKDT1920DD_Node;
  var
    Next       : PKDT1920DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT1920DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1920DD_Node; const BuffPtr: PKDT1920DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1920DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT1920DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1920DD_Vec; const p1, p2: PKDT1920DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1920DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1920DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1920DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1920DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1920DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1920DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1920DD_Node(NearestNodes[0]);
    end;
end;

function TKDT1920DD.Search(const Buff: TKDT1920DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1920DD.Search(const Buff: TKDT1920DD_Vec; var SearchedDistanceMin: Double): PKDT1920DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1920DD.Search(const Buff: TKDT1920DD_Vec): PKDT1920DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1920DD.Search(const inBuff: TKDT1920DD_DynamicVecBuffer; var OutBuff: TKDT1920DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1920DD_DynamicVecBuffer;
  outBuffPtr : PKDT1920DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1920DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1920DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1920DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1920DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1920DD_Source));
end;

procedure TKDT1920DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1920DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1920DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1920DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT1920DD.PrintNodeTree(const NodePtr: PKDT1920DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1920DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1920DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1920DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1920DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT1920DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT1920DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1920DD.Test;
var
  TKDT1920DD_Test    : TKDT1920DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1920DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1920DD_Test := TKDT1920DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1920DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT1920DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT1920DD_AxisCount - 1 do
        TKDT1920DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1920DD_Test.TestBuff), length(TKDT1920DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1920DD_Test.BuildKDTreeM(False, length(TKDT1920DD_Test.TestBuff), @TKDT1920DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1920DD_Test.BuildKDTreeM(False, length(TKDT1920DD_Test.TestBuff), TKDT1920DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1920DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1920DD_Test.TestBuff));
  TKDT1920DD_Test.Search(TKDT1920DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1920DDDistance(TKDT1920DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1920DD_Test.Clear;
  { kMean test }
  TKDT1920DD_Test.BuildKDTreeWithCluster(TKDT1920DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1920DD_Test.Search(TKDT1920DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1920DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1920DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1920DD_Test);
end;

{$ENDIF DEBUG}


function KDT2048DDVec(const s: string): TKDT2048DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT2048DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT2048DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT2048DDVec(const v: TKDT2048DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT2048DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT2048DDPow(const v: TKDT2048DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT2048DDDistance(const v1, v2: TKDT2048DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT2048DD_AxisCount - 1 do
      Result := Result + KDT2048DDPow(v2[i] - v1[i]);
end;

function KDT2048DDCmpare(const v1, v2: TKDT2048DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT2048DD_Vec));
end;

function TKDT2048DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DD_Node;
  function SortCompare(const p1, p2: PKDT2048DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2048DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2048DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2048DD_SourceBuffer;
  dynBuff  : PKDT2048DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT2048DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2048DD.SearchStoreBuff(const StoreBuffPtr: PKDT2048DDyanmicStoreBuffer; const Buff: TKDT2048DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT2048DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT2048DD.GetData(const index: NativeInt): PKDT2048DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2048DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2048DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2048DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2048DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2048DD.StoreBuffPtr: PKDT2048DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2048DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2048DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT2048DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT2048DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2048DD.BuildKDTreeWithCluster(const inBuff: TKDT2048DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT2048DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT2048DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT2048DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2048DD.BuildKDTreeWithCluster(const inBuff: TKDT2048DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DD_BuildCall);
var
  TempStoreBuff: TKDT2048DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DD_BuildMethod);
var
  TempStoreBuff: TKDT2048DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DD_BuildProc);
var
  TempStoreBuff: TKDT2048DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT2048DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT2048DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT2048DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT2048DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT2048DD.Search(const Buff: TKDT2048DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DD_Node;

var
  NearestNeighbour: PKDT2048DD_Node;

  function FindParentNode(const BuffPtr: PKDT2048DD_Vec; NodePtr: PKDT2048DD_Node): PKDT2048DD_Node;
  var
    Next       : PKDT2048DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT2048DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2048DD_Node; const BuffPtr: PKDT2048DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2048DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT2048DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2048DD_Vec; const p1, p2: PKDT2048DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2048DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2048DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2048DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2048DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2048DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2048DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2048DD_Node(NearestNodes[0]);
    end;
end;

function TKDT2048DD.Search(const Buff: TKDT2048DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2048DD.Search(const Buff: TKDT2048DD_Vec; var SearchedDistanceMin: Double): PKDT2048DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2048DD.Search(const Buff: TKDT2048DD_Vec): PKDT2048DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2048DD.Search(const inBuff: TKDT2048DD_DynamicVecBuffer; var OutBuff: TKDT2048DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2048DD_DynamicVecBuffer;
  outBuffPtr : PKDT2048DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2048DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2048DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2048DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2048DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2048DD_Source));
end;

procedure TKDT2048DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2048DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2048DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2048DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT2048DD.PrintNodeTree(const NodePtr: PKDT2048DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2048DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2048DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2048DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2048DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT2048DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT2048DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2048DD.Test;
var
  TKDT2048DD_Test    : TKDT2048DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2048DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2048DD_Test := TKDT2048DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2048DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT2048DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT2048DD_AxisCount - 1 do
        TKDT2048DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT2048DD_Test.TestBuff), length(TKDT2048DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2048DD_Test.BuildKDTreeM(False, length(TKDT2048DD_Test.TestBuff), @TKDT2048DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2048DD_Test.BuildKDTreeM(False, length(TKDT2048DD_Test.TestBuff), TKDT2048DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2048DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2048DD_Test.TestBuff));
  TKDT2048DD_Test.Search(TKDT2048DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2048DDDistance(TKDT2048DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2048DD_Test.Clear;
  { kMean test }
  TKDT2048DD_Test.BuildKDTreeWithCluster(TKDT2048DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2048DD_Test.Search(TKDT2048DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2048DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2048DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2048DD_Test);
end;

{$ENDIF DEBUG}


function KDT3072DDVec(const s: string): TKDT3072DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to TKDT3072DD_AxisCount - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= TKDT3072DD_AxisCount then
                break;
          end;
    end;
  DisposeObject(t);
end;

function KDT3072DDVec(const v: TKDT3072DD_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to TKDT3072DD_AxisCount - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

function KDT3072DDPow(const v: TKDT3072DD_VecType): Double;
begin
  Result := v * v;
end;

function KDT3072DDDistance(const v1, v2: TKDT3072DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to TKDT3072DD_AxisCount - 1 do
      Result := Result + KDT3072DDPow(v2[i] - v1[i]);
end;

function KDT3072DDCmpare(const v1, v2: TKDT3072DD_Vec): Boolean;
begin
  Result := CompareMemory(@v1[0], @v2[0], SizeOf(TKDT3072DD_Vec));
end;

function TKDT3072DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DD_Node;
  function SortCompare(const p1, p2: PKDT3072DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3072DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3072DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3072DD_SourceBuffer;
  dynBuff  : PKDT3072DDyanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod TKDT3072DD_AxisCount;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3072DD.SearchStoreBuff(const StoreBuffPtr: PKDT3072DDyanmicStoreBuffer; const Buff: TKDT3072DD_Vec; const PlanCount: NativeInt): Boolean;
var
  i: NativeInt;
begin
  i := 0;
  while i < PlanCount do
    begin
      if KDT3072DDCmpare(StoreBuffPtr^[i].Buff, Buff) then
          Exit(True);
      inc(i);
    end;
  Result := False;
end;

function TKDT3072DD.GetData(const index: NativeInt): PKDT3072DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3072DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3072DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3072DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3072DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3072DD.StoreBuffPtr: PKDT3072DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3072DD.BuildKDTreeC(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DD_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3072DD.BuildKDTreeM(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DD_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DD.BuildKDTreeP(const ExcludeSame: Boolean; const PlanCount: NativeInt; const OnTrigger: TKDT3072DD_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DDyanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  if ExcludeSame then
    begin
      SetLength(TempStoreBuff, PlanCount);

      j := 0;
      i := 0;
      while i < PlanCount do
        begin
          TempStoreBuff[j].index := i;
          FillPtrByte(@TempStoreBuff[j].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
          OnTrigger(i, TempStoreBuff[j]);
          if not SearchStoreBuff(@TempStoreBuff, TempStoreBuff[j].Buff, j) then
              inc(j);
          inc(i);
        end;

      SetLength(KDStoreBuff, j);
      SetLength(KDBuff, j);
      SetLength(KDNodes, j);
      CopyPtr(@TempStoreBuff[0], @KDStoreBuff[0], j * SizeOf(TKDT3072DD_Source));
      SetLength(TempStoreBuff, 0);

      i := 0;
      while i < j do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          inc(i);
        end;
    end
  else
    begin
      SetLength(KDStoreBuff, PlanCount);
      SetLength(KDBuff, PlanCount);
      SetLength(KDNodes, PlanCount);

      i := 0;
      while i < PlanCount do
        begin
          KDBuff[i] := @KDStoreBuff[i];
          KDStoreBuff[i].index := i;
          FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
          OnTrigger(i, KDStoreBuff[i]);
          inc(i);
        end;

      j := PlanCount;
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3072DD.BuildKDTreeWithCluster(const inBuff: TKDT3072DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), TKDT3072DD_AxisCount);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to TKDT3072DD_AxisCount - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, TKDT3072DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3072DD.BuildKDTreeWithCluster(const inBuff: TKDT3072DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DD_BuildCall);
var
  TempStoreBuff: TKDT3072DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DD_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DD_BuildMethod);
var
  TempStoreBuff: TKDT3072DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DD_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DD_BuildProc);
var
  TempStoreBuff: TKDT3072DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), TKDT3072DD_AxisCount);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to TKDT3072DD_AxisCount - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, TKDT3072DD_AxisCount, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to TKDT3072DD_AxisCount - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DD_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3072DD.Search(const Buff: TKDT3072DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DD_Node;

var
  NearestNeighbour: PKDT3072DD_Node;

  function FindParentNode(const BuffPtr: PKDT3072DD_Vec; NodePtr: PKDT3072DD_Node): PKDT3072DD_Node;
  var
    Next       : PKDT3072DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod TKDT3072DD_AxisCount;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3072DD_Node; const BuffPtr: PKDT3072DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3072DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod TKDT3072DD_AxisCount;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3072DD_Vec; const p1, p2: PKDT3072DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3072DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3072DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3072DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3072DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3072DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3072DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3072DD_Node(NearestNodes[0]);
    end;
end;

function TKDT3072DD.Search(const Buff: TKDT3072DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3072DD.Search(const Buff: TKDT3072DD_Vec; var SearchedDistanceMin: Double): PKDT3072DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3072DD.Search(const Buff: TKDT3072DD_Vec): PKDT3072DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3072DD.Search(const inBuff: TKDT3072DD_DynamicVecBuffer; var OutBuff: TKDT3072DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3072DD_DynamicVecBuffer;
  outBuffPtr : PKDT3072DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3072DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3072DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3072DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3072DD.SaveToStream(stream: TCoreClassStream);
var
  cnt: Int64;
begin
  cnt := length(KDStoreBuff);
  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3072DD_Source));
end;

procedure TKDT3072DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt: Int64;
  i  : NativeInt;
begin
  Clear;

  stream.Read(cnt, 8);
  SetLength(KDStoreBuff, cnt);
  stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3072DD_Source));

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3072DD.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3072DD.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

{$IFDEF DEBUG}


procedure TKDT3072DD.PrintNodeTree(const NodePtr: PKDT3072DD_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3072DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3072DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3072DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3072DDVec(KDStoreBuff[i].Buff)]);
end;

procedure TKDT3072DD.Test_BuildM(IndexFor: NativeInt; var Source: TKDT3072DD_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3072DD.Test;
var
  TKDT3072DD_Test    : TKDT3072DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3072DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;

begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3072DD_Test := TKDT3072DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3072DD_Test.TestBuff, 300);
  for i := 0 to length(TKDT3072DD_Test.TestBuff) - 1 do
    for j := 0 to TKDT3072DD_AxisCount - 1 do
        TKDT3072DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3072DD_Test.TestBuff), length(TKDT3072DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3072DD_Test.BuildKDTreeM(False, length(TKDT3072DD_Test.TestBuff), @TKDT3072DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3072DD_Test.BuildKDTreeM(False, length(TKDT3072DD_Test.TestBuff), TKDT3072DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3072DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3072DD_Test.TestBuff));
  TKDT3072DD_Test.Search(TKDT3072DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3072DDDistance(TKDT3072DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3072DD_Test.Clear;
  { kMean test }
  TKDT3072DD_Test.BuildKDTreeWithCluster(TKDT3072DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3072DD_Test.Search(TKDT3072DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3072DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3072DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3072DD_Test);
end;

{$ENDIF DEBUG}

{$IFDEF DEBUG}
procedure Test_All;
begin
  TKDT1DD.Test();
  TKDT2DD.Test();
  TKDT3DD.Test();
  TKDT4DD.Test();
  TKDT6DD.Test();
  TKDT8DD.Test();
  TKDT10DD.Test();
  TKDT12DD.Test();
  TKDT14DD.Test();
  TKDT16DD.Test();
  TKDT18DD.Test();
  TKDT20DD.Test();
  TKDT22DD.Test();
  TKDT24DD.Test();
  TKDT28DD.Test();
  TKDT30DD.Test();
  TKDT32DD.Test();
  TKDT34DD.Test();
  TKDT36DD.Test();
  TKDT40DD.Test();
  TKDT48DD.Test();
  TKDT64DD.Test();
  TKDT96DD.Test();
  TKDT128DD.Test();
  TKDT256DD.Test();
  TKDT372DD.Test();
  TKDT512DD.Test();
  TKDT640DD.Test();
  TKDT768DD.Test();
  TKDT1024DD.Test();
  TKDT1080DD.Test();
  TKDT1536DD.Test();
  TKDT1920DD.Test();
  TKDT2048DD.Test();
  TKDT3072DD.Test();
  DoStatus('All Test Finished');
end;
{$ENDIF}




initialization

finalization

end.

