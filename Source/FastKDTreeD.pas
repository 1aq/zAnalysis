{ Fast KDTree Double Type support                                                }
{ ****************************************************************************** }
{ * fast KDTree Support,writen by QQ 600585@qq.com                             * }
{ * https://github.com/PassByYou888/CoreCipher                                 * }
{ * https://github.com/PassByYou888/ZServer4D                                  * }
{ * https://github.com/PassByYou888/zExpression                                * }
{ * https://github.com/PassByYou888/zTranslate                                 * }
{ * https://github.com/PassByYou888/zSound                                     * }
{ * https://github.com/PassByYou888/zAnalysis                                  * }
{ ****************************************************************************** }

unit FastKDTreeD;

interface

uses CoreClasses, PascalStrings, KM;

{$I zDefine.inc}

{$IFDEF FPC}
{$DEFINE DEBUG}
{$ENDIF FPC}

const

  // Double float: KDTree
  KDT1DD_Axis = 1;
  KDT2DD_Axis = 2;
  KDT3DD_Axis = 3;
  KDT4DD_Axis = 4;
  KDT5DD_Axis = 5;
  KDT6DD_Axis = 6;
  KDT7DD_Axis = 7;
  KDT8DD_Axis = 8;
  KDT9DD_Axis = 9;
  KDT10DD_Axis = 10;
  KDT11DD_Axis = 11;
  KDT12DD_Axis = 12;
  KDT13DD_Axis = 13;
  KDT14DD_Axis = 14;
  KDT15DD_Axis = 15;
  KDT16DD_Axis = 16;
  KDT17DD_Axis = 17;
  KDT18DD_Axis = 18;
  KDT19DD_Axis = 19;
  KDT20DD_Axis = 20;
  KDT21DD_Axis = 21;
  KDT22DD_Axis = 22;
  KDT23DD_Axis = 23;
  KDT24DD_Axis = 24;
  KDT25DD_Axis = 25;
  KDT26DD_Axis = 26;
  KDT27DD_Axis = 27;
  KDT28DD_Axis = 28;
  KDT29DD_Axis = 29;
  KDT30DD_Axis = 30;
  KDT31DD_Axis = 31;
  KDT32DD_Axis = 32;
  KDT33DD_Axis = 33;
  KDT34DD_Axis = 34;
  KDT35DD_Axis = 35;
  KDT36DD_Axis = 36;
  KDT37DD_Axis = 37;
  KDT38DD_Axis = 38;
  KDT39DD_Axis = 39;
  KDT40DD_Axis = 40;
  KDT41DD_Axis = 41;
  KDT42DD_Axis = 42;
  KDT43DD_Axis = 43;
  KDT44DD_Axis = 44;
  KDT45DD_Axis = 45;
  KDT46DD_Axis = 46;
  KDT47DD_Axis = 47;
  KDT48DD_Axis = 48;
  KDT49DD_Axis = 49;
  KDT50DD_Axis = 50;
  KDT51DD_Axis = 51;
  KDT52DD_Axis = 52;
  KDT53DD_Axis = 53;
  KDT54DD_Axis = 54;
  KDT55DD_Axis = 55;
  KDT56DD_Axis = 56;
  KDT57DD_Axis = 57;
  KDT58DD_Axis = 58;
  KDT59DD_Axis = 59;
  KDT60DD_Axis = 60;
  KDT61DD_Axis = 61;
  KDT62DD_Axis = 62;
  KDT63DD_Axis = 63;
  KDT64DD_Axis = 64;
  KDT65DD_Axis = 65;
  KDT66DD_Axis = 66;
  KDT67DD_Axis = 67;
  KDT68DD_Axis = 68;
  KDT69DD_Axis = 69;
  KDT70DD_Axis = 70;
  KDT71DD_Axis = 71;
  KDT72DD_Axis = 72;
  KDT84DD_Axis = 84;
  KDT96DD_Axis = 96;
  KDT128DD_Axis = 128;
  KDT140DD_Axis = 140;
  KDT160DD_Axis = 160;
  KDT196DD_Axis = 196;
  KDT256DD_Axis = 256;
  KDT272DD_Axis = 272;
  KDT288DD_Axis = 288;
  KDT372DD_Axis = 372;
  KDT512DD_Axis = 512;
  KDT576DD_Axis = 576;
  KDT768DD_Axis = 768;
  KDT1024DD_Axis = 1024;
  KDT1040DD_Axis = 1040;
  KDT1056DD_Axis = 1056;
  KDT1536DD_Axis = 1536;
  KDT1920DD_Axis = 1920;
  KDT1980DD_Axis = 1980;
  KDT2048DD_Axis = 2048;
  KDT3072DD_Axis = 3072;
  KDT3088DD_Axis = 3088;
  KDT3104DD_Axis = 3104;
  KDT4096DD_Axis = 4096;
  KDT8192DD_Axis = 8192;

type

  // Double float: KDTree
  TKDT1DD = class;  TKDT1DD_VecType = Double; // 1D
  TKDT2DD = class;  TKDT2DD_VecType = Double; // 2D
  TKDT3DD = class;  TKDT3DD_VecType = Double; // 3D
  TKDT4DD = class;  TKDT4DD_VecType = Double; // 4D
  TKDT5DD = class;  TKDT5DD_VecType = Double; // 5D
  TKDT6DD = class;  TKDT6DD_VecType = Double; // 6D
  TKDT7DD = class;  TKDT7DD_VecType = Double; // 7D
  TKDT8DD = class;  TKDT8DD_VecType = Double; // 8D
  TKDT9DD = class;  TKDT9DD_VecType = Double; // 9D
  TKDT10DD = class;  TKDT10DD_VecType = Double; // 10D
  TKDT11DD = class;  TKDT11DD_VecType = Double; // 11D
  TKDT12DD = class;  TKDT12DD_VecType = Double; // 12D
  TKDT13DD = class;  TKDT13DD_VecType = Double; // 13D
  TKDT14DD = class;  TKDT14DD_VecType = Double; // 14D
  TKDT15DD = class;  TKDT15DD_VecType = Double; // 15D
  TKDT16DD = class;  TKDT16DD_VecType = Double; // 16D
  TKDT17DD = class;  TKDT17DD_VecType = Double; // 17D
  TKDT18DD = class;  TKDT18DD_VecType = Double; // 18D
  TKDT19DD = class;  TKDT19DD_VecType = Double; // 19D
  TKDT20DD = class;  TKDT20DD_VecType = Double; // 20D
  TKDT21DD = class;  TKDT21DD_VecType = Double; // 21D
  TKDT22DD = class;  TKDT22DD_VecType = Double; // 22D
  TKDT23DD = class;  TKDT23DD_VecType = Double; // 23D
  TKDT24DD = class;  TKDT24DD_VecType = Double; // 24D
  TKDT25DD = class;  TKDT25DD_VecType = Double; // 25D
  TKDT26DD = class;  TKDT26DD_VecType = Double; // 26D
  TKDT27DD = class;  TKDT27DD_VecType = Double; // 27D
  TKDT28DD = class;  TKDT28DD_VecType = Double; // 28D
  TKDT29DD = class;  TKDT29DD_VecType = Double; // 29D
  TKDT30DD = class;  TKDT30DD_VecType = Double; // 30D
  TKDT31DD = class;  TKDT31DD_VecType = Double; // 31D
  TKDT32DD = class;  TKDT32DD_VecType = Double; // 32D
  TKDT33DD = class;  TKDT33DD_VecType = Double; // 33D
  TKDT34DD = class;  TKDT34DD_VecType = Double; // 34D
  TKDT35DD = class;  TKDT35DD_VecType = Double; // 35D
  TKDT36DD = class;  TKDT36DD_VecType = Double; // 36D
  TKDT37DD = class;  TKDT37DD_VecType = Double; // 37D
  TKDT38DD = class;  TKDT38DD_VecType = Double; // 38D
  TKDT39DD = class;  TKDT39DD_VecType = Double; // 39D
  TKDT40DD = class;  TKDT40DD_VecType = Double; // 40D
  TKDT41DD = class;  TKDT41DD_VecType = Double; // 41D
  TKDT42DD = class;  TKDT42DD_VecType = Double; // 42D
  TKDT43DD = class;  TKDT43DD_VecType = Double; // 43D
  TKDT44DD = class;  TKDT44DD_VecType = Double; // 44D
  TKDT45DD = class;  TKDT45DD_VecType = Double; // 45D
  TKDT46DD = class;  TKDT46DD_VecType = Double; // 46D
  TKDT47DD = class;  TKDT47DD_VecType = Double; // 47D
  TKDT48DD = class;  TKDT48DD_VecType = Double; // 48D
  TKDT49DD = class;  TKDT49DD_VecType = Double; // 49D
  TKDT50DD = class;  TKDT50DD_VecType = Double; // 50D
  TKDT51DD = class;  TKDT51DD_VecType = Double; // 51D
  TKDT52DD = class;  TKDT52DD_VecType = Double; // 52D
  TKDT53DD = class;  TKDT53DD_VecType = Double; // 53D
  TKDT54DD = class;  TKDT54DD_VecType = Double; // 54D
  TKDT55DD = class;  TKDT55DD_VecType = Double; // 55D
  TKDT56DD = class;  TKDT56DD_VecType = Double; // 56D
  TKDT57DD = class;  TKDT57DD_VecType = Double; // 57D
  TKDT58DD = class;  TKDT58DD_VecType = Double; // 58D
  TKDT59DD = class;  TKDT59DD_VecType = Double; // 59D
  TKDT60DD = class;  TKDT60DD_VecType = Double; // 60D
  TKDT61DD = class;  TKDT61DD_VecType = Double; // 61D
  TKDT62DD = class;  TKDT62DD_VecType = Double; // 62D
  TKDT63DD = class;  TKDT63DD_VecType = Double; // 63D
  TKDT64DD = class;  TKDT64DD_VecType = Double; // 64D
  TKDT65DD = class;  TKDT65DD_VecType = Double; // 65D
  TKDT66DD = class;  TKDT66DD_VecType = Double; // 66D
  TKDT67DD = class;  TKDT67DD_VecType = Double; // 67D
  TKDT68DD = class;  TKDT68DD_VecType = Double; // 68D
  TKDT69DD = class;  TKDT69DD_VecType = Double; // 69D
  TKDT70DD = class;  TKDT70DD_VecType = Double; // 70D
  TKDT71DD = class;  TKDT71DD_VecType = Double; // 71D
  TKDT72DD = class;  TKDT72DD_VecType = Double; // 72D
  TKDT84DD = class;  TKDT84DD_VecType = Double; // 84D
  TKDT96DD = class;  TKDT96DD_VecType = Double; // 96D
  TKDT128DD = class;  TKDT128DD_VecType = Double; // 128D
  TKDT140DD = class;  TKDT140DD_VecType = Double; // 140D
  TKDT160DD = class;  TKDT160DD_VecType = Double; // 160D
  TKDT196DD = class;  TKDT196DD_VecType = Double; // 196D
  TKDT256DD = class;  TKDT256DD_VecType = Double; // 256D
  TKDT272DD = class;  TKDT272DD_VecType = Double; // 272D
  TKDT288DD = class;  TKDT288DD_VecType = Double; // 288D
  TKDT372DD = class;  TKDT372DD_VecType = Double; // 372D
  TKDT512DD = class;  TKDT512DD_VecType = Double; // 512D
  TKDT576DD = class;  TKDT576DD_VecType = Double; // 576D
  TKDT768DD = class;  TKDT768DD_VecType = Double; // 768D
  TKDT1024DD = class;  TKDT1024DD_VecType = Double; // 1024D
  TKDT1040DD = class;  TKDT1040DD_VecType = Double; // 1040D
  TKDT1056DD = class;  TKDT1056DD_VecType = Double; // 1056D
  TKDT1536DD = class;  TKDT1536DD_VecType = Double; // 1536D
  TKDT1920DD = class;  TKDT1920DD_VecType = Double; // 1920D
  TKDT1980DD = class;  TKDT1980DD_VecType = Double; // 1980D
  TKDT2048DD = class;  TKDT2048DD_VecType = Double; // 2048D
  TKDT3072DD = class;  TKDT3072DD_VecType = Double; // 3072D
  TKDT3088DD = class;  TKDT3088DD_VecType = Double; // 3088D
  TKDT3104DD = class;  TKDT3104DD_VecType = Double; // 3104D
  TKDT4096DD = class;  TKDT4096DD_VecType = Double; // 4096D
  TKDT8192DD = class;  TKDT8192DD_VecType = Double; // 8192D





  // Double float: KDTree


  TKDT1DD = class(TCoreClassObject)
  public type
    // code split
    TKDT1DD_Vec = packed array [0 .. KDT1DD_Axis - 1] of TKDT1DD_VecType;
    PKDT1DD_Vec = ^TKDT1DD_Vec;

    TKDT1DD_DynamicVecBuffer = array of TKDT1DD_Vec;
    PKDT1DD_DynamicVecBuffer = ^TKDT1DD_DynamicVecBuffer;

    TKDT1DD_Source = packed record
      Buff: TKDT1DD_Vec;
      index: Integer;
    end;

    PKDT1DD_Source       = ^TKDT1DD_Source;
    TKDT1DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT1DD_Source) - 1] of PKDT1DD_Source;
    PKDT1DD_SourceBuffer = ^TKDT1DD_SourceBuffer;

    TKDT1DDyanmicSourceBuffer = packed array of PKDT1DD_Source;
    PKDT1DDyanmicSourceBuffer = ^TKDT1DDyanmicSourceBuffer;

    TKDT1DDyanmicStoreBuffer = packed array of TKDT1DD_Source;
    PKDT1DDyanmicStoreBuffer = ^TKDT1DDyanmicStoreBuffer;

    PKDT1DD_Node = ^TKDT1DD_Node;

    TKDT1DD_Node = packed record
      Parent, Right, Left: PKDT1DD_Node;
      vec: PKDT1DD_Source;
    end;

    TKDT1DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1DD_Source; const Data: Pointer);
    TKDT1DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1DDyanmicStoreBuffer;
    KDBuff     : TKDT1DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1DD_Node;
    TestBuff   : TKDT1DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DD_Node;
    function GetData(const index: NativeInt): PKDT1DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DD_Node; overload;
    function Search(const Buff: TKDT1DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DD_Node; overload;
    function Search(const Buff: TKDT1DD_Vec; var SearchedDistanceMin: Double): PKDT1DD_Node; overload;
    function Search(const Buff: TKDT1DD_Vec): PKDT1DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1DD_DynamicVecBuffer; var OutBuff: TKDT1DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT1DD_Node);
    procedure PrintBuffer;

    class function KDT1DDVec(const s: SystemString): TKDT1DD_Vec; overload;
    class function KDT1DDVec(const v: TKDT1DD_Vec): SystemString; overload;
    class function KDT1DDPow(const v: TKDT1DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1DDDistance(const v1, v2: TKDT1DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT2DD = class(TCoreClassObject)
  public type
    // code split
    TKDT2DD_Vec = packed array [0 .. KDT2DD_Axis - 1] of TKDT2DD_VecType;
    PKDT2DD_Vec = ^TKDT2DD_Vec;

    TKDT2DD_DynamicVecBuffer = array of TKDT2DD_Vec;
    PKDT2DD_DynamicVecBuffer = ^TKDT2DD_DynamicVecBuffer;

    TKDT2DD_Source = packed record
      Buff: TKDT2DD_Vec;
      index: Integer;
    end;

    PKDT2DD_Source       = ^TKDT2DD_Source;
    TKDT2DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT2DD_Source) - 1] of PKDT2DD_Source;
    PKDT2DD_SourceBuffer = ^TKDT2DD_SourceBuffer;

    TKDT2DDyanmicSourceBuffer = packed array of PKDT2DD_Source;
    PKDT2DDyanmicSourceBuffer = ^TKDT2DDyanmicSourceBuffer;

    TKDT2DDyanmicStoreBuffer = packed array of TKDT2DD_Source;
    PKDT2DDyanmicStoreBuffer = ^TKDT2DDyanmicStoreBuffer;

    PKDT2DD_Node = ^TKDT2DD_Node;

    TKDT2DD_Node = packed record
      Parent, Right, Left: PKDT2DD_Node;
      vec: PKDT2DD_Source;
    end;

    TKDT2DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT2DD_Source; const Data: Pointer);
    TKDT2DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT2DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT2DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT2DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT2DDyanmicStoreBuffer;
    KDBuff     : TKDT2DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2DD_Node;
    TestBuff   : TKDT2DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DD_Node;
    function GetData(const index: NativeInt): PKDT2DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT2DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DD_Node; overload;
    function Search(const Buff: TKDT2DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DD_Node; overload;
    function Search(const Buff: TKDT2DD_Vec; var SearchedDistanceMin: Double): PKDT2DD_Node; overload;
    function Search(const Buff: TKDT2DD_Vec): PKDT2DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2DD_DynamicVecBuffer; var OutBuff: TKDT2DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT2DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT2DD_Node);
    procedure PrintBuffer;

    class function KDT2DDVec(const s: SystemString): TKDT2DD_Vec; overload;
    class function KDT2DDVec(const v: TKDT2DD_Vec): SystemString; overload;
    class function KDT2DDPow(const v: TKDT2DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT2DDDistance(const v1, v2: TKDT2DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT3DD = class(TCoreClassObject)
  public type
    // code split
    TKDT3DD_Vec = packed array [0 .. KDT3DD_Axis - 1] of TKDT3DD_VecType;
    PKDT3DD_Vec = ^TKDT3DD_Vec;

    TKDT3DD_DynamicVecBuffer = array of TKDT3DD_Vec;
    PKDT3DD_DynamicVecBuffer = ^TKDT3DD_DynamicVecBuffer;

    TKDT3DD_Source = packed record
      Buff: TKDT3DD_Vec;
      index: Integer;
    end;

    PKDT3DD_Source       = ^TKDT3DD_Source;
    TKDT3DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT3DD_Source) - 1] of PKDT3DD_Source;
    PKDT3DD_SourceBuffer = ^TKDT3DD_SourceBuffer;

    TKDT3DDyanmicSourceBuffer = packed array of PKDT3DD_Source;
    PKDT3DDyanmicSourceBuffer = ^TKDT3DDyanmicSourceBuffer;

    TKDT3DDyanmicStoreBuffer = packed array of TKDT3DD_Source;
    PKDT3DDyanmicStoreBuffer = ^TKDT3DDyanmicStoreBuffer;

    PKDT3DD_Node = ^TKDT3DD_Node;

    TKDT3DD_Node = packed record
      Parent, Right, Left: PKDT3DD_Node;
      vec: PKDT3DD_Source;
    end;

    TKDT3DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3DD_Source; const Data: Pointer);
    TKDT3DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT3DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT3DDyanmicStoreBuffer;
    KDBuff     : TKDT3DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3DD_Node;
    TestBuff   : TKDT3DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DD_Node;
    function GetData(const index: NativeInt): PKDT3DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT3DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DD_Node; overload;
    function Search(const Buff: TKDT3DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DD_Node; overload;
    function Search(const Buff: TKDT3DD_Vec; var SearchedDistanceMin: Double): PKDT3DD_Node; overload;
    function Search(const Buff: TKDT3DD_Vec): PKDT3DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3DD_DynamicVecBuffer; var OutBuff: TKDT3DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT3DD_Node);
    procedure PrintBuffer;

    class function KDT3DDVec(const s: SystemString): TKDT3DD_Vec; overload;
    class function KDT3DDVec(const v: TKDT3DD_Vec): SystemString; overload;
    class function KDT3DDPow(const v: TKDT3DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3DDDistance(const v1, v2: TKDT3DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT4DD = class(TCoreClassObject)
  public type
    // code split
    TKDT4DD_Vec = packed array [0 .. KDT4DD_Axis - 1] of TKDT4DD_VecType;
    PKDT4DD_Vec = ^TKDT4DD_Vec;

    TKDT4DD_DynamicVecBuffer = array of TKDT4DD_Vec;
    PKDT4DD_DynamicVecBuffer = ^TKDT4DD_DynamicVecBuffer;

    TKDT4DD_Source = packed record
      Buff: TKDT4DD_Vec;
      index: Integer;
    end;

    PKDT4DD_Source       = ^TKDT4DD_Source;
    TKDT4DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT4DD_Source) - 1] of PKDT4DD_Source;
    PKDT4DD_SourceBuffer = ^TKDT4DD_SourceBuffer;

    TKDT4DDyanmicSourceBuffer = packed array of PKDT4DD_Source;
    PKDT4DDyanmicSourceBuffer = ^TKDT4DDyanmicSourceBuffer;

    TKDT4DDyanmicStoreBuffer = packed array of TKDT4DD_Source;
    PKDT4DDyanmicStoreBuffer = ^TKDT4DDyanmicStoreBuffer;

    PKDT4DD_Node = ^TKDT4DD_Node;

    TKDT4DD_Node = packed record
      Parent, Right, Left: PKDT4DD_Node;
      vec: PKDT4DD_Source;
    end;

    TKDT4DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT4DD_Source; const Data: Pointer);
    TKDT4DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT4DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT4DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT4DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT4DDyanmicStoreBuffer;
    KDBuff     : TKDT4DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT4DD_Node;
    TestBuff   : TKDT4DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DD_Node;
    function GetData(const index: NativeInt): PKDT4DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT4DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DD_Node; overload;
    function Search(const Buff: TKDT4DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DD_Node; overload;
    function Search(const Buff: TKDT4DD_Vec; var SearchedDistanceMin: Double): PKDT4DD_Node; overload;
    function Search(const Buff: TKDT4DD_Vec): PKDT4DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4DD_DynamicVecBuffer; var OutBuff: TKDT4DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT4DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT4DD_Node);
    procedure PrintBuffer;

    class function KDT4DDVec(const s: SystemString): TKDT4DD_Vec; overload;
    class function KDT4DDVec(const v: TKDT4DD_Vec): SystemString; overload;
    class function KDT4DDPow(const v: TKDT4DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT4DDDistance(const v1, v2: TKDT4DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT5DD = class(TCoreClassObject)
  public type
    // code split
    TKDT5DD_Vec = packed array [0 .. KDT5DD_Axis - 1] of TKDT5DD_VecType;
    PKDT5DD_Vec = ^TKDT5DD_Vec;

    TKDT5DD_DynamicVecBuffer = array of TKDT5DD_Vec;
    PKDT5DD_DynamicVecBuffer = ^TKDT5DD_DynamicVecBuffer;

    TKDT5DD_Source = packed record
      Buff: TKDT5DD_Vec;
      index: Integer;
    end;

    PKDT5DD_Source       = ^TKDT5DD_Source;
    TKDT5DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT5DD_Source) - 1] of PKDT5DD_Source;
    PKDT5DD_SourceBuffer = ^TKDT5DD_SourceBuffer;

    TKDT5DDyanmicSourceBuffer = packed array of PKDT5DD_Source;
    PKDT5DDyanmicSourceBuffer = ^TKDT5DDyanmicSourceBuffer;

    TKDT5DDyanmicStoreBuffer = packed array of TKDT5DD_Source;
    PKDT5DDyanmicStoreBuffer = ^TKDT5DDyanmicStoreBuffer;

    PKDT5DD_Node = ^TKDT5DD_Node;

    TKDT5DD_Node = packed record
      Parent, Right, Left: PKDT5DD_Node;
      vec: PKDT5DD_Source;
    end;

    TKDT5DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT5DD_Source; const Data: Pointer);
    TKDT5DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT5DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT5DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT5DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT5DDyanmicStoreBuffer;
    KDBuff     : TKDT5DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT5DD_Node;
    TestBuff   : TKDT5DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DD_Node;
    function GetData(const index: NativeInt): PKDT5DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT5DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT5DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT5DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT5DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DD_Node; overload;
    function Search(const Buff: TKDT5DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DD_Node; overload;
    function Search(const Buff: TKDT5DD_Vec; var SearchedDistanceMin: Double): PKDT5DD_Node; overload;
    function Search(const Buff: TKDT5DD_Vec): PKDT5DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT5DD_DynamicVecBuffer; var OutBuff: TKDT5DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT5DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT5DD_Node);
    procedure PrintBuffer;

    class function KDT5DDVec(const s: SystemString): TKDT5DD_Vec; overload;
    class function KDT5DDVec(const v: TKDT5DD_Vec): SystemString; overload;
    class function KDT5DDPow(const v: TKDT5DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT5DDDistance(const v1, v2: TKDT5DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT5DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT6DD = class(TCoreClassObject)
  public type
    // code split
    TKDT6DD_Vec = packed array [0 .. KDT6DD_Axis - 1] of TKDT6DD_VecType;
    PKDT6DD_Vec = ^TKDT6DD_Vec;

    TKDT6DD_DynamicVecBuffer = array of TKDT6DD_Vec;
    PKDT6DD_DynamicVecBuffer = ^TKDT6DD_DynamicVecBuffer;

    TKDT6DD_Source = packed record
      Buff: TKDT6DD_Vec;
      index: Integer;
    end;

    PKDT6DD_Source       = ^TKDT6DD_Source;
    TKDT6DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT6DD_Source) - 1] of PKDT6DD_Source;
    PKDT6DD_SourceBuffer = ^TKDT6DD_SourceBuffer;

    TKDT6DDyanmicSourceBuffer = packed array of PKDT6DD_Source;
    PKDT6DDyanmicSourceBuffer = ^TKDT6DDyanmicSourceBuffer;

    TKDT6DDyanmicStoreBuffer = packed array of TKDT6DD_Source;
    PKDT6DDyanmicStoreBuffer = ^TKDT6DDyanmicStoreBuffer;

    PKDT6DD_Node = ^TKDT6DD_Node;

    TKDT6DD_Node = packed record
      Parent, Right, Left: PKDT6DD_Node;
      vec: PKDT6DD_Source;
    end;

    TKDT6DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT6DD_Source; const Data: Pointer);
    TKDT6DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT6DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT6DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT6DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT6DDyanmicStoreBuffer;
    KDBuff     : TKDT6DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT6DD_Node;
    TestBuff   : TKDT6DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DD_Node;
    function GetData(const index: NativeInt): PKDT6DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT6DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT6DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT6DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT6DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DD_Node; overload;
    function Search(const Buff: TKDT6DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DD_Node; overload;
    function Search(const Buff: TKDT6DD_Vec; var SearchedDistanceMin: Double): PKDT6DD_Node; overload;
    function Search(const Buff: TKDT6DD_Vec): PKDT6DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT6DD_DynamicVecBuffer; var OutBuff: TKDT6DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT6DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT6DD_Node);
    procedure PrintBuffer;

    class function KDT6DDVec(const s: SystemString): TKDT6DD_Vec; overload;
    class function KDT6DDVec(const v: TKDT6DD_Vec): SystemString; overload;
    class function KDT6DDPow(const v: TKDT6DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT6DDDistance(const v1, v2: TKDT6DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT6DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT7DD = class(TCoreClassObject)
  public type
    // code split
    TKDT7DD_Vec = packed array [0 .. KDT7DD_Axis - 1] of TKDT7DD_VecType;
    PKDT7DD_Vec = ^TKDT7DD_Vec;

    TKDT7DD_DynamicVecBuffer = array of TKDT7DD_Vec;
    PKDT7DD_DynamicVecBuffer = ^TKDT7DD_DynamicVecBuffer;

    TKDT7DD_Source = packed record
      Buff: TKDT7DD_Vec;
      index: Integer;
    end;

    PKDT7DD_Source       = ^TKDT7DD_Source;
    TKDT7DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT7DD_Source) - 1] of PKDT7DD_Source;
    PKDT7DD_SourceBuffer = ^TKDT7DD_SourceBuffer;

    TKDT7DDyanmicSourceBuffer = packed array of PKDT7DD_Source;
    PKDT7DDyanmicSourceBuffer = ^TKDT7DDyanmicSourceBuffer;

    TKDT7DDyanmicStoreBuffer = packed array of TKDT7DD_Source;
    PKDT7DDyanmicStoreBuffer = ^TKDT7DDyanmicStoreBuffer;

    PKDT7DD_Node = ^TKDT7DD_Node;

    TKDT7DD_Node = packed record
      Parent, Right, Left: PKDT7DD_Node;
      vec: PKDT7DD_Source;
    end;

    TKDT7DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT7DD_Source; const Data: Pointer);
    TKDT7DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT7DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT7DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT7DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT7DDyanmicStoreBuffer;
    KDBuff     : TKDT7DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT7DD_Node;
    TestBuff   : TKDT7DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DD_Node;
    function GetData(const index: NativeInt): PKDT7DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT7DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT7DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT7DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT7DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DD_Node; overload;
    function Search(const Buff: TKDT7DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DD_Node; overload;
    function Search(const Buff: TKDT7DD_Vec; var SearchedDistanceMin: Double): PKDT7DD_Node; overload;
    function Search(const Buff: TKDT7DD_Vec): PKDT7DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT7DD_DynamicVecBuffer; var OutBuff: TKDT7DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT7DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT7DD_Node);
    procedure PrintBuffer;

    class function KDT7DDVec(const s: SystemString): TKDT7DD_Vec; overload;
    class function KDT7DDVec(const v: TKDT7DD_Vec): SystemString; overload;
    class function KDT7DDPow(const v: TKDT7DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT7DDDistance(const v1, v2: TKDT7DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT7DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT8DD = class(TCoreClassObject)
  public type
    // code split
    TKDT8DD_Vec = packed array [0 .. KDT8DD_Axis - 1] of TKDT8DD_VecType;
    PKDT8DD_Vec = ^TKDT8DD_Vec;

    TKDT8DD_DynamicVecBuffer = array of TKDT8DD_Vec;
    PKDT8DD_DynamicVecBuffer = ^TKDT8DD_DynamicVecBuffer;

    TKDT8DD_Source = packed record
      Buff: TKDT8DD_Vec;
      index: Integer;
    end;

    PKDT8DD_Source       = ^TKDT8DD_Source;
    TKDT8DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT8DD_Source) - 1] of PKDT8DD_Source;
    PKDT8DD_SourceBuffer = ^TKDT8DD_SourceBuffer;

    TKDT8DDyanmicSourceBuffer = packed array of PKDT8DD_Source;
    PKDT8DDyanmicSourceBuffer = ^TKDT8DDyanmicSourceBuffer;

    TKDT8DDyanmicStoreBuffer = packed array of TKDT8DD_Source;
    PKDT8DDyanmicStoreBuffer = ^TKDT8DDyanmicStoreBuffer;

    PKDT8DD_Node = ^TKDT8DD_Node;

    TKDT8DD_Node = packed record
      Parent, Right, Left: PKDT8DD_Node;
      vec: PKDT8DD_Source;
    end;

    TKDT8DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT8DD_Source; const Data: Pointer);
    TKDT8DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT8DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT8DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT8DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT8DDyanmicStoreBuffer;
    KDBuff     : TKDT8DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT8DD_Node;
    TestBuff   : TKDT8DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DD_Node;
    function GetData(const index: NativeInt): PKDT8DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT8DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DD_Node; overload;
    function Search(const Buff: TKDT8DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DD_Node; overload;
    function Search(const Buff: TKDT8DD_Vec; var SearchedDistanceMin: Double): PKDT8DD_Node; overload;
    function Search(const Buff: TKDT8DD_Vec): PKDT8DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8DD_DynamicVecBuffer; var OutBuff: TKDT8DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT8DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT8DD_Node);
    procedure PrintBuffer;

    class function KDT8DDVec(const s: SystemString): TKDT8DD_Vec; overload;
    class function KDT8DDVec(const v: TKDT8DD_Vec): SystemString; overload;
    class function KDT8DDPow(const v: TKDT8DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT8DDDistance(const v1, v2: TKDT8DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT9DD = class(TCoreClassObject)
  public type
    // code split
    TKDT9DD_Vec = packed array [0 .. KDT9DD_Axis - 1] of TKDT9DD_VecType;
    PKDT9DD_Vec = ^TKDT9DD_Vec;

    TKDT9DD_DynamicVecBuffer = array of TKDT9DD_Vec;
    PKDT9DD_DynamicVecBuffer = ^TKDT9DD_DynamicVecBuffer;

    TKDT9DD_Source = packed record
      Buff: TKDT9DD_Vec;
      index: Integer;
    end;

    PKDT9DD_Source       = ^TKDT9DD_Source;
    TKDT9DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT9DD_Source) - 1] of PKDT9DD_Source;
    PKDT9DD_SourceBuffer = ^TKDT9DD_SourceBuffer;

    TKDT9DDyanmicSourceBuffer = packed array of PKDT9DD_Source;
    PKDT9DDyanmicSourceBuffer = ^TKDT9DDyanmicSourceBuffer;

    TKDT9DDyanmicStoreBuffer = packed array of TKDT9DD_Source;
    PKDT9DDyanmicStoreBuffer = ^TKDT9DDyanmicStoreBuffer;

    PKDT9DD_Node = ^TKDT9DD_Node;

    TKDT9DD_Node = packed record
      Parent, Right, Left: PKDT9DD_Node;
      vec: PKDT9DD_Source;
    end;

    TKDT9DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT9DD_Source; const Data: Pointer);
    TKDT9DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT9DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT9DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT9DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT9DDyanmicStoreBuffer;
    KDBuff     : TKDT9DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT9DD_Node;
    TestBuff   : TKDT9DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DD_Node;
    function GetData(const index: NativeInt): PKDT9DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT9DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT9DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT9DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT9DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DD_Node; overload;
    function Search(const Buff: TKDT9DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DD_Node; overload;
    function Search(const Buff: TKDT9DD_Vec; var SearchedDistanceMin: Double): PKDT9DD_Node; overload;
    function Search(const Buff: TKDT9DD_Vec): PKDT9DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT9DD_DynamicVecBuffer; var OutBuff: TKDT9DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT9DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT9DD_Node);
    procedure PrintBuffer;

    class function KDT9DDVec(const s: SystemString): TKDT9DD_Vec; overload;
    class function KDT9DDVec(const v: TKDT9DD_Vec): SystemString; overload;
    class function KDT9DDPow(const v: TKDT9DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT9DDDistance(const v1, v2: TKDT9DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT9DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT10DD = class(TCoreClassObject)
  public type
    // code split
    TKDT10DD_Vec = packed array [0 .. KDT10DD_Axis - 1] of TKDT10DD_VecType;
    PKDT10DD_Vec = ^TKDT10DD_Vec;

    TKDT10DD_DynamicVecBuffer = array of TKDT10DD_Vec;
    PKDT10DD_DynamicVecBuffer = ^TKDT10DD_DynamicVecBuffer;

    TKDT10DD_Source = packed record
      Buff: TKDT10DD_Vec;
      index: Integer;
    end;

    PKDT10DD_Source       = ^TKDT10DD_Source;
    TKDT10DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT10DD_Source) - 1] of PKDT10DD_Source;
    PKDT10DD_SourceBuffer = ^TKDT10DD_SourceBuffer;

    TKDT10DDyanmicSourceBuffer = packed array of PKDT10DD_Source;
    PKDT10DDyanmicSourceBuffer = ^TKDT10DDyanmicSourceBuffer;

    TKDT10DDyanmicStoreBuffer = packed array of TKDT10DD_Source;
    PKDT10DDyanmicStoreBuffer = ^TKDT10DDyanmicStoreBuffer;

    PKDT10DD_Node = ^TKDT10DD_Node;

    TKDT10DD_Node = packed record
      Parent, Right, Left: PKDT10DD_Node;
      vec: PKDT10DD_Source;
    end;

    TKDT10DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT10DD_Source; const Data: Pointer);
    TKDT10DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT10DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT10DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT10DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT10DDyanmicStoreBuffer;
    KDBuff     : TKDT10DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT10DD_Node;
    TestBuff   : TKDT10DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DD_Node;
    function GetData(const index: NativeInt): PKDT10DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT10DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT10DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT10DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT10DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DD_Node; overload;
    function Search(const Buff: TKDT10DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DD_Node; overload;
    function Search(const Buff: TKDT10DD_Vec; var SearchedDistanceMin: Double): PKDT10DD_Node; overload;
    function Search(const Buff: TKDT10DD_Vec): PKDT10DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT10DD_DynamicVecBuffer; var OutBuff: TKDT10DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT10DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT10DD_Node);
    procedure PrintBuffer;

    class function KDT10DDVec(const s: SystemString): TKDT10DD_Vec; overload;
    class function KDT10DDVec(const v: TKDT10DD_Vec): SystemString; overload;
    class function KDT10DDPow(const v: TKDT10DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT10DDDistance(const v1, v2: TKDT10DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT10DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT11DD = class(TCoreClassObject)
  public type
    // code split
    TKDT11DD_Vec = packed array [0 .. KDT11DD_Axis - 1] of TKDT11DD_VecType;
    PKDT11DD_Vec = ^TKDT11DD_Vec;

    TKDT11DD_DynamicVecBuffer = array of TKDT11DD_Vec;
    PKDT11DD_DynamicVecBuffer = ^TKDT11DD_DynamicVecBuffer;

    TKDT11DD_Source = packed record
      Buff: TKDT11DD_Vec;
      index: Integer;
    end;

    PKDT11DD_Source       = ^TKDT11DD_Source;
    TKDT11DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT11DD_Source) - 1] of PKDT11DD_Source;
    PKDT11DD_SourceBuffer = ^TKDT11DD_SourceBuffer;

    TKDT11DDyanmicSourceBuffer = packed array of PKDT11DD_Source;
    PKDT11DDyanmicSourceBuffer = ^TKDT11DDyanmicSourceBuffer;

    TKDT11DDyanmicStoreBuffer = packed array of TKDT11DD_Source;
    PKDT11DDyanmicStoreBuffer = ^TKDT11DDyanmicStoreBuffer;

    PKDT11DD_Node = ^TKDT11DD_Node;

    TKDT11DD_Node = packed record
      Parent, Right, Left: PKDT11DD_Node;
      vec: PKDT11DD_Source;
    end;

    TKDT11DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT11DD_Source; const Data: Pointer);
    TKDT11DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT11DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT11DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT11DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT11DDyanmicStoreBuffer;
    KDBuff     : TKDT11DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT11DD_Node;
    TestBuff   : TKDT11DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DD_Node;
    function GetData(const index: NativeInt): PKDT11DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT11DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT11DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT11DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT11DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DD_Node; overload;
    function Search(const Buff: TKDT11DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DD_Node; overload;
    function Search(const Buff: TKDT11DD_Vec; var SearchedDistanceMin: Double): PKDT11DD_Node; overload;
    function Search(const Buff: TKDT11DD_Vec): PKDT11DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT11DD_DynamicVecBuffer; var OutBuff: TKDT11DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT11DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT11DD_Node);
    procedure PrintBuffer;

    class function KDT11DDVec(const s: SystemString): TKDT11DD_Vec; overload;
    class function KDT11DDVec(const v: TKDT11DD_Vec): SystemString; overload;
    class function KDT11DDPow(const v: TKDT11DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT11DDDistance(const v1, v2: TKDT11DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT11DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT12DD = class(TCoreClassObject)
  public type
    // code split
    TKDT12DD_Vec = packed array [0 .. KDT12DD_Axis - 1] of TKDT12DD_VecType;
    PKDT12DD_Vec = ^TKDT12DD_Vec;

    TKDT12DD_DynamicVecBuffer = array of TKDT12DD_Vec;
    PKDT12DD_DynamicVecBuffer = ^TKDT12DD_DynamicVecBuffer;

    TKDT12DD_Source = packed record
      Buff: TKDT12DD_Vec;
      index: Integer;
    end;

    PKDT12DD_Source       = ^TKDT12DD_Source;
    TKDT12DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT12DD_Source) - 1] of PKDT12DD_Source;
    PKDT12DD_SourceBuffer = ^TKDT12DD_SourceBuffer;

    TKDT12DDyanmicSourceBuffer = packed array of PKDT12DD_Source;
    PKDT12DDyanmicSourceBuffer = ^TKDT12DDyanmicSourceBuffer;

    TKDT12DDyanmicStoreBuffer = packed array of TKDT12DD_Source;
    PKDT12DDyanmicStoreBuffer = ^TKDT12DDyanmicStoreBuffer;

    PKDT12DD_Node = ^TKDT12DD_Node;

    TKDT12DD_Node = packed record
      Parent, Right, Left: PKDT12DD_Node;
      vec: PKDT12DD_Source;
    end;

    TKDT12DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT12DD_Source; const Data: Pointer);
    TKDT12DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT12DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT12DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT12DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT12DDyanmicStoreBuffer;
    KDBuff     : TKDT12DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT12DD_Node;
    TestBuff   : TKDT12DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DD_Node;
    function GetData(const index: NativeInt): PKDT12DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT12DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT12DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT12DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT12DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DD_Node; overload;
    function Search(const Buff: TKDT12DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DD_Node; overload;
    function Search(const Buff: TKDT12DD_Vec; var SearchedDistanceMin: Double): PKDT12DD_Node; overload;
    function Search(const Buff: TKDT12DD_Vec): PKDT12DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT12DD_DynamicVecBuffer; var OutBuff: TKDT12DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT12DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT12DD_Node);
    procedure PrintBuffer;

    class function KDT12DDVec(const s: SystemString): TKDT12DD_Vec; overload;
    class function KDT12DDVec(const v: TKDT12DD_Vec): SystemString; overload;
    class function KDT12DDPow(const v: TKDT12DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT12DDDistance(const v1, v2: TKDT12DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT12DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT13DD = class(TCoreClassObject)
  public type
    // code split
    TKDT13DD_Vec = packed array [0 .. KDT13DD_Axis - 1] of TKDT13DD_VecType;
    PKDT13DD_Vec = ^TKDT13DD_Vec;

    TKDT13DD_DynamicVecBuffer = array of TKDT13DD_Vec;
    PKDT13DD_DynamicVecBuffer = ^TKDT13DD_DynamicVecBuffer;

    TKDT13DD_Source = packed record
      Buff: TKDT13DD_Vec;
      index: Integer;
    end;

    PKDT13DD_Source       = ^TKDT13DD_Source;
    TKDT13DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT13DD_Source) - 1] of PKDT13DD_Source;
    PKDT13DD_SourceBuffer = ^TKDT13DD_SourceBuffer;

    TKDT13DDyanmicSourceBuffer = packed array of PKDT13DD_Source;
    PKDT13DDyanmicSourceBuffer = ^TKDT13DDyanmicSourceBuffer;

    TKDT13DDyanmicStoreBuffer = packed array of TKDT13DD_Source;
    PKDT13DDyanmicStoreBuffer = ^TKDT13DDyanmicStoreBuffer;

    PKDT13DD_Node = ^TKDT13DD_Node;

    TKDT13DD_Node = packed record
      Parent, Right, Left: PKDT13DD_Node;
      vec: PKDT13DD_Source;
    end;

    TKDT13DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT13DD_Source; const Data: Pointer);
    TKDT13DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT13DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT13DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT13DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT13DDyanmicStoreBuffer;
    KDBuff     : TKDT13DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT13DD_Node;
    TestBuff   : TKDT13DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DD_Node;
    function GetData(const index: NativeInt): PKDT13DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT13DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT13DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT13DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT13DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DD_Node; overload;
    function Search(const Buff: TKDT13DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DD_Node; overload;
    function Search(const Buff: TKDT13DD_Vec; var SearchedDistanceMin: Double): PKDT13DD_Node; overload;
    function Search(const Buff: TKDT13DD_Vec): PKDT13DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT13DD_DynamicVecBuffer; var OutBuff: TKDT13DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT13DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT13DD_Node);
    procedure PrintBuffer;

    class function KDT13DDVec(const s: SystemString): TKDT13DD_Vec; overload;
    class function KDT13DDVec(const v: TKDT13DD_Vec): SystemString; overload;
    class function KDT13DDPow(const v: TKDT13DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT13DDDistance(const v1, v2: TKDT13DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT13DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT14DD = class(TCoreClassObject)
  public type
    // code split
    TKDT14DD_Vec = packed array [0 .. KDT14DD_Axis - 1] of TKDT14DD_VecType;
    PKDT14DD_Vec = ^TKDT14DD_Vec;

    TKDT14DD_DynamicVecBuffer = array of TKDT14DD_Vec;
    PKDT14DD_DynamicVecBuffer = ^TKDT14DD_DynamicVecBuffer;

    TKDT14DD_Source = packed record
      Buff: TKDT14DD_Vec;
      index: Integer;
    end;

    PKDT14DD_Source       = ^TKDT14DD_Source;
    TKDT14DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT14DD_Source) - 1] of PKDT14DD_Source;
    PKDT14DD_SourceBuffer = ^TKDT14DD_SourceBuffer;

    TKDT14DDyanmicSourceBuffer = packed array of PKDT14DD_Source;
    PKDT14DDyanmicSourceBuffer = ^TKDT14DDyanmicSourceBuffer;

    TKDT14DDyanmicStoreBuffer = packed array of TKDT14DD_Source;
    PKDT14DDyanmicStoreBuffer = ^TKDT14DDyanmicStoreBuffer;

    PKDT14DD_Node = ^TKDT14DD_Node;

    TKDT14DD_Node = packed record
      Parent, Right, Left: PKDT14DD_Node;
      vec: PKDT14DD_Source;
    end;

    TKDT14DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT14DD_Source; const Data: Pointer);
    TKDT14DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT14DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT14DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT14DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT14DDyanmicStoreBuffer;
    KDBuff     : TKDT14DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT14DD_Node;
    TestBuff   : TKDT14DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DD_Node;
    function GetData(const index: NativeInt): PKDT14DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT14DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT14DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT14DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT14DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DD_Node; overload;
    function Search(const Buff: TKDT14DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DD_Node; overload;
    function Search(const Buff: TKDT14DD_Vec; var SearchedDistanceMin: Double): PKDT14DD_Node; overload;
    function Search(const Buff: TKDT14DD_Vec): PKDT14DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT14DD_DynamicVecBuffer; var OutBuff: TKDT14DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT14DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT14DD_Node);
    procedure PrintBuffer;

    class function KDT14DDVec(const s: SystemString): TKDT14DD_Vec; overload;
    class function KDT14DDVec(const v: TKDT14DD_Vec): SystemString; overload;
    class function KDT14DDPow(const v: TKDT14DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT14DDDistance(const v1, v2: TKDT14DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT14DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT15DD = class(TCoreClassObject)
  public type
    // code split
    TKDT15DD_Vec = packed array [0 .. KDT15DD_Axis - 1] of TKDT15DD_VecType;
    PKDT15DD_Vec = ^TKDT15DD_Vec;

    TKDT15DD_DynamicVecBuffer = array of TKDT15DD_Vec;
    PKDT15DD_DynamicVecBuffer = ^TKDT15DD_DynamicVecBuffer;

    TKDT15DD_Source = packed record
      Buff: TKDT15DD_Vec;
      index: Integer;
    end;

    PKDT15DD_Source       = ^TKDT15DD_Source;
    TKDT15DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT15DD_Source) - 1] of PKDT15DD_Source;
    PKDT15DD_SourceBuffer = ^TKDT15DD_SourceBuffer;

    TKDT15DDyanmicSourceBuffer = packed array of PKDT15DD_Source;
    PKDT15DDyanmicSourceBuffer = ^TKDT15DDyanmicSourceBuffer;

    TKDT15DDyanmicStoreBuffer = packed array of TKDT15DD_Source;
    PKDT15DDyanmicStoreBuffer = ^TKDT15DDyanmicStoreBuffer;

    PKDT15DD_Node = ^TKDT15DD_Node;

    TKDT15DD_Node = packed record
      Parent, Right, Left: PKDT15DD_Node;
      vec: PKDT15DD_Source;
    end;

    TKDT15DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT15DD_Source; const Data: Pointer);
    TKDT15DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT15DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT15DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT15DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT15DDyanmicStoreBuffer;
    KDBuff     : TKDT15DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT15DD_Node;
    TestBuff   : TKDT15DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DD_Node;
    function GetData(const index: NativeInt): PKDT15DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT15DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT15DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT15DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT15DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DD_Node; overload;
    function Search(const Buff: TKDT15DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DD_Node; overload;
    function Search(const Buff: TKDT15DD_Vec; var SearchedDistanceMin: Double): PKDT15DD_Node; overload;
    function Search(const Buff: TKDT15DD_Vec): PKDT15DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT15DD_DynamicVecBuffer; var OutBuff: TKDT15DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT15DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT15DD_Node);
    procedure PrintBuffer;

    class function KDT15DDVec(const s: SystemString): TKDT15DD_Vec; overload;
    class function KDT15DDVec(const v: TKDT15DD_Vec): SystemString; overload;
    class function KDT15DDPow(const v: TKDT15DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT15DDDistance(const v1, v2: TKDT15DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT15DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT16DD = class(TCoreClassObject)
  public type
    // code split
    TKDT16DD_Vec = packed array [0 .. KDT16DD_Axis - 1] of TKDT16DD_VecType;
    PKDT16DD_Vec = ^TKDT16DD_Vec;

    TKDT16DD_DynamicVecBuffer = array of TKDT16DD_Vec;
    PKDT16DD_DynamicVecBuffer = ^TKDT16DD_DynamicVecBuffer;

    TKDT16DD_Source = packed record
      Buff: TKDT16DD_Vec;
      index: Integer;
    end;

    PKDT16DD_Source       = ^TKDT16DD_Source;
    TKDT16DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT16DD_Source) - 1] of PKDT16DD_Source;
    PKDT16DD_SourceBuffer = ^TKDT16DD_SourceBuffer;

    TKDT16DDyanmicSourceBuffer = packed array of PKDT16DD_Source;
    PKDT16DDyanmicSourceBuffer = ^TKDT16DDyanmicSourceBuffer;

    TKDT16DDyanmicStoreBuffer = packed array of TKDT16DD_Source;
    PKDT16DDyanmicStoreBuffer = ^TKDT16DDyanmicStoreBuffer;

    PKDT16DD_Node = ^TKDT16DD_Node;

    TKDT16DD_Node = packed record
      Parent, Right, Left: PKDT16DD_Node;
      vec: PKDT16DD_Source;
    end;

    TKDT16DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT16DD_Source; const Data: Pointer);
    TKDT16DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT16DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT16DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT16DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT16DDyanmicStoreBuffer;
    KDBuff     : TKDT16DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT16DD_Node;
    TestBuff   : TKDT16DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DD_Node;
    function GetData(const index: NativeInt): PKDT16DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT16DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT16DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT16DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT16DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DD_Node; overload;
    function Search(const Buff: TKDT16DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DD_Node; overload;
    function Search(const Buff: TKDT16DD_Vec; var SearchedDistanceMin: Double): PKDT16DD_Node; overload;
    function Search(const Buff: TKDT16DD_Vec): PKDT16DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT16DD_DynamicVecBuffer; var OutBuff: TKDT16DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT16DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT16DD_Node);
    procedure PrintBuffer;

    class function KDT16DDVec(const s: SystemString): TKDT16DD_Vec; overload;
    class function KDT16DDVec(const v: TKDT16DD_Vec): SystemString; overload;
    class function KDT16DDPow(const v: TKDT16DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT16DDDistance(const v1, v2: TKDT16DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT16DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT17DD = class(TCoreClassObject)
  public type
    // code split
    TKDT17DD_Vec = packed array [0 .. KDT17DD_Axis - 1] of TKDT17DD_VecType;
    PKDT17DD_Vec = ^TKDT17DD_Vec;

    TKDT17DD_DynamicVecBuffer = array of TKDT17DD_Vec;
    PKDT17DD_DynamicVecBuffer = ^TKDT17DD_DynamicVecBuffer;

    TKDT17DD_Source = packed record
      Buff: TKDT17DD_Vec;
      index: Integer;
    end;

    PKDT17DD_Source       = ^TKDT17DD_Source;
    TKDT17DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT17DD_Source) - 1] of PKDT17DD_Source;
    PKDT17DD_SourceBuffer = ^TKDT17DD_SourceBuffer;

    TKDT17DDyanmicSourceBuffer = packed array of PKDT17DD_Source;
    PKDT17DDyanmicSourceBuffer = ^TKDT17DDyanmicSourceBuffer;

    TKDT17DDyanmicStoreBuffer = packed array of TKDT17DD_Source;
    PKDT17DDyanmicStoreBuffer = ^TKDT17DDyanmicStoreBuffer;

    PKDT17DD_Node = ^TKDT17DD_Node;

    TKDT17DD_Node = packed record
      Parent, Right, Left: PKDT17DD_Node;
      vec: PKDT17DD_Source;
    end;

    TKDT17DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT17DD_Source; const Data: Pointer);
    TKDT17DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT17DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT17DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT17DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT17DDyanmicStoreBuffer;
    KDBuff     : TKDT17DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT17DD_Node;
    TestBuff   : TKDT17DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DD_Node;
    function GetData(const index: NativeInt): PKDT17DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT17DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT17DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT17DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT17DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DD_Node; overload;
    function Search(const Buff: TKDT17DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DD_Node; overload;
    function Search(const Buff: TKDT17DD_Vec; var SearchedDistanceMin: Double): PKDT17DD_Node; overload;
    function Search(const Buff: TKDT17DD_Vec): PKDT17DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT17DD_DynamicVecBuffer; var OutBuff: TKDT17DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT17DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT17DD_Node);
    procedure PrintBuffer;

    class function KDT17DDVec(const s: SystemString): TKDT17DD_Vec; overload;
    class function KDT17DDVec(const v: TKDT17DD_Vec): SystemString; overload;
    class function KDT17DDPow(const v: TKDT17DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT17DDDistance(const v1, v2: TKDT17DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT17DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT18DD = class(TCoreClassObject)
  public type
    // code split
    TKDT18DD_Vec = packed array [0 .. KDT18DD_Axis - 1] of TKDT18DD_VecType;
    PKDT18DD_Vec = ^TKDT18DD_Vec;

    TKDT18DD_DynamicVecBuffer = array of TKDT18DD_Vec;
    PKDT18DD_DynamicVecBuffer = ^TKDT18DD_DynamicVecBuffer;

    TKDT18DD_Source = packed record
      Buff: TKDT18DD_Vec;
      index: Integer;
    end;

    PKDT18DD_Source       = ^TKDT18DD_Source;
    TKDT18DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT18DD_Source) - 1] of PKDT18DD_Source;
    PKDT18DD_SourceBuffer = ^TKDT18DD_SourceBuffer;

    TKDT18DDyanmicSourceBuffer = packed array of PKDT18DD_Source;
    PKDT18DDyanmicSourceBuffer = ^TKDT18DDyanmicSourceBuffer;

    TKDT18DDyanmicStoreBuffer = packed array of TKDT18DD_Source;
    PKDT18DDyanmicStoreBuffer = ^TKDT18DDyanmicStoreBuffer;

    PKDT18DD_Node = ^TKDT18DD_Node;

    TKDT18DD_Node = packed record
      Parent, Right, Left: PKDT18DD_Node;
      vec: PKDT18DD_Source;
    end;

    TKDT18DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT18DD_Source; const Data: Pointer);
    TKDT18DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT18DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT18DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT18DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT18DDyanmicStoreBuffer;
    KDBuff     : TKDT18DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT18DD_Node;
    TestBuff   : TKDT18DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DD_Node;
    function GetData(const index: NativeInt): PKDT18DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT18DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT18DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT18DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT18DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DD_Node; overload;
    function Search(const Buff: TKDT18DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DD_Node; overload;
    function Search(const Buff: TKDT18DD_Vec; var SearchedDistanceMin: Double): PKDT18DD_Node; overload;
    function Search(const Buff: TKDT18DD_Vec): PKDT18DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT18DD_DynamicVecBuffer; var OutBuff: TKDT18DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT18DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT18DD_Node);
    procedure PrintBuffer;

    class function KDT18DDVec(const s: SystemString): TKDT18DD_Vec; overload;
    class function KDT18DDVec(const v: TKDT18DD_Vec): SystemString; overload;
    class function KDT18DDPow(const v: TKDT18DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT18DDDistance(const v1, v2: TKDT18DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT18DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT19DD = class(TCoreClassObject)
  public type
    // code split
    TKDT19DD_Vec = packed array [0 .. KDT19DD_Axis - 1] of TKDT19DD_VecType;
    PKDT19DD_Vec = ^TKDT19DD_Vec;

    TKDT19DD_DynamicVecBuffer = array of TKDT19DD_Vec;
    PKDT19DD_DynamicVecBuffer = ^TKDT19DD_DynamicVecBuffer;

    TKDT19DD_Source = packed record
      Buff: TKDT19DD_Vec;
      index: Integer;
    end;

    PKDT19DD_Source       = ^TKDT19DD_Source;
    TKDT19DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT19DD_Source) - 1] of PKDT19DD_Source;
    PKDT19DD_SourceBuffer = ^TKDT19DD_SourceBuffer;

    TKDT19DDyanmicSourceBuffer = packed array of PKDT19DD_Source;
    PKDT19DDyanmicSourceBuffer = ^TKDT19DDyanmicSourceBuffer;

    TKDT19DDyanmicStoreBuffer = packed array of TKDT19DD_Source;
    PKDT19DDyanmicStoreBuffer = ^TKDT19DDyanmicStoreBuffer;

    PKDT19DD_Node = ^TKDT19DD_Node;

    TKDT19DD_Node = packed record
      Parent, Right, Left: PKDT19DD_Node;
      vec: PKDT19DD_Source;
    end;

    TKDT19DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT19DD_Source; const Data: Pointer);
    TKDT19DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT19DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT19DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT19DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT19DDyanmicStoreBuffer;
    KDBuff     : TKDT19DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT19DD_Node;
    TestBuff   : TKDT19DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DD_Node;
    function GetData(const index: NativeInt): PKDT19DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT19DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT19DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT19DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT19DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DD_Node; overload;
    function Search(const Buff: TKDT19DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DD_Node; overload;
    function Search(const Buff: TKDT19DD_Vec; var SearchedDistanceMin: Double): PKDT19DD_Node; overload;
    function Search(const Buff: TKDT19DD_Vec): PKDT19DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT19DD_DynamicVecBuffer; var OutBuff: TKDT19DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT19DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT19DD_Node);
    procedure PrintBuffer;

    class function KDT19DDVec(const s: SystemString): TKDT19DD_Vec; overload;
    class function KDT19DDVec(const v: TKDT19DD_Vec): SystemString; overload;
    class function KDT19DDPow(const v: TKDT19DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT19DDDistance(const v1, v2: TKDT19DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT19DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT20DD = class(TCoreClassObject)
  public type
    // code split
    TKDT20DD_Vec = packed array [0 .. KDT20DD_Axis - 1] of TKDT20DD_VecType;
    PKDT20DD_Vec = ^TKDT20DD_Vec;

    TKDT20DD_DynamicVecBuffer = array of TKDT20DD_Vec;
    PKDT20DD_DynamicVecBuffer = ^TKDT20DD_DynamicVecBuffer;

    TKDT20DD_Source = packed record
      Buff: TKDT20DD_Vec;
      index: Integer;
    end;

    PKDT20DD_Source       = ^TKDT20DD_Source;
    TKDT20DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT20DD_Source) - 1] of PKDT20DD_Source;
    PKDT20DD_SourceBuffer = ^TKDT20DD_SourceBuffer;

    TKDT20DDyanmicSourceBuffer = packed array of PKDT20DD_Source;
    PKDT20DDyanmicSourceBuffer = ^TKDT20DDyanmicSourceBuffer;

    TKDT20DDyanmicStoreBuffer = packed array of TKDT20DD_Source;
    PKDT20DDyanmicStoreBuffer = ^TKDT20DDyanmicStoreBuffer;

    PKDT20DD_Node = ^TKDT20DD_Node;

    TKDT20DD_Node = packed record
      Parent, Right, Left: PKDT20DD_Node;
      vec: PKDT20DD_Source;
    end;

    TKDT20DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT20DD_Source; const Data: Pointer);
    TKDT20DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT20DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT20DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT20DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT20DDyanmicStoreBuffer;
    KDBuff     : TKDT20DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT20DD_Node;
    TestBuff   : TKDT20DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DD_Node;
    function GetData(const index: NativeInt): PKDT20DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT20DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT20DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT20DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT20DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DD_Node; overload;
    function Search(const Buff: TKDT20DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DD_Node; overload;
    function Search(const Buff: TKDT20DD_Vec; var SearchedDistanceMin: Double): PKDT20DD_Node; overload;
    function Search(const Buff: TKDT20DD_Vec): PKDT20DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT20DD_DynamicVecBuffer; var OutBuff: TKDT20DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT20DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT20DD_Node);
    procedure PrintBuffer;

    class function KDT20DDVec(const s: SystemString): TKDT20DD_Vec; overload;
    class function KDT20DDVec(const v: TKDT20DD_Vec): SystemString; overload;
    class function KDT20DDPow(const v: TKDT20DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT20DDDistance(const v1, v2: TKDT20DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT20DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT21DD = class(TCoreClassObject)
  public type
    // code split
    TKDT21DD_Vec = packed array [0 .. KDT21DD_Axis - 1] of TKDT21DD_VecType;
    PKDT21DD_Vec = ^TKDT21DD_Vec;

    TKDT21DD_DynamicVecBuffer = array of TKDT21DD_Vec;
    PKDT21DD_DynamicVecBuffer = ^TKDT21DD_DynamicVecBuffer;

    TKDT21DD_Source = packed record
      Buff: TKDT21DD_Vec;
      index: Integer;
    end;

    PKDT21DD_Source       = ^TKDT21DD_Source;
    TKDT21DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT21DD_Source) - 1] of PKDT21DD_Source;
    PKDT21DD_SourceBuffer = ^TKDT21DD_SourceBuffer;

    TKDT21DDyanmicSourceBuffer = packed array of PKDT21DD_Source;
    PKDT21DDyanmicSourceBuffer = ^TKDT21DDyanmicSourceBuffer;

    TKDT21DDyanmicStoreBuffer = packed array of TKDT21DD_Source;
    PKDT21DDyanmicStoreBuffer = ^TKDT21DDyanmicStoreBuffer;

    PKDT21DD_Node = ^TKDT21DD_Node;

    TKDT21DD_Node = packed record
      Parent, Right, Left: PKDT21DD_Node;
      vec: PKDT21DD_Source;
    end;

    TKDT21DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT21DD_Source; const Data: Pointer);
    TKDT21DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT21DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT21DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT21DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT21DDyanmicStoreBuffer;
    KDBuff     : TKDT21DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT21DD_Node;
    TestBuff   : TKDT21DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DD_Node;
    function GetData(const index: NativeInt): PKDT21DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT21DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT21DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT21DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT21DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DD_Node; overload;
    function Search(const Buff: TKDT21DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DD_Node; overload;
    function Search(const Buff: TKDT21DD_Vec; var SearchedDistanceMin: Double): PKDT21DD_Node; overload;
    function Search(const Buff: TKDT21DD_Vec): PKDT21DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT21DD_DynamicVecBuffer; var OutBuff: TKDT21DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT21DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT21DD_Node);
    procedure PrintBuffer;

    class function KDT21DDVec(const s: SystemString): TKDT21DD_Vec; overload;
    class function KDT21DDVec(const v: TKDT21DD_Vec): SystemString; overload;
    class function KDT21DDPow(const v: TKDT21DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT21DDDistance(const v1, v2: TKDT21DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT21DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT22DD = class(TCoreClassObject)
  public type
    // code split
    TKDT22DD_Vec = packed array [0 .. KDT22DD_Axis - 1] of TKDT22DD_VecType;
    PKDT22DD_Vec = ^TKDT22DD_Vec;

    TKDT22DD_DynamicVecBuffer = array of TKDT22DD_Vec;
    PKDT22DD_DynamicVecBuffer = ^TKDT22DD_DynamicVecBuffer;

    TKDT22DD_Source = packed record
      Buff: TKDT22DD_Vec;
      index: Integer;
    end;

    PKDT22DD_Source       = ^TKDT22DD_Source;
    TKDT22DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT22DD_Source) - 1] of PKDT22DD_Source;
    PKDT22DD_SourceBuffer = ^TKDT22DD_SourceBuffer;

    TKDT22DDyanmicSourceBuffer = packed array of PKDT22DD_Source;
    PKDT22DDyanmicSourceBuffer = ^TKDT22DDyanmicSourceBuffer;

    TKDT22DDyanmicStoreBuffer = packed array of TKDT22DD_Source;
    PKDT22DDyanmicStoreBuffer = ^TKDT22DDyanmicStoreBuffer;

    PKDT22DD_Node = ^TKDT22DD_Node;

    TKDT22DD_Node = packed record
      Parent, Right, Left: PKDT22DD_Node;
      vec: PKDT22DD_Source;
    end;

    TKDT22DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT22DD_Source; const Data: Pointer);
    TKDT22DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT22DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT22DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT22DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT22DDyanmicStoreBuffer;
    KDBuff     : TKDT22DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT22DD_Node;
    TestBuff   : TKDT22DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DD_Node;
    function GetData(const index: NativeInt): PKDT22DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT22DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT22DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT22DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT22DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DD_Node; overload;
    function Search(const Buff: TKDT22DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DD_Node; overload;
    function Search(const Buff: TKDT22DD_Vec; var SearchedDistanceMin: Double): PKDT22DD_Node; overload;
    function Search(const Buff: TKDT22DD_Vec): PKDT22DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT22DD_DynamicVecBuffer; var OutBuff: TKDT22DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT22DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT22DD_Node);
    procedure PrintBuffer;

    class function KDT22DDVec(const s: SystemString): TKDT22DD_Vec; overload;
    class function KDT22DDVec(const v: TKDT22DD_Vec): SystemString; overload;
    class function KDT22DDPow(const v: TKDT22DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT22DDDistance(const v1, v2: TKDT22DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT22DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT23DD = class(TCoreClassObject)
  public type
    // code split
    TKDT23DD_Vec = packed array [0 .. KDT23DD_Axis - 1] of TKDT23DD_VecType;
    PKDT23DD_Vec = ^TKDT23DD_Vec;

    TKDT23DD_DynamicVecBuffer = array of TKDT23DD_Vec;
    PKDT23DD_DynamicVecBuffer = ^TKDT23DD_DynamicVecBuffer;

    TKDT23DD_Source = packed record
      Buff: TKDT23DD_Vec;
      index: Integer;
    end;

    PKDT23DD_Source       = ^TKDT23DD_Source;
    TKDT23DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT23DD_Source) - 1] of PKDT23DD_Source;
    PKDT23DD_SourceBuffer = ^TKDT23DD_SourceBuffer;

    TKDT23DDyanmicSourceBuffer = packed array of PKDT23DD_Source;
    PKDT23DDyanmicSourceBuffer = ^TKDT23DDyanmicSourceBuffer;

    TKDT23DDyanmicStoreBuffer = packed array of TKDT23DD_Source;
    PKDT23DDyanmicStoreBuffer = ^TKDT23DDyanmicStoreBuffer;

    PKDT23DD_Node = ^TKDT23DD_Node;

    TKDT23DD_Node = packed record
      Parent, Right, Left: PKDT23DD_Node;
      vec: PKDT23DD_Source;
    end;

    TKDT23DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT23DD_Source; const Data: Pointer);
    TKDT23DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT23DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT23DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT23DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT23DDyanmicStoreBuffer;
    KDBuff     : TKDT23DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT23DD_Node;
    TestBuff   : TKDT23DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DD_Node;
    function GetData(const index: NativeInt): PKDT23DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT23DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT23DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT23DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT23DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DD_Node; overload;
    function Search(const Buff: TKDT23DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DD_Node; overload;
    function Search(const Buff: TKDT23DD_Vec; var SearchedDistanceMin: Double): PKDT23DD_Node; overload;
    function Search(const Buff: TKDT23DD_Vec): PKDT23DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT23DD_DynamicVecBuffer; var OutBuff: TKDT23DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT23DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT23DD_Node);
    procedure PrintBuffer;

    class function KDT23DDVec(const s: SystemString): TKDT23DD_Vec; overload;
    class function KDT23DDVec(const v: TKDT23DD_Vec): SystemString; overload;
    class function KDT23DDPow(const v: TKDT23DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT23DDDistance(const v1, v2: TKDT23DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT23DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT24DD = class(TCoreClassObject)
  public type
    // code split
    TKDT24DD_Vec = packed array [0 .. KDT24DD_Axis - 1] of TKDT24DD_VecType;
    PKDT24DD_Vec = ^TKDT24DD_Vec;

    TKDT24DD_DynamicVecBuffer = array of TKDT24DD_Vec;
    PKDT24DD_DynamicVecBuffer = ^TKDT24DD_DynamicVecBuffer;

    TKDT24DD_Source = packed record
      Buff: TKDT24DD_Vec;
      index: Integer;
    end;

    PKDT24DD_Source       = ^TKDT24DD_Source;
    TKDT24DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT24DD_Source) - 1] of PKDT24DD_Source;
    PKDT24DD_SourceBuffer = ^TKDT24DD_SourceBuffer;

    TKDT24DDyanmicSourceBuffer = packed array of PKDT24DD_Source;
    PKDT24DDyanmicSourceBuffer = ^TKDT24DDyanmicSourceBuffer;

    TKDT24DDyanmicStoreBuffer = packed array of TKDT24DD_Source;
    PKDT24DDyanmicStoreBuffer = ^TKDT24DDyanmicStoreBuffer;

    PKDT24DD_Node = ^TKDT24DD_Node;

    TKDT24DD_Node = packed record
      Parent, Right, Left: PKDT24DD_Node;
      vec: PKDT24DD_Source;
    end;

    TKDT24DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT24DD_Source; const Data: Pointer);
    TKDT24DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT24DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT24DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT24DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT24DDyanmicStoreBuffer;
    KDBuff     : TKDT24DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT24DD_Node;
    TestBuff   : TKDT24DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DD_Node;
    function GetData(const index: NativeInt): PKDT24DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT24DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT24DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT24DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT24DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DD_Node; overload;
    function Search(const Buff: TKDT24DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DD_Node; overload;
    function Search(const Buff: TKDT24DD_Vec; var SearchedDistanceMin: Double): PKDT24DD_Node; overload;
    function Search(const Buff: TKDT24DD_Vec): PKDT24DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT24DD_DynamicVecBuffer; var OutBuff: TKDT24DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT24DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT24DD_Node);
    procedure PrintBuffer;

    class function KDT24DDVec(const s: SystemString): TKDT24DD_Vec; overload;
    class function KDT24DDVec(const v: TKDT24DD_Vec): SystemString; overload;
    class function KDT24DDPow(const v: TKDT24DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT24DDDistance(const v1, v2: TKDT24DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT24DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT25DD = class(TCoreClassObject)
  public type
    // code split
    TKDT25DD_Vec = packed array [0 .. KDT25DD_Axis - 1] of TKDT25DD_VecType;
    PKDT25DD_Vec = ^TKDT25DD_Vec;

    TKDT25DD_DynamicVecBuffer = array of TKDT25DD_Vec;
    PKDT25DD_DynamicVecBuffer = ^TKDT25DD_DynamicVecBuffer;

    TKDT25DD_Source = packed record
      Buff: TKDT25DD_Vec;
      index: Integer;
    end;

    PKDT25DD_Source       = ^TKDT25DD_Source;
    TKDT25DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT25DD_Source) - 1] of PKDT25DD_Source;
    PKDT25DD_SourceBuffer = ^TKDT25DD_SourceBuffer;

    TKDT25DDyanmicSourceBuffer = packed array of PKDT25DD_Source;
    PKDT25DDyanmicSourceBuffer = ^TKDT25DDyanmicSourceBuffer;

    TKDT25DDyanmicStoreBuffer = packed array of TKDT25DD_Source;
    PKDT25DDyanmicStoreBuffer = ^TKDT25DDyanmicStoreBuffer;

    PKDT25DD_Node = ^TKDT25DD_Node;

    TKDT25DD_Node = packed record
      Parent, Right, Left: PKDT25DD_Node;
      vec: PKDT25DD_Source;
    end;

    TKDT25DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT25DD_Source; const Data: Pointer);
    TKDT25DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT25DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT25DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT25DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT25DDyanmicStoreBuffer;
    KDBuff     : TKDT25DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT25DD_Node;
    TestBuff   : TKDT25DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT25DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT25DD_Node;
    function GetData(const index: NativeInt): PKDT25DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT25DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT25DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT25DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT25DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT25DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT25DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT25DD_Node; overload;
    function Search(const Buff: TKDT25DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT25DD_Node; overload;
    function Search(const Buff: TKDT25DD_Vec; var SearchedDistanceMin: Double): PKDT25DD_Node; overload;
    function Search(const Buff: TKDT25DD_Vec): PKDT25DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT25DD_DynamicVecBuffer; var OutBuff: TKDT25DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT25DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT25DD_Node);
    procedure PrintBuffer;

    class function KDT25DDVec(const s: SystemString): TKDT25DD_Vec; overload;
    class function KDT25DDVec(const v: TKDT25DD_Vec): SystemString; overload;
    class function KDT25DDPow(const v: TKDT25DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT25DDDistance(const v1, v2: TKDT25DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT25DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT26DD = class(TCoreClassObject)
  public type
    // code split
    TKDT26DD_Vec = packed array [0 .. KDT26DD_Axis - 1] of TKDT26DD_VecType;
    PKDT26DD_Vec = ^TKDT26DD_Vec;

    TKDT26DD_DynamicVecBuffer = array of TKDT26DD_Vec;
    PKDT26DD_DynamicVecBuffer = ^TKDT26DD_DynamicVecBuffer;

    TKDT26DD_Source = packed record
      Buff: TKDT26DD_Vec;
      index: Integer;
    end;

    PKDT26DD_Source       = ^TKDT26DD_Source;
    TKDT26DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT26DD_Source) - 1] of PKDT26DD_Source;
    PKDT26DD_SourceBuffer = ^TKDT26DD_SourceBuffer;

    TKDT26DDyanmicSourceBuffer = packed array of PKDT26DD_Source;
    PKDT26DDyanmicSourceBuffer = ^TKDT26DDyanmicSourceBuffer;

    TKDT26DDyanmicStoreBuffer = packed array of TKDT26DD_Source;
    PKDT26DDyanmicStoreBuffer = ^TKDT26DDyanmicStoreBuffer;

    PKDT26DD_Node = ^TKDT26DD_Node;

    TKDT26DD_Node = packed record
      Parent, Right, Left: PKDT26DD_Node;
      vec: PKDT26DD_Source;
    end;

    TKDT26DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT26DD_Source; const Data: Pointer);
    TKDT26DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT26DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT26DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT26DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT26DDyanmicStoreBuffer;
    KDBuff     : TKDT26DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT26DD_Node;
    TestBuff   : TKDT26DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT26DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT26DD_Node;
    function GetData(const index: NativeInt): PKDT26DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT26DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT26DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT26DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT26DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT26DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT26DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT26DD_Node; overload;
    function Search(const Buff: TKDT26DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT26DD_Node; overload;
    function Search(const Buff: TKDT26DD_Vec; var SearchedDistanceMin: Double): PKDT26DD_Node; overload;
    function Search(const Buff: TKDT26DD_Vec): PKDT26DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT26DD_DynamicVecBuffer; var OutBuff: TKDT26DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT26DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT26DD_Node);
    procedure PrintBuffer;

    class function KDT26DDVec(const s: SystemString): TKDT26DD_Vec; overload;
    class function KDT26DDVec(const v: TKDT26DD_Vec): SystemString; overload;
    class function KDT26DDPow(const v: TKDT26DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT26DDDistance(const v1, v2: TKDT26DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT26DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT27DD = class(TCoreClassObject)
  public type
    // code split
    TKDT27DD_Vec = packed array [0 .. KDT27DD_Axis - 1] of TKDT27DD_VecType;
    PKDT27DD_Vec = ^TKDT27DD_Vec;

    TKDT27DD_DynamicVecBuffer = array of TKDT27DD_Vec;
    PKDT27DD_DynamicVecBuffer = ^TKDT27DD_DynamicVecBuffer;

    TKDT27DD_Source = packed record
      Buff: TKDT27DD_Vec;
      index: Integer;
    end;

    PKDT27DD_Source       = ^TKDT27DD_Source;
    TKDT27DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT27DD_Source) - 1] of PKDT27DD_Source;
    PKDT27DD_SourceBuffer = ^TKDT27DD_SourceBuffer;

    TKDT27DDyanmicSourceBuffer = packed array of PKDT27DD_Source;
    PKDT27DDyanmicSourceBuffer = ^TKDT27DDyanmicSourceBuffer;

    TKDT27DDyanmicStoreBuffer = packed array of TKDT27DD_Source;
    PKDT27DDyanmicStoreBuffer = ^TKDT27DDyanmicStoreBuffer;

    PKDT27DD_Node = ^TKDT27DD_Node;

    TKDT27DD_Node = packed record
      Parent, Right, Left: PKDT27DD_Node;
      vec: PKDT27DD_Source;
    end;

    TKDT27DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT27DD_Source; const Data: Pointer);
    TKDT27DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT27DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT27DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT27DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT27DDyanmicStoreBuffer;
    KDBuff     : TKDT27DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT27DD_Node;
    TestBuff   : TKDT27DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT27DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT27DD_Node;
    function GetData(const index: NativeInt): PKDT27DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT27DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT27DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT27DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT27DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT27DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT27DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT27DD_Node; overload;
    function Search(const Buff: TKDT27DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT27DD_Node; overload;
    function Search(const Buff: TKDT27DD_Vec; var SearchedDistanceMin: Double): PKDT27DD_Node; overload;
    function Search(const Buff: TKDT27DD_Vec): PKDT27DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT27DD_DynamicVecBuffer; var OutBuff: TKDT27DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT27DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT27DD_Node);
    procedure PrintBuffer;

    class function KDT27DDVec(const s: SystemString): TKDT27DD_Vec; overload;
    class function KDT27DDVec(const v: TKDT27DD_Vec): SystemString; overload;
    class function KDT27DDPow(const v: TKDT27DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT27DDDistance(const v1, v2: TKDT27DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT27DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT28DD = class(TCoreClassObject)
  public type
    // code split
    TKDT28DD_Vec = packed array [0 .. KDT28DD_Axis - 1] of TKDT28DD_VecType;
    PKDT28DD_Vec = ^TKDT28DD_Vec;

    TKDT28DD_DynamicVecBuffer = array of TKDT28DD_Vec;
    PKDT28DD_DynamicVecBuffer = ^TKDT28DD_DynamicVecBuffer;

    TKDT28DD_Source = packed record
      Buff: TKDT28DD_Vec;
      index: Integer;
    end;

    PKDT28DD_Source       = ^TKDT28DD_Source;
    TKDT28DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT28DD_Source) - 1] of PKDT28DD_Source;
    PKDT28DD_SourceBuffer = ^TKDT28DD_SourceBuffer;

    TKDT28DDyanmicSourceBuffer = packed array of PKDT28DD_Source;
    PKDT28DDyanmicSourceBuffer = ^TKDT28DDyanmicSourceBuffer;

    TKDT28DDyanmicStoreBuffer = packed array of TKDT28DD_Source;
    PKDT28DDyanmicStoreBuffer = ^TKDT28DDyanmicStoreBuffer;

    PKDT28DD_Node = ^TKDT28DD_Node;

    TKDT28DD_Node = packed record
      Parent, Right, Left: PKDT28DD_Node;
      vec: PKDT28DD_Source;
    end;

    TKDT28DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT28DD_Source; const Data: Pointer);
    TKDT28DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT28DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT28DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT28DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT28DDyanmicStoreBuffer;
    KDBuff     : TKDT28DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT28DD_Node;
    TestBuff   : TKDT28DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DD_Node;
    function GetData(const index: NativeInt): PKDT28DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT28DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT28DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT28DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT28DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DD_Node; overload;
    function Search(const Buff: TKDT28DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DD_Node; overload;
    function Search(const Buff: TKDT28DD_Vec; var SearchedDistanceMin: Double): PKDT28DD_Node; overload;
    function Search(const Buff: TKDT28DD_Vec): PKDT28DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT28DD_DynamicVecBuffer; var OutBuff: TKDT28DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT28DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT28DD_Node);
    procedure PrintBuffer;

    class function KDT28DDVec(const s: SystemString): TKDT28DD_Vec; overload;
    class function KDT28DDVec(const v: TKDT28DD_Vec): SystemString; overload;
    class function KDT28DDPow(const v: TKDT28DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT28DDDistance(const v1, v2: TKDT28DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT28DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT29DD = class(TCoreClassObject)
  public type
    // code split
    TKDT29DD_Vec = packed array [0 .. KDT29DD_Axis - 1] of TKDT29DD_VecType;
    PKDT29DD_Vec = ^TKDT29DD_Vec;

    TKDT29DD_DynamicVecBuffer = array of TKDT29DD_Vec;
    PKDT29DD_DynamicVecBuffer = ^TKDT29DD_DynamicVecBuffer;

    TKDT29DD_Source = packed record
      Buff: TKDT29DD_Vec;
      index: Integer;
    end;

    PKDT29DD_Source       = ^TKDT29DD_Source;
    TKDT29DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT29DD_Source) - 1] of PKDT29DD_Source;
    PKDT29DD_SourceBuffer = ^TKDT29DD_SourceBuffer;

    TKDT29DDyanmicSourceBuffer = packed array of PKDT29DD_Source;
    PKDT29DDyanmicSourceBuffer = ^TKDT29DDyanmicSourceBuffer;

    TKDT29DDyanmicStoreBuffer = packed array of TKDT29DD_Source;
    PKDT29DDyanmicStoreBuffer = ^TKDT29DDyanmicStoreBuffer;

    PKDT29DD_Node = ^TKDT29DD_Node;

    TKDT29DD_Node = packed record
      Parent, Right, Left: PKDT29DD_Node;
      vec: PKDT29DD_Source;
    end;

    TKDT29DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT29DD_Source; const Data: Pointer);
    TKDT29DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT29DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT29DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT29DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT29DDyanmicStoreBuffer;
    KDBuff     : TKDT29DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT29DD_Node;
    TestBuff   : TKDT29DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT29DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT29DD_Node;
    function GetData(const index: NativeInt): PKDT29DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT29DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT29DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT29DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT29DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT29DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT29DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT29DD_Node; overload;
    function Search(const Buff: TKDT29DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT29DD_Node; overload;
    function Search(const Buff: TKDT29DD_Vec; var SearchedDistanceMin: Double): PKDT29DD_Node; overload;
    function Search(const Buff: TKDT29DD_Vec): PKDT29DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT29DD_DynamicVecBuffer; var OutBuff: TKDT29DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT29DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT29DD_Node);
    procedure PrintBuffer;

    class function KDT29DDVec(const s: SystemString): TKDT29DD_Vec; overload;
    class function KDT29DDVec(const v: TKDT29DD_Vec): SystemString; overload;
    class function KDT29DDPow(const v: TKDT29DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT29DDDistance(const v1, v2: TKDT29DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT29DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT30DD = class(TCoreClassObject)
  public type
    // code split
    TKDT30DD_Vec = packed array [0 .. KDT30DD_Axis - 1] of TKDT30DD_VecType;
    PKDT30DD_Vec = ^TKDT30DD_Vec;

    TKDT30DD_DynamicVecBuffer = array of TKDT30DD_Vec;
    PKDT30DD_DynamicVecBuffer = ^TKDT30DD_DynamicVecBuffer;

    TKDT30DD_Source = packed record
      Buff: TKDT30DD_Vec;
      index: Integer;
    end;

    PKDT30DD_Source       = ^TKDT30DD_Source;
    TKDT30DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT30DD_Source) - 1] of PKDT30DD_Source;
    PKDT30DD_SourceBuffer = ^TKDT30DD_SourceBuffer;

    TKDT30DDyanmicSourceBuffer = packed array of PKDT30DD_Source;
    PKDT30DDyanmicSourceBuffer = ^TKDT30DDyanmicSourceBuffer;

    TKDT30DDyanmicStoreBuffer = packed array of TKDT30DD_Source;
    PKDT30DDyanmicStoreBuffer = ^TKDT30DDyanmicStoreBuffer;

    PKDT30DD_Node = ^TKDT30DD_Node;

    TKDT30DD_Node = packed record
      Parent, Right, Left: PKDT30DD_Node;
      vec: PKDT30DD_Source;
    end;

    TKDT30DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT30DD_Source; const Data: Pointer);
    TKDT30DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT30DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT30DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT30DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT30DDyanmicStoreBuffer;
    KDBuff     : TKDT30DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT30DD_Node;
    TestBuff   : TKDT30DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DD_Node;
    function GetData(const index: NativeInt): PKDT30DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT30DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT30DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT30DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT30DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DD_Node; overload;
    function Search(const Buff: TKDT30DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DD_Node; overload;
    function Search(const Buff: TKDT30DD_Vec; var SearchedDistanceMin: Double): PKDT30DD_Node; overload;
    function Search(const Buff: TKDT30DD_Vec): PKDT30DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT30DD_DynamicVecBuffer; var OutBuff: TKDT30DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT30DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT30DD_Node);
    procedure PrintBuffer;

    class function KDT30DDVec(const s: SystemString): TKDT30DD_Vec; overload;
    class function KDT30DDVec(const v: TKDT30DD_Vec): SystemString; overload;
    class function KDT30DDPow(const v: TKDT30DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT30DDDistance(const v1, v2: TKDT30DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT30DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT31DD = class(TCoreClassObject)
  public type
    // code split
    TKDT31DD_Vec = packed array [0 .. KDT31DD_Axis - 1] of TKDT31DD_VecType;
    PKDT31DD_Vec = ^TKDT31DD_Vec;

    TKDT31DD_DynamicVecBuffer = array of TKDT31DD_Vec;
    PKDT31DD_DynamicVecBuffer = ^TKDT31DD_DynamicVecBuffer;

    TKDT31DD_Source = packed record
      Buff: TKDT31DD_Vec;
      index: Integer;
    end;

    PKDT31DD_Source       = ^TKDT31DD_Source;
    TKDT31DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT31DD_Source) - 1] of PKDT31DD_Source;
    PKDT31DD_SourceBuffer = ^TKDT31DD_SourceBuffer;

    TKDT31DDyanmicSourceBuffer = packed array of PKDT31DD_Source;
    PKDT31DDyanmicSourceBuffer = ^TKDT31DDyanmicSourceBuffer;

    TKDT31DDyanmicStoreBuffer = packed array of TKDT31DD_Source;
    PKDT31DDyanmicStoreBuffer = ^TKDT31DDyanmicStoreBuffer;

    PKDT31DD_Node = ^TKDT31DD_Node;

    TKDT31DD_Node = packed record
      Parent, Right, Left: PKDT31DD_Node;
      vec: PKDT31DD_Source;
    end;

    TKDT31DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT31DD_Source; const Data: Pointer);
    TKDT31DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT31DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT31DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT31DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT31DDyanmicStoreBuffer;
    KDBuff     : TKDT31DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT31DD_Node;
    TestBuff   : TKDT31DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT31DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT31DD_Node;
    function GetData(const index: NativeInt): PKDT31DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT31DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT31DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT31DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT31DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT31DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT31DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT31DD_Node; overload;
    function Search(const Buff: TKDT31DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT31DD_Node; overload;
    function Search(const Buff: TKDT31DD_Vec; var SearchedDistanceMin: Double): PKDT31DD_Node; overload;
    function Search(const Buff: TKDT31DD_Vec): PKDT31DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT31DD_DynamicVecBuffer; var OutBuff: TKDT31DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT31DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT31DD_Node);
    procedure PrintBuffer;

    class function KDT31DDVec(const s: SystemString): TKDT31DD_Vec; overload;
    class function KDT31DDVec(const v: TKDT31DD_Vec): SystemString; overload;
    class function KDT31DDPow(const v: TKDT31DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT31DDDistance(const v1, v2: TKDT31DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT31DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT32DD = class(TCoreClassObject)
  public type
    // code split
    TKDT32DD_Vec = packed array [0 .. KDT32DD_Axis - 1] of TKDT32DD_VecType;
    PKDT32DD_Vec = ^TKDT32DD_Vec;

    TKDT32DD_DynamicVecBuffer = array of TKDT32DD_Vec;
    PKDT32DD_DynamicVecBuffer = ^TKDT32DD_DynamicVecBuffer;

    TKDT32DD_Source = packed record
      Buff: TKDT32DD_Vec;
      index: Integer;
    end;

    PKDT32DD_Source       = ^TKDT32DD_Source;
    TKDT32DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT32DD_Source) - 1] of PKDT32DD_Source;
    PKDT32DD_SourceBuffer = ^TKDT32DD_SourceBuffer;

    TKDT32DDyanmicSourceBuffer = packed array of PKDT32DD_Source;
    PKDT32DDyanmicSourceBuffer = ^TKDT32DDyanmicSourceBuffer;

    TKDT32DDyanmicStoreBuffer = packed array of TKDT32DD_Source;
    PKDT32DDyanmicStoreBuffer = ^TKDT32DDyanmicStoreBuffer;

    PKDT32DD_Node = ^TKDT32DD_Node;

    TKDT32DD_Node = packed record
      Parent, Right, Left: PKDT32DD_Node;
      vec: PKDT32DD_Source;
    end;

    TKDT32DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT32DD_Source; const Data: Pointer);
    TKDT32DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT32DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT32DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT32DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT32DDyanmicStoreBuffer;
    KDBuff     : TKDT32DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT32DD_Node;
    TestBuff   : TKDT32DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DD_Node;
    function GetData(const index: NativeInt): PKDT32DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT32DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT32DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT32DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT32DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DD_Node; overload;
    function Search(const Buff: TKDT32DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DD_Node; overload;
    function Search(const Buff: TKDT32DD_Vec; var SearchedDistanceMin: Double): PKDT32DD_Node; overload;
    function Search(const Buff: TKDT32DD_Vec): PKDT32DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT32DD_DynamicVecBuffer; var OutBuff: TKDT32DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT32DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT32DD_Node);
    procedure PrintBuffer;

    class function KDT32DDVec(const s: SystemString): TKDT32DD_Vec; overload;
    class function KDT32DDVec(const v: TKDT32DD_Vec): SystemString; overload;
    class function KDT32DDPow(const v: TKDT32DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT32DDDistance(const v1, v2: TKDT32DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT32DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT33DD = class(TCoreClassObject)
  public type
    // code split
    TKDT33DD_Vec = packed array [0 .. KDT33DD_Axis - 1] of TKDT33DD_VecType;
    PKDT33DD_Vec = ^TKDT33DD_Vec;

    TKDT33DD_DynamicVecBuffer = array of TKDT33DD_Vec;
    PKDT33DD_DynamicVecBuffer = ^TKDT33DD_DynamicVecBuffer;

    TKDT33DD_Source = packed record
      Buff: TKDT33DD_Vec;
      index: Integer;
    end;

    PKDT33DD_Source       = ^TKDT33DD_Source;
    TKDT33DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT33DD_Source) - 1] of PKDT33DD_Source;
    PKDT33DD_SourceBuffer = ^TKDT33DD_SourceBuffer;

    TKDT33DDyanmicSourceBuffer = packed array of PKDT33DD_Source;
    PKDT33DDyanmicSourceBuffer = ^TKDT33DDyanmicSourceBuffer;

    TKDT33DDyanmicStoreBuffer = packed array of TKDT33DD_Source;
    PKDT33DDyanmicStoreBuffer = ^TKDT33DDyanmicStoreBuffer;

    PKDT33DD_Node = ^TKDT33DD_Node;

    TKDT33DD_Node = packed record
      Parent, Right, Left: PKDT33DD_Node;
      vec: PKDT33DD_Source;
    end;

    TKDT33DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT33DD_Source; const Data: Pointer);
    TKDT33DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT33DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT33DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT33DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT33DDyanmicStoreBuffer;
    KDBuff     : TKDT33DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT33DD_Node;
    TestBuff   : TKDT33DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT33DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT33DD_Node;
    function GetData(const index: NativeInt): PKDT33DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT33DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT33DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT33DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT33DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT33DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT33DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT33DD_Node; overload;
    function Search(const Buff: TKDT33DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT33DD_Node; overload;
    function Search(const Buff: TKDT33DD_Vec; var SearchedDistanceMin: Double): PKDT33DD_Node; overload;
    function Search(const Buff: TKDT33DD_Vec): PKDT33DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT33DD_DynamicVecBuffer; var OutBuff: TKDT33DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT33DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT33DD_Node);
    procedure PrintBuffer;

    class function KDT33DDVec(const s: SystemString): TKDT33DD_Vec; overload;
    class function KDT33DDVec(const v: TKDT33DD_Vec): SystemString; overload;
    class function KDT33DDPow(const v: TKDT33DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT33DDDistance(const v1, v2: TKDT33DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT33DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT34DD = class(TCoreClassObject)
  public type
    // code split
    TKDT34DD_Vec = packed array [0 .. KDT34DD_Axis - 1] of TKDT34DD_VecType;
    PKDT34DD_Vec = ^TKDT34DD_Vec;

    TKDT34DD_DynamicVecBuffer = array of TKDT34DD_Vec;
    PKDT34DD_DynamicVecBuffer = ^TKDT34DD_DynamicVecBuffer;

    TKDT34DD_Source = packed record
      Buff: TKDT34DD_Vec;
      index: Integer;
    end;

    PKDT34DD_Source       = ^TKDT34DD_Source;
    TKDT34DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT34DD_Source) - 1] of PKDT34DD_Source;
    PKDT34DD_SourceBuffer = ^TKDT34DD_SourceBuffer;

    TKDT34DDyanmicSourceBuffer = packed array of PKDT34DD_Source;
    PKDT34DDyanmicSourceBuffer = ^TKDT34DDyanmicSourceBuffer;

    TKDT34DDyanmicStoreBuffer = packed array of TKDT34DD_Source;
    PKDT34DDyanmicStoreBuffer = ^TKDT34DDyanmicStoreBuffer;

    PKDT34DD_Node = ^TKDT34DD_Node;

    TKDT34DD_Node = packed record
      Parent, Right, Left: PKDT34DD_Node;
      vec: PKDT34DD_Source;
    end;

    TKDT34DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT34DD_Source; const Data: Pointer);
    TKDT34DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT34DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT34DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT34DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT34DDyanmicStoreBuffer;
    KDBuff     : TKDT34DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT34DD_Node;
    TestBuff   : TKDT34DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DD_Node;
    function GetData(const index: NativeInt): PKDT34DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT34DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT34DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT34DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT34DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DD_Node; overload;
    function Search(const Buff: TKDT34DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DD_Node; overload;
    function Search(const Buff: TKDT34DD_Vec; var SearchedDistanceMin: Double): PKDT34DD_Node; overload;
    function Search(const Buff: TKDT34DD_Vec): PKDT34DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT34DD_DynamicVecBuffer; var OutBuff: TKDT34DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT34DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT34DD_Node);
    procedure PrintBuffer;

    class function KDT34DDVec(const s: SystemString): TKDT34DD_Vec; overload;
    class function KDT34DDVec(const v: TKDT34DD_Vec): SystemString; overload;
    class function KDT34DDPow(const v: TKDT34DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT34DDDistance(const v1, v2: TKDT34DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT34DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT35DD = class(TCoreClassObject)
  public type
    // code split
    TKDT35DD_Vec = packed array [0 .. KDT35DD_Axis - 1] of TKDT35DD_VecType;
    PKDT35DD_Vec = ^TKDT35DD_Vec;

    TKDT35DD_DynamicVecBuffer = array of TKDT35DD_Vec;
    PKDT35DD_DynamicVecBuffer = ^TKDT35DD_DynamicVecBuffer;

    TKDT35DD_Source = packed record
      Buff: TKDT35DD_Vec;
      index: Integer;
    end;

    PKDT35DD_Source       = ^TKDT35DD_Source;
    TKDT35DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT35DD_Source) - 1] of PKDT35DD_Source;
    PKDT35DD_SourceBuffer = ^TKDT35DD_SourceBuffer;

    TKDT35DDyanmicSourceBuffer = packed array of PKDT35DD_Source;
    PKDT35DDyanmicSourceBuffer = ^TKDT35DDyanmicSourceBuffer;

    TKDT35DDyanmicStoreBuffer = packed array of TKDT35DD_Source;
    PKDT35DDyanmicStoreBuffer = ^TKDT35DDyanmicStoreBuffer;

    PKDT35DD_Node = ^TKDT35DD_Node;

    TKDT35DD_Node = packed record
      Parent, Right, Left: PKDT35DD_Node;
      vec: PKDT35DD_Source;
    end;

    TKDT35DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT35DD_Source; const Data: Pointer);
    TKDT35DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT35DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT35DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT35DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT35DDyanmicStoreBuffer;
    KDBuff     : TKDT35DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT35DD_Node;
    TestBuff   : TKDT35DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT35DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT35DD_Node;
    function GetData(const index: NativeInt): PKDT35DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT35DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT35DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT35DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT35DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT35DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT35DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT35DD_Node; overload;
    function Search(const Buff: TKDT35DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT35DD_Node; overload;
    function Search(const Buff: TKDT35DD_Vec; var SearchedDistanceMin: Double): PKDT35DD_Node; overload;
    function Search(const Buff: TKDT35DD_Vec): PKDT35DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT35DD_DynamicVecBuffer; var OutBuff: TKDT35DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT35DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT35DD_Node);
    procedure PrintBuffer;

    class function KDT35DDVec(const s: SystemString): TKDT35DD_Vec; overload;
    class function KDT35DDVec(const v: TKDT35DD_Vec): SystemString; overload;
    class function KDT35DDPow(const v: TKDT35DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT35DDDistance(const v1, v2: TKDT35DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT35DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT36DD = class(TCoreClassObject)
  public type
    // code split
    TKDT36DD_Vec = packed array [0 .. KDT36DD_Axis - 1] of TKDT36DD_VecType;
    PKDT36DD_Vec = ^TKDT36DD_Vec;

    TKDT36DD_DynamicVecBuffer = array of TKDT36DD_Vec;
    PKDT36DD_DynamicVecBuffer = ^TKDT36DD_DynamicVecBuffer;

    TKDT36DD_Source = packed record
      Buff: TKDT36DD_Vec;
      index: Integer;
    end;

    PKDT36DD_Source       = ^TKDT36DD_Source;
    TKDT36DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT36DD_Source) - 1] of PKDT36DD_Source;
    PKDT36DD_SourceBuffer = ^TKDT36DD_SourceBuffer;

    TKDT36DDyanmicSourceBuffer = packed array of PKDT36DD_Source;
    PKDT36DDyanmicSourceBuffer = ^TKDT36DDyanmicSourceBuffer;

    TKDT36DDyanmicStoreBuffer = packed array of TKDT36DD_Source;
    PKDT36DDyanmicStoreBuffer = ^TKDT36DDyanmicStoreBuffer;

    PKDT36DD_Node = ^TKDT36DD_Node;

    TKDT36DD_Node = packed record
      Parent, Right, Left: PKDT36DD_Node;
      vec: PKDT36DD_Source;
    end;

    TKDT36DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT36DD_Source; const Data: Pointer);
    TKDT36DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT36DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT36DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT36DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT36DDyanmicStoreBuffer;
    KDBuff     : TKDT36DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT36DD_Node;
    TestBuff   : TKDT36DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DD_Node;
    function GetData(const index: NativeInt): PKDT36DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT36DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT36DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT36DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT36DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DD_Node; overload;
    function Search(const Buff: TKDT36DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DD_Node; overload;
    function Search(const Buff: TKDT36DD_Vec; var SearchedDistanceMin: Double): PKDT36DD_Node; overload;
    function Search(const Buff: TKDT36DD_Vec): PKDT36DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT36DD_DynamicVecBuffer; var OutBuff: TKDT36DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT36DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT36DD_Node);
    procedure PrintBuffer;

    class function KDT36DDVec(const s: SystemString): TKDT36DD_Vec; overload;
    class function KDT36DDVec(const v: TKDT36DD_Vec): SystemString; overload;
    class function KDT36DDPow(const v: TKDT36DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT36DDDistance(const v1, v2: TKDT36DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT36DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT37DD = class(TCoreClassObject)
  public type
    // code split
    TKDT37DD_Vec = packed array [0 .. KDT37DD_Axis - 1] of TKDT37DD_VecType;
    PKDT37DD_Vec = ^TKDT37DD_Vec;

    TKDT37DD_DynamicVecBuffer = array of TKDT37DD_Vec;
    PKDT37DD_DynamicVecBuffer = ^TKDT37DD_DynamicVecBuffer;

    TKDT37DD_Source = packed record
      Buff: TKDT37DD_Vec;
      index: Integer;
    end;

    PKDT37DD_Source       = ^TKDT37DD_Source;
    TKDT37DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT37DD_Source) - 1] of PKDT37DD_Source;
    PKDT37DD_SourceBuffer = ^TKDT37DD_SourceBuffer;

    TKDT37DDyanmicSourceBuffer = packed array of PKDT37DD_Source;
    PKDT37DDyanmicSourceBuffer = ^TKDT37DDyanmicSourceBuffer;

    TKDT37DDyanmicStoreBuffer = packed array of TKDT37DD_Source;
    PKDT37DDyanmicStoreBuffer = ^TKDT37DDyanmicStoreBuffer;

    PKDT37DD_Node = ^TKDT37DD_Node;

    TKDT37DD_Node = packed record
      Parent, Right, Left: PKDT37DD_Node;
      vec: PKDT37DD_Source;
    end;

    TKDT37DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT37DD_Source; const Data: Pointer);
    TKDT37DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT37DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT37DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT37DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT37DDyanmicStoreBuffer;
    KDBuff     : TKDT37DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT37DD_Node;
    TestBuff   : TKDT37DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT37DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT37DD_Node;
    function GetData(const index: NativeInt): PKDT37DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT37DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT37DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT37DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT37DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT37DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT37DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT37DD_Node; overload;
    function Search(const Buff: TKDT37DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT37DD_Node; overload;
    function Search(const Buff: TKDT37DD_Vec; var SearchedDistanceMin: Double): PKDT37DD_Node; overload;
    function Search(const Buff: TKDT37DD_Vec): PKDT37DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT37DD_DynamicVecBuffer; var OutBuff: TKDT37DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT37DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT37DD_Node);
    procedure PrintBuffer;

    class function KDT37DDVec(const s: SystemString): TKDT37DD_Vec; overload;
    class function KDT37DDVec(const v: TKDT37DD_Vec): SystemString; overload;
    class function KDT37DDPow(const v: TKDT37DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT37DDDistance(const v1, v2: TKDT37DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT37DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT38DD = class(TCoreClassObject)
  public type
    // code split
    TKDT38DD_Vec = packed array [0 .. KDT38DD_Axis - 1] of TKDT38DD_VecType;
    PKDT38DD_Vec = ^TKDT38DD_Vec;

    TKDT38DD_DynamicVecBuffer = array of TKDT38DD_Vec;
    PKDT38DD_DynamicVecBuffer = ^TKDT38DD_DynamicVecBuffer;

    TKDT38DD_Source = packed record
      Buff: TKDT38DD_Vec;
      index: Integer;
    end;

    PKDT38DD_Source       = ^TKDT38DD_Source;
    TKDT38DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT38DD_Source) - 1] of PKDT38DD_Source;
    PKDT38DD_SourceBuffer = ^TKDT38DD_SourceBuffer;

    TKDT38DDyanmicSourceBuffer = packed array of PKDT38DD_Source;
    PKDT38DDyanmicSourceBuffer = ^TKDT38DDyanmicSourceBuffer;

    TKDT38DDyanmicStoreBuffer = packed array of TKDT38DD_Source;
    PKDT38DDyanmicStoreBuffer = ^TKDT38DDyanmicStoreBuffer;

    PKDT38DD_Node = ^TKDT38DD_Node;

    TKDT38DD_Node = packed record
      Parent, Right, Left: PKDT38DD_Node;
      vec: PKDT38DD_Source;
    end;

    TKDT38DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT38DD_Source; const Data: Pointer);
    TKDT38DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT38DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT38DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT38DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT38DDyanmicStoreBuffer;
    KDBuff     : TKDT38DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT38DD_Node;
    TestBuff   : TKDT38DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT38DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT38DD_Node;
    function GetData(const index: NativeInt): PKDT38DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT38DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT38DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT38DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT38DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT38DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT38DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT38DD_Node; overload;
    function Search(const Buff: TKDT38DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT38DD_Node; overload;
    function Search(const Buff: TKDT38DD_Vec; var SearchedDistanceMin: Double): PKDT38DD_Node; overload;
    function Search(const Buff: TKDT38DD_Vec): PKDT38DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT38DD_DynamicVecBuffer; var OutBuff: TKDT38DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT38DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT38DD_Node);
    procedure PrintBuffer;

    class function KDT38DDVec(const s: SystemString): TKDT38DD_Vec; overload;
    class function KDT38DDVec(const v: TKDT38DD_Vec): SystemString; overload;
    class function KDT38DDPow(const v: TKDT38DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT38DDDistance(const v1, v2: TKDT38DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT38DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT39DD = class(TCoreClassObject)
  public type
    // code split
    TKDT39DD_Vec = packed array [0 .. KDT39DD_Axis - 1] of TKDT39DD_VecType;
    PKDT39DD_Vec = ^TKDT39DD_Vec;

    TKDT39DD_DynamicVecBuffer = array of TKDT39DD_Vec;
    PKDT39DD_DynamicVecBuffer = ^TKDT39DD_DynamicVecBuffer;

    TKDT39DD_Source = packed record
      Buff: TKDT39DD_Vec;
      index: Integer;
    end;

    PKDT39DD_Source       = ^TKDT39DD_Source;
    TKDT39DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT39DD_Source) - 1] of PKDT39DD_Source;
    PKDT39DD_SourceBuffer = ^TKDT39DD_SourceBuffer;

    TKDT39DDyanmicSourceBuffer = packed array of PKDT39DD_Source;
    PKDT39DDyanmicSourceBuffer = ^TKDT39DDyanmicSourceBuffer;

    TKDT39DDyanmicStoreBuffer = packed array of TKDT39DD_Source;
    PKDT39DDyanmicStoreBuffer = ^TKDT39DDyanmicStoreBuffer;

    PKDT39DD_Node = ^TKDT39DD_Node;

    TKDT39DD_Node = packed record
      Parent, Right, Left: PKDT39DD_Node;
      vec: PKDT39DD_Source;
    end;

    TKDT39DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT39DD_Source; const Data: Pointer);
    TKDT39DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT39DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT39DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT39DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT39DDyanmicStoreBuffer;
    KDBuff     : TKDT39DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT39DD_Node;
    TestBuff   : TKDT39DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT39DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT39DD_Node;
    function GetData(const index: NativeInt): PKDT39DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT39DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT39DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT39DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT39DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT39DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT39DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT39DD_Node; overload;
    function Search(const Buff: TKDT39DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT39DD_Node; overload;
    function Search(const Buff: TKDT39DD_Vec; var SearchedDistanceMin: Double): PKDT39DD_Node; overload;
    function Search(const Buff: TKDT39DD_Vec): PKDT39DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT39DD_DynamicVecBuffer; var OutBuff: TKDT39DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT39DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT39DD_Node);
    procedure PrintBuffer;

    class function KDT39DDVec(const s: SystemString): TKDT39DD_Vec; overload;
    class function KDT39DDVec(const v: TKDT39DD_Vec): SystemString; overload;
    class function KDT39DDPow(const v: TKDT39DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT39DDDistance(const v1, v2: TKDT39DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT39DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT40DD = class(TCoreClassObject)
  public type
    // code split
    TKDT40DD_Vec = packed array [0 .. KDT40DD_Axis - 1] of TKDT40DD_VecType;
    PKDT40DD_Vec = ^TKDT40DD_Vec;

    TKDT40DD_DynamicVecBuffer = array of TKDT40DD_Vec;
    PKDT40DD_DynamicVecBuffer = ^TKDT40DD_DynamicVecBuffer;

    TKDT40DD_Source = packed record
      Buff: TKDT40DD_Vec;
      index: Integer;
    end;

    PKDT40DD_Source       = ^TKDT40DD_Source;
    TKDT40DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT40DD_Source) - 1] of PKDT40DD_Source;
    PKDT40DD_SourceBuffer = ^TKDT40DD_SourceBuffer;

    TKDT40DDyanmicSourceBuffer = packed array of PKDT40DD_Source;
    PKDT40DDyanmicSourceBuffer = ^TKDT40DDyanmicSourceBuffer;

    TKDT40DDyanmicStoreBuffer = packed array of TKDT40DD_Source;
    PKDT40DDyanmicStoreBuffer = ^TKDT40DDyanmicStoreBuffer;

    PKDT40DD_Node = ^TKDT40DD_Node;

    TKDT40DD_Node = packed record
      Parent, Right, Left: PKDT40DD_Node;
      vec: PKDT40DD_Source;
    end;

    TKDT40DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT40DD_Source; const Data: Pointer);
    TKDT40DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT40DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT40DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT40DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT40DDyanmicStoreBuffer;
    KDBuff     : TKDT40DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT40DD_Node;
    TestBuff   : TKDT40DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DD_Node;
    function GetData(const index: NativeInt): PKDT40DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT40DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT40DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT40DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT40DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DD_Node; overload;
    function Search(const Buff: TKDT40DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DD_Node; overload;
    function Search(const Buff: TKDT40DD_Vec; var SearchedDistanceMin: Double): PKDT40DD_Node; overload;
    function Search(const Buff: TKDT40DD_Vec): PKDT40DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT40DD_DynamicVecBuffer; var OutBuff: TKDT40DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT40DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT40DD_Node);
    procedure PrintBuffer;

    class function KDT40DDVec(const s: SystemString): TKDT40DD_Vec; overload;
    class function KDT40DDVec(const v: TKDT40DD_Vec): SystemString; overload;
    class function KDT40DDPow(const v: TKDT40DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT40DDDistance(const v1, v2: TKDT40DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT40DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT41DD = class(TCoreClassObject)
  public type
    // code split
    TKDT41DD_Vec = packed array [0 .. KDT41DD_Axis - 1] of TKDT41DD_VecType;
    PKDT41DD_Vec = ^TKDT41DD_Vec;

    TKDT41DD_DynamicVecBuffer = array of TKDT41DD_Vec;
    PKDT41DD_DynamicVecBuffer = ^TKDT41DD_DynamicVecBuffer;

    TKDT41DD_Source = packed record
      Buff: TKDT41DD_Vec;
      index: Integer;
    end;

    PKDT41DD_Source       = ^TKDT41DD_Source;
    TKDT41DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT41DD_Source) - 1] of PKDT41DD_Source;
    PKDT41DD_SourceBuffer = ^TKDT41DD_SourceBuffer;

    TKDT41DDyanmicSourceBuffer = packed array of PKDT41DD_Source;
    PKDT41DDyanmicSourceBuffer = ^TKDT41DDyanmicSourceBuffer;

    TKDT41DDyanmicStoreBuffer = packed array of TKDT41DD_Source;
    PKDT41DDyanmicStoreBuffer = ^TKDT41DDyanmicStoreBuffer;

    PKDT41DD_Node = ^TKDT41DD_Node;

    TKDT41DD_Node = packed record
      Parent, Right, Left: PKDT41DD_Node;
      vec: PKDT41DD_Source;
    end;

    TKDT41DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT41DD_Source; const Data: Pointer);
    TKDT41DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT41DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT41DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT41DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT41DDyanmicStoreBuffer;
    KDBuff     : TKDT41DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT41DD_Node;
    TestBuff   : TKDT41DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT41DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT41DD_Node;
    function GetData(const index: NativeInt): PKDT41DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT41DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT41DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT41DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT41DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT41DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT41DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT41DD_Node; overload;
    function Search(const Buff: TKDT41DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT41DD_Node; overload;
    function Search(const Buff: TKDT41DD_Vec; var SearchedDistanceMin: Double): PKDT41DD_Node; overload;
    function Search(const Buff: TKDT41DD_Vec): PKDT41DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT41DD_DynamicVecBuffer; var OutBuff: TKDT41DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT41DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT41DD_Node);
    procedure PrintBuffer;

    class function KDT41DDVec(const s: SystemString): TKDT41DD_Vec; overload;
    class function KDT41DDVec(const v: TKDT41DD_Vec): SystemString; overload;
    class function KDT41DDPow(const v: TKDT41DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT41DDDistance(const v1, v2: TKDT41DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT41DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT42DD = class(TCoreClassObject)
  public type
    // code split
    TKDT42DD_Vec = packed array [0 .. KDT42DD_Axis - 1] of TKDT42DD_VecType;
    PKDT42DD_Vec = ^TKDT42DD_Vec;

    TKDT42DD_DynamicVecBuffer = array of TKDT42DD_Vec;
    PKDT42DD_DynamicVecBuffer = ^TKDT42DD_DynamicVecBuffer;

    TKDT42DD_Source = packed record
      Buff: TKDT42DD_Vec;
      index: Integer;
    end;

    PKDT42DD_Source       = ^TKDT42DD_Source;
    TKDT42DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT42DD_Source) - 1] of PKDT42DD_Source;
    PKDT42DD_SourceBuffer = ^TKDT42DD_SourceBuffer;

    TKDT42DDyanmicSourceBuffer = packed array of PKDT42DD_Source;
    PKDT42DDyanmicSourceBuffer = ^TKDT42DDyanmicSourceBuffer;

    TKDT42DDyanmicStoreBuffer = packed array of TKDT42DD_Source;
    PKDT42DDyanmicStoreBuffer = ^TKDT42DDyanmicStoreBuffer;

    PKDT42DD_Node = ^TKDT42DD_Node;

    TKDT42DD_Node = packed record
      Parent, Right, Left: PKDT42DD_Node;
      vec: PKDT42DD_Source;
    end;

    TKDT42DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT42DD_Source; const Data: Pointer);
    TKDT42DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT42DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT42DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT42DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT42DDyanmicStoreBuffer;
    KDBuff     : TKDT42DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT42DD_Node;
    TestBuff   : TKDT42DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT42DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT42DD_Node;
    function GetData(const index: NativeInt): PKDT42DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT42DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT42DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT42DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT42DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT42DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT42DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT42DD_Node; overload;
    function Search(const Buff: TKDT42DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT42DD_Node; overload;
    function Search(const Buff: TKDT42DD_Vec; var SearchedDistanceMin: Double): PKDT42DD_Node; overload;
    function Search(const Buff: TKDT42DD_Vec): PKDT42DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT42DD_DynamicVecBuffer; var OutBuff: TKDT42DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT42DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT42DD_Node);
    procedure PrintBuffer;

    class function KDT42DDVec(const s: SystemString): TKDT42DD_Vec; overload;
    class function KDT42DDVec(const v: TKDT42DD_Vec): SystemString; overload;
    class function KDT42DDPow(const v: TKDT42DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT42DDDistance(const v1, v2: TKDT42DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT42DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT43DD = class(TCoreClassObject)
  public type
    // code split
    TKDT43DD_Vec = packed array [0 .. KDT43DD_Axis - 1] of TKDT43DD_VecType;
    PKDT43DD_Vec = ^TKDT43DD_Vec;

    TKDT43DD_DynamicVecBuffer = array of TKDT43DD_Vec;
    PKDT43DD_DynamicVecBuffer = ^TKDT43DD_DynamicVecBuffer;

    TKDT43DD_Source = packed record
      Buff: TKDT43DD_Vec;
      index: Integer;
    end;

    PKDT43DD_Source       = ^TKDT43DD_Source;
    TKDT43DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT43DD_Source) - 1] of PKDT43DD_Source;
    PKDT43DD_SourceBuffer = ^TKDT43DD_SourceBuffer;

    TKDT43DDyanmicSourceBuffer = packed array of PKDT43DD_Source;
    PKDT43DDyanmicSourceBuffer = ^TKDT43DDyanmicSourceBuffer;

    TKDT43DDyanmicStoreBuffer = packed array of TKDT43DD_Source;
    PKDT43DDyanmicStoreBuffer = ^TKDT43DDyanmicStoreBuffer;

    PKDT43DD_Node = ^TKDT43DD_Node;

    TKDT43DD_Node = packed record
      Parent, Right, Left: PKDT43DD_Node;
      vec: PKDT43DD_Source;
    end;

    TKDT43DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT43DD_Source; const Data: Pointer);
    TKDT43DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT43DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT43DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT43DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT43DDyanmicStoreBuffer;
    KDBuff     : TKDT43DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT43DD_Node;
    TestBuff   : TKDT43DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT43DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT43DD_Node;
    function GetData(const index: NativeInt): PKDT43DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT43DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT43DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT43DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT43DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT43DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT43DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT43DD_Node; overload;
    function Search(const Buff: TKDT43DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT43DD_Node; overload;
    function Search(const Buff: TKDT43DD_Vec; var SearchedDistanceMin: Double): PKDT43DD_Node; overload;
    function Search(const Buff: TKDT43DD_Vec): PKDT43DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT43DD_DynamicVecBuffer; var OutBuff: TKDT43DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT43DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT43DD_Node);
    procedure PrintBuffer;

    class function KDT43DDVec(const s: SystemString): TKDT43DD_Vec; overload;
    class function KDT43DDVec(const v: TKDT43DD_Vec): SystemString; overload;
    class function KDT43DDPow(const v: TKDT43DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT43DDDistance(const v1, v2: TKDT43DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT43DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT44DD = class(TCoreClassObject)
  public type
    // code split
    TKDT44DD_Vec = packed array [0 .. KDT44DD_Axis - 1] of TKDT44DD_VecType;
    PKDT44DD_Vec = ^TKDT44DD_Vec;

    TKDT44DD_DynamicVecBuffer = array of TKDT44DD_Vec;
    PKDT44DD_DynamicVecBuffer = ^TKDT44DD_DynamicVecBuffer;

    TKDT44DD_Source = packed record
      Buff: TKDT44DD_Vec;
      index: Integer;
    end;

    PKDT44DD_Source       = ^TKDT44DD_Source;
    TKDT44DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT44DD_Source) - 1] of PKDT44DD_Source;
    PKDT44DD_SourceBuffer = ^TKDT44DD_SourceBuffer;

    TKDT44DDyanmicSourceBuffer = packed array of PKDT44DD_Source;
    PKDT44DDyanmicSourceBuffer = ^TKDT44DDyanmicSourceBuffer;

    TKDT44DDyanmicStoreBuffer = packed array of TKDT44DD_Source;
    PKDT44DDyanmicStoreBuffer = ^TKDT44DDyanmicStoreBuffer;

    PKDT44DD_Node = ^TKDT44DD_Node;

    TKDT44DD_Node = packed record
      Parent, Right, Left: PKDT44DD_Node;
      vec: PKDT44DD_Source;
    end;

    TKDT44DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT44DD_Source; const Data: Pointer);
    TKDT44DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT44DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT44DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT44DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT44DDyanmicStoreBuffer;
    KDBuff     : TKDT44DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT44DD_Node;
    TestBuff   : TKDT44DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT44DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT44DD_Node;
    function GetData(const index: NativeInt): PKDT44DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT44DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT44DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT44DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT44DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT44DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT44DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT44DD_Node; overload;
    function Search(const Buff: TKDT44DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT44DD_Node; overload;
    function Search(const Buff: TKDT44DD_Vec; var SearchedDistanceMin: Double): PKDT44DD_Node; overload;
    function Search(const Buff: TKDT44DD_Vec): PKDT44DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT44DD_DynamicVecBuffer; var OutBuff: TKDT44DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT44DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT44DD_Node);
    procedure PrintBuffer;

    class function KDT44DDVec(const s: SystemString): TKDT44DD_Vec; overload;
    class function KDT44DDVec(const v: TKDT44DD_Vec): SystemString; overload;
    class function KDT44DDPow(const v: TKDT44DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT44DDDistance(const v1, v2: TKDT44DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT44DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT45DD = class(TCoreClassObject)
  public type
    // code split
    TKDT45DD_Vec = packed array [0 .. KDT45DD_Axis - 1] of TKDT45DD_VecType;
    PKDT45DD_Vec = ^TKDT45DD_Vec;

    TKDT45DD_DynamicVecBuffer = array of TKDT45DD_Vec;
    PKDT45DD_DynamicVecBuffer = ^TKDT45DD_DynamicVecBuffer;

    TKDT45DD_Source = packed record
      Buff: TKDT45DD_Vec;
      index: Integer;
    end;

    PKDT45DD_Source       = ^TKDT45DD_Source;
    TKDT45DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT45DD_Source) - 1] of PKDT45DD_Source;
    PKDT45DD_SourceBuffer = ^TKDT45DD_SourceBuffer;

    TKDT45DDyanmicSourceBuffer = packed array of PKDT45DD_Source;
    PKDT45DDyanmicSourceBuffer = ^TKDT45DDyanmicSourceBuffer;

    TKDT45DDyanmicStoreBuffer = packed array of TKDT45DD_Source;
    PKDT45DDyanmicStoreBuffer = ^TKDT45DDyanmicStoreBuffer;

    PKDT45DD_Node = ^TKDT45DD_Node;

    TKDT45DD_Node = packed record
      Parent, Right, Left: PKDT45DD_Node;
      vec: PKDT45DD_Source;
    end;

    TKDT45DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT45DD_Source; const Data: Pointer);
    TKDT45DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT45DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT45DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT45DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT45DDyanmicStoreBuffer;
    KDBuff     : TKDT45DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT45DD_Node;
    TestBuff   : TKDT45DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT45DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT45DD_Node;
    function GetData(const index: NativeInt): PKDT45DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT45DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT45DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT45DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT45DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT45DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT45DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT45DD_Node; overload;
    function Search(const Buff: TKDT45DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT45DD_Node; overload;
    function Search(const Buff: TKDT45DD_Vec; var SearchedDistanceMin: Double): PKDT45DD_Node; overload;
    function Search(const Buff: TKDT45DD_Vec): PKDT45DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT45DD_DynamicVecBuffer; var OutBuff: TKDT45DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT45DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT45DD_Node);
    procedure PrintBuffer;

    class function KDT45DDVec(const s: SystemString): TKDT45DD_Vec; overload;
    class function KDT45DDVec(const v: TKDT45DD_Vec): SystemString; overload;
    class function KDT45DDPow(const v: TKDT45DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT45DDDistance(const v1, v2: TKDT45DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT45DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT46DD = class(TCoreClassObject)
  public type
    // code split
    TKDT46DD_Vec = packed array [0 .. KDT46DD_Axis - 1] of TKDT46DD_VecType;
    PKDT46DD_Vec = ^TKDT46DD_Vec;

    TKDT46DD_DynamicVecBuffer = array of TKDT46DD_Vec;
    PKDT46DD_DynamicVecBuffer = ^TKDT46DD_DynamicVecBuffer;

    TKDT46DD_Source = packed record
      Buff: TKDT46DD_Vec;
      index: Integer;
    end;

    PKDT46DD_Source       = ^TKDT46DD_Source;
    TKDT46DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT46DD_Source) - 1] of PKDT46DD_Source;
    PKDT46DD_SourceBuffer = ^TKDT46DD_SourceBuffer;

    TKDT46DDyanmicSourceBuffer = packed array of PKDT46DD_Source;
    PKDT46DDyanmicSourceBuffer = ^TKDT46DDyanmicSourceBuffer;

    TKDT46DDyanmicStoreBuffer = packed array of TKDT46DD_Source;
    PKDT46DDyanmicStoreBuffer = ^TKDT46DDyanmicStoreBuffer;

    PKDT46DD_Node = ^TKDT46DD_Node;

    TKDT46DD_Node = packed record
      Parent, Right, Left: PKDT46DD_Node;
      vec: PKDT46DD_Source;
    end;

    TKDT46DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT46DD_Source; const Data: Pointer);
    TKDT46DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT46DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT46DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT46DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT46DDyanmicStoreBuffer;
    KDBuff     : TKDT46DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT46DD_Node;
    TestBuff   : TKDT46DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT46DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT46DD_Node;
    function GetData(const index: NativeInt): PKDT46DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT46DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT46DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT46DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT46DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT46DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT46DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT46DD_Node; overload;
    function Search(const Buff: TKDT46DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT46DD_Node; overload;
    function Search(const Buff: TKDT46DD_Vec; var SearchedDistanceMin: Double): PKDT46DD_Node; overload;
    function Search(const Buff: TKDT46DD_Vec): PKDT46DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT46DD_DynamicVecBuffer; var OutBuff: TKDT46DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT46DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT46DD_Node);
    procedure PrintBuffer;

    class function KDT46DDVec(const s: SystemString): TKDT46DD_Vec; overload;
    class function KDT46DDVec(const v: TKDT46DD_Vec): SystemString; overload;
    class function KDT46DDPow(const v: TKDT46DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT46DDDistance(const v1, v2: TKDT46DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT46DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT47DD = class(TCoreClassObject)
  public type
    // code split
    TKDT47DD_Vec = packed array [0 .. KDT47DD_Axis - 1] of TKDT47DD_VecType;
    PKDT47DD_Vec = ^TKDT47DD_Vec;

    TKDT47DD_DynamicVecBuffer = array of TKDT47DD_Vec;
    PKDT47DD_DynamicVecBuffer = ^TKDT47DD_DynamicVecBuffer;

    TKDT47DD_Source = packed record
      Buff: TKDT47DD_Vec;
      index: Integer;
    end;

    PKDT47DD_Source       = ^TKDT47DD_Source;
    TKDT47DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT47DD_Source) - 1] of PKDT47DD_Source;
    PKDT47DD_SourceBuffer = ^TKDT47DD_SourceBuffer;

    TKDT47DDyanmicSourceBuffer = packed array of PKDT47DD_Source;
    PKDT47DDyanmicSourceBuffer = ^TKDT47DDyanmicSourceBuffer;

    TKDT47DDyanmicStoreBuffer = packed array of TKDT47DD_Source;
    PKDT47DDyanmicStoreBuffer = ^TKDT47DDyanmicStoreBuffer;

    PKDT47DD_Node = ^TKDT47DD_Node;

    TKDT47DD_Node = packed record
      Parent, Right, Left: PKDT47DD_Node;
      vec: PKDT47DD_Source;
    end;

    TKDT47DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT47DD_Source; const Data: Pointer);
    TKDT47DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT47DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT47DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT47DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT47DDyanmicStoreBuffer;
    KDBuff     : TKDT47DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT47DD_Node;
    TestBuff   : TKDT47DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT47DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT47DD_Node;
    function GetData(const index: NativeInt): PKDT47DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT47DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT47DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT47DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT47DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT47DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT47DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT47DD_Node; overload;
    function Search(const Buff: TKDT47DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT47DD_Node; overload;
    function Search(const Buff: TKDT47DD_Vec; var SearchedDistanceMin: Double): PKDT47DD_Node; overload;
    function Search(const Buff: TKDT47DD_Vec): PKDT47DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT47DD_DynamicVecBuffer; var OutBuff: TKDT47DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT47DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT47DD_Node);
    procedure PrintBuffer;

    class function KDT47DDVec(const s: SystemString): TKDT47DD_Vec; overload;
    class function KDT47DDVec(const v: TKDT47DD_Vec): SystemString; overload;
    class function KDT47DDPow(const v: TKDT47DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT47DDDistance(const v1, v2: TKDT47DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT47DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT48DD = class(TCoreClassObject)
  public type
    // code split
    TKDT48DD_Vec = packed array [0 .. KDT48DD_Axis - 1] of TKDT48DD_VecType;
    PKDT48DD_Vec = ^TKDT48DD_Vec;

    TKDT48DD_DynamicVecBuffer = array of TKDT48DD_Vec;
    PKDT48DD_DynamicVecBuffer = ^TKDT48DD_DynamicVecBuffer;

    TKDT48DD_Source = packed record
      Buff: TKDT48DD_Vec;
      index: Integer;
    end;

    PKDT48DD_Source       = ^TKDT48DD_Source;
    TKDT48DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT48DD_Source) - 1] of PKDT48DD_Source;
    PKDT48DD_SourceBuffer = ^TKDT48DD_SourceBuffer;

    TKDT48DDyanmicSourceBuffer = packed array of PKDT48DD_Source;
    PKDT48DDyanmicSourceBuffer = ^TKDT48DDyanmicSourceBuffer;

    TKDT48DDyanmicStoreBuffer = packed array of TKDT48DD_Source;
    PKDT48DDyanmicStoreBuffer = ^TKDT48DDyanmicStoreBuffer;

    PKDT48DD_Node = ^TKDT48DD_Node;

    TKDT48DD_Node = packed record
      Parent, Right, Left: PKDT48DD_Node;
      vec: PKDT48DD_Source;
    end;

    TKDT48DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT48DD_Source; const Data: Pointer);
    TKDT48DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT48DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT48DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT48DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT48DDyanmicStoreBuffer;
    KDBuff     : TKDT48DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT48DD_Node;
    TestBuff   : TKDT48DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DD_Node;
    function GetData(const index: NativeInt): PKDT48DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT48DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT48DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT48DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT48DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DD_Node; overload;
    function Search(const Buff: TKDT48DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DD_Node; overload;
    function Search(const Buff: TKDT48DD_Vec; var SearchedDistanceMin: Double): PKDT48DD_Node; overload;
    function Search(const Buff: TKDT48DD_Vec): PKDT48DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT48DD_DynamicVecBuffer; var OutBuff: TKDT48DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT48DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT48DD_Node);
    procedure PrintBuffer;

    class function KDT48DDVec(const s: SystemString): TKDT48DD_Vec; overload;
    class function KDT48DDVec(const v: TKDT48DD_Vec): SystemString; overload;
    class function KDT48DDPow(const v: TKDT48DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT48DDDistance(const v1, v2: TKDT48DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT48DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT49DD = class(TCoreClassObject)
  public type
    // code split
    TKDT49DD_Vec = packed array [0 .. KDT49DD_Axis - 1] of TKDT49DD_VecType;
    PKDT49DD_Vec = ^TKDT49DD_Vec;

    TKDT49DD_DynamicVecBuffer = array of TKDT49DD_Vec;
    PKDT49DD_DynamicVecBuffer = ^TKDT49DD_DynamicVecBuffer;

    TKDT49DD_Source = packed record
      Buff: TKDT49DD_Vec;
      index: Integer;
    end;

    PKDT49DD_Source       = ^TKDT49DD_Source;
    TKDT49DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT49DD_Source) - 1] of PKDT49DD_Source;
    PKDT49DD_SourceBuffer = ^TKDT49DD_SourceBuffer;

    TKDT49DDyanmicSourceBuffer = packed array of PKDT49DD_Source;
    PKDT49DDyanmicSourceBuffer = ^TKDT49DDyanmicSourceBuffer;

    TKDT49DDyanmicStoreBuffer = packed array of TKDT49DD_Source;
    PKDT49DDyanmicStoreBuffer = ^TKDT49DDyanmicStoreBuffer;

    PKDT49DD_Node = ^TKDT49DD_Node;

    TKDT49DD_Node = packed record
      Parent, Right, Left: PKDT49DD_Node;
      vec: PKDT49DD_Source;
    end;

    TKDT49DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT49DD_Source; const Data: Pointer);
    TKDT49DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT49DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT49DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT49DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT49DDyanmicStoreBuffer;
    KDBuff     : TKDT49DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT49DD_Node;
    TestBuff   : TKDT49DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT49DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT49DD_Node;
    function GetData(const index: NativeInt): PKDT49DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT49DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT49DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT49DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT49DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT49DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT49DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT49DD_Node; overload;
    function Search(const Buff: TKDT49DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT49DD_Node; overload;
    function Search(const Buff: TKDT49DD_Vec; var SearchedDistanceMin: Double): PKDT49DD_Node; overload;
    function Search(const Buff: TKDT49DD_Vec): PKDT49DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT49DD_DynamicVecBuffer; var OutBuff: TKDT49DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT49DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT49DD_Node);
    procedure PrintBuffer;

    class function KDT49DDVec(const s: SystemString): TKDT49DD_Vec; overload;
    class function KDT49DDVec(const v: TKDT49DD_Vec): SystemString; overload;
    class function KDT49DDPow(const v: TKDT49DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT49DDDistance(const v1, v2: TKDT49DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT49DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT50DD = class(TCoreClassObject)
  public type
    // code split
    TKDT50DD_Vec = packed array [0 .. KDT50DD_Axis - 1] of TKDT50DD_VecType;
    PKDT50DD_Vec = ^TKDT50DD_Vec;

    TKDT50DD_DynamicVecBuffer = array of TKDT50DD_Vec;
    PKDT50DD_DynamicVecBuffer = ^TKDT50DD_DynamicVecBuffer;

    TKDT50DD_Source = packed record
      Buff: TKDT50DD_Vec;
      index: Integer;
    end;

    PKDT50DD_Source       = ^TKDT50DD_Source;
    TKDT50DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT50DD_Source) - 1] of PKDT50DD_Source;
    PKDT50DD_SourceBuffer = ^TKDT50DD_SourceBuffer;

    TKDT50DDyanmicSourceBuffer = packed array of PKDT50DD_Source;
    PKDT50DDyanmicSourceBuffer = ^TKDT50DDyanmicSourceBuffer;

    TKDT50DDyanmicStoreBuffer = packed array of TKDT50DD_Source;
    PKDT50DDyanmicStoreBuffer = ^TKDT50DDyanmicStoreBuffer;

    PKDT50DD_Node = ^TKDT50DD_Node;

    TKDT50DD_Node = packed record
      Parent, Right, Left: PKDT50DD_Node;
      vec: PKDT50DD_Source;
    end;

    TKDT50DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT50DD_Source; const Data: Pointer);
    TKDT50DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT50DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT50DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT50DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT50DDyanmicStoreBuffer;
    KDBuff     : TKDT50DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT50DD_Node;
    TestBuff   : TKDT50DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT50DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT50DD_Node;
    function GetData(const index: NativeInt): PKDT50DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT50DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT50DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT50DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT50DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT50DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT50DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT50DD_Node; overload;
    function Search(const Buff: TKDT50DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT50DD_Node; overload;
    function Search(const Buff: TKDT50DD_Vec; var SearchedDistanceMin: Double): PKDT50DD_Node; overload;
    function Search(const Buff: TKDT50DD_Vec): PKDT50DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT50DD_DynamicVecBuffer; var OutBuff: TKDT50DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT50DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT50DD_Node);
    procedure PrintBuffer;

    class function KDT50DDVec(const s: SystemString): TKDT50DD_Vec; overload;
    class function KDT50DDVec(const v: TKDT50DD_Vec): SystemString; overload;
    class function KDT50DDPow(const v: TKDT50DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT50DDDistance(const v1, v2: TKDT50DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT50DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT51DD = class(TCoreClassObject)
  public type
    // code split
    TKDT51DD_Vec = packed array [0 .. KDT51DD_Axis - 1] of TKDT51DD_VecType;
    PKDT51DD_Vec = ^TKDT51DD_Vec;

    TKDT51DD_DynamicVecBuffer = array of TKDT51DD_Vec;
    PKDT51DD_DynamicVecBuffer = ^TKDT51DD_DynamicVecBuffer;

    TKDT51DD_Source = packed record
      Buff: TKDT51DD_Vec;
      index: Integer;
    end;

    PKDT51DD_Source       = ^TKDT51DD_Source;
    TKDT51DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT51DD_Source) - 1] of PKDT51DD_Source;
    PKDT51DD_SourceBuffer = ^TKDT51DD_SourceBuffer;

    TKDT51DDyanmicSourceBuffer = packed array of PKDT51DD_Source;
    PKDT51DDyanmicSourceBuffer = ^TKDT51DDyanmicSourceBuffer;

    TKDT51DDyanmicStoreBuffer = packed array of TKDT51DD_Source;
    PKDT51DDyanmicStoreBuffer = ^TKDT51DDyanmicStoreBuffer;

    PKDT51DD_Node = ^TKDT51DD_Node;

    TKDT51DD_Node = packed record
      Parent, Right, Left: PKDT51DD_Node;
      vec: PKDT51DD_Source;
    end;

    TKDT51DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT51DD_Source; const Data: Pointer);
    TKDT51DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT51DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT51DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT51DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT51DDyanmicStoreBuffer;
    KDBuff     : TKDT51DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT51DD_Node;
    TestBuff   : TKDT51DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT51DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT51DD_Node;
    function GetData(const index: NativeInt): PKDT51DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT51DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT51DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT51DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT51DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT51DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT51DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT51DD_Node; overload;
    function Search(const Buff: TKDT51DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT51DD_Node; overload;
    function Search(const Buff: TKDT51DD_Vec; var SearchedDistanceMin: Double): PKDT51DD_Node; overload;
    function Search(const Buff: TKDT51DD_Vec): PKDT51DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT51DD_DynamicVecBuffer; var OutBuff: TKDT51DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT51DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT51DD_Node);
    procedure PrintBuffer;

    class function KDT51DDVec(const s: SystemString): TKDT51DD_Vec; overload;
    class function KDT51DDVec(const v: TKDT51DD_Vec): SystemString; overload;
    class function KDT51DDPow(const v: TKDT51DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT51DDDistance(const v1, v2: TKDT51DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT51DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT52DD = class(TCoreClassObject)
  public type
    // code split
    TKDT52DD_Vec = packed array [0 .. KDT52DD_Axis - 1] of TKDT52DD_VecType;
    PKDT52DD_Vec = ^TKDT52DD_Vec;

    TKDT52DD_DynamicVecBuffer = array of TKDT52DD_Vec;
    PKDT52DD_DynamicVecBuffer = ^TKDT52DD_DynamicVecBuffer;

    TKDT52DD_Source = packed record
      Buff: TKDT52DD_Vec;
      index: Integer;
    end;

    PKDT52DD_Source       = ^TKDT52DD_Source;
    TKDT52DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT52DD_Source) - 1] of PKDT52DD_Source;
    PKDT52DD_SourceBuffer = ^TKDT52DD_SourceBuffer;

    TKDT52DDyanmicSourceBuffer = packed array of PKDT52DD_Source;
    PKDT52DDyanmicSourceBuffer = ^TKDT52DDyanmicSourceBuffer;

    TKDT52DDyanmicStoreBuffer = packed array of TKDT52DD_Source;
    PKDT52DDyanmicStoreBuffer = ^TKDT52DDyanmicStoreBuffer;

    PKDT52DD_Node = ^TKDT52DD_Node;

    TKDT52DD_Node = packed record
      Parent, Right, Left: PKDT52DD_Node;
      vec: PKDT52DD_Source;
    end;

    TKDT52DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT52DD_Source; const Data: Pointer);
    TKDT52DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT52DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT52DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT52DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT52DDyanmicStoreBuffer;
    KDBuff     : TKDT52DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT52DD_Node;
    TestBuff   : TKDT52DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT52DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT52DD_Node;
    function GetData(const index: NativeInt): PKDT52DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT52DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT52DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT52DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT52DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT52DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT52DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT52DD_Node; overload;
    function Search(const Buff: TKDT52DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT52DD_Node; overload;
    function Search(const Buff: TKDT52DD_Vec; var SearchedDistanceMin: Double): PKDT52DD_Node; overload;
    function Search(const Buff: TKDT52DD_Vec): PKDT52DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT52DD_DynamicVecBuffer; var OutBuff: TKDT52DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT52DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT52DD_Node);
    procedure PrintBuffer;

    class function KDT52DDVec(const s: SystemString): TKDT52DD_Vec; overload;
    class function KDT52DDVec(const v: TKDT52DD_Vec): SystemString; overload;
    class function KDT52DDPow(const v: TKDT52DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT52DDDistance(const v1, v2: TKDT52DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT52DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT53DD = class(TCoreClassObject)
  public type
    // code split
    TKDT53DD_Vec = packed array [0 .. KDT53DD_Axis - 1] of TKDT53DD_VecType;
    PKDT53DD_Vec = ^TKDT53DD_Vec;

    TKDT53DD_DynamicVecBuffer = array of TKDT53DD_Vec;
    PKDT53DD_DynamicVecBuffer = ^TKDT53DD_DynamicVecBuffer;

    TKDT53DD_Source = packed record
      Buff: TKDT53DD_Vec;
      index: Integer;
    end;

    PKDT53DD_Source       = ^TKDT53DD_Source;
    TKDT53DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT53DD_Source) - 1] of PKDT53DD_Source;
    PKDT53DD_SourceBuffer = ^TKDT53DD_SourceBuffer;

    TKDT53DDyanmicSourceBuffer = packed array of PKDT53DD_Source;
    PKDT53DDyanmicSourceBuffer = ^TKDT53DDyanmicSourceBuffer;

    TKDT53DDyanmicStoreBuffer = packed array of TKDT53DD_Source;
    PKDT53DDyanmicStoreBuffer = ^TKDT53DDyanmicStoreBuffer;

    PKDT53DD_Node = ^TKDT53DD_Node;

    TKDT53DD_Node = packed record
      Parent, Right, Left: PKDT53DD_Node;
      vec: PKDT53DD_Source;
    end;

    TKDT53DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT53DD_Source; const Data: Pointer);
    TKDT53DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT53DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT53DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT53DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT53DDyanmicStoreBuffer;
    KDBuff     : TKDT53DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT53DD_Node;
    TestBuff   : TKDT53DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT53DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT53DD_Node;
    function GetData(const index: NativeInt): PKDT53DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT53DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT53DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT53DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT53DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT53DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT53DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT53DD_Node; overload;
    function Search(const Buff: TKDT53DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT53DD_Node; overload;
    function Search(const Buff: TKDT53DD_Vec; var SearchedDistanceMin: Double): PKDT53DD_Node; overload;
    function Search(const Buff: TKDT53DD_Vec): PKDT53DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT53DD_DynamicVecBuffer; var OutBuff: TKDT53DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT53DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT53DD_Node);
    procedure PrintBuffer;

    class function KDT53DDVec(const s: SystemString): TKDT53DD_Vec; overload;
    class function KDT53DDVec(const v: TKDT53DD_Vec): SystemString; overload;
    class function KDT53DDPow(const v: TKDT53DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT53DDDistance(const v1, v2: TKDT53DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT53DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT54DD = class(TCoreClassObject)
  public type
    // code split
    TKDT54DD_Vec = packed array [0 .. KDT54DD_Axis - 1] of TKDT54DD_VecType;
    PKDT54DD_Vec = ^TKDT54DD_Vec;

    TKDT54DD_DynamicVecBuffer = array of TKDT54DD_Vec;
    PKDT54DD_DynamicVecBuffer = ^TKDT54DD_DynamicVecBuffer;

    TKDT54DD_Source = packed record
      Buff: TKDT54DD_Vec;
      index: Integer;
    end;

    PKDT54DD_Source       = ^TKDT54DD_Source;
    TKDT54DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT54DD_Source) - 1] of PKDT54DD_Source;
    PKDT54DD_SourceBuffer = ^TKDT54DD_SourceBuffer;

    TKDT54DDyanmicSourceBuffer = packed array of PKDT54DD_Source;
    PKDT54DDyanmicSourceBuffer = ^TKDT54DDyanmicSourceBuffer;

    TKDT54DDyanmicStoreBuffer = packed array of TKDT54DD_Source;
    PKDT54DDyanmicStoreBuffer = ^TKDT54DDyanmicStoreBuffer;

    PKDT54DD_Node = ^TKDT54DD_Node;

    TKDT54DD_Node = packed record
      Parent, Right, Left: PKDT54DD_Node;
      vec: PKDT54DD_Source;
    end;

    TKDT54DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT54DD_Source; const Data: Pointer);
    TKDT54DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT54DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT54DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT54DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT54DDyanmicStoreBuffer;
    KDBuff     : TKDT54DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT54DD_Node;
    TestBuff   : TKDT54DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT54DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT54DD_Node;
    function GetData(const index: NativeInt): PKDT54DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT54DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT54DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT54DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT54DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT54DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT54DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT54DD_Node; overload;
    function Search(const Buff: TKDT54DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT54DD_Node; overload;
    function Search(const Buff: TKDT54DD_Vec; var SearchedDistanceMin: Double): PKDT54DD_Node; overload;
    function Search(const Buff: TKDT54DD_Vec): PKDT54DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT54DD_DynamicVecBuffer; var OutBuff: TKDT54DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT54DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT54DD_Node);
    procedure PrintBuffer;

    class function KDT54DDVec(const s: SystemString): TKDT54DD_Vec; overload;
    class function KDT54DDVec(const v: TKDT54DD_Vec): SystemString; overload;
    class function KDT54DDPow(const v: TKDT54DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT54DDDistance(const v1, v2: TKDT54DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT54DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT55DD = class(TCoreClassObject)
  public type
    // code split
    TKDT55DD_Vec = packed array [0 .. KDT55DD_Axis - 1] of TKDT55DD_VecType;
    PKDT55DD_Vec = ^TKDT55DD_Vec;

    TKDT55DD_DynamicVecBuffer = array of TKDT55DD_Vec;
    PKDT55DD_DynamicVecBuffer = ^TKDT55DD_DynamicVecBuffer;

    TKDT55DD_Source = packed record
      Buff: TKDT55DD_Vec;
      index: Integer;
    end;

    PKDT55DD_Source       = ^TKDT55DD_Source;
    TKDT55DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT55DD_Source) - 1] of PKDT55DD_Source;
    PKDT55DD_SourceBuffer = ^TKDT55DD_SourceBuffer;

    TKDT55DDyanmicSourceBuffer = packed array of PKDT55DD_Source;
    PKDT55DDyanmicSourceBuffer = ^TKDT55DDyanmicSourceBuffer;

    TKDT55DDyanmicStoreBuffer = packed array of TKDT55DD_Source;
    PKDT55DDyanmicStoreBuffer = ^TKDT55DDyanmicStoreBuffer;

    PKDT55DD_Node = ^TKDT55DD_Node;

    TKDT55DD_Node = packed record
      Parent, Right, Left: PKDT55DD_Node;
      vec: PKDT55DD_Source;
    end;

    TKDT55DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT55DD_Source; const Data: Pointer);
    TKDT55DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT55DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT55DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT55DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT55DDyanmicStoreBuffer;
    KDBuff     : TKDT55DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT55DD_Node;
    TestBuff   : TKDT55DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT55DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT55DD_Node;
    function GetData(const index: NativeInt): PKDT55DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT55DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT55DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT55DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT55DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT55DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT55DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT55DD_Node; overload;
    function Search(const Buff: TKDT55DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT55DD_Node; overload;
    function Search(const Buff: TKDT55DD_Vec; var SearchedDistanceMin: Double): PKDT55DD_Node; overload;
    function Search(const Buff: TKDT55DD_Vec): PKDT55DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT55DD_DynamicVecBuffer; var OutBuff: TKDT55DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT55DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT55DD_Node);
    procedure PrintBuffer;

    class function KDT55DDVec(const s: SystemString): TKDT55DD_Vec; overload;
    class function KDT55DDVec(const v: TKDT55DD_Vec): SystemString; overload;
    class function KDT55DDPow(const v: TKDT55DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT55DDDistance(const v1, v2: TKDT55DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT55DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT56DD = class(TCoreClassObject)
  public type
    // code split
    TKDT56DD_Vec = packed array [0 .. KDT56DD_Axis - 1] of TKDT56DD_VecType;
    PKDT56DD_Vec = ^TKDT56DD_Vec;

    TKDT56DD_DynamicVecBuffer = array of TKDT56DD_Vec;
    PKDT56DD_DynamicVecBuffer = ^TKDT56DD_DynamicVecBuffer;

    TKDT56DD_Source = packed record
      Buff: TKDT56DD_Vec;
      index: Integer;
    end;

    PKDT56DD_Source       = ^TKDT56DD_Source;
    TKDT56DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT56DD_Source) - 1] of PKDT56DD_Source;
    PKDT56DD_SourceBuffer = ^TKDT56DD_SourceBuffer;

    TKDT56DDyanmicSourceBuffer = packed array of PKDT56DD_Source;
    PKDT56DDyanmicSourceBuffer = ^TKDT56DDyanmicSourceBuffer;

    TKDT56DDyanmicStoreBuffer = packed array of TKDT56DD_Source;
    PKDT56DDyanmicStoreBuffer = ^TKDT56DDyanmicStoreBuffer;

    PKDT56DD_Node = ^TKDT56DD_Node;

    TKDT56DD_Node = packed record
      Parent, Right, Left: PKDT56DD_Node;
      vec: PKDT56DD_Source;
    end;

    TKDT56DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT56DD_Source; const Data: Pointer);
    TKDT56DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT56DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT56DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT56DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT56DDyanmicStoreBuffer;
    KDBuff     : TKDT56DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT56DD_Node;
    TestBuff   : TKDT56DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT56DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT56DD_Node;
    function GetData(const index: NativeInt): PKDT56DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT56DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT56DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT56DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT56DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT56DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT56DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT56DD_Node; overload;
    function Search(const Buff: TKDT56DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT56DD_Node; overload;
    function Search(const Buff: TKDT56DD_Vec; var SearchedDistanceMin: Double): PKDT56DD_Node; overload;
    function Search(const Buff: TKDT56DD_Vec): PKDT56DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT56DD_DynamicVecBuffer; var OutBuff: TKDT56DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT56DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT56DD_Node);
    procedure PrintBuffer;

    class function KDT56DDVec(const s: SystemString): TKDT56DD_Vec; overload;
    class function KDT56DDVec(const v: TKDT56DD_Vec): SystemString; overload;
    class function KDT56DDPow(const v: TKDT56DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT56DDDistance(const v1, v2: TKDT56DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT56DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT57DD = class(TCoreClassObject)
  public type
    // code split
    TKDT57DD_Vec = packed array [0 .. KDT57DD_Axis - 1] of TKDT57DD_VecType;
    PKDT57DD_Vec = ^TKDT57DD_Vec;

    TKDT57DD_DynamicVecBuffer = array of TKDT57DD_Vec;
    PKDT57DD_DynamicVecBuffer = ^TKDT57DD_DynamicVecBuffer;

    TKDT57DD_Source = packed record
      Buff: TKDT57DD_Vec;
      index: Integer;
    end;

    PKDT57DD_Source       = ^TKDT57DD_Source;
    TKDT57DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT57DD_Source) - 1] of PKDT57DD_Source;
    PKDT57DD_SourceBuffer = ^TKDT57DD_SourceBuffer;

    TKDT57DDyanmicSourceBuffer = packed array of PKDT57DD_Source;
    PKDT57DDyanmicSourceBuffer = ^TKDT57DDyanmicSourceBuffer;

    TKDT57DDyanmicStoreBuffer = packed array of TKDT57DD_Source;
    PKDT57DDyanmicStoreBuffer = ^TKDT57DDyanmicStoreBuffer;

    PKDT57DD_Node = ^TKDT57DD_Node;

    TKDT57DD_Node = packed record
      Parent, Right, Left: PKDT57DD_Node;
      vec: PKDT57DD_Source;
    end;

    TKDT57DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT57DD_Source; const Data: Pointer);
    TKDT57DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT57DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT57DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT57DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT57DDyanmicStoreBuffer;
    KDBuff     : TKDT57DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT57DD_Node;
    TestBuff   : TKDT57DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT57DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT57DD_Node;
    function GetData(const index: NativeInt): PKDT57DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT57DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT57DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT57DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT57DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT57DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT57DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT57DD_Node; overload;
    function Search(const Buff: TKDT57DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT57DD_Node; overload;
    function Search(const Buff: TKDT57DD_Vec; var SearchedDistanceMin: Double): PKDT57DD_Node; overload;
    function Search(const Buff: TKDT57DD_Vec): PKDT57DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT57DD_DynamicVecBuffer; var OutBuff: TKDT57DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT57DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT57DD_Node);
    procedure PrintBuffer;

    class function KDT57DDVec(const s: SystemString): TKDT57DD_Vec; overload;
    class function KDT57DDVec(const v: TKDT57DD_Vec): SystemString; overload;
    class function KDT57DDPow(const v: TKDT57DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT57DDDistance(const v1, v2: TKDT57DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT57DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT58DD = class(TCoreClassObject)
  public type
    // code split
    TKDT58DD_Vec = packed array [0 .. KDT58DD_Axis - 1] of TKDT58DD_VecType;
    PKDT58DD_Vec = ^TKDT58DD_Vec;

    TKDT58DD_DynamicVecBuffer = array of TKDT58DD_Vec;
    PKDT58DD_DynamicVecBuffer = ^TKDT58DD_DynamicVecBuffer;

    TKDT58DD_Source = packed record
      Buff: TKDT58DD_Vec;
      index: Integer;
    end;

    PKDT58DD_Source       = ^TKDT58DD_Source;
    TKDT58DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT58DD_Source) - 1] of PKDT58DD_Source;
    PKDT58DD_SourceBuffer = ^TKDT58DD_SourceBuffer;

    TKDT58DDyanmicSourceBuffer = packed array of PKDT58DD_Source;
    PKDT58DDyanmicSourceBuffer = ^TKDT58DDyanmicSourceBuffer;

    TKDT58DDyanmicStoreBuffer = packed array of TKDT58DD_Source;
    PKDT58DDyanmicStoreBuffer = ^TKDT58DDyanmicStoreBuffer;

    PKDT58DD_Node = ^TKDT58DD_Node;

    TKDT58DD_Node = packed record
      Parent, Right, Left: PKDT58DD_Node;
      vec: PKDT58DD_Source;
    end;

    TKDT58DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT58DD_Source; const Data: Pointer);
    TKDT58DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT58DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT58DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT58DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT58DDyanmicStoreBuffer;
    KDBuff     : TKDT58DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT58DD_Node;
    TestBuff   : TKDT58DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT58DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT58DD_Node;
    function GetData(const index: NativeInt): PKDT58DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT58DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT58DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT58DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT58DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT58DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT58DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT58DD_Node; overload;
    function Search(const Buff: TKDT58DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT58DD_Node; overload;
    function Search(const Buff: TKDT58DD_Vec; var SearchedDistanceMin: Double): PKDT58DD_Node; overload;
    function Search(const Buff: TKDT58DD_Vec): PKDT58DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT58DD_DynamicVecBuffer; var OutBuff: TKDT58DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT58DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT58DD_Node);
    procedure PrintBuffer;

    class function KDT58DDVec(const s: SystemString): TKDT58DD_Vec; overload;
    class function KDT58DDVec(const v: TKDT58DD_Vec): SystemString; overload;
    class function KDT58DDPow(const v: TKDT58DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT58DDDistance(const v1, v2: TKDT58DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT58DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT59DD = class(TCoreClassObject)
  public type
    // code split
    TKDT59DD_Vec = packed array [0 .. KDT59DD_Axis - 1] of TKDT59DD_VecType;
    PKDT59DD_Vec = ^TKDT59DD_Vec;

    TKDT59DD_DynamicVecBuffer = array of TKDT59DD_Vec;
    PKDT59DD_DynamicVecBuffer = ^TKDT59DD_DynamicVecBuffer;

    TKDT59DD_Source = packed record
      Buff: TKDT59DD_Vec;
      index: Integer;
    end;

    PKDT59DD_Source       = ^TKDT59DD_Source;
    TKDT59DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT59DD_Source) - 1] of PKDT59DD_Source;
    PKDT59DD_SourceBuffer = ^TKDT59DD_SourceBuffer;

    TKDT59DDyanmicSourceBuffer = packed array of PKDT59DD_Source;
    PKDT59DDyanmicSourceBuffer = ^TKDT59DDyanmicSourceBuffer;

    TKDT59DDyanmicStoreBuffer = packed array of TKDT59DD_Source;
    PKDT59DDyanmicStoreBuffer = ^TKDT59DDyanmicStoreBuffer;

    PKDT59DD_Node = ^TKDT59DD_Node;

    TKDT59DD_Node = packed record
      Parent, Right, Left: PKDT59DD_Node;
      vec: PKDT59DD_Source;
    end;

    TKDT59DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT59DD_Source; const Data: Pointer);
    TKDT59DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT59DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT59DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT59DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT59DDyanmicStoreBuffer;
    KDBuff     : TKDT59DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT59DD_Node;
    TestBuff   : TKDT59DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT59DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT59DD_Node;
    function GetData(const index: NativeInt): PKDT59DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT59DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT59DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT59DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT59DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT59DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT59DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT59DD_Node; overload;
    function Search(const Buff: TKDT59DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT59DD_Node; overload;
    function Search(const Buff: TKDT59DD_Vec; var SearchedDistanceMin: Double): PKDT59DD_Node; overload;
    function Search(const Buff: TKDT59DD_Vec): PKDT59DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT59DD_DynamicVecBuffer; var OutBuff: TKDT59DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT59DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT59DD_Node);
    procedure PrintBuffer;

    class function KDT59DDVec(const s: SystemString): TKDT59DD_Vec; overload;
    class function KDT59DDVec(const v: TKDT59DD_Vec): SystemString; overload;
    class function KDT59DDPow(const v: TKDT59DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT59DDDistance(const v1, v2: TKDT59DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT59DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT60DD = class(TCoreClassObject)
  public type
    // code split
    TKDT60DD_Vec = packed array [0 .. KDT60DD_Axis - 1] of TKDT60DD_VecType;
    PKDT60DD_Vec = ^TKDT60DD_Vec;

    TKDT60DD_DynamicVecBuffer = array of TKDT60DD_Vec;
    PKDT60DD_DynamicVecBuffer = ^TKDT60DD_DynamicVecBuffer;

    TKDT60DD_Source = packed record
      Buff: TKDT60DD_Vec;
      index: Integer;
    end;

    PKDT60DD_Source       = ^TKDT60DD_Source;
    TKDT60DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT60DD_Source) - 1] of PKDT60DD_Source;
    PKDT60DD_SourceBuffer = ^TKDT60DD_SourceBuffer;

    TKDT60DDyanmicSourceBuffer = packed array of PKDT60DD_Source;
    PKDT60DDyanmicSourceBuffer = ^TKDT60DDyanmicSourceBuffer;

    TKDT60DDyanmicStoreBuffer = packed array of TKDT60DD_Source;
    PKDT60DDyanmicStoreBuffer = ^TKDT60DDyanmicStoreBuffer;

    PKDT60DD_Node = ^TKDT60DD_Node;

    TKDT60DD_Node = packed record
      Parent, Right, Left: PKDT60DD_Node;
      vec: PKDT60DD_Source;
    end;

    TKDT60DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT60DD_Source; const Data: Pointer);
    TKDT60DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT60DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT60DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT60DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT60DDyanmicStoreBuffer;
    KDBuff     : TKDT60DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT60DD_Node;
    TestBuff   : TKDT60DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT60DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT60DD_Node;
    function GetData(const index: NativeInt): PKDT60DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT60DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT60DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT60DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT60DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT60DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT60DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT60DD_Node; overload;
    function Search(const Buff: TKDT60DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT60DD_Node; overload;
    function Search(const Buff: TKDT60DD_Vec; var SearchedDistanceMin: Double): PKDT60DD_Node; overload;
    function Search(const Buff: TKDT60DD_Vec): PKDT60DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT60DD_DynamicVecBuffer; var OutBuff: TKDT60DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT60DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT60DD_Node);
    procedure PrintBuffer;

    class function KDT60DDVec(const s: SystemString): TKDT60DD_Vec; overload;
    class function KDT60DDVec(const v: TKDT60DD_Vec): SystemString; overload;
    class function KDT60DDPow(const v: TKDT60DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT60DDDistance(const v1, v2: TKDT60DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT60DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT61DD = class(TCoreClassObject)
  public type
    // code split
    TKDT61DD_Vec = packed array [0 .. KDT61DD_Axis - 1] of TKDT61DD_VecType;
    PKDT61DD_Vec = ^TKDT61DD_Vec;

    TKDT61DD_DynamicVecBuffer = array of TKDT61DD_Vec;
    PKDT61DD_DynamicVecBuffer = ^TKDT61DD_DynamicVecBuffer;

    TKDT61DD_Source = packed record
      Buff: TKDT61DD_Vec;
      index: Integer;
    end;

    PKDT61DD_Source       = ^TKDT61DD_Source;
    TKDT61DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT61DD_Source) - 1] of PKDT61DD_Source;
    PKDT61DD_SourceBuffer = ^TKDT61DD_SourceBuffer;

    TKDT61DDyanmicSourceBuffer = packed array of PKDT61DD_Source;
    PKDT61DDyanmicSourceBuffer = ^TKDT61DDyanmicSourceBuffer;

    TKDT61DDyanmicStoreBuffer = packed array of TKDT61DD_Source;
    PKDT61DDyanmicStoreBuffer = ^TKDT61DDyanmicStoreBuffer;

    PKDT61DD_Node = ^TKDT61DD_Node;

    TKDT61DD_Node = packed record
      Parent, Right, Left: PKDT61DD_Node;
      vec: PKDT61DD_Source;
    end;

    TKDT61DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT61DD_Source; const Data: Pointer);
    TKDT61DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT61DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT61DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT61DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT61DDyanmicStoreBuffer;
    KDBuff     : TKDT61DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT61DD_Node;
    TestBuff   : TKDT61DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT61DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT61DD_Node;
    function GetData(const index: NativeInt): PKDT61DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT61DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT61DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT61DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT61DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT61DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT61DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT61DD_Node; overload;
    function Search(const Buff: TKDT61DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT61DD_Node; overload;
    function Search(const Buff: TKDT61DD_Vec; var SearchedDistanceMin: Double): PKDT61DD_Node; overload;
    function Search(const Buff: TKDT61DD_Vec): PKDT61DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT61DD_DynamicVecBuffer; var OutBuff: TKDT61DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT61DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT61DD_Node);
    procedure PrintBuffer;

    class function KDT61DDVec(const s: SystemString): TKDT61DD_Vec; overload;
    class function KDT61DDVec(const v: TKDT61DD_Vec): SystemString; overload;
    class function KDT61DDPow(const v: TKDT61DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT61DDDistance(const v1, v2: TKDT61DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT61DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT62DD = class(TCoreClassObject)
  public type
    // code split
    TKDT62DD_Vec = packed array [0 .. KDT62DD_Axis - 1] of TKDT62DD_VecType;
    PKDT62DD_Vec = ^TKDT62DD_Vec;

    TKDT62DD_DynamicVecBuffer = array of TKDT62DD_Vec;
    PKDT62DD_DynamicVecBuffer = ^TKDT62DD_DynamicVecBuffer;

    TKDT62DD_Source = packed record
      Buff: TKDT62DD_Vec;
      index: Integer;
    end;

    PKDT62DD_Source       = ^TKDT62DD_Source;
    TKDT62DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT62DD_Source) - 1] of PKDT62DD_Source;
    PKDT62DD_SourceBuffer = ^TKDT62DD_SourceBuffer;

    TKDT62DDyanmicSourceBuffer = packed array of PKDT62DD_Source;
    PKDT62DDyanmicSourceBuffer = ^TKDT62DDyanmicSourceBuffer;

    TKDT62DDyanmicStoreBuffer = packed array of TKDT62DD_Source;
    PKDT62DDyanmicStoreBuffer = ^TKDT62DDyanmicStoreBuffer;

    PKDT62DD_Node = ^TKDT62DD_Node;

    TKDT62DD_Node = packed record
      Parent, Right, Left: PKDT62DD_Node;
      vec: PKDT62DD_Source;
    end;

    TKDT62DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT62DD_Source; const Data: Pointer);
    TKDT62DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT62DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT62DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT62DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT62DDyanmicStoreBuffer;
    KDBuff     : TKDT62DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT62DD_Node;
    TestBuff   : TKDT62DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT62DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT62DD_Node;
    function GetData(const index: NativeInt): PKDT62DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT62DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT62DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT62DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT62DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT62DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT62DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT62DD_Node; overload;
    function Search(const Buff: TKDT62DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT62DD_Node; overload;
    function Search(const Buff: TKDT62DD_Vec; var SearchedDistanceMin: Double): PKDT62DD_Node; overload;
    function Search(const Buff: TKDT62DD_Vec): PKDT62DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT62DD_DynamicVecBuffer; var OutBuff: TKDT62DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT62DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT62DD_Node);
    procedure PrintBuffer;

    class function KDT62DDVec(const s: SystemString): TKDT62DD_Vec; overload;
    class function KDT62DDVec(const v: TKDT62DD_Vec): SystemString; overload;
    class function KDT62DDPow(const v: TKDT62DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT62DDDistance(const v1, v2: TKDT62DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT62DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT63DD = class(TCoreClassObject)
  public type
    // code split
    TKDT63DD_Vec = packed array [0 .. KDT63DD_Axis - 1] of TKDT63DD_VecType;
    PKDT63DD_Vec = ^TKDT63DD_Vec;

    TKDT63DD_DynamicVecBuffer = array of TKDT63DD_Vec;
    PKDT63DD_DynamicVecBuffer = ^TKDT63DD_DynamicVecBuffer;

    TKDT63DD_Source = packed record
      Buff: TKDT63DD_Vec;
      index: Integer;
    end;

    PKDT63DD_Source       = ^TKDT63DD_Source;
    TKDT63DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT63DD_Source) - 1] of PKDT63DD_Source;
    PKDT63DD_SourceBuffer = ^TKDT63DD_SourceBuffer;

    TKDT63DDyanmicSourceBuffer = packed array of PKDT63DD_Source;
    PKDT63DDyanmicSourceBuffer = ^TKDT63DDyanmicSourceBuffer;

    TKDT63DDyanmicStoreBuffer = packed array of TKDT63DD_Source;
    PKDT63DDyanmicStoreBuffer = ^TKDT63DDyanmicStoreBuffer;

    PKDT63DD_Node = ^TKDT63DD_Node;

    TKDT63DD_Node = packed record
      Parent, Right, Left: PKDT63DD_Node;
      vec: PKDT63DD_Source;
    end;

    TKDT63DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT63DD_Source; const Data: Pointer);
    TKDT63DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT63DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT63DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT63DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT63DDyanmicStoreBuffer;
    KDBuff     : TKDT63DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT63DD_Node;
    TestBuff   : TKDT63DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT63DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT63DD_Node;
    function GetData(const index: NativeInt): PKDT63DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT63DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT63DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT63DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT63DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT63DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT63DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT63DD_Node; overload;
    function Search(const Buff: TKDT63DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT63DD_Node; overload;
    function Search(const Buff: TKDT63DD_Vec; var SearchedDistanceMin: Double): PKDT63DD_Node; overload;
    function Search(const Buff: TKDT63DD_Vec): PKDT63DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT63DD_DynamicVecBuffer; var OutBuff: TKDT63DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT63DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT63DD_Node);
    procedure PrintBuffer;

    class function KDT63DDVec(const s: SystemString): TKDT63DD_Vec; overload;
    class function KDT63DDVec(const v: TKDT63DD_Vec): SystemString; overload;
    class function KDT63DDPow(const v: TKDT63DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT63DDDistance(const v1, v2: TKDT63DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT63DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT64DD = class(TCoreClassObject)
  public type
    // code split
    TKDT64DD_Vec = packed array [0 .. KDT64DD_Axis - 1] of TKDT64DD_VecType;
    PKDT64DD_Vec = ^TKDT64DD_Vec;

    TKDT64DD_DynamicVecBuffer = array of TKDT64DD_Vec;
    PKDT64DD_DynamicVecBuffer = ^TKDT64DD_DynamicVecBuffer;

    TKDT64DD_Source = packed record
      Buff: TKDT64DD_Vec;
      index: Integer;
    end;

    PKDT64DD_Source       = ^TKDT64DD_Source;
    TKDT64DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT64DD_Source) - 1] of PKDT64DD_Source;
    PKDT64DD_SourceBuffer = ^TKDT64DD_SourceBuffer;

    TKDT64DDyanmicSourceBuffer = packed array of PKDT64DD_Source;
    PKDT64DDyanmicSourceBuffer = ^TKDT64DDyanmicSourceBuffer;

    TKDT64DDyanmicStoreBuffer = packed array of TKDT64DD_Source;
    PKDT64DDyanmicStoreBuffer = ^TKDT64DDyanmicStoreBuffer;

    PKDT64DD_Node = ^TKDT64DD_Node;

    TKDT64DD_Node = packed record
      Parent, Right, Left: PKDT64DD_Node;
      vec: PKDT64DD_Source;
    end;

    TKDT64DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT64DD_Source; const Data: Pointer);
    TKDT64DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT64DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT64DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT64DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT64DDyanmicStoreBuffer;
    KDBuff     : TKDT64DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT64DD_Node;
    TestBuff   : TKDT64DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DD_Node;
    function GetData(const index: NativeInt): PKDT64DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT64DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT64DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT64DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT64DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DD_Node; overload;
    function Search(const Buff: TKDT64DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DD_Node; overload;
    function Search(const Buff: TKDT64DD_Vec; var SearchedDistanceMin: Double): PKDT64DD_Node; overload;
    function Search(const Buff: TKDT64DD_Vec): PKDT64DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT64DD_DynamicVecBuffer; var OutBuff: TKDT64DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT64DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT64DD_Node);
    procedure PrintBuffer;

    class function KDT64DDVec(const s: SystemString): TKDT64DD_Vec; overload;
    class function KDT64DDVec(const v: TKDT64DD_Vec): SystemString; overload;
    class function KDT64DDPow(const v: TKDT64DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT64DDDistance(const v1, v2: TKDT64DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT64DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT65DD = class(TCoreClassObject)
  public type
    // code split
    TKDT65DD_Vec = packed array [0 .. KDT65DD_Axis - 1] of TKDT65DD_VecType;
    PKDT65DD_Vec = ^TKDT65DD_Vec;

    TKDT65DD_DynamicVecBuffer = array of TKDT65DD_Vec;
    PKDT65DD_DynamicVecBuffer = ^TKDT65DD_DynamicVecBuffer;

    TKDT65DD_Source = packed record
      Buff: TKDT65DD_Vec;
      index: Integer;
    end;

    PKDT65DD_Source       = ^TKDT65DD_Source;
    TKDT65DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT65DD_Source) - 1] of PKDT65DD_Source;
    PKDT65DD_SourceBuffer = ^TKDT65DD_SourceBuffer;

    TKDT65DDyanmicSourceBuffer = packed array of PKDT65DD_Source;
    PKDT65DDyanmicSourceBuffer = ^TKDT65DDyanmicSourceBuffer;

    TKDT65DDyanmicStoreBuffer = packed array of TKDT65DD_Source;
    PKDT65DDyanmicStoreBuffer = ^TKDT65DDyanmicStoreBuffer;

    PKDT65DD_Node = ^TKDT65DD_Node;

    TKDT65DD_Node = packed record
      Parent, Right, Left: PKDT65DD_Node;
      vec: PKDT65DD_Source;
    end;

    TKDT65DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT65DD_Source; const Data: Pointer);
    TKDT65DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT65DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT65DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT65DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT65DDyanmicStoreBuffer;
    KDBuff     : TKDT65DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT65DD_Node;
    TestBuff   : TKDT65DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT65DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT65DD_Node;
    function GetData(const index: NativeInt): PKDT65DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT65DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT65DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT65DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT65DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT65DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT65DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT65DD_Node; overload;
    function Search(const Buff: TKDT65DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT65DD_Node; overload;
    function Search(const Buff: TKDT65DD_Vec; var SearchedDistanceMin: Double): PKDT65DD_Node; overload;
    function Search(const Buff: TKDT65DD_Vec): PKDT65DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT65DD_DynamicVecBuffer; var OutBuff: TKDT65DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT65DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT65DD_Node);
    procedure PrintBuffer;

    class function KDT65DDVec(const s: SystemString): TKDT65DD_Vec; overload;
    class function KDT65DDVec(const v: TKDT65DD_Vec): SystemString; overload;
    class function KDT65DDPow(const v: TKDT65DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT65DDDistance(const v1, v2: TKDT65DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT65DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT66DD = class(TCoreClassObject)
  public type
    // code split
    TKDT66DD_Vec = packed array [0 .. KDT66DD_Axis - 1] of TKDT66DD_VecType;
    PKDT66DD_Vec = ^TKDT66DD_Vec;

    TKDT66DD_DynamicVecBuffer = array of TKDT66DD_Vec;
    PKDT66DD_DynamicVecBuffer = ^TKDT66DD_DynamicVecBuffer;

    TKDT66DD_Source = packed record
      Buff: TKDT66DD_Vec;
      index: Integer;
    end;

    PKDT66DD_Source       = ^TKDT66DD_Source;
    TKDT66DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT66DD_Source) - 1] of PKDT66DD_Source;
    PKDT66DD_SourceBuffer = ^TKDT66DD_SourceBuffer;

    TKDT66DDyanmicSourceBuffer = packed array of PKDT66DD_Source;
    PKDT66DDyanmicSourceBuffer = ^TKDT66DDyanmicSourceBuffer;

    TKDT66DDyanmicStoreBuffer = packed array of TKDT66DD_Source;
    PKDT66DDyanmicStoreBuffer = ^TKDT66DDyanmicStoreBuffer;

    PKDT66DD_Node = ^TKDT66DD_Node;

    TKDT66DD_Node = packed record
      Parent, Right, Left: PKDT66DD_Node;
      vec: PKDT66DD_Source;
    end;

    TKDT66DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT66DD_Source; const Data: Pointer);
    TKDT66DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT66DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT66DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT66DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT66DDyanmicStoreBuffer;
    KDBuff     : TKDT66DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT66DD_Node;
    TestBuff   : TKDT66DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT66DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT66DD_Node;
    function GetData(const index: NativeInt): PKDT66DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT66DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT66DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT66DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT66DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT66DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT66DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT66DD_Node; overload;
    function Search(const Buff: TKDT66DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT66DD_Node; overload;
    function Search(const Buff: TKDT66DD_Vec; var SearchedDistanceMin: Double): PKDT66DD_Node; overload;
    function Search(const Buff: TKDT66DD_Vec): PKDT66DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT66DD_DynamicVecBuffer; var OutBuff: TKDT66DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT66DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT66DD_Node);
    procedure PrintBuffer;

    class function KDT66DDVec(const s: SystemString): TKDT66DD_Vec; overload;
    class function KDT66DDVec(const v: TKDT66DD_Vec): SystemString; overload;
    class function KDT66DDPow(const v: TKDT66DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT66DDDistance(const v1, v2: TKDT66DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT66DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT67DD = class(TCoreClassObject)
  public type
    // code split
    TKDT67DD_Vec = packed array [0 .. KDT67DD_Axis - 1] of TKDT67DD_VecType;
    PKDT67DD_Vec = ^TKDT67DD_Vec;

    TKDT67DD_DynamicVecBuffer = array of TKDT67DD_Vec;
    PKDT67DD_DynamicVecBuffer = ^TKDT67DD_DynamicVecBuffer;

    TKDT67DD_Source = packed record
      Buff: TKDT67DD_Vec;
      index: Integer;
    end;

    PKDT67DD_Source       = ^TKDT67DD_Source;
    TKDT67DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT67DD_Source) - 1] of PKDT67DD_Source;
    PKDT67DD_SourceBuffer = ^TKDT67DD_SourceBuffer;

    TKDT67DDyanmicSourceBuffer = packed array of PKDT67DD_Source;
    PKDT67DDyanmicSourceBuffer = ^TKDT67DDyanmicSourceBuffer;

    TKDT67DDyanmicStoreBuffer = packed array of TKDT67DD_Source;
    PKDT67DDyanmicStoreBuffer = ^TKDT67DDyanmicStoreBuffer;

    PKDT67DD_Node = ^TKDT67DD_Node;

    TKDT67DD_Node = packed record
      Parent, Right, Left: PKDT67DD_Node;
      vec: PKDT67DD_Source;
    end;

    TKDT67DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT67DD_Source; const Data: Pointer);
    TKDT67DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT67DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT67DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT67DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT67DDyanmicStoreBuffer;
    KDBuff     : TKDT67DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT67DD_Node;
    TestBuff   : TKDT67DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT67DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT67DD_Node;
    function GetData(const index: NativeInt): PKDT67DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT67DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT67DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT67DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT67DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT67DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT67DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT67DD_Node; overload;
    function Search(const Buff: TKDT67DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT67DD_Node; overload;
    function Search(const Buff: TKDT67DD_Vec; var SearchedDistanceMin: Double): PKDT67DD_Node; overload;
    function Search(const Buff: TKDT67DD_Vec): PKDT67DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT67DD_DynamicVecBuffer; var OutBuff: TKDT67DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT67DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT67DD_Node);
    procedure PrintBuffer;

    class function KDT67DDVec(const s: SystemString): TKDT67DD_Vec; overload;
    class function KDT67DDVec(const v: TKDT67DD_Vec): SystemString; overload;
    class function KDT67DDPow(const v: TKDT67DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT67DDDistance(const v1, v2: TKDT67DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT67DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT68DD = class(TCoreClassObject)
  public type
    // code split
    TKDT68DD_Vec = packed array [0 .. KDT68DD_Axis - 1] of TKDT68DD_VecType;
    PKDT68DD_Vec = ^TKDT68DD_Vec;

    TKDT68DD_DynamicVecBuffer = array of TKDT68DD_Vec;
    PKDT68DD_DynamicVecBuffer = ^TKDT68DD_DynamicVecBuffer;

    TKDT68DD_Source = packed record
      Buff: TKDT68DD_Vec;
      index: Integer;
    end;

    PKDT68DD_Source       = ^TKDT68DD_Source;
    TKDT68DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT68DD_Source) - 1] of PKDT68DD_Source;
    PKDT68DD_SourceBuffer = ^TKDT68DD_SourceBuffer;

    TKDT68DDyanmicSourceBuffer = packed array of PKDT68DD_Source;
    PKDT68DDyanmicSourceBuffer = ^TKDT68DDyanmicSourceBuffer;

    TKDT68DDyanmicStoreBuffer = packed array of TKDT68DD_Source;
    PKDT68DDyanmicStoreBuffer = ^TKDT68DDyanmicStoreBuffer;

    PKDT68DD_Node = ^TKDT68DD_Node;

    TKDT68DD_Node = packed record
      Parent, Right, Left: PKDT68DD_Node;
      vec: PKDT68DD_Source;
    end;

    TKDT68DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT68DD_Source; const Data: Pointer);
    TKDT68DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT68DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT68DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT68DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT68DDyanmicStoreBuffer;
    KDBuff     : TKDT68DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT68DD_Node;
    TestBuff   : TKDT68DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT68DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT68DD_Node;
    function GetData(const index: NativeInt): PKDT68DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT68DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT68DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT68DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT68DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT68DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT68DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT68DD_Node; overload;
    function Search(const Buff: TKDT68DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT68DD_Node; overload;
    function Search(const Buff: TKDT68DD_Vec; var SearchedDistanceMin: Double): PKDT68DD_Node; overload;
    function Search(const Buff: TKDT68DD_Vec): PKDT68DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT68DD_DynamicVecBuffer; var OutBuff: TKDT68DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT68DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT68DD_Node);
    procedure PrintBuffer;

    class function KDT68DDVec(const s: SystemString): TKDT68DD_Vec; overload;
    class function KDT68DDVec(const v: TKDT68DD_Vec): SystemString; overload;
    class function KDT68DDPow(const v: TKDT68DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT68DDDistance(const v1, v2: TKDT68DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT68DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT69DD = class(TCoreClassObject)
  public type
    // code split
    TKDT69DD_Vec = packed array [0 .. KDT69DD_Axis - 1] of TKDT69DD_VecType;
    PKDT69DD_Vec = ^TKDT69DD_Vec;

    TKDT69DD_DynamicVecBuffer = array of TKDT69DD_Vec;
    PKDT69DD_DynamicVecBuffer = ^TKDT69DD_DynamicVecBuffer;

    TKDT69DD_Source = packed record
      Buff: TKDT69DD_Vec;
      index: Integer;
    end;

    PKDT69DD_Source       = ^TKDT69DD_Source;
    TKDT69DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT69DD_Source) - 1] of PKDT69DD_Source;
    PKDT69DD_SourceBuffer = ^TKDT69DD_SourceBuffer;

    TKDT69DDyanmicSourceBuffer = packed array of PKDT69DD_Source;
    PKDT69DDyanmicSourceBuffer = ^TKDT69DDyanmicSourceBuffer;

    TKDT69DDyanmicStoreBuffer = packed array of TKDT69DD_Source;
    PKDT69DDyanmicStoreBuffer = ^TKDT69DDyanmicStoreBuffer;

    PKDT69DD_Node = ^TKDT69DD_Node;

    TKDT69DD_Node = packed record
      Parent, Right, Left: PKDT69DD_Node;
      vec: PKDT69DD_Source;
    end;

    TKDT69DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT69DD_Source; const Data: Pointer);
    TKDT69DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT69DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT69DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT69DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT69DDyanmicStoreBuffer;
    KDBuff     : TKDT69DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT69DD_Node;
    TestBuff   : TKDT69DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT69DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT69DD_Node;
    function GetData(const index: NativeInt): PKDT69DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT69DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT69DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT69DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT69DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT69DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT69DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT69DD_Node; overload;
    function Search(const Buff: TKDT69DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT69DD_Node; overload;
    function Search(const Buff: TKDT69DD_Vec; var SearchedDistanceMin: Double): PKDT69DD_Node; overload;
    function Search(const Buff: TKDT69DD_Vec): PKDT69DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT69DD_DynamicVecBuffer; var OutBuff: TKDT69DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT69DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT69DD_Node);
    procedure PrintBuffer;

    class function KDT69DDVec(const s: SystemString): TKDT69DD_Vec; overload;
    class function KDT69DDVec(const v: TKDT69DD_Vec): SystemString; overload;
    class function KDT69DDPow(const v: TKDT69DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT69DDDistance(const v1, v2: TKDT69DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT69DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT70DD = class(TCoreClassObject)
  public type
    // code split
    TKDT70DD_Vec = packed array [0 .. KDT70DD_Axis - 1] of TKDT70DD_VecType;
    PKDT70DD_Vec = ^TKDT70DD_Vec;

    TKDT70DD_DynamicVecBuffer = array of TKDT70DD_Vec;
    PKDT70DD_DynamicVecBuffer = ^TKDT70DD_DynamicVecBuffer;

    TKDT70DD_Source = packed record
      Buff: TKDT70DD_Vec;
      index: Integer;
    end;

    PKDT70DD_Source       = ^TKDT70DD_Source;
    TKDT70DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT70DD_Source) - 1] of PKDT70DD_Source;
    PKDT70DD_SourceBuffer = ^TKDT70DD_SourceBuffer;

    TKDT70DDyanmicSourceBuffer = packed array of PKDT70DD_Source;
    PKDT70DDyanmicSourceBuffer = ^TKDT70DDyanmicSourceBuffer;

    TKDT70DDyanmicStoreBuffer = packed array of TKDT70DD_Source;
    PKDT70DDyanmicStoreBuffer = ^TKDT70DDyanmicStoreBuffer;

    PKDT70DD_Node = ^TKDT70DD_Node;

    TKDT70DD_Node = packed record
      Parent, Right, Left: PKDT70DD_Node;
      vec: PKDT70DD_Source;
    end;

    TKDT70DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT70DD_Source; const Data: Pointer);
    TKDT70DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT70DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT70DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT70DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT70DDyanmicStoreBuffer;
    KDBuff     : TKDT70DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT70DD_Node;
    TestBuff   : TKDT70DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT70DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT70DD_Node;
    function GetData(const index: NativeInt): PKDT70DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT70DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT70DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT70DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT70DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT70DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT70DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT70DD_Node; overload;
    function Search(const Buff: TKDT70DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT70DD_Node; overload;
    function Search(const Buff: TKDT70DD_Vec; var SearchedDistanceMin: Double): PKDT70DD_Node; overload;
    function Search(const Buff: TKDT70DD_Vec): PKDT70DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT70DD_DynamicVecBuffer; var OutBuff: TKDT70DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT70DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT70DD_Node);
    procedure PrintBuffer;

    class function KDT70DDVec(const s: SystemString): TKDT70DD_Vec; overload;
    class function KDT70DDVec(const v: TKDT70DD_Vec): SystemString; overload;
    class function KDT70DDPow(const v: TKDT70DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT70DDDistance(const v1, v2: TKDT70DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT70DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT71DD = class(TCoreClassObject)
  public type
    // code split
    TKDT71DD_Vec = packed array [0 .. KDT71DD_Axis - 1] of TKDT71DD_VecType;
    PKDT71DD_Vec = ^TKDT71DD_Vec;

    TKDT71DD_DynamicVecBuffer = array of TKDT71DD_Vec;
    PKDT71DD_DynamicVecBuffer = ^TKDT71DD_DynamicVecBuffer;

    TKDT71DD_Source = packed record
      Buff: TKDT71DD_Vec;
      index: Integer;
    end;

    PKDT71DD_Source       = ^TKDT71DD_Source;
    TKDT71DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT71DD_Source) - 1] of PKDT71DD_Source;
    PKDT71DD_SourceBuffer = ^TKDT71DD_SourceBuffer;

    TKDT71DDyanmicSourceBuffer = packed array of PKDT71DD_Source;
    PKDT71DDyanmicSourceBuffer = ^TKDT71DDyanmicSourceBuffer;

    TKDT71DDyanmicStoreBuffer = packed array of TKDT71DD_Source;
    PKDT71DDyanmicStoreBuffer = ^TKDT71DDyanmicStoreBuffer;

    PKDT71DD_Node = ^TKDT71DD_Node;

    TKDT71DD_Node = packed record
      Parent, Right, Left: PKDT71DD_Node;
      vec: PKDT71DD_Source;
    end;

    TKDT71DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT71DD_Source; const Data: Pointer);
    TKDT71DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT71DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT71DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT71DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT71DDyanmicStoreBuffer;
    KDBuff     : TKDT71DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT71DD_Node;
    TestBuff   : TKDT71DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT71DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT71DD_Node;
    function GetData(const index: NativeInt): PKDT71DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT71DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT71DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT71DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT71DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT71DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT71DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT71DD_Node; overload;
    function Search(const Buff: TKDT71DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT71DD_Node; overload;
    function Search(const Buff: TKDT71DD_Vec; var SearchedDistanceMin: Double): PKDT71DD_Node; overload;
    function Search(const Buff: TKDT71DD_Vec): PKDT71DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT71DD_DynamicVecBuffer; var OutBuff: TKDT71DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT71DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT71DD_Node);
    procedure PrintBuffer;

    class function KDT71DDVec(const s: SystemString): TKDT71DD_Vec; overload;
    class function KDT71DDVec(const v: TKDT71DD_Vec): SystemString; overload;
    class function KDT71DDPow(const v: TKDT71DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT71DDDistance(const v1, v2: TKDT71DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT71DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT72DD = class(TCoreClassObject)
  public type
    // code split
    TKDT72DD_Vec = packed array [0 .. KDT72DD_Axis - 1] of TKDT72DD_VecType;
    PKDT72DD_Vec = ^TKDT72DD_Vec;

    TKDT72DD_DynamicVecBuffer = array of TKDT72DD_Vec;
    PKDT72DD_DynamicVecBuffer = ^TKDT72DD_DynamicVecBuffer;

    TKDT72DD_Source = packed record
      Buff: TKDT72DD_Vec;
      index: Integer;
    end;

    PKDT72DD_Source       = ^TKDT72DD_Source;
    TKDT72DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT72DD_Source) - 1] of PKDT72DD_Source;
    PKDT72DD_SourceBuffer = ^TKDT72DD_SourceBuffer;

    TKDT72DDyanmicSourceBuffer = packed array of PKDT72DD_Source;
    PKDT72DDyanmicSourceBuffer = ^TKDT72DDyanmicSourceBuffer;

    TKDT72DDyanmicStoreBuffer = packed array of TKDT72DD_Source;
    PKDT72DDyanmicStoreBuffer = ^TKDT72DDyanmicStoreBuffer;

    PKDT72DD_Node = ^TKDT72DD_Node;

    TKDT72DD_Node = packed record
      Parent, Right, Left: PKDT72DD_Node;
      vec: PKDT72DD_Source;
    end;

    TKDT72DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT72DD_Source; const Data: Pointer);
    TKDT72DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT72DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT72DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT72DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT72DDyanmicStoreBuffer;
    KDBuff     : TKDT72DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT72DD_Node;
    TestBuff   : TKDT72DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT72DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT72DD_Node;
    function GetData(const index: NativeInt): PKDT72DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT72DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT72DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT72DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT72DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT72DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT72DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT72DD_Node; overload;
    function Search(const Buff: TKDT72DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT72DD_Node; overload;
    function Search(const Buff: TKDT72DD_Vec; var SearchedDistanceMin: Double): PKDT72DD_Node; overload;
    function Search(const Buff: TKDT72DD_Vec): PKDT72DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT72DD_DynamicVecBuffer; var OutBuff: TKDT72DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT72DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT72DD_Node);
    procedure PrintBuffer;

    class function KDT72DDVec(const s: SystemString): TKDT72DD_Vec; overload;
    class function KDT72DDVec(const v: TKDT72DD_Vec): SystemString; overload;
    class function KDT72DDPow(const v: TKDT72DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT72DDDistance(const v1, v2: TKDT72DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT72DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT84DD = class(TCoreClassObject)
  public type
    // code split
    TKDT84DD_Vec = packed array [0 .. KDT84DD_Axis - 1] of TKDT84DD_VecType;
    PKDT84DD_Vec = ^TKDT84DD_Vec;

    TKDT84DD_DynamicVecBuffer = array of TKDT84DD_Vec;
    PKDT84DD_DynamicVecBuffer = ^TKDT84DD_DynamicVecBuffer;

    TKDT84DD_Source = packed record
      Buff: TKDT84DD_Vec;
      index: Integer;
    end;

    PKDT84DD_Source       = ^TKDT84DD_Source;
    TKDT84DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT84DD_Source) - 1] of PKDT84DD_Source;
    PKDT84DD_SourceBuffer = ^TKDT84DD_SourceBuffer;

    TKDT84DDyanmicSourceBuffer = packed array of PKDT84DD_Source;
    PKDT84DDyanmicSourceBuffer = ^TKDT84DDyanmicSourceBuffer;

    TKDT84DDyanmicStoreBuffer = packed array of TKDT84DD_Source;
    PKDT84DDyanmicStoreBuffer = ^TKDT84DDyanmicStoreBuffer;

    PKDT84DD_Node = ^TKDT84DD_Node;

    TKDT84DD_Node = packed record
      Parent, Right, Left: PKDT84DD_Node;
      vec: PKDT84DD_Source;
    end;

    TKDT84DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT84DD_Source; const Data: Pointer);
    TKDT84DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT84DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT84DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT84DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT84DDyanmicStoreBuffer;
    KDBuff     : TKDT84DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT84DD_Node;
    TestBuff   : TKDT84DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT84DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT84DD_Node;
    function GetData(const index: NativeInt): PKDT84DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT84DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT84DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT84DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT84DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT84DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT84DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT84DD_Node; overload;
    function Search(const Buff: TKDT84DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT84DD_Node; overload;
    function Search(const Buff: TKDT84DD_Vec; var SearchedDistanceMin: Double): PKDT84DD_Node; overload;
    function Search(const Buff: TKDT84DD_Vec): PKDT84DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT84DD_DynamicVecBuffer; var OutBuff: TKDT84DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT84DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT84DD_Node);
    procedure PrintBuffer;

    class function KDT84DDVec(const s: SystemString): TKDT84DD_Vec; overload;
    class function KDT84DDVec(const v: TKDT84DD_Vec): SystemString; overload;
    class function KDT84DDPow(const v: TKDT84DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT84DDDistance(const v1, v2: TKDT84DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT84DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT96DD = class(TCoreClassObject)
  public type
    // code split
    TKDT96DD_Vec = packed array [0 .. KDT96DD_Axis - 1] of TKDT96DD_VecType;
    PKDT96DD_Vec = ^TKDT96DD_Vec;

    TKDT96DD_DynamicVecBuffer = array of TKDT96DD_Vec;
    PKDT96DD_DynamicVecBuffer = ^TKDT96DD_DynamicVecBuffer;

    TKDT96DD_Source = packed record
      Buff: TKDT96DD_Vec;
      index: Integer;
    end;

    PKDT96DD_Source       = ^TKDT96DD_Source;
    TKDT96DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT96DD_Source) - 1] of PKDT96DD_Source;
    PKDT96DD_SourceBuffer = ^TKDT96DD_SourceBuffer;

    TKDT96DDyanmicSourceBuffer = packed array of PKDT96DD_Source;
    PKDT96DDyanmicSourceBuffer = ^TKDT96DDyanmicSourceBuffer;

    TKDT96DDyanmicStoreBuffer = packed array of TKDT96DD_Source;
    PKDT96DDyanmicStoreBuffer = ^TKDT96DDyanmicStoreBuffer;

    PKDT96DD_Node = ^TKDT96DD_Node;

    TKDT96DD_Node = packed record
      Parent, Right, Left: PKDT96DD_Node;
      vec: PKDT96DD_Source;
    end;

    TKDT96DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT96DD_Source; const Data: Pointer);
    TKDT96DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT96DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT96DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT96DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT96DDyanmicStoreBuffer;
    KDBuff     : TKDT96DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT96DD_Node;
    TestBuff   : TKDT96DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DD_Node;
    function GetData(const index: NativeInt): PKDT96DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT96DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT96DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT96DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT96DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DD_Node; overload;
    function Search(const Buff: TKDT96DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DD_Node; overload;
    function Search(const Buff: TKDT96DD_Vec; var SearchedDistanceMin: Double): PKDT96DD_Node; overload;
    function Search(const Buff: TKDT96DD_Vec): PKDT96DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT96DD_DynamicVecBuffer; var OutBuff: TKDT96DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT96DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT96DD_Node);
    procedure PrintBuffer;

    class function KDT96DDVec(const s: SystemString): TKDT96DD_Vec; overload;
    class function KDT96DDVec(const v: TKDT96DD_Vec): SystemString; overload;
    class function KDT96DDPow(const v: TKDT96DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT96DDDistance(const v1, v2: TKDT96DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT96DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT128DD = class(TCoreClassObject)
  public type
    // code split
    TKDT128DD_Vec = packed array [0 .. KDT128DD_Axis - 1] of TKDT128DD_VecType;
    PKDT128DD_Vec = ^TKDT128DD_Vec;

    TKDT128DD_DynamicVecBuffer = array of TKDT128DD_Vec;
    PKDT128DD_DynamicVecBuffer = ^TKDT128DD_DynamicVecBuffer;

    TKDT128DD_Source = packed record
      Buff: TKDT128DD_Vec;
      index: Integer;
    end;

    PKDT128DD_Source       = ^TKDT128DD_Source;
    TKDT128DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT128DD_Source) - 1] of PKDT128DD_Source;
    PKDT128DD_SourceBuffer = ^TKDT128DD_SourceBuffer;

    TKDT128DDyanmicSourceBuffer = packed array of PKDT128DD_Source;
    PKDT128DDyanmicSourceBuffer = ^TKDT128DDyanmicSourceBuffer;

    TKDT128DDyanmicStoreBuffer = packed array of TKDT128DD_Source;
    PKDT128DDyanmicStoreBuffer = ^TKDT128DDyanmicStoreBuffer;

    PKDT128DD_Node = ^TKDT128DD_Node;

    TKDT128DD_Node = packed record
      Parent, Right, Left: PKDT128DD_Node;
      vec: PKDT128DD_Source;
    end;

    TKDT128DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT128DD_Source; const Data: Pointer);
    TKDT128DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT128DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT128DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT128DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT128DDyanmicStoreBuffer;
    KDBuff     : TKDT128DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT128DD_Node;
    TestBuff   : TKDT128DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DD_Node;
    function GetData(const index: NativeInt): PKDT128DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT128DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT128DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT128DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT128DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DD_Node; overload;
    function Search(const Buff: TKDT128DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DD_Node; overload;
    function Search(const Buff: TKDT128DD_Vec; var SearchedDistanceMin: Double): PKDT128DD_Node; overload;
    function Search(const Buff: TKDT128DD_Vec): PKDT128DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT128DD_DynamicVecBuffer; var OutBuff: TKDT128DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT128DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT128DD_Node);
    procedure PrintBuffer;

    class function KDT128DDVec(const s: SystemString): TKDT128DD_Vec; overload;
    class function KDT128DDVec(const v: TKDT128DD_Vec): SystemString; overload;
    class function KDT128DDPow(const v: TKDT128DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT128DDDistance(const v1, v2: TKDT128DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT128DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT140DD = class(TCoreClassObject)
  public type
    // code split
    TKDT140DD_Vec = packed array [0 .. KDT140DD_Axis - 1] of TKDT140DD_VecType;
    PKDT140DD_Vec = ^TKDT140DD_Vec;

    TKDT140DD_DynamicVecBuffer = array of TKDT140DD_Vec;
    PKDT140DD_DynamicVecBuffer = ^TKDT140DD_DynamicVecBuffer;

    TKDT140DD_Source = packed record
      Buff: TKDT140DD_Vec;
      index: Integer;
    end;

    PKDT140DD_Source       = ^TKDT140DD_Source;
    TKDT140DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT140DD_Source) - 1] of PKDT140DD_Source;
    PKDT140DD_SourceBuffer = ^TKDT140DD_SourceBuffer;

    TKDT140DDyanmicSourceBuffer = packed array of PKDT140DD_Source;
    PKDT140DDyanmicSourceBuffer = ^TKDT140DDyanmicSourceBuffer;

    TKDT140DDyanmicStoreBuffer = packed array of TKDT140DD_Source;
    PKDT140DDyanmicStoreBuffer = ^TKDT140DDyanmicStoreBuffer;

    PKDT140DD_Node = ^TKDT140DD_Node;

    TKDT140DD_Node = packed record
      Parent, Right, Left: PKDT140DD_Node;
      vec: PKDT140DD_Source;
    end;

    TKDT140DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT140DD_Source; const Data: Pointer);
    TKDT140DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT140DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT140DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT140DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT140DDyanmicStoreBuffer;
    KDBuff     : TKDT140DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT140DD_Node;
    TestBuff   : TKDT140DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT140DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT140DD_Node;
    function GetData(const index: NativeInt): PKDT140DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT140DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT140DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT140DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT140DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT140DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT140DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT140DD_Node; overload;
    function Search(const Buff: TKDT140DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT140DD_Node; overload;
    function Search(const Buff: TKDT140DD_Vec; var SearchedDistanceMin: Double): PKDT140DD_Node; overload;
    function Search(const Buff: TKDT140DD_Vec): PKDT140DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT140DD_DynamicVecBuffer; var OutBuff: TKDT140DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT140DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT140DD_Node);
    procedure PrintBuffer;

    class function KDT140DDVec(const s: SystemString): TKDT140DD_Vec; overload;
    class function KDT140DDVec(const v: TKDT140DD_Vec): SystemString; overload;
    class function KDT140DDPow(const v: TKDT140DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT140DDDistance(const v1, v2: TKDT140DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT140DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT160DD = class(TCoreClassObject)
  public type
    // code split
    TKDT160DD_Vec = packed array [0 .. KDT160DD_Axis - 1] of TKDT160DD_VecType;
    PKDT160DD_Vec = ^TKDT160DD_Vec;

    TKDT160DD_DynamicVecBuffer = array of TKDT160DD_Vec;
    PKDT160DD_DynamicVecBuffer = ^TKDT160DD_DynamicVecBuffer;

    TKDT160DD_Source = packed record
      Buff: TKDT160DD_Vec;
      index: Integer;
    end;

    PKDT160DD_Source       = ^TKDT160DD_Source;
    TKDT160DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT160DD_Source) - 1] of PKDT160DD_Source;
    PKDT160DD_SourceBuffer = ^TKDT160DD_SourceBuffer;

    TKDT160DDyanmicSourceBuffer = packed array of PKDT160DD_Source;
    PKDT160DDyanmicSourceBuffer = ^TKDT160DDyanmicSourceBuffer;

    TKDT160DDyanmicStoreBuffer = packed array of TKDT160DD_Source;
    PKDT160DDyanmicStoreBuffer = ^TKDT160DDyanmicStoreBuffer;

    PKDT160DD_Node = ^TKDT160DD_Node;

    TKDT160DD_Node = packed record
      Parent, Right, Left: PKDT160DD_Node;
      vec: PKDT160DD_Source;
    end;

    TKDT160DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT160DD_Source; const Data: Pointer);
    TKDT160DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT160DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT160DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT160DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT160DDyanmicStoreBuffer;
    KDBuff     : TKDT160DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT160DD_Node;
    TestBuff   : TKDT160DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT160DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT160DD_Node;
    function GetData(const index: NativeInt): PKDT160DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT160DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT160DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT160DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT160DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT160DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT160DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT160DD_Node; overload;
    function Search(const Buff: TKDT160DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT160DD_Node; overload;
    function Search(const Buff: TKDT160DD_Vec; var SearchedDistanceMin: Double): PKDT160DD_Node; overload;
    function Search(const Buff: TKDT160DD_Vec): PKDT160DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT160DD_DynamicVecBuffer; var OutBuff: TKDT160DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT160DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT160DD_Node);
    procedure PrintBuffer;

    class function KDT160DDVec(const s: SystemString): TKDT160DD_Vec; overload;
    class function KDT160DDVec(const v: TKDT160DD_Vec): SystemString; overload;
    class function KDT160DDPow(const v: TKDT160DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT160DDDistance(const v1, v2: TKDT160DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT160DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT196DD = class(TCoreClassObject)
  public type
    // code split
    TKDT196DD_Vec = packed array [0 .. KDT196DD_Axis - 1] of TKDT196DD_VecType;
    PKDT196DD_Vec = ^TKDT196DD_Vec;

    TKDT196DD_DynamicVecBuffer = array of TKDT196DD_Vec;
    PKDT196DD_DynamicVecBuffer = ^TKDT196DD_DynamicVecBuffer;

    TKDT196DD_Source = packed record
      Buff: TKDT196DD_Vec;
      index: Integer;
    end;

    PKDT196DD_Source       = ^TKDT196DD_Source;
    TKDT196DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT196DD_Source) - 1] of PKDT196DD_Source;
    PKDT196DD_SourceBuffer = ^TKDT196DD_SourceBuffer;

    TKDT196DDyanmicSourceBuffer = packed array of PKDT196DD_Source;
    PKDT196DDyanmicSourceBuffer = ^TKDT196DDyanmicSourceBuffer;

    TKDT196DDyanmicStoreBuffer = packed array of TKDT196DD_Source;
    PKDT196DDyanmicStoreBuffer = ^TKDT196DDyanmicStoreBuffer;

    PKDT196DD_Node = ^TKDT196DD_Node;

    TKDT196DD_Node = packed record
      Parent, Right, Left: PKDT196DD_Node;
      vec: PKDT196DD_Source;
    end;

    TKDT196DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT196DD_Source; const Data: Pointer);
    TKDT196DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT196DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT196DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT196DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT196DDyanmicStoreBuffer;
    KDBuff     : TKDT196DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT196DD_Node;
    TestBuff   : TKDT196DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT196DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT196DD_Node;
    function GetData(const index: NativeInt): PKDT196DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT196DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT196DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT196DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT196DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT196DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT196DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT196DD_Node; overload;
    function Search(const Buff: TKDT196DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT196DD_Node; overload;
    function Search(const Buff: TKDT196DD_Vec; var SearchedDistanceMin: Double): PKDT196DD_Node; overload;
    function Search(const Buff: TKDT196DD_Vec): PKDT196DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT196DD_DynamicVecBuffer; var OutBuff: TKDT196DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT196DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT196DD_Node);
    procedure PrintBuffer;

    class function KDT196DDVec(const s: SystemString): TKDT196DD_Vec; overload;
    class function KDT196DDVec(const v: TKDT196DD_Vec): SystemString; overload;
    class function KDT196DDPow(const v: TKDT196DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT196DDDistance(const v1, v2: TKDT196DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT196DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT256DD = class(TCoreClassObject)
  public type
    // code split
    TKDT256DD_Vec = packed array [0 .. KDT256DD_Axis - 1] of TKDT256DD_VecType;
    PKDT256DD_Vec = ^TKDT256DD_Vec;

    TKDT256DD_DynamicVecBuffer = array of TKDT256DD_Vec;
    PKDT256DD_DynamicVecBuffer = ^TKDT256DD_DynamicVecBuffer;

    TKDT256DD_Source = packed record
      Buff: TKDT256DD_Vec;
      index: Integer;
    end;

    PKDT256DD_Source       = ^TKDT256DD_Source;
    TKDT256DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT256DD_Source) - 1] of PKDT256DD_Source;
    PKDT256DD_SourceBuffer = ^TKDT256DD_SourceBuffer;

    TKDT256DDyanmicSourceBuffer = packed array of PKDT256DD_Source;
    PKDT256DDyanmicSourceBuffer = ^TKDT256DDyanmicSourceBuffer;

    TKDT256DDyanmicStoreBuffer = packed array of TKDT256DD_Source;
    PKDT256DDyanmicStoreBuffer = ^TKDT256DDyanmicStoreBuffer;

    PKDT256DD_Node = ^TKDT256DD_Node;

    TKDT256DD_Node = packed record
      Parent, Right, Left: PKDT256DD_Node;
      vec: PKDT256DD_Source;
    end;

    TKDT256DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT256DD_Source; const Data: Pointer);
    TKDT256DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT256DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT256DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT256DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT256DDyanmicStoreBuffer;
    KDBuff     : TKDT256DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT256DD_Node;
    TestBuff   : TKDT256DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DD_Node;
    function GetData(const index: NativeInt): PKDT256DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT256DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT256DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT256DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT256DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DD_Node; overload;
    function Search(const Buff: TKDT256DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DD_Node; overload;
    function Search(const Buff: TKDT256DD_Vec; var SearchedDistanceMin: Double): PKDT256DD_Node; overload;
    function Search(const Buff: TKDT256DD_Vec): PKDT256DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT256DD_DynamicVecBuffer; var OutBuff: TKDT256DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT256DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT256DD_Node);
    procedure PrintBuffer;

    class function KDT256DDVec(const s: SystemString): TKDT256DD_Vec; overload;
    class function KDT256DDVec(const v: TKDT256DD_Vec): SystemString; overload;
    class function KDT256DDPow(const v: TKDT256DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT256DDDistance(const v1, v2: TKDT256DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT256DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT272DD = class(TCoreClassObject)
  public type
    // code split
    TKDT272DD_Vec = packed array [0 .. KDT272DD_Axis - 1] of TKDT272DD_VecType;
    PKDT272DD_Vec = ^TKDT272DD_Vec;

    TKDT272DD_DynamicVecBuffer = array of TKDT272DD_Vec;
    PKDT272DD_DynamicVecBuffer = ^TKDT272DD_DynamicVecBuffer;

    TKDT272DD_Source = packed record
      Buff: TKDT272DD_Vec;
      index: Integer;
    end;

    PKDT272DD_Source       = ^TKDT272DD_Source;
    TKDT272DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT272DD_Source) - 1] of PKDT272DD_Source;
    PKDT272DD_SourceBuffer = ^TKDT272DD_SourceBuffer;

    TKDT272DDyanmicSourceBuffer = packed array of PKDT272DD_Source;
    PKDT272DDyanmicSourceBuffer = ^TKDT272DDyanmicSourceBuffer;

    TKDT272DDyanmicStoreBuffer = packed array of TKDT272DD_Source;
    PKDT272DDyanmicStoreBuffer = ^TKDT272DDyanmicStoreBuffer;

    PKDT272DD_Node = ^TKDT272DD_Node;

    TKDT272DD_Node = packed record
      Parent, Right, Left: PKDT272DD_Node;
      vec: PKDT272DD_Source;
    end;

    TKDT272DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT272DD_Source; const Data: Pointer);
    TKDT272DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT272DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT272DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT272DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT272DDyanmicStoreBuffer;
    KDBuff     : TKDT272DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT272DD_Node;
    TestBuff   : TKDT272DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT272DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT272DD_Node;
    function GetData(const index: NativeInt): PKDT272DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT272DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT272DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT272DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT272DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT272DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT272DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT272DD_Node; overload;
    function Search(const Buff: TKDT272DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT272DD_Node; overload;
    function Search(const Buff: TKDT272DD_Vec; var SearchedDistanceMin: Double): PKDT272DD_Node; overload;
    function Search(const Buff: TKDT272DD_Vec): PKDT272DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT272DD_DynamicVecBuffer; var OutBuff: TKDT272DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT272DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT272DD_Node);
    procedure PrintBuffer;

    class function KDT272DDVec(const s: SystemString): TKDT272DD_Vec; overload;
    class function KDT272DDVec(const v: TKDT272DD_Vec): SystemString; overload;
    class function KDT272DDPow(const v: TKDT272DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT272DDDistance(const v1, v2: TKDT272DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT272DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT288DD = class(TCoreClassObject)
  public type
    // code split
    TKDT288DD_Vec = packed array [0 .. KDT288DD_Axis - 1] of TKDT288DD_VecType;
    PKDT288DD_Vec = ^TKDT288DD_Vec;

    TKDT288DD_DynamicVecBuffer = array of TKDT288DD_Vec;
    PKDT288DD_DynamicVecBuffer = ^TKDT288DD_DynamicVecBuffer;

    TKDT288DD_Source = packed record
      Buff: TKDT288DD_Vec;
      index: Integer;
    end;

    PKDT288DD_Source       = ^TKDT288DD_Source;
    TKDT288DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT288DD_Source) - 1] of PKDT288DD_Source;
    PKDT288DD_SourceBuffer = ^TKDT288DD_SourceBuffer;

    TKDT288DDyanmicSourceBuffer = packed array of PKDT288DD_Source;
    PKDT288DDyanmicSourceBuffer = ^TKDT288DDyanmicSourceBuffer;

    TKDT288DDyanmicStoreBuffer = packed array of TKDT288DD_Source;
    PKDT288DDyanmicStoreBuffer = ^TKDT288DDyanmicStoreBuffer;

    PKDT288DD_Node = ^TKDT288DD_Node;

    TKDT288DD_Node = packed record
      Parent, Right, Left: PKDT288DD_Node;
      vec: PKDT288DD_Source;
    end;

    TKDT288DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT288DD_Source; const Data: Pointer);
    TKDT288DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT288DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT288DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT288DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT288DDyanmicStoreBuffer;
    KDBuff     : TKDT288DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT288DD_Node;
    TestBuff   : TKDT288DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT288DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT288DD_Node;
    function GetData(const index: NativeInt): PKDT288DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT288DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT288DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT288DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT288DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT288DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT288DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT288DD_Node; overload;
    function Search(const Buff: TKDT288DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT288DD_Node; overload;
    function Search(const Buff: TKDT288DD_Vec; var SearchedDistanceMin: Double): PKDT288DD_Node; overload;
    function Search(const Buff: TKDT288DD_Vec): PKDT288DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT288DD_DynamicVecBuffer; var OutBuff: TKDT288DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT288DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT288DD_Node);
    procedure PrintBuffer;

    class function KDT288DDVec(const s: SystemString): TKDT288DD_Vec; overload;
    class function KDT288DDVec(const v: TKDT288DD_Vec): SystemString; overload;
    class function KDT288DDPow(const v: TKDT288DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT288DDDistance(const v1, v2: TKDT288DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT288DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT372DD = class(TCoreClassObject)
  public type
    // code split
    TKDT372DD_Vec = packed array [0 .. KDT372DD_Axis - 1] of TKDT372DD_VecType;
    PKDT372DD_Vec = ^TKDT372DD_Vec;

    TKDT372DD_DynamicVecBuffer = array of TKDT372DD_Vec;
    PKDT372DD_DynamicVecBuffer = ^TKDT372DD_DynamicVecBuffer;

    TKDT372DD_Source = packed record
      Buff: TKDT372DD_Vec;
      index: Integer;
    end;

    PKDT372DD_Source       = ^TKDT372DD_Source;
    TKDT372DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT372DD_Source) - 1] of PKDT372DD_Source;
    PKDT372DD_SourceBuffer = ^TKDT372DD_SourceBuffer;

    TKDT372DDyanmicSourceBuffer = packed array of PKDT372DD_Source;
    PKDT372DDyanmicSourceBuffer = ^TKDT372DDyanmicSourceBuffer;

    TKDT372DDyanmicStoreBuffer = packed array of TKDT372DD_Source;
    PKDT372DDyanmicStoreBuffer = ^TKDT372DDyanmicStoreBuffer;

    PKDT372DD_Node = ^TKDT372DD_Node;

    TKDT372DD_Node = packed record
      Parent, Right, Left: PKDT372DD_Node;
      vec: PKDT372DD_Source;
    end;

    TKDT372DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT372DD_Source; const Data: Pointer);
    TKDT372DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT372DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT372DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT372DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT372DDyanmicStoreBuffer;
    KDBuff     : TKDT372DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT372DD_Node;
    TestBuff   : TKDT372DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DD_Node;
    function GetData(const index: NativeInt): PKDT372DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT372DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT372DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT372DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT372DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DD_Node; overload;
    function Search(const Buff: TKDT372DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DD_Node; overload;
    function Search(const Buff: TKDT372DD_Vec; var SearchedDistanceMin: Double): PKDT372DD_Node; overload;
    function Search(const Buff: TKDT372DD_Vec): PKDT372DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT372DD_DynamicVecBuffer; var OutBuff: TKDT372DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT372DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT372DD_Node);
    procedure PrintBuffer;

    class function KDT372DDVec(const s: SystemString): TKDT372DD_Vec; overload;
    class function KDT372DDVec(const v: TKDT372DD_Vec): SystemString; overload;
    class function KDT372DDPow(const v: TKDT372DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT372DDDistance(const v1, v2: TKDT372DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT372DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT512DD = class(TCoreClassObject)
  public type
    // code split
    TKDT512DD_Vec = packed array [0 .. KDT512DD_Axis - 1] of TKDT512DD_VecType;
    PKDT512DD_Vec = ^TKDT512DD_Vec;

    TKDT512DD_DynamicVecBuffer = array of TKDT512DD_Vec;
    PKDT512DD_DynamicVecBuffer = ^TKDT512DD_DynamicVecBuffer;

    TKDT512DD_Source = packed record
      Buff: TKDT512DD_Vec;
      index: Integer;
    end;

    PKDT512DD_Source       = ^TKDT512DD_Source;
    TKDT512DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT512DD_Source) - 1] of PKDT512DD_Source;
    PKDT512DD_SourceBuffer = ^TKDT512DD_SourceBuffer;

    TKDT512DDyanmicSourceBuffer = packed array of PKDT512DD_Source;
    PKDT512DDyanmicSourceBuffer = ^TKDT512DDyanmicSourceBuffer;

    TKDT512DDyanmicStoreBuffer = packed array of TKDT512DD_Source;
    PKDT512DDyanmicStoreBuffer = ^TKDT512DDyanmicStoreBuffer;

    PKDT512DD_Node = ^TKDT512DD_Node;

    TKDT512DD_Node = packed record
      Parent, Right, Left: PKDT512DD_Node;
      vec: PKDT512DD_Source;
    end;

    TKDT512DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT512DD_Source; const Data: Pointer);
    TKDT512DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT512DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT512DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT512DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT512DDyanmicStoreBuffer;
    KDBuff     : TKDT512DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT512DD_Node;
    TestBuff   : TKDT512DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DD_Node;
    function GetData(const index: NativeInt): PKDT512DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT512DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT512DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT512DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT512DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DD_Node; overload;
    function Search(const Buff: TKDT512DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DD_Node; overload;
    function Search(const Buff: TKDT512DD_Vec; var SearchedDistanceMin: Double): PKDT512DD_Node; overload;
    function Search(const Buff: TKDT512DD_Vec): PKDT512DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT512DD_DynamicVecBuffer; var OutBuff: TKDT512DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT512DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT512DD_Node);
    procedure PrintBuffer;

    class function KDT512DDVec(const s: SystemString): TKDT512DD_Vec; overload;
    class function KDT512DDVec(const v: TKDT512DD_Vec): SystemString; overload;
    class function KDT512DDPow(const v: TKDT512DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT512DDDistance(const v1, v2: TKDT512DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT512DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT576DD = class(TCoreClassObject)
  public type
    // code split
    TKDT576DD_Vec = packed array [0 .. KDT576DD_Axis - 1] of TKDT576DD_VecType;
    PKDT576DD_Vec = ^TKDT576DD_Vec;

    TKDT576DD_DynamicVecBuffer = array of TKDT576DD_Vec;
    PKDT576DD_DynamicVecBuffer = ^TKDT576DD_DynamicVecBuffer;

    TKDT576DD_Source = packed record
      Buff: TKDT576DD_Vec;
      index: Integer;
    end;

    PKDT576DD_Source       = ^TKDT576DD_Source;
    TKDT576DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT576DD_Source) - 1] of PKDT576DD_Source;
    PKDT576DD_SourceBuffer = ^TKDT576DD_SourceBuffer;

    TKDT576DDyanmicSourceBuffer = packed array of PKDT576DD_Source;
    PKDT576DDyanmicSourceBuffer = ^TKDT576DDyanmicSourceBuffer;

    TKDT576DDyanmicStoreBuffer = packed array of TKDT576DD_Source;
    PKDT576DDyanmicStoreBuffer = ^TKDT576DDyanmicStoreBuffer;

    PKDT576DD_Node = ^TKDT576DD_Node;

    TKDT576DD_Node = packed record
      Parent, Right, Left: PKDT576DD_Node;
      vec: PKDT576DD_Source;
    end;

    TKDT576DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT576DD_Source; const Data: Pointer);
    TKDT576DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT576DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT576DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT576DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT576DDyanmicStoreBuffer;
    KDBuff     : TKDT576DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT576DD_Node;
    TestBuff   : TKDT576DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT576DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT576DD_Node;
    function GetData(const index: NativeInt): PKDT576DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT576DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT576DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT576DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT576DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT576DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT576DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT576DD_Node; overload;
    function Search(const Buff: TKDT576DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT576DD_Node; overload;
    function Search(const Buff: TKDT576DD_Vec; var SearchedDistanceMin: Double): PKDT576DD_Node; overload;
    function Search(const Buff: TKDT576DD_Vec): PKDT576DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT576DD_DynamicVecBuffer; var OutBuff: TKDT576DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT576DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT576DD_Node);
    procedure PrintBuffer;

    class function KDT576DDVec(const s: SystemString): TKDT576DD_Vec; overload;
    class function KDT576DDVec(const v: TKDT576DD_Vec): SystemString; overload;
    class function KDT576DDPow(const v: TKDT576DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT576DDDistance(const v1, v2: TKDT576DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT576DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT768DD = class(TCoreClassObject)
  public type
    // code split
    TKDT768DD_Vec = packed array [0 .. KDT768DD_Axis - 1] of TKDT768DD_VecType;
    PKDT768DD_Vec = ^TKDT768DD_Vec;

    TKDT768DD_DynamicVecBuffer = array of TKDT768DD_Vec;
    PKDT768DD_DynamicVecBuffer = ^TKDT768DD_DynamicVecBuffer;

    TKDT768DD_Source = packed record
      Buff: TKDT768DD_Vec;
      index: Integer;
    end;

    PKDT768DD_Source       = ^TKDT768DD_Source;
    TKDT768DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT768DD_Source) - 1] of PKDT768DD_Source;
    PKDT768DD_SourceBuffer = ^TKDT768DD_SourceBuffer;

    TKDT768DDyanmicSourceBuffer = packed array of PKDT768DD_Source;
    PKDT768DDyanmicSourceBuffer = ^TKDT768DDyanmicSourceBuffer;

    TKDT768DDyanmicStoreBuffer = packed array of TKDT768DD_Source;
    PKDT768DDyanmicStoreBuffer = ^TKDT768DDyanmicStoreBuffer;

    PKDT768DD_Node = ^TKDT768DD_Node;

    TKDT768DD_Node = packed record
      Parent, Right, Left: PKDT768DD_Node;
      vec: PKDT768DD_Source;
    end;

    TKDT768DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT768DD_Source; const Data: Pointer);
    TKDT768DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT768DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT768DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT768DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT768DDyanmicStoreBuffer;
    KDBuff     : TKDT768DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT768DD_Node;
    TestBuff   : TKDT768DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DD_Node;
    function GetData(const index: NativeInt): PKDT768DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT768DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT768DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT768DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT768DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DD_Node; overload;
    function Search(const Buff: TKDT768DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DD_Node; overload;
    function Search(const Buff: TKDT768DD_Vec; var SearchedDistanceMin: Double): PKDT768DD_Node; overload;
    function Search(const Buff: TKDT768DD_Vec): PKDT768DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT768DD_DynamicVecBuffer; var OutBuff: TKDT768DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT768DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT768DD_Node);
    procedure PrintBuffer;

    class function KDT768DDVec(const s: SystemString): TKDT768DD_Vec; overload;
    class function KDT768DDVec(const v: TKDT768DD_Vec): SystemString; overload;
    class function KDT768DDPow(const v: TKDT768DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT768DDDistance(const v1, v2: TKDT768DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT768DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1024DD = class(TCoreClassObject)
  public type
    // code split
    TKDT1024DD_Vec = packed array [0 .. KDT1024DD_Axis - 1] of TKDT1024DD_VecType;
    PKDT1024DD_Vec = ^TKDT1024DD_Vec;

    TKDT1024DD_DynamicVecBuffer = array of TKDT1024DD_Vec;
    PKDT1024DD_DynamicVecBuffer = ^TKDT1024DD_DynamicVecBuffer;

    TKDT1024DD_Source = packed record
      Buff: TKDT1024DD_Vec;
      index: Integer;
    end;

    PKDT1024DD_Source       = ^TKDT1024DD_Source;
    TKDT1024DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT1024DD_Source) - 1] of PKDT1024DD_Source;
    PKDT1024DD_SourceBuffer = ^TKDT1024DD_SourceBuffer;

    TKDT1024DDyanmicSourceBuffer = packed array of PKDT1024DD_Source;
    PKDT1024DDyanmicSourceBuffer = ^TKDT1024DDyanmicSourceBuffer;

    TKDT1024DDyanmicStoreBuffer = packed array of TKDT1024DD_Source;
    PKDT1024DDyanmicStoreBuffer = ^TKDT1024DDyanmicStoreBuffer;

    PKDT1024DD_Node = ^TKDT1024DD_Node;

    TKDT1024DD_Node = packed record
      Parent, Right, Left: PKDT1024DD_Node;
      vec: PKDT1024DD_Source;
    end;

    TKDT1024DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1024DD_Source; const Data: Pointer);
    TKDT1024DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1024DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1024DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1024DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1024DDyanmicStoreBuffer;
    KDBuff     : TKDT1024DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1024DD_Node;
    TestBuff   : TKDT1024DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DD_Node;
    function GetData(const index: NativeInt): PKDT1024DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1024DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1024DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1024DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1024DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DD_Node; overload;
    function Search(const Buff: TKDT1024DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DD_Node; overload;
    function Search(const Buff: TKDT1024DD_Vec; var SearchedDistanceMin: Double): PKDT1024DD_Node; overload;
    function Search(const Buff: TKDT1024DD_Vec): PKDT1024DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1024DD_DynamicVecBuffer; var OutBuff: TKDT1024DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1024DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT1024DD_Node);
    procedure PrintBuffer;

    class function KDT1024DDVec(const s: SystemString): TKDT1024DD_Vec; overload;
    class function KDT1024DDVec(const v: TKDT1024DD_Vec): SystemString; overload;
    class function KDT1024DDPow(const v: TKDT1024DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1024DDDistance(const v1, v2: TKDT1024DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1024DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1040DD = class(TCoreClassObject)
  public type
    // code split
    TKDT1040DD_Vec = packed array [0 .. KDT1040DD_Axis - 1] of TKDT1040DD_VecType;
    PKDT1040DD_Vec = ^TKDT1040DD_Vec;

    TKDT1040DD_DynamicVecBuffer = array of TKDT1040DD_Vec;
    PKDT1040DD_DynamicVecBuffer = ^TKDT1040DD_DynamicVecBuffer;

    TKDT1040DD_Source = packed record
      Buff: TKDT1040DD_Vec;
      index: Integer;
    end;

    PKDT1040DD_Source       = ^TKDT1040DD_Source;
    TKDT1040DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT1040DD_Source) - 1] of PKDT1040DD_Source;
    PKDT1040DD_SourceBuffer = ^TKDT1040DD_SourceBuffer;

    TKDT1040DDyanmicSourceBuffer = packed array of PKDT1040DD_Source;
    PKDT1040DDyanmicSourceBuffer = ^TKDT1040DDyanmicSourceBuffer;

    TKDT1040DDyanmicStoreBuffer = packed array of TKDT1040DD_Source;
    PKDT1040DDyanmicStoreBuffer = ^TKDT1040DDyanmicStoreBuffer;

    PKDT1040DD_Node = ^TKDT1040DD_Node;

    TKDT1040DD_Node = packed record
      Parent, Right, Left: PKDT1040DD_Node;
      vec: PKDT1040DD_Source;
    end;

    TKDT1040DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1040DD_Source; const Data: Pointer);
    TKDT1040DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1040DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1040DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1040DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1040DDyanmicStoreBuffer;
    KDBuff     : TKDT1040DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1040DD_Node;
    TestBuff   : TKDT1040DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1040DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1040DD_Node;
    function GetData(const index: NativeInt): PKDT1040DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1040DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1040DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1040DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1040DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1040DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1040DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1040DD_Node; overload;
    function Search(const Buff: TKDT1040DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1040DD_Node; overload;
    function Search(const Buff: TKDT1040DD_Vec; var SearchedDistanceMin: Double): PKDT1040DD_Node; overload;
    function Search(const Buff: TKDT1040DD_Vec): PKDT1040DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1040DD_DynamicVecBuffer; var OutBuff: TKDT1040DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1040DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT1040DD_Node);
    procedure PrintBuffer;

    class function KDT1040DDVec(const s: SystemString): TKDT1040DD_Vec; overload;
    class function KDT1040DDVec(const v: TKDT1040DD_Vec): SystemString; overload;
    class function KDT1040DDPow(const v: TKDT1040DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1040DDDistance(const v1, v2: TKDT1040DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1040DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1056DD = class(TCoreClassObject)
  public type
    // code split
    TKDT1056DD_Vec = packed array [0 .. KDT1056DD_Axis - 1] of TKDT1056DD_VecType;
    PKDT1056DD_Vec = ^TKDT1056DD_Vec;

    TKDT1056DD_DynamicVecBuffer = array of TKDT1056DD_Vec;
    PKDT1056DD_DynamicVecBuffer = ^TKDT1056DD_DynamicVecBuffer;

    TKDT1056DD_Source = packed record
      Buff: TKDT1056DD_Vec;
      index: Integer;
    end;

    PKDT1056DD_Source       = ^TKDT1056DD_Source;
    TKDT1056DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT1056DD_Source) - 1] of PKDT1056DD_Source;
    PKDT1056DD_SourceBuffer = ^TKDT1056DD_SourceBuffer;

    TKDT1056DDyanmicSourceBuffer = packed array of PKDT1056DD_Source;
    PKDT1056DDyanmicSourceBuffer = ^TKDT1056DDyanmicSourceBuffer;

    TKDT1056DDyanmicStoreBuffer = packed array of TKDT1056DD_Source;
    PKDT1056DDyanmicStoreBuffer = ^TKDT1056DDyanmicStoreBuffer;

    PKDT1056DD_Node = ^TKDT1056DD_Node;

    TKDT1056DD_Node = packed record
      Parent, Right, Left: PKDT1056DD_Node;
      vec: PKDT1056DD_Source;
    end;

    TKDT1056DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1056DD_Source; const Data: Pointer);
    TKDT1056DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1056DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1056DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1056DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1056DDyanmicStoreBuffer;
    KDBuff     : TKDT1056DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1056DD_Node;
    TestBuff   : TKDT1056DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1056DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1056DD_Node;
    function GetData(const index: NativeInt): PKDT1056DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1056DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1056DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1056DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1056DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1056DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1056DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1056DD_Node; overload;
    function Search(const Buff: TKDT1056DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1056DD_Node; overload;
    function Search(const Buff: TKDT1056DD_Vec; var SearchedDistanceMin: Double): PKDT1056DD_Node; overload;
    function Search(const Buff: TKDT1056DD_Vec): PKDT1056DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1056DD_DynamicVecBuffer; var OutBuff: TKDT1056DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1056DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT1056DD_Node);
    procedure PrintBuffer;

    class function KDT1056DDVec(const s: SystemString): TKDT1056DD_Vec; overload;
    class function KDT1056DDVec(const v: TKDT1056DD_Vec): SystemString; overload;
    class function KDT1056DDPow(const v: TKDT1056DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1056DDDistance(const v1, v2: TKDT1056DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1056DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1536DD = class(TCoreClassObject)
  public type
    // code split
    TKDT1536DD_Vec = packed array [0 .. KDT1536DD_Axis - 1] of TKDT1536DD_VecType;
    PKDT1536DD_Vec = ^TKDT1536DD_Vec;

    TKDT1536DD_DynamicVecBuffer = array of TKDT1536DD_Vec;
    PKDT1536DD_DynamicVecBuffer = ^TKDT1536DD_DynamicVecBuffer;

    TKDT1536DD_Source = packed record
      Buff: TKDT1536DD_Vec;
      index: Integer;
    end;

    PKDT1536DD_Source       = ^TKDT1536DD_Source;
    TKDT1536DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT1536DD_Source) - 1] of PKDT1536DD_Source;
    PKDT1536DD_SourceBuffer = ^TKDT1536DD_SourceBuffer;

    TKDT1536DDyanmicSourceBuffer = packed array of PKDT1536DD_Source;
    PKDT1536DDyanmicSourceBuffer = ^TKDT1536DDyanmicSourceBuffer;

    TKDT1536DDyanmicStoreBuffer = packed array of TKDT1536DD_Source;
    PKDT1536DDyanmicStoreBuffer = ^TKDT1536DDyanmicStoreBuffer;

    PKDT1536DD_Node = ^TKDT1536DD_Node;

    TKDT1536DD_Node = packed record
      Parent, Right, Left: PKDT1536DD_Node;
      vec: PKDT1536DD_Source;
    end;

    TKDT1536DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1536DD_Source; const Data: Pointer);
    TKDT1536DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1536DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1536DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1536DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1536DDyanmicStoreBuffer;
    KDBuff     : TKDT1536DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1536DD_Node;
    TestBuff   : TKDT1536DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DD_Node;
    function GetData(const index: NativeInt): PKDT1536DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1536DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1536DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1536DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1536DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DD_Node; overload;
    function Search(const Buff: TKDT1536DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DD_Node; overload;
    function Search(const Buff: TKDT1536DD_Vec; var SearchedDistanceMin: Double): PKDT1536DD_Node; overload;
    function Search(const Buff: TKDT1536DD_Vec): PKDT1536DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1536DD_DynamicVecBuffer; var OutBuff: TKDT1536DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1536DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT1536DD_Node);
    procedure PrintBuffer;

    class function KDT1536DDVec(const s: SystemString): TKDT1536DD_Vec; overload;
    class function KDT1536DDVec(const v: TKDT1536DD_Vec): SystemString; overload;
    class function KDT1536DDPow(const v: TKDT1536DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1536DDDistance(const v1, v2: TKDT1536DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1536DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1920DD = class(TCoreClassObject)
  public type
    // code split
    TKDT1920DD_Vec = packed array [0 .. KDT1920DD_Axis - 1] of TKDT1920DD_VecType;
    PKDT1920DD_Vec = ^TKDT1920DD_Vec;

    TKDT1920DD_DynamicVecBuffer = array of TKDT1920DD_Vec;
    PKDT1920DD_DynamicVecBuffer = ^TKDT1920DD_DynamicVecBuffer;

    TKDT1920DD_Source = packed record
      Buff: TKDT1920DD_Vec;
      index: Integer;
    end;

    PKDT1920DD_Source       = ^TKDT1920DD_Source;
    TKDT1920DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT1920DD_Source) - 1] of PKDT1920DD_Source;
    PKDT1920DD_SourceBuffer = ^TKDT1920DD_SourceBuffer;

    TKDT1920DDyanmicSourceBuffer = packed array of PKDT1920DD_Source;
    PKDT1920DDyanmicSourceBuffer = ^TKDT1920DDyanmicSourceBuffer;

    TKDT1920DDyanmicStoreBuffer = packed array of TKDT1920DD_Source;
    PKDT1920DDyanmicStoreBuffer = ^TKDT1920DDyanmicStoreBuffer;

    PKDT1920DD_Node = ^TKDT1920DD_Node;

    TKDT1920DD_Node = packed record
      Parent, Right, Left: PKDT1920DD_Node;
      vec: PKDT1920DD_Source;
    end;

    TKDT1920DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1920DD_Source; const Data: Pointer);
    TKDT1920DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1920DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1920DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1920DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1920DDyanmicStoreBuffer;
    KDBuff     : TKDT1920DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1920DD_Node;
    TestBuff   : TKDT1920DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DD_Node;
    function GetData(const index: NativeInt): PKDT1920DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1920DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1920DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1920DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1920DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DD_Node; overload;
    function Search(const Buff: TKDT1920DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DD_Node; overload;
    function Search(const Buff: TKDT1920DD_Vec; var SearchedDistanceMin: Double): PKDT1920DD_Node; overload;
    function Search(const Buff: TKDT1920DD_Vec): PKDT1920DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1920DD_DynamicVecBuffer; var OutBuff: TKDT1920DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1920DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT1920DD_Node);
    procedure PrintBuffer;

    class function KDT1920DDVec(const s: SystemString): TKDT1920DD_Vec; overload;
    class function KDT1920DDVec(const v: TKDT1920DD_Vec): SystemString; overload;
    class function KDT1920DDPow(const v: TKDT1920DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1920DDDistance(const v1, v2: TKDT1920DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1920DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT1980DD = class(TCoreClassObject)
  public type
    // code split
    TKDT1980DD_Vec = packed array [0 .. KDT1980DD_Axis - 1] of TKDT1980DD_VecType;
    PKDT1980DD_Vec = ^TKDT1980DD_Vec;

    TKDT1980DD_DynamicVecBuffer = array of TKDT1980DD_Vec;
    PKDT1980DD_DynamicVecBuffer = ^TKDT1980DD_DynamicVecBuffer;

    TKDT1980DD_Source = packed record
      Buff: TKDT1980DD_Vec;
      index: Integer;
    end;

    PKDT1980DD_Source       = ^TKDT1980DD_Source;
    TKDT1980DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT1980DD_Source) - 1] of PKDT1980DD_Source;
    PKDT1980DD_SourceBuffer = ^TKDT1980DD_SourceBuffer;

    TKDT1980DDyanmicSourceBuffer = packed array of PKDT1980DD_Source;
    PKDT1980DDyanmicSourceBuffer = ^TKDT1980DDyanmicSourceBuffer;

    TKDT1980DDyanmicStoreBuffer = packed array of TKDT1980DD_Source;
    PKDT1980DDyanmicStoreBuffer = ^TKDT1980DDyanmicStoreBuffer;

    PKDT1980DD_Node = ^TKDT1980DD_Node;

    TKDT1980DD_Node = packed record
      Parent, Right, Left: PKDT1980DD_Node;
      vec: PKDT1980DD_Source;
    end;

    TKDT1980DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1980DD_Source; const Data: Pointer);
    TKDT1980DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1980DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT1980DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1980DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT1980DDyanmicStoreBuffer;
    KDBuff     : TKDT1980DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1980DD_Node;
    TestBuff   : TKDT1980DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1980DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1980DD_Node;
    function GetData(const index: NativeInt): PKDT1980DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1980DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1980DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT1980DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1980DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1980DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1980DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1980DD_Node; overload;
    function Search(const Buff: TKDT1980DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1980DD_Node; overload;
    function Search(const Buff: TKDT1980DD_Vec; var SearchedDistanceMin: Double): PKDT1980DD_Node; overload;
    function Search(const Buff: TKDT1980DD_Vec): PKDT1980DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1980DD_DynamicVecBuffer; var OutBuff: TKDT1980DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1980DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT1980DD_Node);
    procedure PrintBuffer;

    class function KDT1980DDVec(const s: SystemString): TKDT1980DD_Vec; overload;
    class function KDT1980DDVec(const v: TKDT1980DD_Vec): SystemString; overload;
    class function KDT1980DDPow(const v: TKDT1980DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1980DDDistance(const v1, v2: TKDT1980DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1980DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT2048DD = class(TCoreClassObject)
  public type
    // code split
    TKDT2048DD_Vec = packed array [0 .. KDT2048DD_Axis - 1] of TKDT2048DD_VecType;
    PKDT2048DD_Vec = ^TKDT2048DD_Vec;

    TKDT2048DD_DynamicVecBuffer = array of TKDT2048DD_Vec;
    PKDT2048DD_DynamicVecBuffer = ^TKDT2048DD_DynamicVecBuffer;

    TKDT2048DD_Source = packed record
      Buff: TKDT2048DD_Vec;
      index: Integer;
    end;

    PKDT2048DD_Source       = ^TKDT2048DD_Source;
    TKDT2048DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT2048DD_Source) - 1] of PKDT2048DD_Source;
    PKDT2048DD_SourceBuffer = ^TKDT2048DD_SourceBuffer;

    TKDT2048DDyanmicSourceBuffer = packed array of PKDT2048DD_Source;
    PKDT2048DDyanmicSourceBuffer = ^TKDT2048DDyanmicSourceBuffer;

    TKDT2048DDyanmicStoreBuffer = packed array of TKDT2048DD_Source;
    PKDT2048DDyanmicStoreBuffer = ^TKDT2048DDyanmicStoreBuffer;

    PKDT2048DD_Node = ^TKDT2048DD_Node;

    TKDT2048DD_Node = packed record
      Parent, Right, Left: PKDT2048DD_Node;
      vec: PKDT2048DD_Source;
    end;

    TKDT2048DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT2048DD_Source; const Data: Pointer);
    TKDT2048DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT2048DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT2048DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT2048DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT2048DDyanmicStoreBuffer;
    KDBuff     : TKDT2048DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2048DD_Node;
    TestBuff   : TKDT2048DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DD_Node;
    function GetData(const index: NativeInt): PKDT2048DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2048DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2048DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT2048DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2048DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DD_Node; overload;
    function Search(const Buff: TKDT2048DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DD_Node; overload;
    function Search(const Buff: TKDT2048DD_Vec; var SearchedDistanceMin: Double): PKDT2048DD_Node; overload;
    function Search(const Buff: TKDT2048DD_Vec): PKDT2048DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2048DD_DynamicVecBuffer; var OutBuff: TKDT2048DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT2048DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT2048DD_Node);
    procedure PrintBuffer;

    class function KDT2048DDVec(const s: SystemString): TKDT2048DD_Vec; overload;
    class function KDT2048DDVec(const v: TKDT2048DD_Vec): SystemString; overload;
    class function KDT2048DDPow(const v: TKDT2048DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT2048DDDistance(const v1, v2: TKDT2048DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2048DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT3072DD = class(TCoreClassObject)
  public type
    // code split
    TKDT3072DD_Vec = packed array [0 .. KDT3072DD_Axis - 1] of TKDT3072DD_VecType;
    PKDT3072DD_Vec = ^TKDT3072DD_Vec;

    TKDT3072DD_DynamicVecBuffer = array of TKDT3072DD_Vec;
    PKDT3072DD_DynamicVecBuffer = ^TKDT3072DD_DynamicVecBuffer;

    TKDT3072DD_Source = packed record
      Buff: TKDT3072DD_Vec;
      index: Integer;
    end;

    PKDT3072DD_Source       = ^TKDT3072DD_Source;
    TKDT3072DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT3072DD_Source) - 1] of PKDT3072DD_Source;
    PKDT3072DD_SourceBuffer = ^TKDT3072DD_SourceBuffer;

    TKDT3072DDyanmicSourceBuffer = packed array of PKDT3072DD_Source;
    PKDT3072DDyanmicSourceBuffer = ^TKDT3072DDyanmicSourceBuffer;

    TKDT3072DDyanmicStoreBuffer = packed array of TKDT3072DD_Source;
    PKDT3072DDyanmicStoreBuffer = ^TKDT3072DDyanmicStoreBuffer;

    PKDT3072DD_Node = ^TKDT3072DD_Node;

    TKDT3072DD_Node = packed record
      Parent, Right, Left: PKDT3072DD_Node;
      vec: PKDT3072DD_Source;
    end;

    TKDT3072DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3072DD_Source; const Data: Pointer);
    TKDT3072DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3072DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT3072DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3072DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT3072DDyanmicStoreBuffer;
    KDBuff     : TKDT3072DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3072DD_Node;
    TestBuff   : TKDT3072DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DD_Node;
    function GetData(const index: NativeInt): PKDT3072DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3072DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3072DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT3072DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3072DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DD_Node; overload;
    function Search(const Buff: TKDT3072DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DD_Node; overload;
    function Search(const Buff: TKDT3072DD_Vec; var SearchedDistanceMin: Double): PKDT3072DD_Node; overload;
    function Search(const Buff: TKDT3072DD_Vec): PKDT3072DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3072DD_DynamicVecBuffer; var OutBuff: TKDT3072DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3072DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT3072DD_Node);
    procedure PrintBuffer;

    class function KDT3072DDVec(const s: SystemString): TKDT3072DD_Vec; overload;
    class function KDT3072DDVec(const v: TKDT3072DD_Vec): SystemString; overload;
    class function KDT3072DDPow(const v: TKDT3072DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3072DDDistance(const v1, v2: TKDT3072DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3072DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT3088DD = class(TCoreClassObject)
  public type
    // code split
    TKDT3088DD_Vec = packed array [0 .. KDT3088DD_Axis - 1] of TKDT3088DD_VecType;
    PKDT3088DD_Vec = ^TKDT3088DD_Vec;

    TKDT3088DD_DynamicVecBuffer = array of TKDT3088DD_Vec;
    PKDT3088DD_DynamicVecBuffer = ^TKDT3088DD_DynamicVecBuffer;

    TKDT3088DD_Source = packed record
      Buff: TKDT3088DD_Vec;
      index: Integer;
    end;

    PKDT3088DD_Source       = ^TKDT3088DD_Source;
    TKDT3088DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT3088DD_Source) - 1] of PKDT3088DD_Source;
    PKDT3088DD_SourceBuffer = ^TKDT3088DD_SourceBuffer;

    TKDT3088DDyanmicSourceBuffer = packed array of PKDT3088DD_Source;
    PKDT3088DDyanmicSourceBuffer = ^TKDT3088DDyanmicSourceBuffer;

    TKDT3088DDyanmicStoreBuffer = packed array of TKDT3088DD_Source;
    PKDT3088DDyanmicStoreBuffer = ^TKDT3088DDyanmicStoreBuffer;

    PKDT3088DD_Node = ^TKDT3088DD_Node;

    TKDT3088DD_Node = packed record
      Parent, Right, Left: PKDT3088DD_Node;
      vec: PKDT3088DD_Source;
    end;

    TKDT3088DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3088DD_Source; const Data: Pointer);
    TKDT3088DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3088DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT3088DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3088DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT3088DDyanmicStoreBuffer;
    KDBuff     : TKDT3088DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3088DD_Node;
    TestBuff   : TKDT3088DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3088DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3088DD_Node;
    function GetData(const index: NativeInt): PKDT3088DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3088DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3088DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT3088DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3088DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3088DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3088DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3088DD_Node; overload;
    function Search(const Buff: TKDT3088DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3088DD_Node; overload;
    function Search(const Buff: TKDT3088DD_Vec; var SearchedDistanceMin: Double): PKDT3088DD_Node; overload;
    function Search(const Buff: TKDT3088DD_Vec): PKDT3088DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3088DD_DynamicVecBuffer; var OutBuff: TKDT3088DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3088DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT3088DD_Node);
    procedure PrintBuffer;

    class function KDT3088DDVec(const s: SystemString): TKDT3088DD_Vec; overload;
    class function KDT3088DDVec(const v: TKDT3088DD_Vec): SystemString; overload;
    class function KDT3088DDPow(const v: TKDT3088DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3088DDDistance(const v1, v2: TKDT3088DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3088DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT3104DD = class(TCoreClassObject)
  public type
    // code split
    TKDT3104DD_Vec = packed array [0 .. KDT3104DD_Axis - 1] of TKDT3104DD_VecType;
    PKDT3104DD_Vec = ^TKDT3104DD_Vec;

    TKDT3104DD_DynamicVecBuffer = array of TKDT3104DD_Vec;
    PKDT3104DD_DynamicVecBuffer = ^TKDT3104DD_DynamicVecBuffer;

    TKDT3104DD_Source = packed record
      Buff: TKDT3104DD_Vec;
      index: Integer;
    end;

    PKDT3104DD_Source       = ^TKDT3104DD_Source;
    TKDT3104DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT3104DD_Source) - 1] of PKDT3104DD_Source;
    PKDT3104DD_SourceBuffer = ^TKDT3104DD_SourceBuffer;

    TKDT3104DDyanmicSourceBuffer = packed array of PKDT3104DD_Source;
    PKDT3104DDyanmicSourceBuffer = ^TKDT3104DDyanmicSourceBuffer;

    TKDT3104DDyanmicStoreBuffer = packed array of TKDT3104DD_Source;
    PKDT3104DDyanmicStoreBuffer = ^TKDT3104DDyanmicStoreBuffer;

    PKDT3104DD_Node = ^TKDT3104DD_Node;

    TKDT3104DD_Node = packed record
      Parent, Right, Left: PKDT3104DD_Node;
      vec: PKDT3104DD_Source;
    end;

    TKDT3104DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3104DD_Source; const Data: Pointer);
    TKDT3104DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3104DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT3104DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3104DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT3104DDyanmicStoreBuffer;
    KDBuff     : TKDT3104DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3104DD_Node;
    TestBuff   : TKDT3104DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3104DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3104DD_Node;
    function GetData(const index: NativeInt): PKDT3104DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3104DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3104DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT3104DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3104DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3104DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3104DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3104DD_Node; overload;
    function Search(const Buff: TKDT3104DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3104DD_Node; overload;
    function Search(const Buff: TKDT3104DD_Vec; var SearchedDistanceMin: Double): PKDT3104DD_Node; overload;
    function Search(const Buff: TKDT3104DD_Vec): PKDT3104DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3104DD_DynamicVecBuffer; var OutBuff: TKDT3104DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3104DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT3104DD_Node);
    procedure PrintBuffer;

    class function KDT3104DDVec(const s: SystemString): TKDT3104DD_Vec; overload;
    class function KDT3104DDVec(const v: TKDT3104DD_Vec): SystemString; overload;
    class function KDT3104DDPow(const v: TKDT3104DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3104DDDistance(const v1, v2: TKDT3104DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3104DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT4096DD = class(TCoreClassObject)
  public type
    // code split
    TKDT4096DD_Vec = packed array [0 .. KDT4096DD_Axis - 1] of TKDT4096DD_VecType;
    PKDT4096DD_Vec = ^TKDT4096DD_Vec;

    TKDT4096DD_DynamicVecBuffer = array of TKDT4096DD_Vec;
    PKDT4096DD_DynamicVecBuffer = ^TKDT4096DD_DynamicVecBuffer;

    TKDT4096DD_Source = packed record
      Buff: TKDT4096DD_Vec;
      index: Integer;
    end;

    PKDT4096DD_Source       = ^TKDT4096DD_Source;
    TKDT4096DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT4096DD_Source) - 1] of PKDT4096DD_Source;
    PKDT4096DD_SourceBuffer = ^TKDT4096DD_SourceBuffer;

    TKDT4096DDyanmicSourceBuffer = packed array of PKDT4096DD_Source;
    PKDT4096DDyanmicSourceBuffer = ^TKDT4096DDyanmicSourceBuffer;

    TKDT4096DDyanmicStoreBuffer = packed array of TKDT4096DD_Source;
    PKDT4096DDyanmicStoreBuffer = ^TKDT4096DDyanmicStoreBuffer;

    PKDT4096DD_Node = ^TKDT4096DD_Node;

    TKDT4096DD_Node = packed record
      Parent, Right, Left: PKDT4096DD_Node;
      vec: PKDT4096DD_Source;
    end;

    TKDT4096DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT4096DD_Source; const Data: Pointer);
    TKDT4096DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT4096DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT4096DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT4096DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT4096DDyanmicStoreBuffer;
    KDBuff     : TKDT4096DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT4096DD_Node;
    TestBuff   : TKDT4096DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4096DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4096DD_Node;
    function GetData(const index: NativeInt): PKDT4096DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4096DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4096DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT4096DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4096DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4096DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4096DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4096DD_Node; overload;
    function Search(const Buff: TKDT4096DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4096DD_Node; overload;
    function Search(const Buff: TKDT4096DD_Vec; var SearchedDistanceMin: Double): PKDT4096DD_Node; overload;
    function Search(const Buff: TKDT4096DD_Vec): PKDT4096DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4096DD_DynamicVecBuffer; var OutBuff: TKDT4096DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT4096DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT4096DD_Node);
    procedure PrintBuffer;

    class function KDT4096DDVec(const s: SystemString): TKDT4096DD_Vec; overload;
    class function KDT4096DDVec(const v: TKDT4096DD_Vec): SystemString; overload;
    class function KDT4096DDPow(const v: TKDT4096DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT4096DDDistance(const v1, v2: TKDT4096DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4096DD_Source; const Data: Pointer);
    class procedure Test;
  end;



  TKDT8192DD = class(TCoreClassObject)
  public type
    // code split
    TKDT8192DD_Vec = packed array [0 .. KDT8192DD_Axis - 1] of TKDT8192DD_VecType;
    PKDT8192DD_Vec = ^TKDT8192DD_Vec;

    TKDT8192DD_DynamicVecBuffer = array of TKDT8192DD_Vec;
    PKDT8192DD_DynamicVecBuffer = ^TKDT8192DD_DynamicVecBuffer;

    TKDT8192DD_Source = packed record
      Buff: TKDT8192DD_Vec;
      index: Integer;
    end;

    PKDT8192DD_Source       = ^TKDT8192DD_Source;
    TKDT8192DD_SourceBuffer = packed array [0 .. MaxInt div SizeOf(PKDT8192DD_Source) - 1] of PKDT8192DD_Source;
    PKDT8192DD_SourceBuffer = ^TKDT8192DD_SourceBuffer;

    TKDT8192DDyanmicSourceBuffer = packed array of PKDT8192DD_Source;
    PKDT8192DDyanmicSourceBuffer = ^TKDT8192DDyanmicSourceBuffer;

    TKDT8192DDyanmicStoreBuffer = packed array of TKDT8192DD_Source;
    PKDT8192DDyanmicStoreBuffer = ^TKDT8192DDyanmicStoreBuffer;

    PKDT8192DD_Node = ^TKDT8192DD_Node;

    TKDT8192DD_Node = packed record
      Parent, Right, Left: PKDT8192DD_Node;
      vec: PKDT8192DD_Source;
    end;

    TKDT8192DD_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT8192DD_Source; const Data: Pointer);
    TKDT8192DD_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT8192DD_Source; const Data: Pointer) of object;
    {$IFNDEF FPC} TKDT8192DD_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT8192DD_Source; const Data: Pointer); {$ENDIF}
  private
    KDStoreBuff: TKDT8192DDyanmicStoreBuffer;
    KDBuff     : TKDT8192DDyanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT8192DD_Node;
    TestBuff   : TKDT8192DD_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8192DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8192DD_Node;
    function GetData(const index: NativeInt): PKDT8192DD_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8192DD_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8192DDyanmicStoreBuffer;
    property SourceP[const index: NativeInt]: PKDT8192DD_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DD_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DD_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DD_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8192DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8192DD_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DD_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DD_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DD_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8192DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8192DD_Node; overload;
    function Search(const Buff: TKDT8192DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8192DD_Node; overload;
    function Search(const Buff: TKDT8192DD_Vec; var SearchedDistanceMin: Double): PKDT8192DD_Node; overload;
    function Search(const Buff: TKDT8192DD_Vec): PKDT8192DD_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8192DD_DynamicVecBuffer; var OutBuff: TKDT8192DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT8192DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: SystemString);
    procedure LoadFromFile(fileName: SystemString);

    procedure PrintNodeTree(const NodePtr: PKDT8192DD_Node);
    procedure PrintBuffer;

    class function KDT8192DDVec(const s: SystemString): TKDT8192DD_Vec; overload;
    class function KDT8192DDVec(const v: TKDT8192DD_Vec): SystemString; overload;
    class function KDT8192DDPow(const v: TKDT8192DD_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT8192DDDistance(const v1, v2: TKDT8192DD_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8192DD_Source; const Data: Pointer);
    class procedure Test;
  end;






procedure Test_All;



implementation

uses
  {$IFDEF FPC}
  mtprocs,
  {$ELSE FPC}
  Threading,
  {$ENDIF FPC}
  TextParsing, UnicodeMixedLib, DoStatusIO;





const
  SaveToken = $11;



function TKDT1DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DD_Node;
  function SortCompare(const p1, p2: PKDT1DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1DD.GetData(const index: NativeInt): PKDT1DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1DD.StoreBuffPtr: PKDT1DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1DD.BuildKDTreeWithCluster(const inBuff: TKDT1DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1DD.BuildKDTreeWithCluster(const inBuff: TKDT1DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DD_BuildCall);
var
  TempStoreBuff: TKDT1DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DD_BuildMethod);
var
  TempStoreBuff: TKDT1DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1DD_BuildProc);
var
  TempStoreBuff: TKDT1DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1DD.Search(const Buff: TKDT1DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DD_Node;

var
  NearestNeighbour: PKDT1DD_Node;

  function FindParentNode(const BuffPtr: PKDT1DD_Vec; NodePtr: PKDT1DD_Node): PKDT1DD_Node;
  var
    Next       : PKDT1DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1DD_Node; const BuffPtr: PKDT1DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1DD_Vec; const p1, p2: PKDT1DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1DD_Node(NearestNodes[0]);
    end;
end;

function TKDT1DD.Search(const Buff: TKDT1DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1DD.Search(const Buff: TKDT1DD_Vec; var SearchedDistanceMin: Double): PKDT1DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1DD.Search(const Buff: TKDT1DD_Vec): PKDT1DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1DD.Search(const inBuff: TKDT1DD_DynamicVecBuffer; var OutBuff: TKDT1DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1DD_DynamicVecBuffer;
  outBuffPtr : PKDT1DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DD.Search(const inBuff: TKDT1DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1DD_Source));
end;

procedure TKDT1DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DD.PrintNodeTree(const NodePtr: PKDT1DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT1DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1DD.KDT1DDVec(const s: SystemString): TKDT1DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1DD.KDT1DDVec(const v: TKDT1DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1DD.KDT1DDPow(const v: TKDT1DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1DD.KDT1DDDistance(const v1, v2: TKDT1DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1DD_Axis - 1 do
      Result := Result + KDT1DDPow(v2[i] - v1[i]);
end;

procedure TKDT1DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1DD.Test;
var
  TKDT1DD_Test    : TKDT1DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1DD_Test := TKDT1DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT1DD_Test.TestBuff) - 1 do
    for j := 0 to KDT1DD_Axis - 1 do
        TKDT1DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1DD_Test.TestBuff), length(TKDT1DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1DD_Test.BuildKDTreeM(length(TKDT1DD_Test.TestBuff), nil, @TKDT1DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1DD_Test.BuildKDTreeM(length(TKDT1DD_Test.TestBuff), nil, TKDT1DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1DD_Test.TestBuff));
  TKDT1DD_Test.Search(TKDT1DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1DDDistance(TKDT1DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1DD_Test.Clear;
  { kMean test }
  TKDT1DD_Test.BuildKDTreeWithCluster(TKDT1DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1DD_Test.Search(TKDT1DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1DD_Test);
end;


function TKDT2DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DD_Node;
  function SortCompare(const p1, p2: PKDT2DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT2DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2DD.GetData(const index: NativeInt): PKDT2DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2DD.StoreBuffPtr: PKDT2DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2DD.BuildKDTreeWithCluster(const inBuff: TKDT2DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT2DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT2DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT2DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2DD.BuildKDTreeWithCluster(const inBuff: TKDT2DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DD_BuildCall);
var
  TempStoreBuff: TKDT2DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DD_BuildMethod);
var
  TempStoreBuff: TKDT2DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2DD_BuildProc);
var
  TempStoreBuff: TKDT2DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT2DD.Search(const Buff: TKDT2DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DD_Node;

var
  NearestNeighbour: PKDT2DD_Node;

  function FindParentNode(const BuffPtr: PKDT2DD_Vec; NodePtr: PKDT2DD_Node): PKDT2DD_Node;
  var
    Next       : PKDT2DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT2DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2DD_Node; const BuffPtr: PKDT2DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT2DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2DD_Vec; const p1, p2: PKDT2DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2DD_Node(NearestNodes[0]);
    end;
end;

function TKDT2DD.Search(const Buff: TKDT2DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2DD.Search(const Buff: TKDT2DD_Vec; var SearchedDistanceMin: Double): PKDT2DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2DD.Search(const Buff: TKDT2DD_Vec): PKDT2DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2DD.Search(const inBuff: TKDT2DD_DynamicVecBuffer; var OutBuff: TKDT2DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2DD_DynamicVecBuffer;
  outBuffPtr : PKDT2DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DD.Search(const inBuff: TKDT2DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT2DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2DD_Source));
end;

procedure TKDT2DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT2DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DD.PrintNodeTree(const NodePtr: PKDT2DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT2DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT2DD.KDT2DDVec(const s: SystemString): TKDT2DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT2DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT2DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT2DD.KDT2DDVec(const v: TKDT2DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT2DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT2DD.KDT2DDPow(const v: TKDT2DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT2DD.KDT2DDDistance(const v1, v2: TKDT2DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT2DD_Axis - 1 do
      Result := Result + KDT2DDPow(v2[i] - v1[i]);
end;

procedure TKDT2DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2DD.Test;
var
  TKDT2DD_Test    : TKDT2DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2DD_Test := TKDT2DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT2DD_Test.TestBuff) - 1 do
    for j := 0 to KDT2DD_Axis - 1 do
        TKDT2DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT2DD_Test.TestBuff), length(TKDT2DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2DD_Test.BuildKDTreeM(length(TKDT2DD_Test.TestBuff), nil, @TKDT2DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2DD_Test.BuildKDTreeM(length(TKDT2DD_Test.TestBuff), nil, TKDT2DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2DD_Test.TestBuff));
  TKDT2DD_Test.Search(TKDT2DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2DDDistance(TKDT2DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2DD_Test.Clear;
  { kMean test }
  TKDT2DD_Test.BuildKDTreeWithCluster(TKDT2DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2DD_Test.Search(TKDT2DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2DD_Test);
end;


function TKDT3DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DD_Node;
  function SortCompare(const p1, p2: PKDT3DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3DD.GetData(const index: NativeInt): PKDT3DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3DD.StoreBuffPtr: PKDT3DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3DD.BuildKDTreeWithCluster(const inBuff: TKDT3DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3DD.BuildKDTreeWithCluster(const inBuff: TKDT3DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DD_BuildCall);
var
  TempStoreBuff: TKDT3DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DD_BuildMethod);
var
  TempStoreBuff: TKDT3DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3DD_BuildProc);
var
  TempStoreBuff: TKDT3DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT3DD.Search(const Buff: TKDT3DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DD_Node;

var
  NearestNeighbour: PKDT3DD_Node;

  function FindParentNode(const BuffPtr: PKDT3DD_Vec; NodePtr: PKDT3DD_Node): PKDT3DD_Node;
  var
    Next       : PKDT3DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3DD_Node; const BuffPtr: PKDT3DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3DD_Vec; const p1, p2: PKDT3DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3DD_Node(NearestNodes[0]);
    end;
end;

function TKDT3DD.Search(const Buff: TKDT3DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3DD.Search(const Buff: TKDT3DD_Vec; var SearchedDistanceMin: Double): PKDT3DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3DD.Search(const Buff: TKDT3DD_Vec): PKDT3DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3DD.Search(const inBuff: TKDT3DD_DynamicVecBuffer; var OutBuff: TKDT3DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3DD_DynamicVecBuffer;
  outBuffPtr : PKDT3DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DD.Search(const inBuff: TKDT3DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3DD_Source));
end;

procedure TKDT3DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DD.PrintNodeTree(const NodePtr: PKDT3DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT3DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3DD.KDT3DDVec(const s: SystemString): TKDT3DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3DD.KDT3DDVec(const v: TKDT3DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT3DD.KDT3DDPow(const v: TKDT3DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3DD.KDT3DDDistance(const v1, v2: TKDT3DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3DD_Axis - 1 do
      Result := Result + KDT3DDPow(v2[i] - v1[i]);
end;

procedure TKDT3DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3DD.Test;
var
  TKDT3DD_Test    : TKDT3DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3DD_Test := TKDT3DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT3DD_Test.TestBuff) - 1 do
    for j := 0 to KDT3DD_Axis - 1 do
        TKDT3DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3DD_Test.TestBuff), length(TKDT3DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3DD_Test.BuildKDTreeM(length(TKDT3DD_Test.TestBuff), nil, @TKDT3DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3DD_Test.BuildKDTreeM(length(TKDT3DD_Test.TestBuff), nil, TKDT3DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3DD_Test.TestBuff));
  TKDT3DD_Test.Search(TKDT3DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3DDDistance(TKDT3DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3DD_Test.Clear;
  { kMean test }
  TKDT3DD_Test.BuildKDTreeWithCluster(TKDT3DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3DD_Test.Search(TKDT3DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3DD_Test);
end;


function TKDT4DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DD_Node;
  function SortCompare(const p1, p2: PKDT4DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT4DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4DD.GetData(const index: NativeInt): PKDT4DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4DD.StoreBuffPtr: PKDT4DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4DD.BuildKDTreeWithCluster(const inBuff: TKDT4DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT4DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT4DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT4DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4DD.BuildKDTreeWithCluster(const inBuff: TKDT4DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DD_BuildCall);
var
  TempStoreBuff: TKDT4DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DD_BuildMethod);
var
  TempStoreBuff: TKDT4DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4DD_BuildProc);
var
  TempStoreBuff: TKDT4DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT4DD.Search(const Buff: TKDT4DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DD_Node;

var
  NearestNeighbour: PKDT4DD_Node;

  function FindParentNode(const BuffPtr: PKDT4DD_Vec; NodePtr: PKDT4DD_Node): PKDT4DD_Node;
  var
    Next       : PKDT4DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT4DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4DD_Node; const BuffPtr: PKDT4DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT4DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4DD_Vec; const p1, p2: PKDT4DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4DD_Node(NearestNodes[0]);
    end;
end;

function TKDT4DD.Search(const Buff: TKDT4DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4DD.Search(const Buff: TKDT4DD_Vec; var SearchedDistanceMin: Double): PKDT4DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4DD.Search(const Buff: TKDT4DD_Vec): PKDT4DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4DD.Search(const inBuff: TKDT4DD_DynamicVecBuffer; var OutBuff: TKDT4DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4DD_DynamicVecBuffer;
  outBuffPtr : PKDT4DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DD.Search(const inBuff: TKDT4DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT4DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4DD_Source));
end;

procedure TKDT4DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT4DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DD.PrintNodeTree(const NodePtr: PKDT4DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT4DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT4DD.KDT4DDVec(const s: SystemString): TKDT4DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT4DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT4DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT4DD.KDT4DDVec(const v: TKDT4DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT4DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT4DD.KDT4DDPow(const v: TKDT4DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT4DD.KDT4DDDistance(const v1, v2: TKDT4DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT4DD_Axis - 1 do
      Result := Result + KDT4DDPow(v2[i] - v1[i]);
end;

procedure TKDT4DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4DD.Test;
var
  TKDT4DD_Test    : TKDT4DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4DD_Test := TKDT4DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT4DD_Test.TestBuff) - 1 do
    for j := 0 to KDT4DD_Axis - 1 do
        TKDT4DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT4DD_Test.TestBuff), length(TKDT4DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4DD_Test.BuildKDTreeM(length(TKDT4DD_Test.TestBuff), nil, @TKDT4DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4DD_Test.BuildKDTreeM(length(TKDT4DD_Test.TestBuff), nil, TKDT4DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4DD_Test.TestBuff));
  TKDT4DD_Test.Search(TKDT4DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4DDDistance(TKDT4DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4DD_Test.Clear;
  { kMean test }
  TKDT4DD_Test.BuildKDTreeWithCluster(TKDT4DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4DD_Test.Search(TKDT4DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4DD_Test);
end;


function TKDT5DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DD_Node;
  function SortCompare(const p1, p2: PKDT5DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT5DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT5DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT5DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT5DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT5DD.GetData(const index: NativeInt): PKDT5DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT5DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT5DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT5DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT5DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT5DD.StoreBuffPtr: PKDT5DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT5DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT5DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT5DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT5DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT5DD.BuildKDTreeWithCluster(const inBuff: TKDT5DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT5DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT5DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT5DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT5DD.BuildKDTreeWithCluster(const inBuff: TKDT5DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT5DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DD_BuildCall);
var
  TempStoreBuff: TKDT5DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT5DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DD_BuildMethod);
var
  TempStoreBuff: TKDT5DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT5DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT5DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT5DD_BuildProc);
var
  TempStoreBuff: TKDT5DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT5DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT5DD.Search(const Buff: TKDT5DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DD_Node;

var
  NearestNeighbour: PKDT5DD_Node;

  function FindParentNode(const BuffPtr: PKDT5DD_Vec; NodePtr: PKDT5DD_Node): PKDT5DD_Node;
  var
    Next       : PKDT5DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT5DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT5DD_Node; const BuffPtr: PKDT5DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT5DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT5DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT5DD_Vec; const p1, p2: PKDT5DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT5DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT5DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT5DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT5DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT5DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT5DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT5DD_Node(NearestNodes[0]);
    end;
end;

function TKDT5DD.Search(const Buff: TKDT5DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT5DD.Search(const Buff: TKDT5DD_Vec; var SearchedDistanceMin: Double): PKDT5DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT5DD.Search(const Buff: TKDT5DD_Vec): PKDT5DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT5DD.Search(const inBuff: TKDT5DD_DynamicVecBuffer; var OutBuff: TKDT5DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT5DD_DynamicVecBuffer;
  outBuffPtr : PKDT5DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT5DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT5DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT5DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT5DD.Search(const inBuff: TKDT5DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT5DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT5DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT5DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT5DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT5DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT5DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT5DD_Source));
end;

procedure TKDT5DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT5DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT5DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT5DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT5DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT5DD.PrintNodeTree(const NodePtr: PKDT5DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT5DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT5DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT5DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT5DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT5DD.KDT5DDVec(const s: SystemString): TKDT5DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT5DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT5DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT5DD.KDT5DDVec(const v: TKDT5DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT5DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT5DD.KDT5DDPow(const v: TKDT5DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT5DD.KDT5DDDistance(const v1, v2: TKDT5DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT5DD_Axis - 1 do
      Result := Result + KDT5DDPow(v2[i] - v1[i]);
end;

procedure TKDT5DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT5DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT5DD.Test;
var
  TKDT5DD_Test    : TKDT5DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT5DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT5DD_Test := TKDT5DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT5DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT5DD_Test.TestBuff) - 1 do
    for j := 0 to KDT5DD_Axis - 1 do
        TKDT5DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT5DD_Test.TestBuff), length(TKDT5DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT5DD_Test.BuildKDTreeM(length(TKDT5DD_Test.TestBuff), nil, @TKDT5DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT5DD_Test.BuildKDTreeM(length(TKDT5DD_Test.TestBuff), nil, TKDT5DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT5DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT5DD_Test.TestBuff));
  TKDT5DD_Test.Search(TKDT5DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT5DDDistance(TKDT5DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT5DD_Test.Clear;
  { kMean test }
  TKDT5DD_Test.BuildKDTreeWithCluster(TKDT5DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT5DD_Test.Search(TKDT5DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT5DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT5DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT5DD_Test);
end;


function TKDT6DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DD_Node;
  function SortCompare(const p1, p2: PKDT6DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT6DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT6DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT6DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT6DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT6DD.GetData(const index: NativeInt): PKDT6DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT6DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT6DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT6DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT6DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT6DD.StoreBuffPtr: PKDT6DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT6DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT6DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT6DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT6DD.BuildKDTreeWithCluster(const inBuff: TKDT6DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT6DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT6DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT6DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT6DD.BuildKDTreeWithCluster(const inBuff: TKDT6DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DD_BuildCall);
var
  TempStoreBuff: TKDT6DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT6DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DD_BuildMethod);
var
  TempStoreBuff: TKDT6DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT6DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT6DD_BuildProc);
var
  TempStoreBuff: TKDT6DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT6DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT6DD.Search(const Buff: TKDT6DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DD_Node;

var
  NearestNeighbour: PKDT6DD_Node;

  function FindParentNode(const BuffPtr: PKDT6DD_Vec; NodePtr: PKDT6DD_Node): PKDT6DD_Node;
  var
    Next       : PKDT6DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT6DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT6DD_Node; const BuffPtr: PKDT6DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT6DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT6DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT6DD_Vec; const p1, p2: PKDT6DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT6DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT6DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT6DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT6DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT6DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT6DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT6DD_Node(NearestNodes[0]);
    end;
end;

function TKDT6DD.Search(const Buff: TKDT6DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT6DD.Search(const Buff: TKDT6DD_Vec; var SearchedDistanceMin: Double): PKDT6DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT6DD.Search(const Buff: TKDT6DD_Vec): PKDT6DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT6DD.Search(const inBuff: TKDT6DD_DynamicVecBuffer; var OutBuff: TKDT6DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT6DD_DynamicVecBuffer;
  outBuffPtr : PKDT6DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT6DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT6DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DD.Search(const inBuff: TKDT6DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT6DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT6DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT6DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT6DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT6DD_Source));
end;

procedure TKDT6DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT6DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT6DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT6DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DD.PrintNodeTree(const NodePtr: PKDT6DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT6DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT6DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT6DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT6DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT6DD.KDT6DDVec(const s: SystemString): TKDT6DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT6DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT6DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT6DD.KDT6DDVec(const v: TKDT6DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT6DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT6DD.KDT6DDPow(const v: TKDT6DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT6DD.KDT6DDDistance(const v1, v2: TKDT6DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT6DD_Axis - 1 do
      Result := Result + KDT6DDPow(v2[i] - v1[i]);
end;

procedure TKDT6DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT6DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT6DD.Test;
var
  TKDT6DD_Test    : TKDT6DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT6DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT6DD_Test := TKDT6DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT6DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT6DD_Test.TestBuff) - 1 do
    for j := 0 to KDT6DD_Axis - 1 do
        TKDT6DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT6DD_Test.TestBuff), length(TKDT6DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT6DD_Test.BuildKDTreeM(length(TKDT6DD_Test.TestBuff), nil, @TKDT6DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT6DD_Test.BuildKDTreeM(length(TKDT6DD_Test.TestBuff), nil, TKDT6DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT6DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT6DD_Test.TestBuff));
  TKDT6DD_Test.Search(TKDT6DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT6DDDistance(TKDT6DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT6DD_Test.Clear;
  { kMean test }
  TKDT6DD_Test.BuildKDTreeWithCluster(TKDT6DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT6DD_Test.Search(TKDT6DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT6DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT6DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT6DD_Test);
end;


function TKDT7DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DD_Node;
  function SortCompare(const p1, p2: PKDT7DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT7DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT7DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT7DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT7DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT7DD.GetData(const index: NativeInt): PKDT7DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT7DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT7DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT7DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT7DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT7DD.StoreBuffPtr: PKDT7DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT7DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT7DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT7DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT7DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT7DD.BuildKDTreeWithCluster(const inBuff: TKDT7DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT7DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT7DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT7DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT7DD.BuildKDTreeWithCluster(const inBuff: TKDT7DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT7DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DD_BuildCall);
var
  TempStoreBuff: TKDT7DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT7DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DD_BuildMethod);
var
  TempStoreBuff: TKDT7DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT7DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT7DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT7DD_BuildProc);
var
  TempStoreBuff: TKDT7DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT7DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT7DD.Search(const Buff: TKDT7DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DD_Node;

var
  NearestNeighbour: PKDT7DD_Node;

  function FindParentNode(const BuffPtr: PKDT7DD_Vec; NodePtr: PKDT7DD_Node): PKDT7DD_Node;
  var
    Next       : PKDT7DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT7DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT7DD_Node; const BuffPtr: PKDT7DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT7DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT7DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT7DD_Vec; const p1, p2: PKDT7DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT7DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT7DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT7DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT7DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT7DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT7DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT7DD_Node(NearestNodes[0]);
    end;
end;

function TKDT7DD.Search(const Buff: TKDT7DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT7DD.Search(const Buff: TKDT7DD_Vec; var SearchedDistanceMin: Double): PKDT7DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT7DD.Search(const Buff: TKDT7DD_Vec): PKDT7DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT7DD.Search(const inBuff: TKDT7DD_DynamicVecBuffer; var OutBuff: TKDT7DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT7DD_DynamicVecBuffer;
  outBuffPtr : PKDT7DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT7DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT7DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT7DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT7DD.Search(const inBuff: TKDT7DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT7DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT7DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT7DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT7DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT7DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT7DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT7DD_Source));
end;

procedure TKDT7DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT7DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT7DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT7DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT7DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT7DD.PrintNodeTree(const NodePtr: PKDT7DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT7DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT7DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT7DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT7DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT7DD.KDT7DDVec(const s: SystemString): TKDT7DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT7DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT7DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT7DD.KDT7DDVec(const v: TKDT7DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT7DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT7DD.KDT7DDPow(const v: TKDT7DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT7DD.KDT7DDDistance(const v1, v2: TKDT7DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT7DD_Axis - 1 do
      Result := Result + KDT7DDPow(v2[i] - v1[i]);
end;

procedure TKDT7DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT7DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT7DD.Test;
var
  TKDT7DD_Test    : TKDT7DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT7DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT7DD_Test := TKDT7DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT7DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT7DD_Test.TestBuff) - 1 do
    for j := 0 to KDT7DD_Axis - 1 do
        TKDT7DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT7DD_Test.TestBuff), length(TKDT7DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT7DD_Test.BuildKDTreeM(length(TKDT7DD_Test.TestBuff), nil, @TKDT7DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT7DD_Test.BuildKDTreeM(length(TKDT7DD_Test.TestBuff), nil, TKDT7DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT7DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT7DD_Test.TestBuff));
  TKDT7DD_Test.Search(TKDT7DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT7DDDistance(TKDT7DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT7DD_Test.Clear;
  { kMean test }
  TKDT7DD_Test.BuildKDTreeWithCluster(TKDT7DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT7DD_Test.Search(TKDT7DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT7DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT7DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT7DD_Test);
end;


function TKDT8DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DD_Node;
  function SortCompare(const p1, p2: PKDT8DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT8DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8DD.GetData(const index: NativeInt): PKDT8DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8DD.StoreBuffPtr: PKDT8DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8DD.BuildKDTreeWithCluster(const inBuff: TKDT8DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT8DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT8DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT8DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8DD.BuildKDTreeWithCluster(const inBuff: TKDT8DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DD_BuildCall);
var
  TempStoreBuff: TKDT8DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DD_BuildMethod);
var
  TempStoreBuff: TKDT8DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8DD_BuildProc);
var
  TempStoreBuff: TKDT8DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT8DD.Search(const Buff: TKDT8DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DD_Node;

var
  NearestNeighbour: PKDT8DD_Node;

  function FindParentNode(const BuffPtr: PKDT8DD_Vec; NodePtr: PKDT8DD_Node): PKDT8DD_Node;
  var
    Next       : PKDT8DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT8DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8DD_Node; const BuffPtr: PKDT8DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT8DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8DD_Vec; const p1, p2: PKDT8DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8DD_Node(NearestNodes[0]);
    end;
end;

function TKDT8DD.Search(const Buff: TKDT8DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8DD.Search(const Buff: TKDT8DD_Vec; var SearchedDistanceMin: Double): PKDT8DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8DD.Search(const Buff: TKDT8DD_Vec): PKDT8DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8DD.Search(const inBuff: TKDT8DD_DynamicVecBuffer; var OutBuff: TKDT8DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8DD_DynamicVecBuffer;
  outBuffPtr : PKDT8DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DD.Search(const inBuff: TKDT8DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT8DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8DD_Source));
end;

procedure TKDT8DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT8DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DD.PrintNodeTree(const NodePtr: PKDT8DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT8DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT8DD.KDT8DDVec(const s: SystemString): TKDT8DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT8DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT8DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT8DD.KDT8DDVec(const v: TKDT8DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT8DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT8DD.KDT8DDPow(const v: TKDT8DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT8DD.KDT8DDDistance(const v1, v2: TKDT8DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT8DD_Axis - 1 do
      Result := Result + KDT8DDPow(v2[i] - v1[i]);
end;

procedure TKDT8DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8DD.Test;
var
  TKDT8DD_Test    : TKDT8DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8DD_Test := TKDT8DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT8DD_Test.TestBuff) - 1 do
    for j := 0 to KDT8DD_Axis - 1 do
        TKDT8DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT8DD_Test.TestBuff), length(TKDT8DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8DD_Test.BuildKDTreeM(length(TKDT8DD_Test.TestBuff), nil, @TKDT8DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8DD_Test.BuildKDTreeM(length(TKDT8DD_Test.TestBuff), nil, TKDT8DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8DD_Test.TestBuff));
  TKDT8DD_Test.Search(TKDT8DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8DDDistance(TKDT8DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8DD_Test.Clear;
  { kMean test }
  TKDT8DD_Test.BuildKDTreeWithCluster(TKDT8DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8DD_Test.Search(TKDT8DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8DD_Test);
end;


function TKDT9DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DD_Node;
  function SortCompare(const p1, p2: PKDT9DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT9DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT9DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT9DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT9DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT9DD.GetData(const index: NativeInt): PKDT9DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT9DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT9DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT9DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT9DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT9DD.StoreBuffPtr: PKDT9DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT9DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT9DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT9DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT9DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT9DD.BuildKDTreeWithCluster(const inBuff: TKDT9DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT9DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT9DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT9DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT9DD.BuildKDTreeWithCluster(const inBuff: TKDT9DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT9DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DD_BuildCall);
var
  TempStoreBuff: TKDT9DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT9DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DD_BuildMethod);
var
  TempStoreBuff: TKDT9DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT9DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT9DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT9DD_BuildProc);
var
  TempStoreBuff: TKDT9DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT9DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT9DD.Search(const Buff: TKDT9DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DD_Node;

var
  NearestNeighbour: PKDT9DD_Node;

  function FindParentNode(const BuffPtr: PKDT9DD_Vec; NodePtr: PKDT9DD_Node): PKDT9DD_Node;
  var
    Next       : PKDT9DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT9DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT9DD_Node; const BuffPtr: PKDT9DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT9DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT9DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT9DD_Vec; const p1, p2: PKDT9DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT9DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT9DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT9DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT9DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT9DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT9DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT9DD_Node(NearestNodes[0]);
    end;
end;

function TKDT9DD.Search(const Buff: TKDT9DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT9DD.Search(const Buff: TKDT9DD_Vec; var SearchedDistanceMin: Double): PKDT9DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT9DD.Search(const Buff: TKDT9DD_Vec): PKDT9DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT9DD.Search(const inBuff: TKDT9DD_DynamicVecBuffer; var OutBuff: TKDT9DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT9DD_DynamicVecBuffer;
  outBuffPtr : PKDT9DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT9DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT9DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT9DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT9DD.Search(const inBuff: TKDT9DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT9DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT9DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT9DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT9DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT9DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT9DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT9DD_Source));
end;

procedure TKDT9DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT9DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT9DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT9DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT9DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT9DD.PrintNodeTree(const NodePtr: PKDT9DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT9DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT9DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT9DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT9DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT9DD.KDT9DDVec(const s: SystemString): TKDT9DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT9DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT9DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT9DD.KDT9DDVec(const v: TKDT9DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT9DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT9DD.KDT9DDPow(const v: TKDT9DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT9DD.KDT9DDDistance(const v1, v2: TKDT9DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT9DD_Axis - 1 do
      Result := Result + KDT9DDPow(v2[i] - v1[i]);
end;

procedure TKDT9DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT9DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT9DD.Test;
var
  TKDT9DD_Test    : TKDT9DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT9DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT9DD_Test := TKDT9DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT9DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT9DD_Test.TestBuff) - 1 do
    for j := 0 to KDT9DD_Axis - 1 do
        TKDT9DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT9DD_Test.TestBuff), length(TKDT9DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT9DD_Test.BuildKDTreeM(length(TKDT9DD_Test.TestBuff), nil, @TKDT9DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT9DD_Test.BuildKDTreeM(length(TKDT9DD_Test.TestBuff), nil, TKDT9DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT9DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT9DD_Test.TestBuff));
  TKDT9DD_Test.Search(TKDT9DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT9DDDistance(TKDT9DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT9DD_Test.Clear;
  { kMean test }
  TKDT9DD_Test.BuildKDTreeWithCluster(TKDT9DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT9DD_Test.Search(TKDT9DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT9DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT9DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT9DD_Test);
end;


function TKDT10DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DD_Node;
  function SortCompare(const p1, p2: PKDT10DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT10DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT10DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT10DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT10DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT10DD.GetData(const index: NativeInt): PKDT10DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT10DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT10DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT10DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT10DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT10DD.StoreBuffPtr: PKDT10DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT10DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT10DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT10DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT10DD.BuildKDTreeWithCluster(const inBuff: TKDT10DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT10DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT10DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT10DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT10DD.BuildKDTreeWithCluster(const inBuff: TKDT10DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DD_BuildCall);
var
  TempStoreBuff: TKDT10DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT10DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DD_BuildMethod);
var
  TempStoreBuff: TKDT10DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT10DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT10DD_BuildProc);
var
  TempStoreBuff: TKDT10DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT10DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT10DD.Search(const Buff: TKDT10DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DD_Node;

var
  NearestNeighbour: PKDT10DD_Node;

  function FindParentNode(const BuffPtr: PKDT10DD_Vec; NodePtr: PKDT10DD_Node): PKDT10DD_Node;
  var
    Next       : PKDT10DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT10DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT10DD_Node; const BuffPtr: PKDT10DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT10DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT10DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT10DD_Vec; const p1, p2: PKDT10DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT10DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT10DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT10DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT10DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT10DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT10DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT10DD_Node(NearestNodes[0]);
    end;
end;

function TKDT10DD.Search(const Buff: TKDT10DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT10DD.Search(const Buff: TKDT10DD_Vec; var SearchedDistanceMin: Double): PKDT10DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT10DD.Search(const Buff: TKDT10DD_Vec): PKDT10DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT10DD.Search(const inBuff: TKDT10DD_DynamicVecBuffer; var OutBuff: TKDT10DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT10DD_DynamicVecBuffer;
  outBuffPtr : PKDT10DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT10DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT10DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DD.Search(const inBuff: TKDT10DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT10DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT10DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT10DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT10DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT10DD_Source));
end;

procedure TKDT10DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT10DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT10DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT10DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DD.PrintNodeTree(const NodePtr: PKDT10DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT10DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT10DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT10DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT10DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT10DD.KDT10DDVec(const s: SystemString): TKDT10DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT10DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT10DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT10DD.KDT10DDVec(const v: TKDT10DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT10DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT10DD.KDT10DDPow(const v: TKDT10DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT10DD.KDT10DDDistance(const v1, v2: TKDT10DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT10DD_Axis - 1 do
      Result := Result + KDT10DDPow(v2[i] - v1[i]);
end;

procedure TKDT10DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT10DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT10DD.Test;
var
  TKDT10DD_Test    : TKDT10DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT10DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT10DD_Test := TKDT10DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT10DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT10DD_Test.TestBuff) - 1 do
    for j := 0 to KDT10DD_Axis - 1 do
        TKDT10DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT10DD_Test.TestBuff), length(TKDT10DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT10DD_Test.BuildKDTreeM(length(TKDT10DD_Test.TestBuff), nil, @TKDT10DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT10DD_Test.BuildKDTreeM(length(TKDT10DD_Test.TestBuff), nil, TKDT10DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT10DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT10DD_Test.TestBuff));
  TKDT10DD_Test.Search(TKDT10DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT10DDDistance(TKDT10DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT10DD_Test.Clear;
  { kMean test }
  TKDT10DD_Test.BuildKDTreeWithCluster(TKDT10DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT10DD_Test.Search(TKDT10DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT10DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT10DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT10DD_Test);
end;


function TKDT11DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DD_Node;
  function SortCompare(const p1, p2: PKDT11DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT11DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT11DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT11DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT11DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT11DD.GetData(const index: NativeInt): PKDT11DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT11DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT11DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT11DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT11DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT11DD.StoreBuffPtr: PKDT11DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT11DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT11DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT11DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT11DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT11DD.BuildKDTreeWithCluster(const inBuff: TKDT11DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT11DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT11DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT11DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT11DD.BuildKDTreeWithCluster(const inBuff: TKDT11DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT11DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DD_BuildCall);
var
  TempStoreBuff: TKDT11DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT11DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DD_BuildMethod);
var
  TempStoreBuff: TKDT11DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT11DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT11DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT11DD_BuildProc);
var
  TempStoreBuff: TKDT11DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT11DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT11DD.Search(const Buff: TKDT11DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DD_Node;

var
  NearestNeighbour: PKDT11DD_Node;

  function FindParentNode(const BuffPtr: PKDT11DD_Vec; NodePtr: PKDT11DD_Node): PKDT11DD_Node;
  var
    Next       : PKDT11DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT11DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT11DD_Node; const BuffPtr: PKDT11DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT11DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT11DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT11DD_Vec; const p1, p2: PKDT11DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT11DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT11DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT11DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT11DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT11DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT11DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT11DD_Node(NearestNodes[0]);
    end;
end;

function TKDT11DD.Search(const Buff: TKDT11DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT11DD.Search(const Buff: TKDT11DD_Vec; var SearchedDistanceMin: Double): PKDT11DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT11DD.Search(const Buff: TKDT11DD_Vec): PKDT11DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT11DD.Search(const inBuff: TKDT11DD_DynamicVecBuffer; var OutBuff: TKDT11DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT11DD_DynamicVecBuffer;
  outBuffPtr : PKDT11DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT11DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT11DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT11DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT11DD.Search(const inBuff: TKDT11DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT11DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT11DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT11DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT11DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT11DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT11DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT11DD_Source));
end;

procedure TKDT11DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT11DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT11DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT11DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT11DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT11DD.PrintNodeTree(const NodePtr: PKDT11DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT11DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT11DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT11DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT11DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT11DD.KDT11DDVec(const s: SystemString): TKDT11DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT11DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT11DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT11DD.KDT11DDVec(const v: TKDT11DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT11DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT11DD.KDT11DDPow(const v: TKDT11DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT11DD.KDT11DDDistance(const v1, v2: TKDT11DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT11DD_Axis - 1 do
      Result := Result + KDT11DDPow(v2[i] - v1[i]);
end;

procedure TKDT11DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT11DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT11DD.Test;
var
  TKDT11DD_Test    : TKDT11DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT11DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT11DD_Test := TKDT11DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT11DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT11DD_Test.TestBuff) - 1 do
    for j := 0 to KDT11DD_Axis - 1 do
        TKDT11DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT11DD_Test.TestBuff), length(TKDT11DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT11DD_Test.BuildKDTreeM(length(TKDT11DD_Test.TestBuff), nil, @TKDT11DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT11DD_Test.BuildKDTreeM(length(TKDT11DD_Test.TestBuff), nil, TKDT11DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT11DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT11DD_Test.TestBuff));
  TKDT11DD_Test.Search(TKDT11DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT11DDDistance(TKDT11DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT11DD_Test.Clear;
  { kMean test }
  TKDT11DD_Test.BuildKDTreeWithCluster(TKDT11DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT11DD_Test.Search(TKDT11DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT11DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT11DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT11DD_Test);
end;


function TKDT12DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DD_Node;
  function SortCompare(const p1, p2: PKDT12DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT12DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT12DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT12DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT12DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT12DD.GetData(const index: NativeInt): PKDT12DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT12DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT12DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT12DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT12DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT12DD.StoreBuffPtr: PKDT12DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT12DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT12DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT12DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT12DD.BuildKDTreeWithCluster(const inBuff: TKDT12DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT12DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT12DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT12DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT12DD.BuildKDTreeWithCluster(const inBuff: TKDT12DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DD_BuildCall);
var
  TempStoreBuff: TKDT12DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT12DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DD_BuildMethod);
var
  TempStoreBuff: TKDT12DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT12DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT12DD_BuildProc);
var
  TempStoreBuff: TKDT12DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT12DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT12DD.Search(const Buff: TKDT12DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DD_Node;

var
  NearestNeighbour: PKDT12DD_Node;

  function FindParentNode(const BuffPtr: PKDT12DD_Vec; NodePtr: PKDT12DD_Node): PKDT12DD_Node;
  var
    Next       : PKDT12DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT12DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT12DD_Node; const BuffPtr: PKDT12DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT12DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT12DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT12DD_Vec; const p1, p2: PKDT12DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT12DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT12DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT12DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT12DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT12DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT12DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT12DD_Node(NearestNodes[0]);
    end;
end;

function TKDT12DD.Search(const Buff: TKDT12DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT12DD.Search(const Buff: TKDT12DD_Vec; var SearchedDistanceMin: Double): PKDT12DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT12DD.Search(const Buff: TKDT12DD_Vec): PKDT12DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT12DD.Search(const inBuff: TKDT12DD_DynamicVecBuffer; var OutBuff: TKDT12DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT12DD_DynamicVecBuffer;
  outBuffPtr : PKDT12DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT12DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT12DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DD.Search(const inBuff: TKDT12DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT12DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT12DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT12DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT12DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT12DD_Source));
end;

procedure TKDT12DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT12DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT12DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT12DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DD.PrintNodeTree(const NodePtr: PKDT12DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT12DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT12DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT12DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT12DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT12DD.KDT12DDVec(const s: SystemString): TKDT12DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT12DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT12DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT12DD.KDT12DDVec(const v: TKDT12DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT12DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT12DD.KDT12DDPow(const v: TKDT12DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT12DD.KDT12DDDistance(const v1, v2: TKDT12DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT12DD_Axis - 1 do
      Result := Result + KDT12DDPow(v2[i] - v1[i]);
end;

procedure TKDT12DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT12DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT12DD.Test;
var
  TKDT12DD_Test    : TKDT12DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT12DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT12DD_Test := TKDT12DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT12DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT12DD_Test.TestBuff) - 1 do
    for j := 0 to KDT12DD_Axis - 1 do
        TKDT12DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT12DD_Test.TestBuff), length(TKDT12DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT12DD_Test.BuildKDTreeM(length(TKDT12DD_Test.TestBuff), nil, @TKDT12DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT12DD_Test.BuildKDTreeM(length(TKDT12DD_Test.TestBuff), nil, TKDT12DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT12DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT12DD_Test.TestBuff));
  TKDT12DD_Test.Search(TKDT12DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT12DDDistance(TKDT12DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT12DD_Test.Clear;
  { kMean test }
  TKDT12DD_Test.BuildKDTreeWithCluster(TKDT12DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT12DD_Test.Search(TKDT12DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT12DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT12DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT12DD_Test);
end;


function TKDT13DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DD_Node;
  function SortCompare(const p1, p2: PKDT13DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT13DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT13DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT13DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT13DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT13DD.GetData(const index: NativeInt): PKDT13DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT13DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT13DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT13DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT13DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT13DD.StoreBuffPtr: PKDT13DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT13DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT13DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT13DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT13DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT13DD.BuildKDTreeWithCluster(const inBuff: TKDT13DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT13DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT13DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT13DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT13DD.BuildKDTreeWithCluster(const inBuff: TKDT13DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT13DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DD_BuildCall);
var
  TempStoreBuff: TKDT13DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT13DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DD_BuildMethod);
var
  TempStoreBuff: TKDT13DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT13DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT13DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT13DD_BuildProc);
var
  TempStoreBuff: TKDT13DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT13DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT13DD.Search(const Buff: TKDT13DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DD_Node;

var
  NearestNeighbour: PKDT13DD_Node;

  function FindParentNode(const BuffPtr: PKDT13DD_Vec; NodePtr: PKDT13DD_Node): PKDT13DD_Node;
  var
    Next       : PKDT13DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT13DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT13DD_Node; const BuffPtr: PKDT13DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT13DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT13DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT13DD_Vec; const p1, p2: PKDT13DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT13DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT13DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT13DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT13DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT13DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT13DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT13DD_Node(NearestNodes[0]);
    end;
end;

function TKDT13DD.Search(const Buff: TKDT13DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT13DD.Search(const Buff: TKDT13DD_Vec; var SearchedDistanceMin: Double): PKDT13DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT13DD.Search(const Buff: TKDT13DD_Vec): PKDT13DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT13DD.Search(const inBuff: TKDT13DD_DynamicVecBuffer; var OutBuff: TKDT13DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT13DD_DynamicVecBuffer;
  outBuffPtr : PKDT13DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT13DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT13DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT13DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT13DD.Search(const inBuff: TKDT13DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT13DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT13DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT13DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT13DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT13DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT13DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT13DD_Source));
end;

procedure TKDT13DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT13DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT13DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT13DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT13DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT13DD.PrintNodeTree(const NodePtr: PKDT13DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT13DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT13DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT13DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT13DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT13DD.KDT13DDVec(const s: SystemString): TKDT13DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT13DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT13DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT13DD.KDT13DDVec(const v: TKDT13DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT13DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT13DD.KDT13DDPow(const v: TKDT13DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT13DD.KDT13DDDistance(const v1, v2: TKDT13DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT13DD_Axis - 1 do
      Result := Result + KDT13DDPow(v2[i] - v1[i]);
end;

procedure TKDT13DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT13DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT13DD.Test;
var
  TKDT13DD_Test    : TKDT13DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT13DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT13DD_Test := TKDT13DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT13DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT13DD_Test.TestBuff) - 1 do
    for j := 0 to KDT13DD_Axis - 1 do
        TKDT13DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT13DD_Test.TestBuff), length(TKDT13DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT13DD_Test.BuildKDTreeM(length(TKDT13DD_Test.TestBuff), nil, @TKDT13DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT13DD_Test.BuildKDTreeM(length(TKDT13DD_Test.TestBuff), nil, TKDT13DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT13DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT13DD_Test.TestBuff));
  TKDT13DD_Test.Search(TKDT13DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT13DDDistance(TKDT13DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT13DD_Test.Clear;
  { kMean test }
  TKDT13DD_Test.BuildKDTreeWithCluster(TKDT13DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT13DD_Test.Search(TKDT13DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT13DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT13DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT13DD_Test);
end;


function TKDT14DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DD_Node;
  function SortCompare(const p1, p2: PKDT14DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT14DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT14DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT14DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT14DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT14DD.GetData(const index: NativeInt): PKDT14DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT14DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT14DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT14DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT14DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT14DD.StoreBuffPtr: PKDT14DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT14DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT14DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT14DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT14DD.BuildKDTreeWithCluster(const inBuff: TKDT14DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT14DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT14DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT14DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT14DD.BuildKDTreeWithCluster(const inBuff: TKDT14DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DD_BuildCall);
var
  TempStoreBuff: TKDT14DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT14DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DD_BuildMethod);
var
  TempStoreBuff: TKDT14DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT14DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT14DD_BuildProc);
var
  TempStoreBuff: TKDT14DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT14DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT14DD.Search(const Buff: TKDT14DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DD_Node;

var
  NearestNeighbour: PKDT14DD_Node;

  function FindParentNode(const BuffPtr: PKDT14DD_Vec; NodePtr: PKDT14DD_Node): PKDT14DD_Node;
  var
    Next       : PKDT14DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT14DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT14DD_Node; const BuffPtr: PKDT14DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT14DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT14DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT14DD_Vec; const p1, p2: PKDT14DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT14DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT14DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT14DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT14DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT14DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT14DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT14DD_Node(NearestNodes[0]);
    end;
end;

function TKDT14DD.Search(const Buff: TKDT14DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT14DD.Search(const Buff: TKDT14DD_Vec; var SearchedDistanceMin: Double): PKDT14DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT14DD.Search(const Buff: TKDT14DD_Vec): PKDT14DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT14DD.Search(const inBuff: TKDT14DD_DynamicVecBuffer; var OutBuff: TKDT14DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT14DD_DynamicVecBuffer;
  outBuffPtr : PKDT14DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT14DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT14DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DD.Search(const inBuff: TKDT14DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT14DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT14DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT14DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT14DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT14DD_Source));
end;

procedure TKDT14DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT14DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT14DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT14DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DD.PrintNodeTree(const NodePtr: PKDT14DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT14DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT14DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT14DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT14DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT14DD.KDT14DDVec(const s: SystemString): TKDT14DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT14DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT14DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT14DD.KDT14DDVec(const v: TKDT14DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT14DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT14DD.KDT14DDPow(const v: TKDT14DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT14DD.KDT14DDDistance(const v1, v2: TKDT14DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT14DD_Axis - 1 do
      Result := Result + KDT14DDPow(v2[i] - v1[i]);
end;

procedure TKDT14DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT14DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT14DD.Test;
var
  TKDT14DD_Test    : TKDT14DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT14DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT14DD_Test := TKDT14DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT14DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT14DD_Test.TestBuff) - 1 do
    for j := 0 to KDT14DD_Axis - 1 do
        TKDT14DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT14DD_Test.TestBuff), length(TKDT14DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT14DD_Test.BuildKDTreeM(length(TKDT14DD_Test.TestBuff), nil, @TKDT14DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT14DD_Test.BuildKDTreeM(length(TKDT14DD_Test.TestBuff), nil, TKDT14DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT14DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT14DD_Test.TestBuff));
  TKDT14DD_Test.Search(TKDT14DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT14DDDistance(TKDT14DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT14DD_Test.Clear;
  { kMean test }
  TKDT14DD_Test.BuildKDTreeWithCluster(TKDT14DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT14DD_Test.Search(TKDT14DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT14DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT14DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT14DD_Test);
end;


function TKDT15DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DD_Node;
  function SortCompare(const p1, p2: PKDT15DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT15DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT15DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT15DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT15DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT15DD.GetData(const index: NativeInt): PKDT15DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT15DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT15DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT15DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT15DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT15DD.StoreBuffPtr: PKDT15DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT15DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT15DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT15DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT15DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT15DD.BuildKDTreeWithCluster(const inBuff: TKDT15DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT15DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT15DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT15DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT15DD.BuildKDTreeWithCluster(const inBuff: TKDT15DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT15DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DD_BuildCall);
var
  TempStoreBuff: TKDT15DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT15DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DD_BuildMethod);
var
  TempStoreBuff: TKDT15DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT15DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT15DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT15DD_BuildProc);
var
  TempStoreBuff: TKDT15DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT15DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT15DD.Search(const Buff: TKDT15DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DD_Node;

var
  NearestNeighbour: PKDT15DD_Node;

  function FindParentNode(const BuffPtr: PKDT15DD_Vec; NodePtr: PKDT15DD_Node): PKDT15DD_Node;
  var
    Next       : PKDT15DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT15DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT15DD_Node; const BuffPtr: PKDT15DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT15DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT15DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT15DD_Vec; const p1, p2: PKDT15DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT15DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT15DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT15DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT15DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT15DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT15DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT15DD_Node(NearestNodes[0]);
    end;
end;

function TKDT15DD.Search(const Buff: TKDT15DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT15DD.Search(const Buff: TKDT15DD_Vec; var SearchedDistanceMin: Double): PKDT15DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT15DD.Search(const Buff: TKDT15DD_Vec): PKDT15DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT15DD.Search(const inBuff: TKDT15DD_DynamicVecBuffer; var OutBuff: TKDT15DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT15DD_DynamicVecBuffer;
  outBuffPtr : PKDT15DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT15DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT15DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT15DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT15DD.Search(const inBuff: TKDT15DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT15DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT15DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT15DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT15DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT15DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT15DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT15DD_Source));
end;

procedure TKDT15DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT15DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT15DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT15DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT15DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT15DD.PrintNodeTree(const NodePtr: PKDT15DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT15DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT15DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT15DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT15DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT15DD.KDT15DDVec(const s: SystemString): TKDT15DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT15DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT15DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT15DD.KDT15DDVec(const v: TKDT15DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT15DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT15DD.KDT15DDPow(const v: TKDT15DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT15DD.KDT15DDDistance(const v1, v2: TKDT15DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT15DD_Axis - 1 do
      Result := Result + KDT15DDPow(v2[i] - v1[i]);
end;

procedure TKDT15DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT15DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT15DD.Test;
var
  TKDT15DD_Test    : TKDT15DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT15DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT15DD_Test := TKDT15DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT15DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT15DD_Test.TestBuff) - 1 do
    for j := 0 to KDT15DD_Axis - 1 do
        TKDT15DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT15DD_Test.TestBuff), length(TKDT15DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT15DD_Test.BuildKDTreeM(length(TKDT15DD_Test.TestBuff), nil, @TKDT15DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT15DD_Test.BuildKDTreeM(length(TKDT15DD_Test.TestBuff), nil, TKDT15DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT15DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT15DD_Test.TestBuff));
  TKDT15DD_Test.Search(TKDT15DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT15DDDistance(TKDT15DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT15DD_Test.Clear;
  { kMean test }
  TKDT15DD_Test.BuildKDTreeWithCluster(TKDT15DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT15DD_Test.Search(TKDT15DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT15DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT15DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT15DD_Test);
end;


function TKDT16DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DD_Node;
  function SortCompare(const p1, p2: PKDT16DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT16DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT16DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT16DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT16DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT16DD.GetData(const index: NativeInt): PKDT16DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT16DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT16DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT16DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT16DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT16DD.StoreBuffPtr: PKDT16DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT16DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT16DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT16DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT16DD.BuildKDTreeWithCluster(const inBuff: TKDT16DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT16DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT16DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT16DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT16DD.BuildKDTreeWithCluster(const inBuff: TKDT16DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DD_BuildCall);
var
  TempStoreBuff: TKDT16DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT16DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DD_BuildMethod);
var
  TempStoreBuff: TKDT16DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT16DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT16DD_BuildProc);
var
  TempStoreBuff: TKDT16DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT16DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT16DD.Search(const Buff: TKDT16DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DD_Node;

var
  NearestNeighbour: PKDT16DD_Node;

  function FindParentNode(const BuffPtr: PKDT16DD_Vec; NodePtr: PKDT16DD_Node): PKDT16DD_Node;
  var
    Next       : PKDT16DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT16DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT16DD_Node; const BuffPtr: PKDT16DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT16DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT16DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT16DD_Vec; const p1, p2: PKDT16DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT16DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT16DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT16DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT16DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT16DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT16DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT16DD_Node(NearestNodes[0]);
    end;
end;

function TKDT16DD.Search(const Buff: TKDT16DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT16DD.Search(const Buff: TKDT16DD_Vec; var SearchedDistanceMin: Double): PKDT16DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT16DD.Search(const Buff: TKDT16DD_Vec): PKDT16DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT16DD.Search(const inBuff: TKDT16DD_DynamicVecBuffer; var OutBuff: TKDT16DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT16DD_DynamicVecBuffer;
  outBuffPtr : PKDT16DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT16DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT16DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DD.Search(const inBuff: TKDT16DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT16DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT16DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT16DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT16DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT16DD_Source));
end;

procedure TKDT16DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT16DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT16DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT16DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DD.PrintNodeTree(const NodePtr: PKDT16DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT16DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT16DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT16DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT16DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT16DD.KDT16DDVec(const s: SystemString): TKDT16DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT16DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT16DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT16DD.KDT16DDVec(const v: TKDT16DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT16DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT16DD.KDT16DDPow(const v: TKDT16DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT16DD.KDT16DDDistance(const v1, v2: TKDT16DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT16DD_Axis - 1 do
      Result := Result + KDT16DDPow(v2[i] - v1[i]);
end;

procedure TKDT16DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT16DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT16DD.Test;
var
  TKDT16DD_Test    : TKDT16DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT16DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT16DD_Test := TKDT16DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT16DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT16DD_Test.TestBuff) - 1 do
    for j := 0 to KDT16DD_Axis - 1 do
        TKDT16DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT16DD_Test.TestBuff), length(TKDT16DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT16DD_Test.BuildKDTreeM(length(TKDT16DD_Test.TestBuff), nil, @TKDT16DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT16DD_Test.BuildKDTreeM(length(TKDT16DD_Test.TestBuff), nil, TKDT16DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT16DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT16DD_Test.TestBuff));
  TKDT16DD_Test.Search(TKDT16DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT16DDDistance(TKDT16DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT16DD_Test.Clear;
  { kMean test }
  TKDT16DD_Test.BuildKDTreeWithCluster(TKDT16DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT16DD_Test.Search(TKDT16DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT16DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT16DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT16DD_Test);
end;


function TKDT17DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DD_Node;
  function SortCompare(const p1, p2: PKDT17DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT17DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT17DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT17DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT17DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT17DD.GetData(const index: NativeInt): PKDT17DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT17DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT17DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT17DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT17DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT17DD.StoreBuffPtr: PKDT17DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT17DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT17DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT17DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT17DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT17DD.BuildKDTreeWithCluster(const inBuff: TKDT17DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT17DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT17DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT17DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT17DD.BuildKDTreeWithCluster(const inBuff: TKDT17DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT17DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DD_BuildCall);
var
  TempStoreBuff: TKDT17DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT17DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DD_BuildMethod);
var
  TempStoreBuff: TKDT17DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT17DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT17DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT17DD_BuildProc);
var
  TempStoreBuff: TKDT17DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT17DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT17DD.Search(const Buff: TKDT17DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DD_Node;

var
  NearestNeighbour: PKDT17DD_Node;

  function FindParentNode(const BuffPtr: PKDT17DD_Vec; NodePtr: PKDT17DD_Node): PKDT17DD_Node;
  var
    Next       : PKDT17DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT17DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT17DD_Node; const BuffPtr: PKDT17DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT17DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT17DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT17DD_Vec; const p1, p2: PKDT17DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT17DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT17DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT17DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT17DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT17DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT17DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT17DD_Node(NearestNodes[0]);
    end;
end;

function TKDT17DD.Search(const Buff: TKDT17DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT17DD.Search(const Buff: TKDT17DD_Vec; var SearchedDistanceMin: Double): PKDT17DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT17DD.Search(const Buff: TKDT17DD_Vec): PKDT17DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT17DD.Search(const inBuff: TKDT17DD_DynamicVecBuffer; var OutBuff: TKDT17DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT17DD_DynamicVecBuffer;
  outBuffPtr : PKDT17DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT17DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT17DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT17DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT17DD.Search(const inBuff: TKDT17DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT17DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT17DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT17DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT17DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT17DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT17DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT17DD_Source));
end;

procedure TKDT17DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT17DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT17DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT17DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT17DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT17DD.PrintNodeTree(const NodePtr: PKDT17DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT17DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT17DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT17DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT17DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT17DD.KDT17DDVec(const s: SystemString): TKDT17DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT17DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT17DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT17DD.KDT17DDVec(const v: TKDT17DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT17DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT17DD.KDT17DDPow(const v: TKDT17DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT17DD.KDT17DDDistance(const v1, v2: TKDT17DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT17DD_Axis - 1 do
      Result := Result + KDT17DDPow(v2[i] - v1[i]);
end;

procedure TKDT17DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT17DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT17DD.Test;
var
  TKDT17DD_Test    : TKDT17DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT17DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT17DD_Test := TKDT17DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT17DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT17DD_Test.TestBuff) - 1 do
    for j := 0 to KDT17DD_Axis - 1 do
        TKDT17DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT17DD_Test.TestBuff), length(TKDT17DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT17DD_Test.BuildKDTreeM(length(TKDT17DD_Test.TestBuff), nil, @TKDT17DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT17DD_Test.BuildKDTreeM(length(TKDT17DD_Test.TestBuff), nil, TKDT17DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT17DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT17DD_Test.TestBuff));
  TKDT17DD_Test.Search(TKDT17DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT17DDDistance(TKDT17DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT17DD_Test.Clear;
  { kMean test }
  TKDT17DD_Test.BuildKDTreeWithCluster(TKDT17DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT17DD_Test.Search(TKDT17DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT17DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT17DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT17DD_Test);
end;


function TKDT18DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DD_Node;
  function SortCompare(const p1, p2: PKDT18DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT18DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT18DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT18DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT18DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT18DD.GetData(const index: NativeInt): PKDT18DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT18DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT18DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT18DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT18DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT18DD.StoreBuffPtr: PKDT18DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT18DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT18DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT18DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT18DD.BuildKDTreeWithCluster(const inBuff: TKDT18DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT18DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT18DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT18DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT18DD.BuildKDTreeWithCluster(const inBuff: TKDT18DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DD_BuildCall);
var
  TempStoreBuff: TKDT18DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT18DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DD_BuildMethod);
var
  TempStoreBuff: TKDT18DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT18DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT18DD_BuildProc);
var
  TempStoreBuff: TKDT18DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT18DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT18DD.Search(const Buff: TKDT18DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DD_Node;

var
  NearestNeighbour: PKDT18DD_Node;

  function FindParentNode(const BuffPtr: PKDT18DD_Vec; NodePtr: PKDT18DD_Node): PKDT18DD_Node;
  var
    Next       : PKDT18DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT18DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT18DD_Node; const BuffPtr: PKDT18DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT18DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT18DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT18DD_Vec; const p1, p2: PKDT18DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT18DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT18DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT18DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT18DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT18DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT18DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT18DD_Node(NearestNodes[0]);
    end;
end;

function TKDT18DD.Search(const Buff: TKDT18DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT18DD.Search(const Buff: TKDT18DD_Vec; var SearchedDistanceMin: Double): PKDT18DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT18DD.Search(const Buff: TKDT18DD_Vec): PKDT18DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT18DD.Search(const inBuff: TKDT18DD_DynamicVecBuffer; var OutBuff: TKDT18DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT18DD_DynamicVecBuffer;
  outBuffPtr : PKDT18DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT18DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT18DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DD.Search(const inBuff: TKDT18DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT18DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT18DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT18DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT18DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT18DD_Source));
end;

procedure TKDT18DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT18DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT18DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT18DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DD.PrintNodeTree(const NodePtr: PKDT18DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT18DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT18DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT18DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT18DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT18DD.KDT18DDVec(const s: SystemString): TKDT18DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT18DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT18DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT18DD.KDT18DDVec(const v: TKDT18DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT18DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT18DD.KDT18DDPow(const v: TKDT18DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT18DD.KDT18DDDistance(const v1, v2: TKDT18DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT18DD_Axis - 1 do
      Result := Result + KDT18DDPow(v2[i] - v1[i]);
end;

procedure TKDT18DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT18DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT18DD.Test;
var
  TKDT18DD_Test    : TKDT18DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT18DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT18DD_Test := TKDT18DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT18DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT18DD_Test.TestBuff) - 1 do
    for j := 0 to KDT18DD_Axis - 1 do
        TKDT18DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT18DD_Test.TestBuff), length(TKDT18DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT18DD_Test.BuildKDTreeM(length(TKDT18DD_Test.TestBuff), nil, @TKDT18DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT18DD_Test.BuildKDTreeM(length(TKDT18DD_Test.TestBuff), nil, TKDT18DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT18DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT18DD_Test.TestBuff));
  TKDT18DD_Test.Search(TKDT18DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT18DDDistance(TKDT18DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT18DD_Test.Clear;
  { kMean test }
  TKDT18DD_Test.BuildKDTreeWithCluster(TKDT18DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT18DD_Test.Search(TKDT18DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT18DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT18DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT18DD_Test);
end;


function TKDT19DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DD_Node;
  function SortCompare(const p1, p2: PKDT19DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT19DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT19DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT19DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT19DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT19DD.GetData(const index: NativeInt): PKDT19DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT19DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT19DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT19DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT19DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT19DD.StoreBuffPtr: PKDT19DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT19DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT19DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT19DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT19DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT19DD.BuildKDTreeWithCluster(const inBuff: TKDT19DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT19DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT19DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT19DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT19DD.BuildKDTreeWithCluster(const inBuff: TKDT19DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT19DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DD_BuildCall);
var
  TempStoreBuff: TKDT19DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT19DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DD_BuildMethod);
var
  TempStoreBuff: TKDT19DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT19DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT19DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT19DD_BuildProc);
var
  TempStoreBuff: TKDT19DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT19DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT19DD.Search(const Buff: TKDT19DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DD_Node;

var
  NearestNeighbour: PKDT19DD_Node;

  function FindParentNode(const BuffPtr: PKDT19DD_Vec; NodePtr: PKDT19DD_Node): PKDT19DD_Node;
  var
    Next       : PKDT19DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT19DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT19DD_Node; const BuffPtr: PKDT19DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT19DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT19DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT19DD_Vec; const p1, p2: PKDT19DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT19DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT19DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT19DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT19DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT19DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT19DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT19DD_Node(NearestNodes[0]);
    end;
end;

function TKDT19DD.Search(const Buff: TKDT19DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT19DD.Search(const Buff: TKDT19DD_Vec; var SearchedDistanceMin: Double): PKDT19DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT19DD.Search(const Buff: TKDT19DD_Vec): PKDT19DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT19DD.Search(const inBuff: TKDT19DD_DynamicVecBuffer; var OutBuff: TKDT19DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT19DD_DynamicVecBuffer;
  outBuffPtr : PKDT19DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT19DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT19DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT19DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT19DD.Search(const inBuff: TKDT19DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT19DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT19DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT19DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT19DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT19DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT19DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT19DD_Source));
end;

procedure TKDT19DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT19DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT19DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT19DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT19DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT19DD.PrintNodeTree(const NodePtr: PKDT19DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT19DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT19DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT19DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT19DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT19DD.KDT19DDVec(const s: SystemString): TKDT19DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT19DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT19DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT19DD.KDT19DDVec(const v: TKDT19DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT19DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT19DD.KDT19DDPow(const v: TKDT19DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT19DD.KDT19DDDistance(const v1, v2: TKDT19DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT19DD_Axis - 1 do
      Result := Result + KDT19DDPow(v2[i] - v1[i]);
end;

procedure TKDT19DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT19DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT19DD.Test;
var
  TKDT19DD_Test    : TKDT19DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT19DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT19DD_Test := TKDT19DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT19DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT19DD_Test.TestBuff) - 1 do
    for j := 0 to KDT19DD_Axis - 1 do
        TKDT19DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT19DD_Test.TestBuff), length(TKDT19DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT19DD_Test.BuildKDTreeM(length(TKDT19DD_Test.TestBuff), nil, @TKDT19DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT19DD_Test.BuildKDTreeM(length(TKDT19DD_Test.TestBuff), nil, TKDT19DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT19DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT19DD_Test.TestBuff));
  TKDT19DD_Test.Search(TKDT19DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT19DDDistance(TKDT19DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT19DD_Test.Clear;
  { kMean test }
  TKDT19DD_Test.BuildKDTreeWithCluster(TKDT19DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT19DD_Test.Search(TKDT19DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT19DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT19DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT19DD_Test);
end;


function TKDT20DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DD_Node;
  function SortCompare(const p1, p2: PKDT20DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT20DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT20DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT20DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT20DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT20DD.GetData(const index: NativeInt): PKDT20DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT20DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT20DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT20DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT20DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT20DD.StoreBuffPtr: PKDT20DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT20DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT20DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT20DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT20DD.BuildKDTreeWithCluster(const inBuff: TKDT20DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT20DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT20DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT20DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT20DD.BuildKDTreeWithCluster(const inBuff: TKDT20DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DD_BuildCall);
var
  TempStoreBuff: TKDT20DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT20DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DD_BuildMethod);
var
  TempStoreBuff: TKDT20DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT20DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT20DD_BuildProc);
var
  TempStoreBuff: TKDT20DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT20DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT20DD.Search(const Buff: TKDT20DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DD_Node;

var
  NearestNeighbour: PKDT20DD_Node;

  function FindParentNode(const BuffPtr: PKDT20DD_Vec; NodePtr: PKDT20DD_Node): PKDT20DD_Node;
  var
    Next       : PKDT20DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT20DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT20DD_Node; const BuffPtr: PKDT20DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT20DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT20DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT20DD_Vec; const p1, p2: PKDT20DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT20DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT20DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT20DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT20DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT20DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT20DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT20DD_Node(NearestNodes[0]);
    end;
end;

function TKDT20DD.Search(const Buff: TKDT20DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT20DD.Search(const Buff: TKDT20DD_Vec; var SearchedDistanceMin: Double): PKDT20DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT20DD.Search(const Buff: TKDT20DD_Vec): PKDT20DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT20DD.Search(const inBuff: TKDT20DD_DynamicVecBuffer; var OutBuff: TKDT20DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT20DD_DynamicVecBuffer;
  outBuffPtr : PKDT20DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT20DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT20DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DD.Search(const inBuff: TKDT20DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT20DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT20DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT20DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT20DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT20DD_Source));
end;

procedure TKDT20DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT20DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT20DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT20DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DD.PrintNodeTree(const NodePtr: PKDT20DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT20DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT20DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT20DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT20DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT20DD.KDT20DDVec(const s: SystemString): TKDT20DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT20DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT20DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT20DD.KDT20DDVec(const v: TKDT20DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT20DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT20DD.KDT20DDPow(const v: TKDT20DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT20DD.KDT20DDDistance(const v1, v2: TKDT20DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT20DD_Axis - 1 do
      Result := Result + KDT20DDPow(v2[i] - v1[i]);
end;

procedure TKDT20DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT20DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT20DD.Test;
var
  TKDT20DD_Test    : TKDT20DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT20DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT20DD_Test := TKDT20DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT20DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT20DD_Test.TestBuff) - 1 do
    for j := 0 to KDT20DD_Axis - 1 do
        TKDT20DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT20DD_Test.TestBuff), length(TKDT20DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT20DD_Test.BuildKDTreeM(length(TKDT20DD_Test.TestBuff), nil, @TKDT20DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT20DD_Test.BuildKDTreeM(length(TKDT20DD_Test.TestBuff), nil, TKDT20DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT20DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT20DD_Test.TestBuff));
  TKDT20DD_Test.Search(TKDT20DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT20DDDistance(TKDT20DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT20DD_Test.Clear;
  { kMean test }
  TKDT20DD_Test.BuildKDTreeWithCluster(TKDT20DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT20DD_Test.Search(TKDT20DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT20DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT20DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT20DD_Test);
end;


function TKDT21DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DD_Node;
  function SortCompare(const p1, p2: PKDT21DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT21DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT21DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT21DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT21DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT21DD.GetData(const index: NativeInt): PKDT21DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT21DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT21DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT21DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT21DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT21DD.StoreBuffPtr: PKDT21DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT21DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT21DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT21DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT21DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT21DD.BuildKDTreeWithCluster(const inBuff: TKDT21DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT21DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT21DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT21DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT21DD.BuildKDTreeWithCluster(const inBuff: TKDT21DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT21DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DD_BuildCall);
var
  TempStoreBuff: TKDT21DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT21DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DD_BuildMethod);
var
  TempStoreBuff: TKDT21DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT21DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT21DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT21DD_BuildProc);
var
  TempStoreBuff: TKDT21DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT21DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT21DD.Search(const Buff: TKDT21DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DD_Node;

var
  NearestNeighbour: PKDT21DD_Node;

  function FindParentNode(const BuffPtr: PKDT21DD_Vec; NodePtr: PKDT21DD_Node): PKDT21DD_Node;
  var
    Next       : PKDT21DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT21DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT21DD_Node; const BuffPtr: PKDT21DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT21DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT21DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT21DD_Vec; const p1, p2: PKDT21DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT21DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT21DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT21DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT21DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT21DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT21DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT21DD_Node(NearestNodes[0]);
    end;
end;

function TKDT21DD.Search(const Buff: TKDT21DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT21DD.Search(const Buff: TKDT21DD_Vec; var SearchedDistanceMin: Double): PKDT21DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT21DD.Search(const Buff: TKDT21DD_Vec): PKDT21DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT21DD.Search(const inBuff: TKDT21DD_DynamicVecBuffer; var OutBuff: TKDT21DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT21DD_DynamicVecBuffer;
  outBuffPtr : PKDT21DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT21DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT21DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT21DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT21DD.Search(const inBuff: TKDT21DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT21DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT21DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT21DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT21DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT21DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT21DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT21DD_Source));
end;

procedure TKDT21DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT21DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT21DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT21DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT21DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT21DD.PrintNodeTree(const NodePtr: PKDT21DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT21DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT21DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT21DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT21DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT21DD.KDT21DDVec(const s: SystemString): TKDT21DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT21DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT21DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT21DD.KDT21DDVec(const v: TKDT21DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT21DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT21DD.KDT21DDPow(const v: TKDT21DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT21DD.KDT21DDDistance(const v1, v2: TKDT21DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT21DD_Axis - 1 do
      Result := Result + KDT21DDPow(v2[i] - v1[i]);
end;

procedure TKDT21DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT21DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT21DD.Test;
var
  TKDT21DD_Test    : TKDT21DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT21DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT21DD_Test := TKDT21DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT21DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT21DD_Test.TestBuff) - 1 do
    for j := 0 to KDT21DD_Axis - 1 do
        TKDT21DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT21DD_Test.TestBuff), length(TKDT21DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT21DD_Test.BuildKDTreeM(length(TKDT21DD_Test.TestBuff), nil, @TKDT21DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT21DD_Test.BuildKDTreeM(length(TKDT21DD_Test.TestBuff), nil, TKDT21DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT21DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT21DD_Test.TestBuff));
  TKDT21DD_Test.Search(TKDT21DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT21DDDistance(TKDT21DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT21DD_Test.Clear;
  { kMean test }
  TKDT21DD_Test.BuildKDTreeWithCluster(TKDT21DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT21DD_Test.Search(TKDT21DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT21DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT21DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT21DD_Test);
end;


function TKDT22DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DD_Node;
  function SortCompare(const p1, p2: PKDT22DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT22DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT22DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT22DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT22DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT22DD.GetData(const index: NativeInt): PKDT22DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT22DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT22DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT22DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT22DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT22DD.StoreBuffPtr: PKDT22DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT22DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT22DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT22DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT22DD.BuildKDTreeWithCluster(const inBuff: TKDT22DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT22DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT22DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT22DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT22DD.BuildKDTreeWithCluster(const inBuff: TKDT22DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DD_BuildCall);
var
  TempStoreBuff: TKDT22DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT22DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DD_BuildMethod);
var
  TempStoreBuff: TKDT22DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT22DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT22DD_BuildProc);
var
  TempStoreBuff: TKDT22DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT22DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT22DD.Search(const Buff: TKDT22DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DD_Node;

var
  NearestNeighbour: PKDT22DD_Node;

  function FindParentNode(const BuffPtr: PKDT22DD_Vec; NodePtr: PKDT22DD_Node): PKDT22DD_Node;
  var
    Next       : PKDT22DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT22DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT22DD_Node; const BuffPtr: PKDT22DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT22DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT22DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT22DD_Vec; const p1, p2: PKDT22DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT22DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT22DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT22DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT22DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT22DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT22DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT22DD_Node(NearestNodes[0]);
    end;
end;

function TKDT22DD.Search(const Buff: TKDT22DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT22DD.Search(const Buff: TKDT22DD_Vec; var SearchedDistanceMin: Double): PKDT22DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT22DD.Search(const Buff: TKDT22DD_Vec): PKDT22DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT22DD.Search(const inBuff: TKDT22DD_DynamicVecBuffer; var OutBuff: TKDT22DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT22DD_DynamicVecBuffer;
  outBuffPtr : PKDT22DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT22DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT22DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DD.Search(const inBuff: TKDT22DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT22DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT22DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT22DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT22DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT22DD_Source));
end;

procedure TKDT22DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT22DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT22DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT22DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DD.PrintNodeTree(const NodePtr: PKDT22DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT22DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT22DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT22DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT22DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT22DD.KDT22DDVec(const s: SystemString): TKDT22DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT22DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT22DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT22DD.KDT22DDVec(const v: TKDT22DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT22DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT22DD.KDT22DDPow(const v: TKDT22DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT22DD.KDT22DDDistance(const v1, v2: TKDT22DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT22DD_Axis - 1 do
      Result := Result + KDT22DDPow(v2[i] - v1[i]);
end;

procedure TKDT22DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT22DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT22DD.Test;
var
  TKDT22DD_Test    : TKDT22DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT22DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT22DD_Test := TKDT22DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT22DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT22DD_Test.TestBuff) - 1 do
    for j := 0 to KDT22DD_Axis - 1 do
        TKDT22DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT22DD_Test.TestBuff), length(TKDT22DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT22DD_Test.BuildKDTreeM(length(TKDT22DD_Test.TestBuff), nil, @TKDT22DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT22DD_Test.BuildKDTreeM(length(TKDT22DD_Test.TestBuff), nil, TKDT22DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT22DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT22DD_Test.TestBuff));
  TKDT22DD_Test.Search(TKDT22DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT22DDDistance(TKDT22DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT22DD_Test.Clear;
  { kMean test }
  TKDT22DD_Test.BuildKDTreeWithCluster(TKDT22DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT22DD_Test.Search(TKDT22DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT22DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT22DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT22DD_Test);
end;


function TKDT23DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DD_Node;
  function SortCompare(const p1, p2: PKDT23DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT23DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT23DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT23DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT23DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT23DD.GetData(const index: NativeInt): PKDT23DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT23DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT23DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT23DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT23DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT23DD.StoreBuffPtr: PKDT23DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT23DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT23DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT23DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT23DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT23DD.BuildKDTreeWithCluster(const inBuff: TKDT23DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT23DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT23DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT23DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT23DD.BuildKDTreeWithCluster(const inBuff: TKDT23DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT23DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DD_BuildCall);
var
  TempStoreBuff: TKDT23DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT23DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DD_BuildMethod);
var
  TempStoreBuff: TKDT23DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT23DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT23DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT23DD_BuildProc);
var
  TempStoreBuff: TKDT23DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT23DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT23DD.Search(const Buff: TKDT23DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DD_Node;

var
  NearestNeighbour: PKDT23DD_Node;

  function FindParentNode(const BuffPtr: PKDT23DD_Vec; NodePtr: PKDT23DD_Node): PKDT23DD_Node;
  var
    Next       : PKDT23DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT23DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT23DD_Node; const BuffPtr: PKDT23DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT23DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT23DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT23DD_Vec; const p1, p2: PKDT23DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT23DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT23DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT23DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT23DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT23DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT23DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT23DD_Node(NearestNodes[0]);
    end;
end;

function TKDT23DD.Search(const Buff: TKDT23DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT23DD.Search(const Buff: TKDT23DD_Vec; var SearchedDistanceMin: Double): PKDT23DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT23DD.Search(const Buff: TKDT23DD_Vec): PKDT23DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT23DD.Search(const inBuff: TKDT23DD_DynamicVecBuffer; var OutBuff: TKDT23DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT23DD_DynamicVecBuffer;
  outBuffPtr : PKDT23DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT23DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT23DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT23DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT23DD.Search(const inBuff: TKDT23DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT23DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT23DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT23DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT23DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT23DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT23DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT23DD_Source));
end;

procedure TKDT23DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT23DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT23DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT23DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT23DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT23DD.PrintNodeTree(const NodePtr: PKDT23DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT23DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT23DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT23DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT23DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT23DD.KDT23DDVec(const s: SystemString): TKDT23DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT23DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT23DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT23DD.KDT23DDVec(const v: TKDT23DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT23DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT23DD.KDT23DDPow(const v: TKDT23DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT23DD.KDT23DDDistance(const v1, v2: TKDT23DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT23DD_Axis - 1 do
      Result := Result + KDT23DDPow(v2[i] - v1[i]);
end;

procedure TKDT23DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT23DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT23DD.Test;
var
  TKDT23DD_Test    : TKDT23DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT23DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT23DD_Test := TKDT23DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT23DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT23DD_Test.TestBuff) - 1 do
    for j := 0 to KDT23DD_Axis - 1 do
        TKDT23DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT23DD_Test.TestBuff), length(TKDT23DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT23DD_Test.BuildKDTreeM(length(TKDT23DD_Test.TestBuff), nil, @TKDT23DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT23DD_Test.BuildKDTreeM(length(TKDT23DD_Test.TestBuff), nil, TKDT23DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT23DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT23DD_Test.TestBuff));
  TKDT23DD_Test.Search(TKDT23DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT23DDDistance(TKDT23DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT23DD_Test.Clear;
  { kMean test }
  TKDT23DD_Test.BuildKDTreeWithCluster(TKDT23DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT23DD_Test.Search(TKDT23DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT23DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT23DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT23DD_Test);
end;


function TKDT24DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DD_Node;
  function SortCompare(const p1, p2: PKDT24DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT24DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT24DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT24DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT24DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT24DD.GetData(const index: NativeInt): PKDT24DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT24DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT24DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT24DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT24DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT24DD.StoreBuffPtr: PKDT24DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT24DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT24DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT24DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT24DD.BuildKDTreeWithCluster(const inBuff: TKDT24DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT24DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT24DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT24DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT24DD.BuildKDTreeWithCluster(const inBuff: TKDT24DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DD_BuildCall);
var
  TempStoreBuff: TKDT24DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT24DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DD_BuildMethod);
var
  TempStoreBuff: TKDT24DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT24DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT24DD_BuildProc);
var
  TempStoreBuff: TKDT24DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT24DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT24DD.Search(const Buff: TKDT24DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DD_Node;

var
  NearestNeighbour: PKDT24DD_Node;

  function FindParentNode(const BuffPtr: PKDT24DD_Vec; NodePtr: PKDT24DD_Node): PKDT24DD_Node;
  var
    Next       : PKDT24DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT24DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT24DD_Node; const BuffPtr: PKDT24DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT24DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT24DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT24DD_Vec; const p1, p2: PKDT24DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT24DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT24DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT24DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT24DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT24DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT24DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT24DD_Node(NearestNodes[0]);
    end;
end;

function TKDT24DD.Search(const Buff: TKDT24DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT24DD.Search(const Buff: TKDT24DD_Vec; var SearchedDistanceMin: Double): PKDT24DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT24DD.Search(const Buff: TKDT24DD_Vec): PKDT24DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT24DD.Search(const inBuff: TKDT24DD_DynamicVecBuffer; var OutBuff: TKDT24DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT24DD_DynamicVecBuffer;
  outBuffPtr : PKDT24DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT24DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT24DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DD.Search(const inBuff: TKDT24DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT24DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT24DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT24DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT24DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT24DD_Source));
end;

procedure TKDT24DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT24DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT24DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT24DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DD.PrintNodeTree(const NodePtr: PKDT24DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT24DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT24DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT24DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT24DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT24DD.KDT24DDVec(const s: SystemString): TKDT24DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT24DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT24DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT24DD.KDT24DDVec(const v: TKDT24DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT24DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT24DD.KDT24DDPow(const v: TKDT24DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT24DD.KDT24DDDistance(const v1, v2: TKDT24DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT24DD_Axis - 1 do
      Result := Result + KDT24DDPow(v2[i] - v1[i]);
end;

procedure TKDT24DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT24DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT24DD.Test;
var
  TKDT24DD_Test    : TKDT24DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT24DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT24DD_Test := TKDT24DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT24DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT24DD_Test.TestBuff) - 1 do
    for j := 0 to KDT24DD_Axis - 1 do
        TKDT24DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT24DD_Test.TestBuff), length(TKDT24DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT24DD_Test.BuildKDTreeM(length(TKDT24DD_Test.TestBuff), nil, @TKDT24DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT24DD_Test.BuildKDTreeM(length(TKDT24DD_Test.TestBuff), nil, TKDT24DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT24DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT24DD_Test.TestBuff));
  TKDT24DD_Test.Search(TKDT24DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT24DDDistance(TKDT24DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT24DD_Test.Clear;
  { kMean test }
  TKDT24DD_Test.BuildKDTreeWithCluster(TKDT24DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT24DD_Test.Search(TKDT24DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT24DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT24DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT24DD_Test);
end;


function TKDT25DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT25DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT25DD_Node;
  function SortCompare(const p1, p2: PKDT25DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT25DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT25DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT25DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT25DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT25DD.GetData(const index: NativeInt): PKDT25DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT25DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT25DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT25DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT25DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT25DD.StoreBuffPtr: PKDT25DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT25DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT25DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT25DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT25DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT25DD.BuildKDTreeWithCluster(const inBuff: TKDT25DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT25DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT25DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT25DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT25DD.BuildKDTreeWithCluster(const inBuff: TKDT25DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT25DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DD_BuildCall);
var
  TempStoreBuff: TKDT25DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT25DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT25DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT25DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT25DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DD_BuildMethod);
var
  TempStoreBuff: TKDT25DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT25DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT25DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT25DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT25DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT25DD_BuildProc);
var
  TempStoreBuff: TKDT25DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT25DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT25DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT25DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT25DD.Search(const Buff: TKDT25DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT25DD_Node;

var
  NearestNeighbour: PKDT25DD_Node;

  function FindParentNode(const BuffPtr: PKDT25DD_Vec; NodePtr: PKDT25DD_Node): PKDT25DD_Node;
  var
    Next       : PKDT25DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT25DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT25DD_Node; const BuffPtr: PKDT25DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT25DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT25DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT25DD_Vec; const p1, p2: PKDT25DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT25DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT25DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT25DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT25DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT25DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT25DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT25DD_Node(NearestNodes[0]);
    end;
end;

function TKDT25DD.Search(const Buff: TKDT25DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT25DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT25DD.Search(const Buff: TKDT25DD_Vec; var SearchedDistanceMin: Double): PKDT25DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT25DD.Search(const Buff: TKDT25DD_Vec): PKDT25DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT25DD.Search(const inBuff: TKDT25DD_DynamicVecBuffer; var OutBuff: TKDT25DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT25DD_DynamicVecBuffer;
  outBuffPtr : PKDT25DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT25DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT25DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT25DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT25DD.Search(const inBuff: TKDT25DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT25DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT25DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT25DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT25DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT25DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT25DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT25DD_Source));
end;

procedure TKDT25DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT25DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT25DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT25DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT25DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT25DD.PrintNodeTree(const NodePtr: PKDT25DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT25DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT25DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT25DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT25DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT25DD.KDT25DDVec(const s: SystemString): TKDT25DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT25DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT25DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT25DD.KDT25DDVec(const v: TKDT25DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT25DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT25DD.KDT25DDPow(const v: TKDT25DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT25DD.KDT25DDDistance(const v1, v2: TKDT25DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT25DD_Axis - 1 do
      Result := Result + KDT25DDPow(v2[i] - v1[i]);
end;

procedure TKDT25DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT25DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT25DD.Test;
var
  TKDT25DD_Test    : TKDT25DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT25DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT25DD_Test := TKDT25DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT25DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT25DD_Test.TestBuff) - 1 do
    for j := 0 to KDT25DD_Axis - 1 do
        TKDT25DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT25DD_Test.TestBuff), length(TKDT25DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT25DD_Test.BuildKDTreeM(length(TKDT25DD_Test.TestBuff), nil, @TKDT25DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT25DD_Test.BuildKDTreeM(length(TKDT25DD_Test.TestBuff), nil, TKDT25DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT25DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT25DD_Test.TestBuff));
  TKDT25DD_Test.Search(TKDT25DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT25DDDistance(TKDT25DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT25DD_Test.Clear;
  { kMean test }
  TKDT25DD_Test.BuildKDTreeWithCluster(TKDT25DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT25DD_Test.Search(TKDT25DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT25DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT25DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT25DD_Test);
end;


function TKDT26DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT26DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT26DD_Node;
  function SortCompare(const p1, p2: PKDT26DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT26DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT26DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT26DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT26DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT26DD.GetData(const index: NativeInt): PKDT26DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT26DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT26DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT26DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT26DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT26DD.StoreBuffPtr: PKDT26DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT26DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT26DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT26DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT26DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT26DD.BuildKDTreeWithCluster(const inBuff: TKDT26DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT26DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT26DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT26DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT26DD.BuildKDTreeWithCluster(const inBuff: TKDT26DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT26DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DD_BuildCall);
var
  TempStoreBuff: TKDT26DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT26DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT26DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT26DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT26DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DD_BuildMethod);
var
  TempStoreBuff: TKDT26DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT26DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT26DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT26DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT26DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT26DD_BuildProc);
var
  TempStoreBuff: TKDT26DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT26DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT26DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT26DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT26DD.Search(const Buff: TKDT26DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT26DD_Node;

var
  NearestNeighbour: PKDT26DD_Node;

  function FindParentNode(const BuffPtr: PKDT26DD_Vec; NodePtr: PKDT26DD_Node): PKDT26DD_Node;
  var
    Next       : PKDT26DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT26DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT26DD_Node; const BuffPtr: PKDT26DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT26DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT26DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT26DD_Vec; const p1, p2: PKDT26DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT26DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT26DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT26DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT26DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT26DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT26DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT26DD_Node(NearestNodes[0]);
    end;
end;

function TKDT26DD.Search(const Buff: TKDT26DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT26DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT26DD.Search(const Buff: TKDT26DD_Vec; var SearchedDistanceMin: Double): PKDT26DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT26DD.Search(const Buff: TKDT26DD_Vec): PKDT26DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT26DD.Search(const inBuff: TKDT26DD_DynamicVecBuffer; var OutBuff: TKDT26DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT26DD_DynamicVecBuffer;
  outBuffPtr : PKDT26DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT26DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT26DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT26DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT26DD.Search(const inBuff: TKDT26DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT26DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT26DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT26DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT26DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT26DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT26DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT26DD_Source));
end;

procedure TKDT26DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT26DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT26DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT26DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT26DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT26DD.PrintNodeTree(const NodePtr: PKDT26DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT26DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT26DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT26DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT26DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT26DD.KDT26DDVec(const s: SystemString): TKDT26DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT26DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT26DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT26DD.KDT26DDVec(const v: TKDT26DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT26DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT26DD.KDT26DDPow(const v: TKDT26DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT26DD.KDT26DDDistance(const v1, v2: TKDT26DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT26DD_Axis - 1 do
      Result := Result + KDT26DDPow(v2[i] - v1[i]);
end;

procedure TKDT26DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT26DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT26DD.Test;
var
  TKDT26DD_Test    : TKDT26DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT26DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT26DD_Test := TKDT26DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT26DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT26DD_Test.TestBuff) - 1 do
    for j := 0 to KDT26DD_Axis - 1 do
        TKDT26DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT26DD_Test.TestBuff), length(TKDT26DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT26DD_Test.BuildKDTreeM(length(TKDT26DD_Test.TestBuff), nil, @TKDT26DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT26DD_Test.BuildKDTreeM(length(TKDT26DD_Test.TestBuff), nil, TKDT26DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT26DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT26DD_Test.TestBuff));
  TKDT26DD_Test.Search(TKDT26DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT26DDDistance(TKDT26DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT26DD_Test.Clear;
  { kMean test }
  TKDT26DD_Test.BuildKDTreeWithCluster(TKDT26DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT26DD_Test.Search(TKDT26DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT26DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT26DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT26DD_Test);
end;


function TKDT27DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT27DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT27DD_Node;
  function SortCompare(const p1, p2: PKDT27DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT27DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT27DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT27DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT27DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT27DD.GetData(const index: NativeInt): PKDT27DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT27DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT27DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT27DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT27DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT27DD.StoreBuffPtr: PKDT27DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT27DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT27DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT27DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT27DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT27DD.BuildKDTreeWithCluster(const inBuff: TKDT27DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT27DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT27DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT27DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT27DD.BuildKDTreeWithCluster(const inBuff: TKDT27DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT27DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DD_BuildCall);
var
  TempStoreBuff: TKDT27DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT27DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT27DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT27DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT27DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DD_BuildMethod);
var
  TempStoreBuff: TKDT27DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT27DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT27DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT27DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT27DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT27DD_BuildProc);
var
  TempStoreBuff: TKDT27DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT27DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT27DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT27DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT27DD.Search(const Buff: TKDT27DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT27DD_Node;

var
  NearestNeighbour: PKDT27DD_Node;

  function FindParentNode(const BuffPtr: PKDT27DD_Vec; NodePtr: PKDT27DD_Node): PKDT27DD_Node;
  var
    Next       : PKDT27DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT27DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT27DD_Node; const BuffPtr: PKDT27DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT27DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT27DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT27DD_Vec; const p1, p2: PKDT27DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT27DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT27DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT27DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT27DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT27DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT27DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT27DD_Node(NearestNodes[0]);
    end;
end;

function TKDT27DD.Search(const Buff: TKDT27DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT27DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT27DD.Search(const Buff: TKDT27DD_Vec; var SearchedDistanceMin: Double): PKDT27DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT27DD.Search(const Buff: TKDT27DD_Vec): PKDT27DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT27DD.Search(const inBuff: TKDT27DD_DynamicVecBuffer; var OutBuff: TKDT27DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT27DD_DynamicVecBuffer;
  outBuffPtr : PKDT27DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT27DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT27DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT27DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT27DD.Search(const inBuff: TKDT27DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT27DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT27DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT27DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT27DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT27DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT27DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT27DD_Source));
end;

procedure TKDT27DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT27DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT27DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT27DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT27DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT27DD.PrintNodeTree(const NodePtr: PKDT27DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT27DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT27DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT27DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT27DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT27DD.KDT27DDVec(const s: SystemString): TKDT27DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT27DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT27DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT27DD.KDT27DDVec(const v: TKDT27DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT27DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT27DD.KDT27DDPow(const v: TKDT27DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT27DD.KDT27DDDistance(const v1, v2: TKDT27DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT27DD_Axis - 1 do
      Result := Result + KDT27DDPow(v2[i] - v1[i]);
end;

procedure TKDT27DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT27DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT27DD.Test;
var
  TKDT27DD_Test    : TKDT27DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT27DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT27DD_Test := TKDT27DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT27DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT27DD_Test.TestBuff) - 1 do
    for j := 0 to KDT27DD_Axis - 1 do
        TKDT27DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT27DD_Test.TestBuff), length(TKDT27DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT27DD_Test.BuildKDTreeM(length(TKDT27DD_Test.TestBuff), nil, @TKDT27DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT27DD_Test.BuildKDTreeM(length(TKDT27DD_Test.TestBuff), nil, TKDT27DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT27DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT27DD_Test.TestBuff));
  TKDT27DD_Test.Search(TKDT27DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT27DDDistance(TKDT27DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT27DD_Test.Clear;
  { kMean test }
  TKDT27DD_Test.BuildKDTreeWithCluster(TKDT27DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT27DD_Test.Search(TKDT27DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT27DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT27DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT27DD_Test);
end;


function TKDT28DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DD_Node;
  function SortCompare(const p1, p2: PKDT28DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT28DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT28DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT28DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT28DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT28DD.GetData(const index: NativeInt): PKDT28DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT28DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT28DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT28DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT28DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT28DD.StoreBuffPtr: PKDT28DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT28DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT28DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT28DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT28DD.BuildKDTreeWithCluster(const inBuff: TKDT28DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT28DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT28DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT28DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT28DD.BuildKDTreeWithCluster(const inBuff: TKDT28DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DD_BuildCall);
var
  TempStoreBuff: TKDT28DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT28DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT28DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT28DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DD_BuildMethod);
var
  TempStoreBuff: TKDT28DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT28DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT28DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT28DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT28DD_BuildProc);
var
  TempStoreBuff: TKDT28DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT28DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT28DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT28DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT28DD.Search(const Buff: TKDT28DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DD_Node;

var
  NearestNeighbour: PKDT28DD_Node;

  function FindParentNode(const BuffPtr: PKDT28DD_Vec; NodePtr: PKDT28DD_Node): PKDT28DD_Node;
  var
    Next       : PKDT28DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT28DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT28DD_Node; const BuffPtr: PKDT28DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT28DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT28DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT28DD_Vec; const p1, p2: PKDT28DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT28DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT28DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT28DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT28DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT28DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT28DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT28DD_Node(NearestNodes[0]);
    end;
end;

function TKDT28DD.Search(const Buff: TKDT28DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT28DD.Search(const Buff: TKDT28DD_Vec; var SearchedDistanceMin: Double): PKDT28DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT28DD.Search(const Buff: TKDT28DD_Vec): PKDT28DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT28DD.Search(const inBuff: TKDT28DD_DynamicVecBuffer; var OutBuff: TKDT28DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT28DD_DynamicVecBuffer;
  outBuffPtr : PKDT28DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT28DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT28DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT28DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT28DD.Search(const inBuff: TKDT28DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT28DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT28DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT28DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT28DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT28DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT28DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT28DD_Source));
end;

procedure TKDT28DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT28DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT28DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT28DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT28DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT28DD.PrintNodeTree(const NodePtr: PKDT28DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT28DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT28DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT28DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT28DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT28DD.KDT28DDVec(const s: SystemString): TKDT28DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT28DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT28DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT28DD.KDT28DDVec(const v: TKDT28DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT28DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT28DD.KDT28DDPow(const v: TKDT28DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT28DD.KDT28DDDistance(const v1, v2: TKDT28DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT28DD_Axis - 1 do
      Result := Result + KDT28DDPow(v2[i] - v1[i]);
end;

procedure TKDT28DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT28DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT28DD.Test;
var
  TKDT28DD_Test    : TKDT28DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT28DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT28DD_Test := TKDT28DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT28DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT28DD_Test.TestBuff) - 1 do
    for j := 0 to KDT28DD_Axis - 1 do
        TKDT28DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT28DD_Test.TestBuff), length(TKDT28DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT28DD_Test.BuildKDTreeM(length(TKDT28DD_Test.TestBuff), nil, @TKDT28DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT28DD_Test.BuildKDTreeM(length(TKDT28DD_Test.TestBuff), nil, TKDT28DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT28DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT28DD_Test.TestBuff));
  TKDT28DD_Test.Search(TKDT28DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT28DDDistance(TKDT28DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT28DD_Test.Clear;
  { kMean test }
  TKDT28DD_Test.BuildKDTreeWithCluster(TKDT28DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT28DD_Test.Search(TKDT28DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT28DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT28DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT28DD_Test);
end;


function TKDT29DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT29DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT29DD_Node;
  function SortCompare(const p1, p2: PKDT29DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT29DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT29DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT29DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT29DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT29DD.GetData(const index: NativeInt): PKDT29DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT29DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT29DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT29DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT29DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT29DD.StoreBuffPtr: PKDT29DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT29DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT29DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT29DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT29DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT29DD.BuildKDTreeWithCluster(const inBuff: TKDT29DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT29DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT29DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT29DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT29DD.BuildKDTreeWithCluster(const inBuff: TKDT29DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT29DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DD_BuildCall);
var
  TempStoreBuff: TKDT29DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT29DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT29DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT29DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT29DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DD_BuildMethod);
var
  TempStoreBuff: TKDT29DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT29DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT29DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT29DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT29DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT29DD_BuildProc);
var
  TempStoreBuff: TKDT29DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT29DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT29DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT29DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT29DD.Search(const Buff: TKDT29DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT29DD_Node;

var
  NearestNeighbour: PKDT29DD_Node;

  function FindParentNode(const BuffPtr: PKDT29DD_Vec; NodePtr: PKDT29DD_Node): PKDT29DD_Node;
  var
    Next       : PKDT29DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT29DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT29DD_Node; const BuffPtr: PKDT29DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT29DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT29DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT29DD_Vec; const p1, p2: PKDT29DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT29DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT29DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT29DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT29DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT29DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT29DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT29DD_Node(NearestNodes[0]);
    end;
end;

function TKDT29DD.Search(const Buff: TKDT29DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT29DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT29DD.Search(const Buff: TKDT29DD_Vec; var SearchedDistanceMin: Double): PKDT29DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT29DD.Search(const Buff: TKDT29DD_Vec): PKDT29DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT29DD.Search(const inBuff: TKDT29DD_DynamicVecBuffer; var OutBuff: TKDT29DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT29DD_DynamicVecBuffer;
  outBuffPtr : PKDT29DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT29DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT29DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT29DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT29DD.Search(const inBuff: TKDT29DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT29DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT29DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT29DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT29DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT29DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT29DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT29DD_Source));
end;

procedure TKDT29DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT29DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT29DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT29DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT29DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT29DD.PrintNodeTree(const NodePtr: PKDT29DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT29DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT29DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT29DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT29DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT29DD.KDT29DDVec(const s: SystemString): TKDT29DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT29DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT29DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT29DD.KDT29DDVec(const v: TKDT29DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT29DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT29DD.KDT29DDPow(const v: TKDT29DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT29DD.KDT29DDDistance(const v1, v2: TKDT29DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT29DD_Axis - 1 do
      Result := Result + KDT29DDPow(v2[i] - v1[i]);
end;

procedure TKDT29DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT29DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT29DD.Test;
var
  TKDT29DD_Test    : TKDT29DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT29DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT29DD_Test := TKDT29DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT29DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT29DD_Test.TestBuff) - 1 do
    for j := 0 to KDT29DD_Axis - 1 do
        TKDT29DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT29DD_Test.TestBuff), length(TKDT29DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT29DD_Test.BuildKDTreeM(length(TKDT29DD_Test.TestBuff), nil, @TKDT29DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT29DD_Test.BuildKDTreeM(length(TKDT29DD_Test.TestBuff), nil, TKDT29DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT29DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT29DD_Test.TestBuff));
  TKDT29DD_Test.Search(TKDT29DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT29DDDistance(TKDT29DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT29DD_Test.Clear;
  { kMean test }
  TKDT29DD_Test.BuildKDTreeWithCluster(TKDT29DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT29DD_Test.Search(TKDT29DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT29DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT29DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT29DD_Test);
end;


function TKDT30DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DD_Node;
  function SortCompare(const p1, p2: PKDT30DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT30DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT30DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT30DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT30DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT30DD.GetData(const index: NativeInt): PKDT30DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT30DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT30DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT30DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT30DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT30DD.StoreBuffPtr: PKDT30DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT30DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT30DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT30DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT30DD.BuildKDTreeWithCluster(const inBuff: TKDT30DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT30DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT30DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT30DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT30DD.BuildKDTreeWithCluster(const inBuff: TKDT30DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DD_BuildCall);
var
  TempStoreBuff: TKDT30DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT30DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT30DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT30DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DD_BuildMethod);
var
  TempStoreBuff: TKDT30DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT30DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT30DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT30DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT30DD_BuildProc);
var
  TempStoreBuff: TKDT30DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT30DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT30DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT30DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT30DD.Search(const Buff: TKDT30DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DD_Node;

var
  NearestNeighbour: PKDT30DD_Node;

  function FindParentNode(const BuffPtr: PKDT30DD_Vec; NodePtr: PKDT30DD_Node): PKDT30DD_Node;
  var
    Next       : PKDT30DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT30DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT30DD_Node; const BuffPtr: PKDT30DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT30DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT30DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT30DD_Vec; const p1, p2: PKDT30DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT30DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT30DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT30DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT30DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT30DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT30DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT30DD_Node(NearestNodes[0]);
    end;
end;

function TKDT30DD.Search(const Buff: TKDT30DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT30DD.Search(const Buff: TKDT30DD_Vec; var SearchedDistanceMin: Double): PKDT30DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT30DD.Search(const Buff: TKDT30DD_Vec): PKDT30DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT30DD.Search(const inBuff: TKDT30DD_DynamicVecBuffer; var OutBuff: TKDT30DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT30DD_DynamicVecBuffer;
  outBuffPtr : PKDT30DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT30DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT30DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT30DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT30DD.Search(const inBuff: TKDT30DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT30DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT30DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT30DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT30DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT30DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT30DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT30DD_Source));
end;

procedure TKDT30DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT30DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT30DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT30DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT30DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT30DD.PrintNodeTree(const NodePtr: PKDT30DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT30DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT30DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT30DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT30DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT30DD.KDT30DDVec(const s: SystemString): TKDT30DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT30DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT30DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT30DD.KDT30DDVec(const v: TKDT30DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT30DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT30DD.KDT30DDPow(const v: TKDT30DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT30DD.KDT30DDDistance(const v1, v2: TKDT30DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT30DD_Axis - 1 do
      Result := Result + KDT30DDPow(v2[i] - v1[i]);
end;

procedure TKDT30DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT30DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT30DD.Test;
var
  TKDT30DD_Test    : TKDT30DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT30DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT30DD_Test := TKDT30DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT30DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT30DD_Test.TestBuff) - 1 do
    for j := 0 to KDT30DD_Axis - 1 do
        TKDT30DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT30DD_Test.TestBuff), length(TKDT30DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT30DD_Test.BuildKDTreeM(length(TKDT30DD_Test.TestBuff), nil, @TKDT30DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT30DD_Test.BuildKDTreeM(length(TKDT30DD_Test.TestBuff), nil, TKDT30DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT30DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT30DD_Test.TestBuff));
  TKDT30DD_Test.Search(TKDT30DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT30DDDistance(TKDT30DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT30DD_Test.Clear;
  { kMean test }
  TKDT30DD_Test.BuildKDTreeWithCluster(TKDT30DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT30DD_Test.Search(TKDT30DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT30DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT30DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT30DD_Test);
end;


function TKDT31DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT31DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT31DD_Node;
  function SortCompare(const p1, p2: PKDT31DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT31DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT31DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT31DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT31DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT31DD.GetData(const index: NativeInt): PKDT31DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT31DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT31DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT31DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT31DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT31DD.StoreBuffPtr: PKDT31DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT31DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT31DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT31DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT31DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT31DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT31DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT31DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT31DD.BuildKDTreeWithCluster(const inBuff: TKDT31DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT31DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT31DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT31DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT31DD.BuildKDTreeWithCluster(const inBuff: TKDT31DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT31DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DD_BuildCall);
var
  TempStoreBuff: TKDT31DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT31DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT31DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT31DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT31DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT31DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DD_BuildMethod);
var
  TempStoreBuff: TKDT31DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT31DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT31DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT31DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT31DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT31DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT31DD_BuildProc);
var
  TempStoreBuff: TKDT31DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT31DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT31DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT31DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT31DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT31DD.Search(const Buff: TKDT31DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT31DD_Node;

var
  NearestNeighbour: PKDT31DD_Node;

  function FindParentNode(const BuffPtr: PKDT31DD_Vec; NodePtr: PKDT31DD_Node): PKDT31DD_Node;
  var
    Next       : PKDT31DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT31DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT31DD_Node; const BuffPtr: PKDT31DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT31DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT31DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT31DD_Vec; const p1, p2: PKDT31DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT31DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT31DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT31DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT31DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT31DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT31DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT31DD_Node(NearestNodes[0]);
    end;
end;

function TKDT31DD.Search(const Buff: TKDT31DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT31DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT31DD.Search(const Buff: TKDT31DD_Vec; var SearchedDistanceMin: Double): PKDT31DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT31DD.Search(const Buff: TKDT31DD_Vec): PKDT31DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT31DD.Search(const inBuff: TKDT31DD_DynamicVecBuffer; var OutBuff: TKDT31DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT31DD_DynamicVecBuffer;
  outBuffPtr : PKDT31DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT31DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT31DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT31DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT31DD.Search(const inBuff: TKDT31DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT31DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT31DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT31DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT31DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT31DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT31DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT31DD_Source));
end;

procedure TKDT31DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT31DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT31DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT31DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT31DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT31DD.PrintNodeTree(const NodePtr: PKDT31DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT31DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT31DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT31DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT31DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT31DD.KDT31DDVec(const s: SystemString): TKDT31DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT31DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT31DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT31DD.KDT31DDVec(const v: TKDT31DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT31DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT31DD.KDT31DDPow(const v: TKDT31DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT31DD.KDT31DDDistance(const v1, v2: TKDT31DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT31DD_Axis - 1 do
      Result := Result + KDT31DDPow(v2[i] - v1[i]);
end;

procedure TKDT31DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT31DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT31DD.Test;
var
  TKDT31DD_Test    : TKDT31DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT31DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT31DD_Test := TKDT31DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT31DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT31DD_Test.TestBuff) - 1 do
    for j := 0 to KDT31DD_Axis - 1 do
        TKDT31DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT31DD_Test.TestBuff), length(TKDT31DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT31DD_Test.BuildKDTreeM(length(TKDT31DD_Test.TestBuff), nil, @TKDT31DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT31DD_Test.BuildKDTreeM(length(TKDT31DD_Test.TestBuff), nil, TKDT31DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT31DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT31DD_Test.TestBuff));
  TKDT31DD_Test.Search(TKDT31DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT31DDDistance(TKDT31DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT31DD_Test.Clear;
  { kMean test }
  TKDT31DD_Test.BuildKDTreeWithCluster(TKDT31DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT31DD_Test.Search(TKDT31DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT31DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT31DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT31DD_Test);
end;


function TKDT32DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DD_Node;
  function SortCompare(const p1, p2: PKDT32DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT32DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT32DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT32DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT32DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT32DD.GetData(const index: NativeInt): PKDT32DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT32DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT32DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT32DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT32DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT32DD.StoreBuffPtr: PKDT32DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT32DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT32DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT32DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT32DD.BuildKDTreeWithCluster(const inBuff: TKDT32DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT32DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT32DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT32DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT32DD.BuildKDTreeWithCluster(const inBuff: TKDT32DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DD_BuildCall);
var
  TempStoreBuff: TKDT32DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT32DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT32DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT32DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DD_BuildMethod);
var
  TempStoreBuff: TKDT32DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT32DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT32DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT32DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT32DD_BuildProc);
var
  TempStoreBuff: TKDT32DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT32DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT32DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT32DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT32DD.Search(const Buff: TKDT32DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DD_Node;

var
  NearestNeighbour: PKDT32DD_Node;

  function FindParentNode(const BuffPtr: PKDT32DD_Vec; NodePtr: PKDT32DD_Node): PKDT32DD_Node;
  var
    Next       : PKDT32DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT32DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT32DD_Node; const BuffPtr: PKDT32DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT32DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT32DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT32DD_Vec; const p1, p2: PKDT32DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT32DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT32DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT32DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT32DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT32DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT32DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT32DD_Node(NearestNodes[0]);
    end;
end;

function TKDT32DD.Search(const Buff: TKDT32DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT32DD.Search(const Buff: TKDT32DD_Vec; var SearchedDistanceMin: Double): PKDT32DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT32DD.Search(const Buff: TKDT32DD_Vec): PKDT32DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT32DD.Search(const inBuff: TKDT32DD_DynamicVecBuffer; var OutBuff: TKDT32DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT32DD_DynamicVecBuffer;
  outBuffPtr : PKDT32DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT32DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT32DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT32DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT32DD.Search(const inBuff: TKDT32DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT32DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT32DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT32DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT32DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT32DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT32DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT32DD_Source));
end;

procedure TKDT32DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT32DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT32DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT32DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT32DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT32DD.PrintNodeTree(const NodePtr: PKDT32DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT32DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT32DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT32DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT32DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT32DD.KDT32DDVec(const s: SystemString): TKDT32DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT32DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT32DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT32DD.KDT32DDVec(const v: TKDT32DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT32DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT32DD.KDT32DDPow(const v: TKDT32DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT32DD.KDT32DDDistance(const v1, v2: TKDT32DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT32DD_Axis - 1 do
      Result := Result + KDT32DDPow(v2[i] - v1[i]);
end;

procedure TKDT32DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT32DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT32DD.Test;
var
  TKDT32DD_Test    : TKDT32DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT32DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT32DD_Test := TKDT32DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT32DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT32DD_Test.TestBuff) - 1 do
    for j := 0 to KDT32DD_Axis - 1 do
        TKDT32DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT32DD_Test.TestBuff), length(TKDT32DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT32DD_Test.BuildKDTreeM(length(TKDT32DD_Test.TestBuff), nil, @TKDT32DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT32DD_Test.BuildKDTreeM(length(TKDT32DD_Test.TestBuff), nil, TKDT32DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT32DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT32DD_Test.TestBuff));
  TKDT32DD_Test.Search(TKDT32DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT32DDDistance(TKDT32DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT32DD_Test.Clear;
  { kMean test }
  TKDT32DD_Test.BuildKDTreeWithCluster(TKDT32DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT32DD_Test.Search(TKDT32DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT32DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT32DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT32DD_Test);
end;


function TKDT33DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT33DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT33DD_Node;
  function SortCompare(const p1, p2: PKDT33DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT33DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT33DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT33DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT33DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT33DD.GetData(const index: NativeInt): PKDT33DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT33DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT33DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT33DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT33DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT33DD.StoreBuffPtr: PKDT33DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT33DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT33DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT33DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT33DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT33DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT33DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT33DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT33DD.BuildKDTreeWithCluster(const inBuff: TKDT33DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT33DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT33DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT33DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT33DD.BuildKDTreeWithCluster(const inBuff: TKDT33DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT33DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DD_BuildCall);
var
  TempStoreBuff: TKDT33DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT33DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT33DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT33DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT33DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT33DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DD_BuildMethod);
var
  TempStoreBuff: TKDT33DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT33DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT33DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT33DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT33DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT33DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT33DD_BuildProc);
var
  TempStoreBuff: TKDT33DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT33DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT33DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT33DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT33DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT33DD.Search(const Buff: TKDT33DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT33DD_Node;

var
  NearestNeighbour: PKDT33DD_Node;

  function FindParentNode(const BuffPtr: PKDT33DD_Vec; NodePtr: PKDT33DD_Node): PKDT33DD_Node;
  var
    Next       : PKDT33DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT33DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT33DD_Node; const BuffPtr: PKDT33DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT33DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT33DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT33DD_Vec; const p1, p2: PKDT33DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT33DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT33DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT33DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT33DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT33DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT33DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT33DD_Node(NearestNodes[0]);
    end;
end;

function TKDT33DD.Search(const Buff: TKDT33DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT33DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT33DD.Search(const Buff: TKDT33DD_Vec; var SearchedDistanceMin: Double): PKDT33DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT33DD.Search(const Buff: TKDT33DD_Vec): PKDT33DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT33DD.Search(const inBuff: TKDT33DD_DynamicVecBuffer; var OutBuff: TKDT33DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT33DD_DynamicVecBuffer;
  outBuffPtr : PKDT33DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT33DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT33DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT33DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT33DD.Search(const inBuff: TKDT33DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT33DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT33DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT33DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT33DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT33DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT33DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT33DD_Source));
end;

procedure TKDT33DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT33DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT33DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT33DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT33DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT33DD.PrintNodeTree(const NodePtr: PKDT33DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT33DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT33DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT33DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT33DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT33DD.KDT33DDVec(const s: SystemString): TKDT33DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT33DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT33DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT33DD.KDT33DDVec(const v: TKDT33DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT33DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT33DD.KDT33DDPow(const v: TKDT33DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT33DD.KDT33DDDistance(const v1, v2: TKDT33DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT33DD_Axis - 1 do
      Result := Result + KDT33DDPow(v2[i] - v1[i]);
end;

procedure TKDT33DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT33DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT33DD.Test;
var
  TKDT33DD_Test    : TKDT33DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT33DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT33DD_Test := TKDT33DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT33DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT33DD_Test.TestBuff) - 1 do
    for j := 0 to KDT33DD_Axis - 1 do
        TKDT33DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT33DD_Test.TestBuff), length(TKDT33DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT33DD_Test.BuildKDTreeM(length(TKDT33DD_Test.TestBuff), nil, @TKDT33DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT33DD_Test.BuildKDTreeM(length(TKDT33DD_Test.TestBuff), nil, TKDT33DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT33DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT33DD_Test.TestBuff));
  TKDT33DD_Test.Search(TKDT33DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT33DDDistance(TKDT33DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT33DD_Test.Clear;
  { kMean test }
  TKDT33DD_Test.BuildKDTreeWithCluster(TKDT33DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT33DD_Test.Search(TKDT33DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT33DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT33DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT33DD_Test);
end;


function TKDT34DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DD_Node;
  function SortCompare(const p1, p2: PKDT34DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT34DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT34DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT34DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT34DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT34DD.GetData(const index: NativeInt): PKDT34DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT34DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT34DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT34DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT34DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT34DD.StoreBuffPtr: PKDT34DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT34DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT34DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT34DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT34DD.BuildKDTreeWithCluster(const inBuff: TKDT34DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT34DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT34DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT34DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT34DD.BuildKDTreeWithCluster(const inBuff: TKDT34DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DD_BuildCall);
var
  TempStoreBuff: TKDT34DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT34DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT34DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT34DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DD_BuildMethod);
var
  TempStoreBuff: TKDT34DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT34DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT34DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT34DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT34DD_BuildProc);
var
  TempStoreBuff: TKDT34DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT34DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT34DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT34DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT34DD.Search(const Buff: TKDT34DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DD_Node;

var
  NearestNeighbour: PKDT34DD_Node;

  function FindParentNode(const BuffPtr: PKDT34DD_Vec; NodePtr: PKDT34DD_Node): PKDT34DD_Node;
  var
    Next       : PKDT34DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT34DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT34DD_Node; const BuffPtr: PKDT34DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT34DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT34DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT34DD_Vec; const p1, p2: PKDT34DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT34DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT34DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT34DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT34DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT34DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT34DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT34DD_Node(NearestNodes[0]);
    end;
end;

function TKDT34DD.Search(const Buff: TKDT34DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT34DD.Search(const Buff: TKDT34DD_Vec; var SearchedDistanceMin: Double): PKDT34DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT34DD.Search(const Buff: TKDT34DD_Vec): PKDT34DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT34DD.Search(const inBuff: TKDT34DD_DynamicVecBuffer; var OutBuff: TKDT34DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT34DD_DynamicVecBuffer;
  outBuffPtr : PKDT34DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT34DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT34DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT34DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT34DD.Search(const inBuff: TKDT34DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT34DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT34DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT34DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT34DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT34DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT34DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT34DD_Source));
end;

procedure TKDT34DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT34DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT34DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT34DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT34DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT34DD.PrintNodeTree(const NodePtr: PKDT34DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT34DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT34DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT34DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT34DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT34DD.KDT34DDVec(const s: SystemString): TKDT34DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT34DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT34DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT34DD.KDT34DDVec(const v: TKDT34DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT34DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT34DD.KDT34DDPow(const v: TKDT34DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT34DD.KDT34DDDistance(const v1, v2: TKDT34DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT34DD_Axis - 1 do
      Result := Result + KDT34DDPow(v2[i] - v1[i]);
end;

procedure TKDT34DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT34DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT34DD.Test;
var
  TKDT34DD_Test    : TKDT34DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT34DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT34DD_Test := TKDT34DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT34DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT34DD_Test.TestBuff) - 1 do
    for j := 0 to KDT34DD_Axis - 1 do
        TKDT34DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT34DD_Test.TestBuff), length(TKDT34DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT34DD_Test.BuildKDTreeM(length(TKDT34DD_Test.TestBuff), nil, @TKDT34DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT34DD_Test.BuildKDTreeM(length(TKDT34DD_Test.TestBuff), nil, TKDT34DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT34DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT34DD_Test.TestBuff));
  TKDT34DD_Test.Search(TKDT34DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT34DDDistance(TKDT34DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT34DD_Test.Clear;
  { kMean test }
  TKDT34DD_Test.BuildKDTreeWithCluster(TKDT34DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT34DD_Test.Search(TKDT34DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT34DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT34DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT34DD_Test);
end;


function TKDT35DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT35DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT35DD_Node;
  function SortCompare(const p1, p2: PKDT35DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT35DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT35DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT35DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT35DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT35DD.GetData(const index: NativeInt): PKDT35DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT35DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT35DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT35DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT35DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT35DD.StoreBuffPtr: PKDT35DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT35DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT35DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT35DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT35DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT35DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT35DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT35DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT35DD.BuildKDTreeWithCluster(const inBuff: TKDT35DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT35DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT35DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT35DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT35DD.BuildKDTreeWithCluster(const inBuff: TKDT35DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT35DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DD_BuildCall);
var
  TempStoreBuff: TKDT35DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT35DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT35DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT35DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT35DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT35DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DD_BuildMethod);
var
  TempStoreBuff: TKDT35DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT35DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT35DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT35DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT35DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT35DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT35DD_BuildProc);
var
  TempStoreBuff: TKDT35DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT35DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT35DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT35DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT35DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT35DD.Search(const Buff: TKDT35DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT35DD_Node;

var
  NearestNeighbour: PKDT35DD_Node;

  function FindParentNode(const BuffPtr: PKDT35DD_Vec; NodePtr: PKDT35DD_Node): PKDT35DD_Node;
  var
    Next       : PKDT35DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT35DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT35DD_Node; const BuffPtr: PKDT35DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT35DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT35DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT35DD_Vec; const p1, p2: PKDT35DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT35DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT35DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT35DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT35DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT35DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT35DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT35DD_Node(NearestNodes[0]);
    end;
end;

function TKDT35DD.Search(const Buff: TKDT35DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT35DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT35DD.Search(const Buff: TKDT35DD_Vec; var SearchedDistanceMin: Double): PKDT35DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT35DD.Search(const Buff: TKDT35DD_Vec): PKDT35DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT35DD.Search(const inBuff: TKDT35DD_DynamicVecBuffer; var OutBuff: TKDT35DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT35DD_DynamicVecBuffer;
  outBuffPtr : PKDT35DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT35DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT35DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT35DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT35DD.Search(const inBuff: TKDT35DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT35DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT35DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT35DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT35DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT35DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT35DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT35DD_Source));
end;

procedure TKDT35DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT35DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT35DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT35DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT35DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT35DD.PrintNodeTree(const NodePtr: PKDT35DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT35DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT35DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT35DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT35DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT35DD.KDT35DDVec(const s: SystemString): TKDT35DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT35DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT35DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT35DD.KDT35DDVec(const v: TKDT35DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT35DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT35DD.KDT35DDPow(const v: TKDT35DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT35DD.KDT35DDDistance(const v1, v2: TKDT35DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT35DD_Axis - 1 do
      Result := Result + KDT35DDPow(v2[i] - v1[i]);
end;

procedure TKDT35DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT35DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT35DD.Test;
var
  TKDT35DD_Test    : TKDT35DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT35DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT35DD_Test := TKDT35DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT35DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT35DD_Test.TestBuff) - 1 do
    for j := 0 to KDT35DD_Axis - 1 do
        TKDT35DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT35DD_Test.TestBuff), length(TKDT35DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT35DD_Test.BuildKDTreeM(length(TKDT35DD_Test.TestBuff), nil, @TKDT35DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT35DD_Test.BuildKDTreeM(length(TKDT35DD_Test.TestBuff), nil, TKDT35DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT35DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT35DD_Test.TestBuff));
  TKDT35DD_Test.Search(TKDT35DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT35DDDistance(TKDT35DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT35DD_Test.Clear;
  { kMean test }
  TKDT35DD_Test.BuildKDTreeWithCluster(TKDT35DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT35DD_Test.Search(TKDT35DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT35DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT35DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT35DD_Test);
end;


function TKDT36DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DD_Node;
  function SortCompare(const p1, p2: PKDT36DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT36DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT36DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT36DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT36DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT36DD.GetData(const index: NativeInt): PKDT36DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT36DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT36DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT36DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT36DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT36DD.StoreBuffPtr: PKDT36DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT36DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT36DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT36DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT36DD.BuildKDTreeWithCluster(const inBuff: TKDT36DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT36DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT36DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT36DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT36DD.BuildKDTreeWithCluster(const inBuff: TKDT36DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DD_BuildCall);
var
  TempStoreBuff: TKDT36DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT36DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT36DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT36DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DD_BuildMethod);
var
  TempStoreBuff: TKDT36DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT36DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT36DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT36DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT36DD_BuildProc);
var
  TempStoreBuff: TKDT36DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT36DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT36DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT36DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT36DD.Search(const Buff: TKDT36DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DD_Node;

var
  NearestNeighbour: PKDT36DD_Node;

  function FindParentNode(const BuffPtr: PKDT36DD_Vec; NodePtr: PKDT36DD_Node): PKDT36DD_Node;
  var
    Next       : PKDT36DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT36DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT36DD_Node; const BuffPtr: PKDT36DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT36DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT36DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT36DD_Vec; const p1, p2: PKDT36DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT36DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT36DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT36DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT36DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT36DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT36DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT36DD_Node(NearestNodes[0]);
    end;
end;

function TKDT36DD.Search(const Buff: TKDT36DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT36DD.Search(const Buff: TKDT36DD_Vec; var SearchedDistanceMin: Double): PKDT36DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT36DD.Search(const Buff: TKDT36DD_Vec): PKDT36DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT36DD.Search(const inBuff: TKDT36DD_DynamicVecBuffer; var OutBuff: TKDT36DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT36DD_DynamicVecBuffer;
  outBuffPtr : PKDT36DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT36DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT36DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT36DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT36DD.Search(const inBuff: TKDT36DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT36DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT36DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT36DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT36DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT36DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT36DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT36DD_Source));
end;

procedure TKDT36DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT36DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT36DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT36DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT36DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT36DD.PrintNodeTree(const NodePtr: PKDT36DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT36DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT36DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT36DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT36DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT36DD.KDT36DDVec(const s: SystemString): TKDT36DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT36DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT36DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT36DD.KDT36DDVec(const v: TKDT36DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT36DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT36DD.KDT36DDPow(const v: TKDT36DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT36DD.KDT36DDDistance(const v1, v2: TKDT36DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT36DD_Axis - 1 do
      Result := Result + KDT36DDPow(v2[i] - v1[i]);
end;

procedure TKDT36DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT36DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT36DD.Test;
var
  TKDT36DD_Test    : TKDT36DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT36DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT36DD_Test := TKDT36DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT36DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT36DD_Test.TestBuff) - 1 do
    for j := 0 to KDT36DD_Axis - 1 do
        TKDT36DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT36DD_Test.TestBuff), length(TKDT36DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT36DD_Test.BuildKDTreeM(length(TKDT36DD_Test.TestBuff), nil, @TKDT36DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT36DD_Test.BuildKDTreeM(length(TKDT36DD_Test.TestBuff), nil, TKDT36DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT36DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT36DD_Test.TestBuff));
  TKDT36DD_Test.Search(TKDT36DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT36DDDistance(TKDT36DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT36DD_Test.Clear;
  { kMean test }
  TKDT36DD_Test.BuildKDTreeWithCluster(TKDT36DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT36DD_Test.Search(TKDT36DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT36DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT36DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT36DD_Test);
end;


function TKDT37DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT37DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT37DD_Node;
  function SortCompare(const p1, p2: PKDT37DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT37DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT37DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT37DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT37DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT37DD.GetData(const index: NativeInt): PKDT37DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT37DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT37DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT37DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT37DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT37DD.StoreBuffPtr: PKDT37DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT37DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT37DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT37DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT37DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT37DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT37DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT37DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT37DD.BuildKDTreeWithCluster(const inBuff: TKDT37DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT37DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT37DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT37DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT37DD.BuildKDTreeWithCluster(const inBuff: TKDT37DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT37DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DD_BuildCall);
var
  TempStoreBuff: TKDT37DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT37DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT37DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT37DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT37DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT37DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DD_BuildMethod);
var
  TempStoreBuff: TKDT37DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT37DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT37DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT37DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT37DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT37DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT37DD_BuildProc);
var
  TempStoreBuff: TKDT37DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT37DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT37DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT37DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT37DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT37DD.Search(const Buff: TKDT37DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT37DD_Node;

var
  NearestNeighbour: PKDT37DD_Node;

  function FindParentNode(const BuffPtr: PKDT37DD_Vec; NodePtr: PKDT37DD_Node): PKDT37DD_Node;
  var
    Next       : PKDT37DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT37DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT37DD_Node; const BuffPtr: PKDT37DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT37DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT37DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT37DD_Vec; const p1, p2: PKDT37DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT37DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT37DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT37DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT37DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT37DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT37DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT37DD_Node(NearestNodes[0]);
    end;
end;

function TKDT37DD.Search(const Buff: TKDT37DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT37DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT37DD.Search(const Buff: TKDT37DD_Vec; var SearchedDistanceMin: Double): PKDT37DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT37DD.Search(const Buff: TKDT37DD_Vec): PKDT37DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT37DD.Search(const inBuff: TKDT37DD_DynamicVecBuffer; var OutBuff: TKDT37DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT37DD_DynamicVecBuffer;
  outBuffPtr : PKDT37DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT37DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT37DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT37DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT37DD.Search(const inBuff: TKDT37DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT37DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT37DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT37DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT37DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT37DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT37DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT37DD_Source));
end;

procedure TKDT37DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT37DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT37DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT37DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT37DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT37DD.PrintNodeTree(const NodePtr: PKDT37DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT37DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT37DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT37DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT37DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT37DD.KDT37DDVec(const s: SystemString): TKDT37DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT37DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT37DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT37DD.KDT37DDVec(const v: TKDT37DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT37DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT37DD.KDT37DDPow(const v: TKDT37DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT37DD.KDT37DDDistance(const v1, v2: TKDT37DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT37DD_Axis - 1 do
      Result := Result + KDT37DDPow(v2[i] - v1[i]);
end;

procedure TKDT37DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT37DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT37DD.Test;
var
  TKDT37DD_Test    : TKDT37DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT37DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT37DD_Test := TKDT37DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT37DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT37DD_Test.TestBuff) - 1 do
    for j := 0 to KDT37DD_Axis - 1 do
        TKDT37DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT37DD_Test.TestBuff), length(TKDT37DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT37DD_Test.BuildKDTreeM(length(TKDT37DD_Test.TestBuff), nil, @TKDT37DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT37DD_Test.BuildKDTreeM(length(TKDT37DD_Test.TestBuff), nil, TKDT37DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT37DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT37DD_Test.TestBuff));
  TKDT37DD_Test.Search(TKDT37DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT37DDDistance(TKDT37DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT37DD_Test.Clear;
  { kMean test }
  TKDT37DD_Test.BuildKDTreeWithCluster(TKDT37DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT37DD_Test.Search(TKDT37DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT37DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT37DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT37DD_Test);
end;


function TKDT38DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT38DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT38DD_Node;
  function SortCompare(const p1, p2: PKDT38DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT38DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT38DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT38DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT38DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT38DD.GetData(const index: NativeInt): PKDT38DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT38DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT38DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT38DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT38DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT38DD.StoreBuffPtr: PKDT38DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT38DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT38DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT38DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT38DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT38DD.BuildKDTreeWithCluster(const inBuff: TKDT38DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT38DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT38DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT38DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT38DD.BuildKDTreeWithCluster(const inBuff: TKDT38DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT38DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DD_BuildCall);
var
  TempStoreBuff: TKDT38DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT38DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT38DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT38DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT38DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DD_BuildMethod);
var
  TempStoreBuff: TKDT38DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT38DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT38DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT38DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT38DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT38DD_BuildProc);
var
  TempStoreBuff: TKDT38DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT38DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT38DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT38DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT38DD.Search(const Buff: TKDT38DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT38DD_Node;

var
  NearestNeighbour: PKDT38DD_Node;

  function FindParentNode(const BuffPtr: PKDT38DD_Vec; NodePtr: PKDT38DD_Node): PKDT38DD_Node;
  var
    Next       : PKDT38DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT38DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT38DD_Node; const BuffPtr: PKDT38DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT38DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT38DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT38DD_Vec; const p1, p2: PKDT38DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT38DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT38DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT38DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT38DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT38DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT38DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT38DD_Node(NearestNodes[0]);
    end;
end;

function TKDT38DD.Search(const Buff: TKDT38DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT38DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT38DD.Search(const Buff: TKDT38DD_Vec; var SearchedDistanceMin: Double): PKDT38DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT38DD.Search(const Buff: TKDT38DD_Vec): PKDT38DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT38DD.Search(const inBuff: TKDT38DD_DynamicVecBuffer; var OutBuff: TKDT38DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT38DD_DynamicVecBuffer;
  outBuffPtr : PKDT38DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT38DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT38DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT38DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT38DD.Search(const inBuff: TKDT38DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT38DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT38DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT38DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT38DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT38DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT38DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT38DD_Source));
end;

procedure TKDT38DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT38DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT38DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT38DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT38DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT38DD.PrintNodeTree(const NodePtr: PKDT38DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT38DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT38DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT38DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT38DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT38DD.KDT38DDVec(const s: SystemString): TKDT38DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT38DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT38DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT38DD.KDT38DDVec(const v: TKDT38DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT38DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT38DD.KDT38DDPow(const v: TKDT38DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT38DD.KDT38DDDistance(const v1, v2: TKDT38DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT38DD_Axis - 1 do
      Result := Result + KDT38DDPow(v2[i] - v1[i]);
end;

procedure TKDT38DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT38DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT38DD.Test;
var
  TKDT38DD_Test    : TKDT38DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT38DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT38DD_Test := TKDT38DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT38DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT38DD_Test.TestBuff) - 1 do
    for j := 0 to KDT38DD_Axis - 1 do
        TKDT38DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT38DD_Test.TestBuff), length(TKDT38DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT38DD_Test.BuildKDTreeM(length(TKDT38DD_Test.TestBuff), nil, @TKDT38DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT38DD_Test.BuildKDTreeM(length(TKDT38DD_Test.TestBuff), nil, TKDT38DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT38DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT38DD_Test.TestBuff));
  TKDT38DD_Test.Search(TKDT38DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT38DDDistance(TKDT38DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT38DD_Test.Clear;
  { kMean test }
  TKDT38DD_Test.BuildKDTreeWithCluster(TKDT38DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT38DD_Test.Search(TKDT38DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT38DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT38DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT38DD_Test);
end;


function TKDT39DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT39DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT39DD_Node;
  function SortCompare(const p1, p2: PKDT39DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT39DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT39DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT39DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT39DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT39DD.GetData(const index: NativeInt): PKDT39DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT39DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT39DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT39DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT39DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT39DD.StoreBuffPtr: PKDT39DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT39DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT39DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT39DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT39DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT39DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT39DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT39DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT39DD.BuildKDTreeWithCluster(const inBuff: TKDT39DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT39DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT39DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT39DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT39DD.BuildKDTreeWithCluster(const inBuff: TKDT39DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT39DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DD_BuildCall);
var
  TempStoreBuff: TKDT39DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT39DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT39DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT39DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT39DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT39DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DD_BuildMethod);
var
  TempStoreBuff: TKDT39DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT39DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT39DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT39DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT39DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT39DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT39DD_BuildProc);
var
  TempStoreBuff: TKDT39DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT39DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT39DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT39DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT39DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT39DD.Search(const Buff: TKDT39DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT39DD_Node;

var
  NearestNeighbour: PKDT39DD_Node;

  function FindParentNode(const BuffPtr: PKDT39DD_Vec; NodePtr: PKDT39DD_Node): PKDT39DD_Node;
  var
    Next       : PKDT39DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT39DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT39DD_Node; const BuffPtr: PKDT39DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT39DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT39DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT39DD_Vec; const p1, p2: PKDT39DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT39DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT39DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT39DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT39DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT39DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT39DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT39DD_Node(NearestNodes[0]);
    end;
end;

function TKDT39DD.Search(const Buff: TKDT39DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT39DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT39DD.Search(const Buff: TKDT39DD_Vec; var SearchedDistanceMin: Double): PKDT39DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT39DD.Search(const Buff: TKDT39DD_Vec): PKDT39DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT39DD.Search(const inBuff: TKDT39DD_DynamicVecBuffer; var OutBuff: TKDT39DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT39DD_DynamicVecBuffer;
  outBuffPtr : PKDT39DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT39DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT39DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT39DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT39DD.Search(const inBuff: TKDT39DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT39DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT39DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT39DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT39DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT39DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT39DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT39DD_Source));
end;

procedure TKDT39DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT39DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT39DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT39DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT39DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT39DD.PrintNodeTree(const NodePtr: PKDT39DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT39DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT39DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT39DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT39DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT39DD.KDT39DDVec(const s: SystemString): TKDT39DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT39DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT39DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT39DD.KDT39DDVec(const v: TKDT39DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT39DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT39DD.KDT39DDPow(const v: TKDT39DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT39DD.KDT39DDDistance(const v1, v2: TKDT39DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT39DD_Axis - 1 do
      Result := Result + KDT39DDPow(v2[i] - v1[i]);
end;

procedure TKDT39DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT39DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT39DD.Test;
var
  TKDT39DD_Test    : TKDT39DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT39DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT39DD_Test := TKDT39DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT39DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT39DD_Test.TestBuff) - 1 do
    for j := 0 to KDT39DD_Axis - 1 do
        TKDT39DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT39DD_Test.TestBuff), length(TKDT39DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT39DD_Test.BuildKDTreeM(length(TKDT39DD_Test.TestBuff), nil, @TKDT39DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT39DD_Test.BuildKDTreeM(length(TKDT39DD_Test.TestBuff), nil, TKDT39DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT39DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT39DD_Test.TestBuff));
  TKDT39DD_Test.Search(TKDT39DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT39DDDistance(TKDT39DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT39DD_Test.Clear;
  { kMean test }
  TKDT39DD_Test.BuildKDTreeWithCluster(TKDT39DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT39DD_Test.Search(TKDT39DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT39DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT39DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT39DD_Test);
end;


function TKDT40DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DD_Node;
  function SortCompare(const p1, p2: PKDT40DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT40DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT40DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT40DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT40DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT40DD.GetData(const index: NativeInt): PKDT40DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT40DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT40DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT40DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT40DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT40DD.StoreBuffPtr: PKDT40DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT40DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT40DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT40DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT40DD.BuildKDTreeWithCluster(const inBuff: TKDT40DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT40DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT40DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT40DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT40DD.BuildKDTreeWithCluster(const inBuff: TKDT40DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DD_BuildCall);
var
  TempStoreBuff: TKDT40DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT40DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT40DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT40DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DD_BuildMethod);
var
  TempStoreBuff: TKDT40DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT40DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT40DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT40DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT40DD_BuildProc);
var
  TempStoreBuff: TKDT40DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT40DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT40DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT40DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT40DD.Search(const Buff: TKDT40DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DD_Node;

var
  NearestNeighbour: PKDT40DD_Node;

  function FindParentNode(const BuffPtr: PKDT40DD_Vec; NodePtr: PKDT40DD_Node): PKDT40DD_Node;
  var
    Next       : PKDT40DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT40DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT40DD_Node; const BuffPtr: PKDT40DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT40DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT40DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT40DD_Vec; const p1, p2: PKDT40DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT40DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT40DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT40DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT40DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT40DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT40DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT40DD_Node(NearestNodes[0]);
    end;
end;

function TKDT40DD.Search(const Buff: TKDT40DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT40DD.Search(const Buff: TKDT40DD_Vec; var SearchedDistanceMin: Double): PKDT40DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT40DD.Search(const Buff: TKDT40DD_Vec): PKDT40DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT40DD.Search(const inBuff: TKDT40DD_DynamicVecBuffer; var OutBuff: TKDT40DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT40DD_DynamicVecBuffer;
  outBuffPtr : PKDT40DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT40DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT40DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT40DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT40DD.Search(const inBuff: TKDT40DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT40DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT40DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT40DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT40DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT40DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT40DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT40DD_Source));
end;

procedure TKDT40DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT40DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT40DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT40DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT40DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT40DD.PrintNodeTree(const NodePtr: PKDT40DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT40DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT40DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT40DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT40DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT40DD.KDT40DDVec(const s: SystemString): TKDT40DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT40DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT40DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT40DD.KDT40DDVec(const v: TKDT40DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT40DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT40DD.KDT40DDPow(const v: TKDT40DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT40DD.KDT40DDDistance(const v1, v2: TKDT40DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT40DD_Axis - 1 do
      Result := Result + KDT40DDPow(v2[i] - v1[i]);
end;

procedure TKDT40DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT40DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT40DD.Test;
var
  TKDT40DD_Test    : TKDT40DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT40DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT40DD_Test := TKDT40DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT40DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT40DD_Test.TestBuff) - 1 do
    for j := 0 to KDT40DD_Axis - 1 do
        TKDT40DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT40DD_Test.TestBuff), length(TKDT40DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT40DD_Test.BuildKDTreeM(length(TKDT40DD_Test.TestBuff), nil, @TKDT40DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT40DD_Test.BuildKDTreeM(length(TKDT40DD_Test.TestBuff), nil, TKDT40DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT40DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT40DD_Test.TestBuff));
  TKDT40DD_Test.Search(TKDT40DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT40DDDistance(TKDT40DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT40DD_Test.Clear;
  { kMean test }
  TKDT40DD_Test.BuildKDTreeWithCluster(TKDT40DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT40DD_Test.Search(TKDT40DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT40DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT40DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT40DD_Test);
end;


function TKDT41DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT41DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT41DD_Node;
  function SortCompare(const p1, p2: PKDT41DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT41DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT41DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT41DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT41DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT41DD.GetData(const index: NativeInt): PKDT41DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT41DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT41DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT41DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT41DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT41DD.StoreBuffPtr: PKDT41DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT41DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT41DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT41DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT41DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT41DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT41DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT41DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT41DD.BuildKDTreeWithCluster(const inBuff: TKDT41DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT41DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT41DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT41DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT41DD.BuildKDTreeWithCluster(const inBuff: TKDT41DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT41DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DD_BuildCall);
var
  TempStoreBuff: TKDT41DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT41DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT41DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT41DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT41DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT41DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DD_BuildMethod);
var
  TempStoreBuff: TKDT41DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT41DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT41DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT41DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT41DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT41DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT41DD_BuildProc);
var
  TempStoreBuff: TKDT41DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT41DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT41DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT41DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT41DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT41DD.Search(const Buff: TKDT41DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT41DD_Node;

var
  NearestNeighbour: PKDT41DD_Node;

  function FindParentNode(const BuffPtr: PKDT41DD_Vec; NodePtr: PKDT41DD_Node): PKDT41DD_Node;
  var
    Next       : PKDT41DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT41DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT41DD_Node; const BuffPtr: PKDT41DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT41DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT41DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT41DD_Vec; const p1, p2: PKDT41DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT41DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT41DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT41DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT41DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT41DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT41DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT41DD_Node(NearestNodes[0]);
    end;
end;

function TKDT41DD.Search(const Buff: TKDT41DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT41DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT41DD.Search(const Buff: TKDT41DD_Vec; var SearchedDistanceMin: Double): PKDT41DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT41DD.Search(const Buff: TKDT41DD_Vec): PKDT41DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT41DD.Search(const inBuff: TKDT41DD_DynamicVecBuffer; var OutBuff: TKDT41DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT41DD_DynamicVecBuffer;
  outBuffPtr : PKDT41DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT41DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT41DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT41DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT41DD.Search(const inBuff: TKDT41DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT41DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT41DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT41DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT41DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT41DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT41DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT41DD_Source));
end;

procedure TKDT41DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT41DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT41DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT41DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT41DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT41DD.PrintNodeTree(const NodePtr: PKDT41DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT41DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT41DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT41DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT41DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT41DD.KDT41DDVec(const s: SystemString): TKDT41DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT41DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT41DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT41DD.KDT41DDVec(const v: TKDT41DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT41DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT41DD.KDT41DDPow(const v: TKDT41DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT41DD.KDT41DDDistance(const v1, v2: TKDT41DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT41DD_Axis - 1 do
      Result := Result + KDT41DDPow(v2[i] - v1[i]);
end;

procedure TKDT41DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT41DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT41DD.Test;
var
  TKDT41DD_Test    : TKDT41DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT41DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT41DD_Test := TKDT41DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT41DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT41DD_Test.TestBuff) - 1 do
    for j := 0 to KDT41DD_Axis - 1 do
        TKDT41DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT41DD_Test.TestBuff), length(TKDT41DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT41DD_Test.BuildKDTreeM(length(TKDT41DD_Test.TestBuff), nil, @TKDT41DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT41DD_Test.BuildKDTreeM(length(TKDT41DD_Test.TestBuff), nil, TKDT41DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT41DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT41DD_Test.TestBuff));
  TKDT41DD_Test.Search(TKDT41DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT41DDDistance(TKDT41DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT41DD_Test.Clear;
  { kMean test }
  TKDT41DD_Test.BuildKDTreeWithCluster(TKDT41DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT41DD_Test.Search(TKDT41DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT41DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT41DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT41DD_Test);
end;


function TKDT42DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT42DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT42DD_Node;
  function SortCompare(const p1, p2: PKDT42DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT42DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT42DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT42DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT42DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT42DD.GetData(const index: NativeInt): PKDT42DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT42DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT42DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT42DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT42DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT42DD.StoreBuffPtr: PKDT42DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT42DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT42DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT42DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT42DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT42DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT42DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT42DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT42DD.BuildKDTreeWithCluster(const inBuff: TKDT42DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT42DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT42DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT42DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT42DD.BuildKDTreeWithCluster(const inBuff: TKDT42DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT42DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DD_BuildCall);
var
  TempStoreBuff: TKDT42DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT42DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT42DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT42DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT42DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT42DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DD_BuildMethod);
var
  TempStoreBuff: TKDT42DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT42DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT42DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT42DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT42DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT42DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT42DD_BuildProc);
var
  TempStoreBuff: TKDT42DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT42DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT42DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT42DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT42DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT42DD.Search(const Buff: TKDT42DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT42DD_Node;

var
  NearestNeighbour: PKDT42DD_Node;

  function FindParentNode(const BuffPtr: PKDT42DD_Vec; NodePtr: PKDT42DD_Node): PKDT42DD_Node;
  var
    Next       : PKDT42DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT42DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT42DD_Node; const BuffPtr: PKDT42DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT42DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT42DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT42DD_Vec; const p1, p2: PKDT42DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT42DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT42DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT42DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT42DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT42DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT42DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT42DD_Node(NearestNodes[0]);
    end;
end;

function TKDT42DD.Search(const Buff: TKDT42DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT42DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT42DD.Search(const Buff: TKDT42DD_Vec; var SearchedDistanceMin: Double): PKDT42DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT42DD.Search(const Buff: TKDT42DD_Vec): PKDT42DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT42DD.Search(const inBuff: TKDT42DD_DynamicVecBuffer; var OutBuff: TKDT42DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT42DD_DynamicVecBuffer;
  outBuffPtr : PKDT42DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT42DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT42DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT42DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT42DD.Search(const inBuff: TKDT42DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT42DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT42DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT42DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT42DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT42DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT42DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT42DD_Source));
end;

procedure TKDT42DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT42DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT42DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT42DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT42DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT42DD.PrintNodeTree(const NodePtr: PKDT42DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT42DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT42DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT42DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT42DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT42DD.KDT42DDVec(const s: SystemString): TKDT42DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT42DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT42DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT42DD.KDT42DDVec(const v: TKDT42DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT42DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT42DD.KDT42DDPow(const v: TKDT42DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT42DD.KDT42DDDistance(const v1, v2: TKDT42DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT42DD_Axis - 1 do
      Result := Result + KDT42DDPow(v2[i] - v1[i]);
end;

procedure TKDT42DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT42DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT42DD.Test;
var
  TKDT42DD_Test    : TKDT42DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT42DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT42DD_Test := TKDT42DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT42DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT42DD_Test.TestBuff) - 1 do
    for j := 0 to KDT42DD_Axis - 1 do
        TKDT42DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT42DD_Test.TestBuff), length(TKDT42DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT42DD_Test.BuildKDTreeM(length(TKDT42DD_Test.TestBuff), nil, @TKDT42DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT42DD_Test.BuildKDTreeM(length(TKDT42DD_Test.TestBuff), nil, TKDT42DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT42DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT42DD_Test.TestBuff));
  TKDT42DD_Test.Search(TKDT42DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT42DDDistance(TKDT42DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT42DD_Test.Clear;
  { kMean test }
  TKDT42DD_Test.BuildKDTreeWithCluster(TKDT42DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT42DD_Test.Search(TKDT42DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT42DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT42DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT42DD_Test);
end;


function TKDT43DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT43DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT43DD_Node;
  function SortCompare(const p1, p2: PKDT43DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT43DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT43DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT43DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT43DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT43DD.GetData(const index: NativeInt): PKDT43DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT43DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT43DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT43DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT43DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT43DD.StoreBuffPtr: PKDT43DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT43DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT43DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT43DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT43DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT43DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT43DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT43DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT43DD.BuildKDTreeWithCluster(const inBuff: TKDT43DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT43DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT43DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT43DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT43DD.BuildKDTreeWithCluster(const inBuff: TKDT43DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT43DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DD_BuildCall);
var
  TempStoreBuff: TKDT43DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT43DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT43DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT43DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT43DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT43DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DD_BuildMethod);
var
  TempStoreBuff: TKDT43DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT43DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT43DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT43DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT43DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT43DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT43DD_BuildProc);
var
  TempStoreBuff: TKDT43DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT43DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT43DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT43DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT43DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT43DD.Search(const Buff: TKDT43DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT43DD_Node;

var
  NearestNeighbour: PKDT43DD_Node;

  function FindParentNode(const BuffPtr: PKDT43DD_Vec; NodePtr: PKDT43DD_Node): PKDT43DD_Node;
  var
    Next       : PKDT43DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT43DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT43DD_Node; const BuffPtr: PKDT43DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT43DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT43DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT43DD_Vec; const p1, p2: PKDT43DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT43DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT43DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT43DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT43DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT43DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT43DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT43DD_Node(NearestNodes[0]);
    end;
end;

function TKDT43DD.Search(const Buff: TKDT43DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT43DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT43DD.Search(const Buff: TKDT43DD_Vec; var SearchedDistanceMin: Double): PKDT43DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT43DD.Search(const Buff: TKDT43DD_Vec): PKDT43DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT43DD.Search(const inBuff: TKDT43DD_DynamicVecBuffer; var OutBuff: TKDT43DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT43DD_DynamicVecBuffer;
  outBuffPtr : PKDT43DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT43DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT43DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT43DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT43DD.Search(const inBuff: TKDT43DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT43DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT43DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT43DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT43DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT43DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT43DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT43DD_Source));
end;

procedure TKDT43DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT43DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT43DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT43DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT43DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT43DD.PrintNodeTree(const NodePtr: PKDT43DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT43DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT43DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT43DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT43DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT43DD.KDT43DDVec(const s: SystemString): TKDT43DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT43DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT43DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT43DD.KDT43DDVec(const v: TKDT43DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT43DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT43DD.KDT43DDPow(const v: TKDT43DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT43DD.KDT43DDDistance(const v1, v2: TKDT43DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT43DD_Axis - 1 do
      Result := Result + KDT43DDPow(v2[i] - v1[i]);
end;

procedure TKDT43DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT43DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT43DD.Test;
var
  TKDT43DD_Test    : TKDT43DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT43DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT43DD_Test := TKDT43DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT43DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT43DD_Test.TestBuff) - 1 do
    for j := 0 to KDT43DD_Axis - 1 do
        TKDT43DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT43DD_Test.TestBuff), length(TKDT43DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT43DD_Test.BuildKDTreeM(length(TKDT43DD_Test.TestBuff), nil, @TKDT43DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT43DD_Test.BuildKDTreeM(length(TKDT43DD_Test.TestBuff), nil, TKDT43DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT43DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT43DD_Test.TestBuff));
  TKDT43DD_Test.Search(TKDT43DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT43DDDistance(TKDT43DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT43DD_Test.Clear;
  { kMean test }
  TKDT43DD_Test.BuildKDTreeWithCluster(TKDT43DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT43DD_Test.Search(TKDT43DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT43DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT43DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT43DD_Test);
end;


function TKDT44DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT44DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT44DD_Node;
  function SortCompare(const p1, p2: PKDT44DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT44DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT44DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT44DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT44DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT44DD.GetData(const index: NativeInt): PKDT44DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT44DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT44DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT44DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT44DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT44DD.StoreBuffPtr: PKDT44DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT44DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT44DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT44DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT44DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT44DD.BuildKDTreeWithCluster(const inBuff: TKDT44DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT44DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT44DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT44DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT44DD.BuildKDTreeWithCluster(const inBuff: TKDT44DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT44DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DD_BuildCall);
var
  TempStoreBuff: TKDT44DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT44DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT44DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT44DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT44DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DD_BuildMethod);
var
  TempStoreBuff: TKDT44DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT44DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT44DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT44DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT44DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT44DD_BuildProc);
var
  TempStoreBuff: TKDT44DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT44DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT44DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT44DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT44DD.Search(const Buff: TKDT44DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT44DD_Node;

var
  NearestNeighbour: PKDT44DD_Node;

  function FindParentNode(const BuffPtr: PKDT44DD_Vec; NodePtr: PKDT44DD_Node): PKDT44DD_Node;
  var
    Next       : PKDT44DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT44DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT44DD_Node; const BuffPtr: PKDT44DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT44DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT44DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT44DD_Vec; const p1, p2: PKDT44DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT44DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT44DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT44DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT44DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT44DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT44DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT44DD_Node(NearestNodes[0]);
    end;
end;

function TKDT44DD.Search(const Buff: TKDT44DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT44DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT44DD.Search(const Buff: TKDT44DD_Vec; var SearchedDistanceMin: Double): PKDT44DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT44DD.Search(const Buff: TKDT44DD_Vec): PKDT44DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT44DD.Search(const inBuff: TKDT44DD_DynamicVecBuffer; var OutBuff: TKDT44DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT44DD_DynamicVecBuffer;
  outBuffPtr : PKDT44DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT44DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT44DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT44DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT44DD.Search(const inBuff: TKDT44DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT44DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT44DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT44DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT44DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT44DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT44DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT44DD_Source));
end;

procedure TKDT44DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT44DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT44DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT44DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT44DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT44DD.PrintNodeTree(const NodePtr: PKDT44DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT44DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT44DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT44DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT44DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT44DD.KDT44DDVec(const s: SystemString): TKDT44DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT44DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT44DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT44DD.KDT44DDVec(const v: TKDT44DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT44DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT44DD.KDT44DDPow(const v: TKDT44DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT44DD.KDT44DDDistance(const v1, v2: TKDT44DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT44DD_Axis - 1 do
      Result := Result + KDT44DDPow(v2[i] - v1[i]);
end;

procedure TKDT44DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT44DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT44DD.Test;
var
  TKDT44DD_Test    : TKDT44DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT44DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT44DD_Test := TKDT44DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT44DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT44DD_Test.TestBuff) - 1 do
    for j := 0 to KDT44DD_Axis - 1 do
        TKDT44DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT44DD_Test.TestBuff), length(TKDT44DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT44DD_Test.BuildKDTreeM(length(TKDT44DD_Test.TestBuff), nil, @TKDT44DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT44DD_Test.BuildKDTreeM(length(TKDT44DD_Test.TestBuff), nil, TKDT44DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT44DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT44DD_Test.TestBuff));
  TKDT44DD_Test.Search(TKDT44DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT44DDDistance(TKDT44DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT44DD_Test.Clear;
  { kMean test }
  TKDT44DD_Test.BuildKDTreeWithCluster(TKDT44DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT44DD_Test.Search(TKDT44DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT44DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT44DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT44DD_Test);
end;


function TKDT45DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT45DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT45DD_Node;
  function SortCompare(const p1, p2: PKDT45DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT45DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT45DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT45DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT45DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT45DD.GetData(const index: NativeInt): PKDT45DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT45DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT45DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT45DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT45DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT45DD.StoreBuffPtr: PKDT45DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT45DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT45DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT45DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT45DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT45DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT45DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT45DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT45DD.BuildKDTreeWithCluster(const inBuff: TKDT45DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT45DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT45DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT45DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT45DD.BuildKDTreeWithCluster(const inBuff: TKDT45DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT45DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DD_BuildCall);
var
  TempStoreBuff: TKDT45DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT45DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT45DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT45DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT45DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT45DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DD_BuildMethod);
var
  TempStoreBuff: TKDT45DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT45DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT45DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT45DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT45DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT45DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT45DD_BuildProc);
var
  TempStoreBuff: TKDT45DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT45DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT45DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT45DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT45DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT45DD.Search(const Buff: TKDT45DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT45DD_Node;

var
  NearestNeighbour: PKDT45DD_Node;

  function FindParentNode(const BuffPtr: PKDT45DD_Vec; NodePtr: PKDT45DD_Node): PKDT45DD_Node;
  var
    Next       : PKDT45DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT45DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT45DD_Node; const BuffPtr: PKDT45DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT45DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT45DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT45DD_Vec; const p1, p2: PKDT45DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT45DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT45DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT45DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT45DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT45DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT45DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT45DD_Node(NearestNodes[0]);
    end;
end;

function TKDT45DD.Search(const Buff: TKDT45DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT45DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT45DD.Search(const Buff: TKDT45DD_Vec; var SearchedDistanceMin: Double): PKDT45DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT45DD.Search(const Buff: TKDT45DD_Vec): PKDT45DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT45DD.Search(const inBuff: TKDT45DD_DynamicVecBuffer; var OutBuff: TKDT45DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT45DD_DynamicVecBuffer;
  outBuffPtr : PKDT45DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT45DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT45DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT45DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT45DD.Search(const inBuff: TKDT45DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT45DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT45DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT45DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT45DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT45DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT45DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT45DD_Source));
end;

procedure TKDT45DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT45DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT45DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT45DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT45DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT45DD.PrintNodeTree(const NodePtr: PKDT45DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT45DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT45DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT45DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT45DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT45DD.KDT45DDVec(const s: SystemString): TKDT45DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT45DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT45DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT45DD.KDT45DDVec(const v: TKDT45DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT45DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT45DD.KDT45DDPow(const v: TKDT45DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT45DD.KDT45DDDistance(const v1, v2: TKDT45DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT45DD_Axis - 1 do
      Result := Result + KDT45DDPow(v2[i] - v1[i]);
end;

procedure TKDT45DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT45DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT45DD.Test;
var
  TKDT45DD_Test    : TKDT45DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT45DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT45DD_Test := TKDT45DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT45DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT45DD_Test.TestBuff) - 1 do
    for j := 0 to KDT45DD_Axis - 1 do
        TKDT45DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT45DD_Test.TestBuff), length(TKDT45DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT45DD_Test.BuildKDTreeM(length(TKDT45DD_Test.TestBuff), nil, @TKDT45DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT45DD_Test.BuildKDTreeM(length(TKDT45DD_Test.TestBuff), nil, TKDT45DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT45DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT45DD_Test.TestBuff));
  TKDT45DD_Test.Search(TKDT45DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT45DDDistance(TKDT45DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT45DD_Test.Clear;
  { kMean test }
  TKDT45DD_Test.BuildKDTreeWithCluster(TKDT45DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT45DD_Test.Search(TKDT45DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT45DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT45DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT45DD_Test);
end;


function TKDT46DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT46DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT46DD_Node;
  function SortCompare(const p1, p2: PKDT46DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT46DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT46DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT46DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT46DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT46DD.GetData(const index: NativeInt): PKDT46DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT46DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT46DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT46DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT46DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT46DD.StoreBuffPtr: PKDT46DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT46DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT46DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT46DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT46DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT46DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT46DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT46DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT46DD.BuildKDTreeWithCluster(const inBuff: TKDT46DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT46DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT46DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT46DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT46DD.BuildKDTreeWithCluster(const inBuff: TKDT46DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT46DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DD_BuildCall);
var
  TempStoreBuff: TKDT46DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT46DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT46DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT46DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT46DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT46DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DD_BuildMethod);
var
  TempStoreBuff: TKDT46DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT46DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT46DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT46DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT46DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT46DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT46DD_BuildProc);
var
  TempStoreBuff: TKDT46DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT46DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT46DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT46DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT46DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT46DD.Search(const Buff: TKDT46DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT46DD_Node;

var
  NearestNeighbour: PKDT46DD_Node;

  function FindParentNode(const BuffPtr: PKDT46DD_Vec; NodePtr: PKDT46DD_Node): PKDT46DD_Node;
  var
    Next       : PKDT46DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT46DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT46DD_Node; const BuffPtr: PKDT46DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT46DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT46DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT46DD_Vec; const p1, p2: PKDT46DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT46DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT46DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT46DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT46DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT46DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT46DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT46DD_Node(NearestNodes[0]);
    end;
end;

function TKDT46DD.Search(const Buff: TKDT46DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT46DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT46DD.Search(const Buff: TKDT46DD_Vec; var SearchedDistanceMin: Double): PKDT46DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT46DD.Search(const Buff: TKDT46DD_Vec): PKDT46DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT46DD.Search(const inBuff: TKDT46DD_DynamicVecBuffer; var OutBuff: TKDT46DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT46DD_DynamicVecBuffer;
  outBuffPtr : PKDT46DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT46DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT46DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT46DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT46DD.Search(const inBuff: TKDT46DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT46DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT46DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT46DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT46DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT46DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT46DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT46DD_Source));
end;

procedure TKDT46DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT46DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT46DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT46DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT46DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT46DD.PrintNodeTree(const NodePtr: PKDT46DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT46DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT46DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT46DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT46DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT46DD.KDT46DDVec(const s: SystemString): TKDT46DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT46DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT46DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT46DD.KDT46DDVec(const v: TKDT46DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT46DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT46DD.KDT46DDPow(const v: TKDT46DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT46DD.KDT46DDDistance(const v1, v2: TKDT46DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT46DD_Axis - 1 do
      Result := Result + KDT46DDPow(v2[i] - v1[i]);
end;

procedure TKDT46DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT46DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT46DD.Test;
var
  TKDT46DD_Test    : TKDT46DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT46DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT46DD_Test := TKDT46DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT46DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT46DD_Test.TestBuff) - 1 do
    for j := 0 to KDT46DD_Axis - 1 do
        TKDT46DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT46DD_Test.TestBuff), length(TKDT46DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT46DD_Test.BuildKDTreeM(length(TKDT46DD_Test.TestBuff), nil, @TKDT46DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT46DD_Test.BuildKDTreeM(length(TKDT46DD_Test.TestBuff), nil, TKDT46DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT46DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT46DD_Test.TestBuff));
  TKDT46DD_Test.Search(TKDT46DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT46DDDistance(TKDT46DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT46DD_Test.Clear;
  { kMean test }
  TKDT46DD_Test.BuildKDTreeWithCluster(TKDT46DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT46DD_Test.Search(TKDT46DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT46DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT46DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT46DD_Test);
end;


function TKDT47DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT47DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT47DD_Node;
  function SortCompare(const p1, p2: PKDT47DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT47DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT47DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT47DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT47DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT47DD.GetData(const index: NativeInt): PKDT47DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT47DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT47DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT47DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT47DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT47DD.StoreBuffPtr: PKDT47DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT47DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT47DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT47DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT47DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT47DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT47DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT47DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT47DD.BuildKDTreeWithCluster(const inBuff: TKDT47DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT47DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT47DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT47DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT47DD.BuildKDTreeWithCluster(const inBuff: TKDT47DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT47DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DD_BuildCall);
var
  TempStoreBuff: TKDT47DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT47DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT47DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT47DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT47DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT47DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DD_BuildMethod);
var
  TempStoreBuff: TKDT47DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT47DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT47DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT47DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT47DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT47DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT47DD_BuildProc);
var
  TempStoreBuff: TKDT47DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT47DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT47DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT47DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT47DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT47DD.Search(const Buff: TKDT47DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT47DD_Node;

var
  NearestNeighbour: PKDT47DD_Node;

  function FindParentNode(const BuffPtr: PKDT47DD_Vec; NodePtr: PKDT47DD_Node): PKDT47DD_Node;
  var
    Next       : PKDT47DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT47DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT47DD_Node; const BuffPtr: PKDT47DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT47DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT47DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT47DD_Vec; const p1, p2: PKDT47DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT47DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT47DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT47DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT47DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT47DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT47DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT47DD_Node(NearestNodes[0]);
    end;
end;

function TKDT47DD.Search(const Buff: TKDT47DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT47DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT47DD.Search(const Buff: TKDT47DD_Vec; var SearchedDistanceMin: Double): PKDT47DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT47DD.Search(const Buff: TKDT47DD_Vec): PKDT47DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT47DD.Search(const inBuff: TKDT47DD_DynamicVecBuffer; var OutBuff: TKDT47DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT47DD_DynamicVecBuffer;
  outBuffPtr : PKDT47DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT47DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT47DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT47DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT47DD.Search(const inBuff: TKDT47DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT47DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT47DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT47DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT47DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT47DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT47DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT47DD_Source));
end;

procedure TKDT47DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT47DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT47DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT47DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT47DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT47DD.PrintNodeTree(const NodePtr: PKDT47DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT47DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT47DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT47DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT47DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT47DD.KDT47DDVec(const s: SystemString): TKDT47DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT47DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT47DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT47DD.KDT47DDVec(const v: TKDT47DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT47DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT47DD.KDT47DDPow(const v: TKDT47DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT47DD.KDT47DDDistance(const v1, v2: TKDT47DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT47DD_Axis - 1 do
      Result := Result + KDT47DDPow(v2[i] - v1[i]);
end;

procedure TKDT47DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT47DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT47DD.Test;
var
  TKDT47DD_Test    : TKDT47DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT47DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT47DD_Test := TKDT47DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT47DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT47DD_Test.TestBuff) - 1 do
    for j := 0 to KDT47DD_Axis - 1 do
        TKDT47DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT47DD_Test.TestBuff), length(TKDT47DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT47DD_Test.BuildKDTreeM(length(TKDT47DD_Test.TestBuff), nil, @TKDT47DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT47DD_Test.BuildKDTreeM(length(TKDT47DD_Test.TestBuff), nil, TKDT47DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT47DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT47DD_Test.TestBuff));
  TKDT47DD_Test.Search(TKDT47DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT47DDDistance(TKDT47DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT47DD_Test.Clear;
  { kMean test }
  TKDT47DD_Test.BuildKDTreeWithCluster(TKDT47DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT47DD_Test.Search(TKDT47DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT47DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT47DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT47DD_Test);
end;


function TKDT48DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DD_Node;
  function SortCompare(const p1, p2: PKDT48DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT48DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT48DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT48DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT48DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT48DD.GetData(const index: NativeInt): PKDT48DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT48DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT48DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT48DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT48DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT48DD.StoreBuffPtr: PKDT48DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT48DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT48DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT48DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT48DD.BuildKDTreeWithCluster(const inBuff: TKDT48DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT48DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT48DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT48DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT48DD.BuildKDTreeWithCluster(const inBuff: TKDT48DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DD_BuildCall);
var
  TempStoreBuff: TKDT48DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT48DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DD_BuildMethod);
var
  TempStoreBuff: TKDT48DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT48DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT48DD_BuildProc);
var
  TempStoreBuff: TKDT48DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT48DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT48DD.Search(const Buff: TKDT48DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DD_Node;

var
  NearestNeighbour: PKDT48DD_Node;

  function FindParentNode(const BuffPtr: PKDT48DD_Vec; NodePtr: PKDT48DD_Node): PKDT48DD_Node;
  var
    Next       : PKDT48DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT48DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT48DD_Node; const BuffPtr: PKDT48DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT48DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT48DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT48DD_Vec; const p1, p2: PKDT48DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT48DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT48DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT48DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT48DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT48DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT48DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT48DD_Node(NearestNodes[0]);
    end;
end;

function TKDT48DD.Search(const Buff: TKDT48DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT48DD.Search(const Buff: TKDT48DD_Vec; var SearchedDistanceMin: Double): PKDT48DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT48DD.Search(const Buff: TKDT48DD_Vec): PKDT48DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT48DD.Search(const inBuff: TKDT48DD_DynamicVecBuffer; var OutBuff: TKDT48DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT48DD_DynamicVecBuffer;
  outBuffPtr : PKDT48DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT48DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT48DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DD.Search(const inBuff: TKDT48DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT48DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT48DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT48DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT48DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT48DD_Source));
end;

procedure TKDT48DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT48DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT48DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT48DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DD.PrintNodeTree(const NodePtr: PKDT48DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT48DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT48DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT48DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT48DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT48DD.KDT48DDVec(const s: SystemString): TKDT48DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT48DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT48DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT48DD.KDT48DDVec(const v: TKDT48DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT48DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT48DD.KDT48DDPow(const v: TKDT48DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT48DD.KDT48DDDistance(const v1, v2: TKDT48DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT48DD_Axis - 1 do
      Result := Result + KDT48DDPow(v2[i] - v1[i]);
end;

procedure TKDT48DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT48DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT48DD.Test;
var
  TKDT48DD_Test    : TKDT48DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT48DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT48DD_Test := TKDT48DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT48DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT48DD_Test.TestBuff) - 1 do
    for j := 0 to KDT48DD_Axis - 1 do
        TKDT48DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT48DD_Test.TestBuff), length(TKDT48DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT48DD_Test.BuildKDTreeM(length(TKDT48DD_Test.TestBuff), nil, @TKDT48DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT48DD_Test.BuildKDTreeM(length(TKDT48DD_Test.TestBuff), nil, TKDT48DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT48DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT48DD_Test.TestBuff));
  TKDT48DD_Test.Search(TKDT48DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT48DDDistance(TKDT48DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT48DD_Test.Clear;
  { kMean test }
  TKDT48DD_Test.BuildKDTreeWithCluster(TKDT48DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT48DD_Test.Search(TKDT48DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT48DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT48DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT48DD_Test);
end;


function TKDT49DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT49DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT49DD_Node;
  function SortCompare(const p1, p2: PKDT49DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT49DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT49DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT49DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT49DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT49DD.GetData(const index: NativeInt): PKDT49DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT49DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT49DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT49DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT49DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT49DD.StoreBuffPtr: PKDT49DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT49DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT49DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT49DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT49DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT49DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT49DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT49DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT49DD.BuildKDTreeWithCluster(const inBuff: TKDT49DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT49DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT49DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT49DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT49DD.BuildKDTreeWithCluster(const inBuff: TKDT49DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT49DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DD_BuildCall);
var
  TempStoreBuff: TKDT49DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT49DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT49DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT49DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT49DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT49DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DD_BuildMethod);
var
  TempStoreBuff: TKDT49DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT49DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT49DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT49DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT49DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT49DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT49DD_BuildProc);
var
  TempStoreBuff: TKDT49DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT49DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT49DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT49DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT49DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT49DD.Search(const Buff: TKDT49DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT49DD_Node;

var
  NearestNeighbour: PKDT49DD_Node;

  function FindParentNode(const BuffPtr: PKDT49DD_Vec; NodePtr: PKDT49DD_Node): PKDT49DD_Node;
  var
    Next       : PKDT49DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT49DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT49DD_Node; const BuffPtr: PKDT49DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT49DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT49DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT49DD_Vec; const p1, p2: PKDT49DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT49DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT49DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT49DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT49DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT49DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT49DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT49DD_Node(NearestNodes[0]);
    end;
end;

function TKDT49DD.Search(const Buff: TKDT49DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT49DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT49DD.Search(const Buff: TKDT49DD_Vec; var SearchedDistanceMin: Double): PKDT49DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT49DD.Search(const Buff: TKDT49DD_Vec): PKDT49DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT49DD.Search(const inBuff: TKDT49DD_DynamicVecBuffer; var OutBuff: TKDT49DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT49DD_DynamicVecBuffer;
  outBuffPtr : PKDT49DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT49DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT49DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT49DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT49DD.Search(const inBuff: TKDT49DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT49DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT49DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT49DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT49DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT49DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT49DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT49DD_Source));
end;

procedure TKDT49DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT49DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT49DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT49DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT49DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT49DD.PrintNodeTree(const NodePtr: PKDT49DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT49DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT49DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT49DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT49DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT49DD.KDT49DDVec(const s: SystemString): TKDT49DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT49DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT49DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT49DD.KDT49DDVec(const v: TKDT49DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT49DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT49DD.KDT49DDPow(const v: TKDT49DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT49DD.KDT49DDDistance(const v1, v2: TKDT49DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT49DD_Axis - 1 do
      Result := Result + KDT49DDPow(v2[i] - v1[i]);
end;

procedure TKDT49DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT49DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT49DD.Test;
var
  TKDT49DD_Test    : TKDT49DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT49DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT49DD_Test := TKDT49DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT49DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT49DD_Test.TestBuff) - 1 do
    for j := 0 to KDT49DD_Axis - 1 do
        TKDT49DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT49DD_Test.TestBuff), length(TKDT49DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT49DD_Test.BuildKDTreeM(length(TKDT49DD_Test.TestBuff), nil, @TKDT49DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT49DD_Test.BuildKDTreeM(length(TKDT49DD_Test.TestBuff), nil, TKDT49DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT49DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT49DD_Test.TestBuff));
  TKDT49DD_Test.Search(TKDT49DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT49DDDistance(TKDT49DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT49DD_Test.Clear;
  { kMean test }
  TKDT49DD_Test.BuildKDTreeWithCluster(TKDT49DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT49DD_Test.Search(TKDT49DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT49DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT49DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT49DD_Test);
end;


function TKDT50DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT50DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT50DD_Node;
  function SortCompare(const p1, p2: PKDT50DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT50DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT50DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT50DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT50DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT50DD.GetData(const index: NativeInt): PKDT50DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT50DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT50DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT50DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT50DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT50DD.StoreBuffPtr: PKDT50DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT50DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT50DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT50DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT50DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT50DD.BuildKDTreeWithCluster(const inBuff: TKDT50DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT50DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT50DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT50DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT50DD.BuildKDTreeWithCluster(const inBuff: TKDT50DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT50DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DD_BuildCall);
var
  TempStoreBuff: TKDT50DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT50DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT50DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT50DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT50DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DD_BuildMethod);
var
  TempStoreBuff: TKDT50DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT50DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT50DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT50DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT50DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT50DD_BuildProc);
var
  TempStoreBuff: TKDT50DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT50DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT50DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT50DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT50DD.Search(const Buff: TKDT50DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT50DD_Node;

var
  NearestNeighbour: PKDT50DD_Node;

  function FindParentNode(const BuffPtr: PKDT50DD_Vec; NodePtr: PKDT50DD_Node): PKDT50DD_Node;
  var
    Next       : PKDT50DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT50DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT50DD_Node; const BuffPtr: PKDT50DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT50DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT50DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT50DD_Vec; const p1, p2: PKDT50DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT50DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT50DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT50DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT50DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT50DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT50DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT50DD_Node(NearestNodes[0]);
    end;
end;

function TKDT50DD.Search(const Buff: TKDT50DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT50DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT50DD.Search(const Buff: TKDT50DD_Vec; var SearchedDistanceMin: Double): PKDT50DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT50DD.Search(const Buff: TKDT50DD_Vec): PKDT50DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT50DD.Search(const inBuff: TKDT50DD_DynamicVecBuffer; var OutBuff: TKDT50DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT50DD_DynamicVecBuffer;
  outBuffPtr : PKDT50DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT50DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT50DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT50DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT50DD.Search(const inBuff: TKDT50DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT50DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT50DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT50DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT50DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT50DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT50DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT50DD_Source));
end;

procedure TKDT50DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT50DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT50DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT50DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT50DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT50DD.PrintNodeTree(const NodePtr: PKDT50DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT50DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT50DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT50DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT50DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT50DD.KDT50DDVec(const s: SystemString): TKDT50DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT50DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT50DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT50DD.KDT50DDVec(const v: TKDT50DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT50DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT50DD.KDT50DDPow(const v: TKDT50DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT50DD.KDT50DDDistance(const v1, v2: TKDT50DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT50DD_Axis - 1 do
      Result := Result + KDT50DDPow(v2[i] - v1[i]);
end;

procedure TKDT50DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT50DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT50DD.Test;
var
  TKDT50DD_Test    : TKDT50DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT50DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT50DD_Test := TKDT50DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT50DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT50DD_Test.TestBuff) - 1 do
    for j := 0 to KDT50DD_Axis - 1 do
        TKDT50DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT50DD_Test.TestBuff), length(TKDT50DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT50DD_Test.BuildKDTreeM(length(TKDT50DD_Test.TestBuff), nil, @TKDT50DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT50DD_Test.BuildKDTreeM(length(TKDT50DD_Test.TestBuff), nil, TKDT50DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT50DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT50DD_Test.TestBuff));
  TKDT50DD_Test.Search(TKDT50DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT50DDDistance(TKDT50DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT50DD_Test.Clear;
  { kMean test }
  TKDT50DD_Test.BuildKDTreeWithCluster(TKDT50DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT50DD_Test.Search(TKDT50DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT50DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT50DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT50DD_Test);
end;


function TKDT51DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT51DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT51DD_Node;
  function SortCompare(const p1, p2: PKDT51DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT51DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT51DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT51DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT51DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT51DD.GetData(const index: NativeInt): PKDT51DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT51DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT51DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT51DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT51DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT51DD.StoreBuffPtr: PKDT51DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT51DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT51DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT51DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT51DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT51DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT51DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT51DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT51DD.BuildKDTreeWithCluster(const inBuff: TKDT51DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT51DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT51DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT51DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT51DD.BuildKDTreeWithCluster(const inBuff: TKDT51DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT51DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DD_BuildCall);
var
  TempStoreBuff: TKDT51DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT51DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT51DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT51DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT51DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT51DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DD_BuildMethod);
var
  TempStoreBuff: TKDT51DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT51DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT51DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT51DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT51DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT51DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT51DD_BuildProc);
var
  TempStoreBuff: TKDT51DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT51DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT51DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT51DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT51DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT51DD.Search(const Buff: TKDT51DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT51DD_Node;

var
  NearestNeighbour: PKDT51DD_Node;

  function FindParentNode(const BuffPtr: PKDT51DD_Vec; NodePtr: PKDT51DD_Node): PKDT51DD_Node;
  var
    Next       : PKDT51DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT51DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT51DD_Node; const BuffPtr: PKDT51DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT51DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT51DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT51DD_Vec; const p1, p2: PKDT51DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT51DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT51DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT51DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT51DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT51DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT51DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT51DD_Node(NearestNodes[0]);
    end;
end;

function TKDT51DD.Search(const Buff: TKDT51DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT51DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT51DD.Search(const Buff: TKDT51DD_Vec; var SearchedDistanceMin: Double): PKDT51DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT51DD.Search(const Buff: TKDT51DD_Vec): PKDT51DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT51DD.Search(const inBuff: TKDT51DD_DynamicVecBuffer; var OutBuff: TKDT51DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT51DD_DynamicVecBuffer;
  outBuffPtr : PKDT51DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT51DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT51DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT51DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT51DD.Search(const inBuff: TKDT51DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT51DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT51DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT51DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT51DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT51DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT51DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT51DD_Source));
end;

procedure TKDT51DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT51DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT51DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT51DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT51DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT51DD.PrintNodeTree(const NodePtr: PKDT51DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT51DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT51DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT51DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT51DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT51DD.KDT51DDVec(const s: SystemString): TKDT51DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT51DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT51DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT51DD.KDT51DDVec(const v: TKDT51DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT51DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT51DD.KDT51DDPow(const v: TKDT51DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT51DD.KDT51DDDistance(const v1, v2: TKDT51DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT51DD_Axis - 1 do
      Result := Result + KDT51DDPow(v2[i] - v1[i]);
end;

procedure TKDT51DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT51DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT51DD.Test;
var
  TKDT51DD_Test    : TKDT51DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT51DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT51DD_Test := TKDT51DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT51DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT51DD_Test.TestBuff) - 1 do
    for j := 0 to KDT51DD_Axis - 1 do
        TKDT51DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT51DD_Test.TestBuff), length(TKDT51DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT51DD_Test.BuildKDTreeM(length(TKDT51DD_Test.TestBuff), nil, @TKDT51DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT51DD_Test.BuildKDTreeM(length(TKDT51DD_Test.TestBuff), nil, TKDT51DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT51DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT51DD_Test.TestBuff));
  TKDT51DD_Test.Search(TKDT51DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT51DDDistance(TKDT51DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT51DD_Test.Clear;
  { kMean test }
  TKDT51DD_Test.BuildKDTreeWithCluster(TKDT51DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT51DD_Test.Search(TKDT51DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT51DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT51DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT51DD_Test);
end;


function TKDT52DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT52DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT52DD_Node;
  function SortCompare(const p1, p2: PKDT52DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT52DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT52DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT52DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT52DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT52DD.GetData(const index: NativeInt): PKDT52DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT52DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT52DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT52DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT52DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT52DD.StoreBuffPtr: PKDT52DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT52DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT52DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT52DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT52DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT52DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT52DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT52DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT52DD.BuildKDTreeWithCluster(const inBuff: TKDT52DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT52DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT52DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT52DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT52DD.BuildKDTreeWithCluster(const inBuff: TKDT52DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT52DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DD_BuildCall);
var
  TempStoreBuff: TKDT52DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT52DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT52DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT52DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DD_BuildMethod);
var
  TempStoreBuff: TKDT52DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT52DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT52DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT52DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT52DD_BuildProc);
var
  TempStoreBuff: TKDT52DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT52DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT52DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT52DD.Search(const Buff: TKDT52DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT52DD_Node;

var
  NearestNeighbour: PKDT52DD_Node;

  function FindParentNode(const BuffPtr: PKDT52DD_Vec; NodePtr: PKDT52DD_Node): PKDT52DD_Node;
  var
    Next       : PKDT52DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT52DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT52DD_Node; const BuffPtr: PKDT52DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT52DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT52DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT52DD_Vec; const p1, p2: PKDT52DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT52DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT52DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT52DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT52DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT52DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT52DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT52DD_Node(NearestNodes[0]);
    end;
end;

function TKDT52DD.Search(const Buff: TKDT52DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT52DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT52DD.Search(const Buff: TKDT52DD_Vec; var SearchedDistanceMin: Double): PKDT52DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT52DD.Search(const Buff: TKDT52DD_Vec): PKDT52DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT52DD.Search(const inBuff: TKDT52DD_DynamicVecBuffer; var OutBuff: TKDT52DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT52DD_DynamicVecBuffer;
  outBuffPtr : PKDT52DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT52DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT52DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT52DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT52DD.Search(const inBuff: TKDT52DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT52DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT52DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT52DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT52DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT52DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT52DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT52DD_Source));
end;

procedure TKDT52DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT52DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT52DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT52DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT52DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT52DD.PrintNodeTree(const NodePtr: PKDT52DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT52DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT52DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT52DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT52DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT52DD.KDT52DDVec(const s: SystemString): TKDT52DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT52DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT52DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT52DD.KDT52DDVec(const v: TKDT52DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT52DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT52DD.KDT52DDPow(const v: TKDT52DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT52DD.KDT52DDDistance(const v1, v2: TKDT52DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT52DD_Axis - 1 do
      Result := Result + KDT52DDPow(v2[i] - v1[i]);
end;

procedure TKDT52DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT52DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT52DD.Test;
var
  TKDT52DD_Test    : TKDT52DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT52DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT52DD_Test := TKDT52DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT52DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT52DD_Test.TestBuff) - 1 do
    for j := 0 to KDT52DD_Axis - 1 do
        TKDT52DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT52DD_Test.TestBuff), length(TKDT52DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT52DD_Test.BuildKDTreeM(length(TKDT52DD_Test.TestBuff), nil, @TKDT52DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT52DD_Test.BuildKDTreeM(length(TKDT52DD_Test.TestBuff), nil, TKDT52DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT52DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT52DD_Test.TestBuff));
  TKDT52DD_Test.Search(TKDT52DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT52DDDistance(TKDT52DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT52DD_Test.Clear;
  { kMean test }
  TKDT52DD_Test.BuildKDTreeWithCluster(TKDT52DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT52DD_Test.Search(TKDT52DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT52DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT52DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT52DD_Test);
end;


function TKDT53DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT53DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT53DD_Node;
  function SortCompare(const p1, p2: PKDT53DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT53DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT53DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT53DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT53DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT53DD.GetData(const index: NativeInt): PKDT53DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT53DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT53DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT53DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT53DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT53DD.StoreBuffPtr: PKDT53DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT53DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT53DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT53DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT53DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT53DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT53DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT53DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT53DD.BuildKDTreeWithCluster(const inBuff: TKDT53DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT53DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT53DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT53DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT53DD.BuildKDTreeWithCluster(const inBuff: TKDT53DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT53DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DD_BuildCall);
var
  TempStoreBuff: TKDT53DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT53DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT53DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT53DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT53DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT53DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DD_BuildMethod);
var
  TempStoreBuff: TKDT53DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT53DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT53DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT53DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT53DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT53DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT53DD_BuildProc);
var
  TempStoreBuff: TKDT53DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT53DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT53DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT53DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT53DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT53DD.Search(const Buff: TKDT53DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT53DD_Node;

var
  NearestNeighbour: PKDT53DD_Node;

  function FindParentNode(const BuffPtr: PKDT53DD_Vec; NodePtr: PKDT53DD_Node): PKDT53DD_Node;
  var
    Next       : PKDT53DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT53DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT53DD_Node; const BuffPtr: PKDT53DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT53DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT53DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT53DD_Vec; const p1, p2: PKDT53DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT53DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT53DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT53DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT53DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT53DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT53DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT53DD_Node(NearestNodes[0]);
    end;
end;

function TKDT53DD.Search(const Buff: TKDT53DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT53DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT53DD.Search(const Buff: TKDT53DD_Vec; var SearchedDistanceMin: Double): PKDT53DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT53DD.Search(const Buff: TKDT53DD_Vec): PKDT53DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT53DD.Search(const inBuff: TKDT53DD_DynamicVecBuffer; var OutBuff: TKDT53DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT53DD_DynamicVecBuffer;
  outBuffPtr : PKDT53DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT53DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT53DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT53DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT53DD.Search(const inBuff: TKDT53DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT53DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT53DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT53DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT53DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT53DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT53DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT53DD_Source));
end;

procedure TKDT53DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT53DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT53DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT53DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT53DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT53DD.PrintNodeTree(const NodePtr: PKDT53DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT53DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT53DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT53DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT53DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT53DD.KDT53DDVec(const s: SystemString): TKDT53DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT53DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT53DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT53DD.KDT53DDVec(const v: TKDT53DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT53DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT53DD.KDT53DDPow(const v: TKDT53DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT53DD.KDT53DDDistance(const v1, v2: TKDT53DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT53DD_Axis - 1 do
      Result := Result + KDT53DDPow(v2[i] - v1[i]);
end;

procedure TKDT53DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT53DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT53DD.Test;
var
  TKDT53DD_Test    : TKDT53DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT53DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT53DD_Test := TKDT53DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT53DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT53DD_Test.TestBuff) - 1 do
    for j := 0 to KDT53DD_Axis - 1 do
        TKDT53DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT53DD_Test.TestBuff), length(TKDT53DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT53DD_Test.BuildKDTreeM(length(TKDT53DD_Test.TestBuff), nil, @TKDT53DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT53DD_Test.BuildKDTreeM(length(TKDT53DD_Test.TestBuff), nil, TKDT53DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT53DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT53DD_Test.TestBuff));
  TKDT53DD_Test.Search(TKDT53DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT53DDDistance(TKDT53DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT53DD_Test.Clear;
  { kMean test }
  TKDT53DD_Test.BuildKDTreeWithCluster(TKDT53DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT53DD_Test.Search(TKDT53DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT53DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT53DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT53DD_Test);
end;


function TKDT54DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT54DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT54DD_Node;
  function SortCompare(const p1, p2: PKDT54DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT54DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT54DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT54DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT54DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT54DD.GetData(const index: NativeInt): PKDT54DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT54DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT54DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT54DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT54DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT54DD.StoreBuffPtr: PKDT54DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT54DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT54DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT54DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT54DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT54DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT54DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT54DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT54DD.BuildKDTreeWithCluster(const inBuff: TKDT54DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT54DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT54DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT54DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT54DD.BuildKDTreeWithCluster(const inBuff: TKDT54DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT54DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DD_BuildCall);
var
  TempStoreBuff: TKDT54DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT54DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT54DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT54DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT54DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT54DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DD_BuildMethod);
var
  TempStoreBuff: TKDT54DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT54DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT54DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT54DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT54DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT54DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT54DD_BuildProc);
var
  TempStoreBuff: TKDT54DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT54DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT54DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT54DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT54DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT54DD.Search(const Buff: TKDT54DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT54DD_Node;

var
  NearestNeighbour: PKDT54DD_Node;

  function FindParentNode(const BuffPtr: PKDT54DD_Vec; NodePtr: PKDT54DD_Node): PKDT54DD_Node;
  var
    Next       : PKDT54DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT54DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT54DD_Node; const BuffPtr: PKDT54DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT54DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT54DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT54DD_Vec; const p1, p2: PKDT54DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT54DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT54DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT54DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT54DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT54DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT54DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT54DD_Node(NearestNodes[0]);
    end;
end;

function TKDT54DD.Search(const Buff: TKDT54DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT54DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT54DD.Search(const Buff: TKDT54DD_Vec; var SearchedDistanceMin: Double): PKDT54DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT54DD.Search(const Buff: TKDT54DD_Vec): PKDT54DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT54DD.Search(const inBuff: TKDT54DD_DynamicVecBuffer; var OutBuff: TKDT54DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT54DD_DynamicVecBuffer;
  outBuffPtr : PKDT54DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT54DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT54DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT54DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT54DD.Search(const inBuff: TKDT54DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT54DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT54DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT54DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT54DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT54DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT54DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT54DD_Source));
end;

procedure TKDT54DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT54DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT54DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT54DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT54DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT54DD.PrintNodeTree(const NodePtr: PKDT54DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT54DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT54DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT54DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT54DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT54DD.KDT54DDVec(const s: SystemString): TKDT54DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT54DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT54DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT54DD.KDT54DDVec(const v: TKDT54DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT54DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT54DD.KDT54DDPow(const v: TKDT54DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT54DD.KDT54DDDistance(const v1, v2: TKDT54DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT54DD_Axis - 1 do
      Result := Result + KDT54DDPow(v2[i] - v1[i]);
end;

procedure TKDT54DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT54DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT54DD.Test;
var
  TKDT54DD_Test    : TKDT54DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT54DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT54DD_Test := TKDT54DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT54DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT54DD_Test.TestBuff) - 1 do
    for j := 0 to KDT54DD_Axis - 1 do
        TKDT54DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT54DD_Test.TestBuff), length(TKDT54DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT54DD_Test.BuildKDTreeM(length(TKDT54DD_Test.TestBuff), nil, @TKDT54DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT54DD_Test.BuildKDTreeM(length(TKDT54DD_Test.TestBuff), nil, TKDT54DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT54DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT54DD_Test.TestBuff));
  TKDT54DD_Test.Search(TKDT54DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT54DDDistance(TKDT54DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT54DD_Test.Clear;
  { kMean test }
  TKDT54DD_Test.BuildKDTreeWithCluster(TKDT54DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT54DD_Test.Search(TKDT54DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT54DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT54DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT54DD_Test);
end;


function TKDT55DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT55DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT55DD_Node;
  function SortCompare(const p1, p2: PKDT55DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT55DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT55DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT55DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT55DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT55DD.GetData(const index: NativeInt): PKDT55DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT55DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT55DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT55DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT55DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT55DD.StoreBuffPtr: PKDT55DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT55DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT55DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT55DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT55DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT55DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT55DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT55DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT55DD.BuildKDTreeWithCluster(const inBuff: TKDT55DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT55DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT55DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT55DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT55DD.BuildKDTreeWithCluster(const inBuff: TKDT55DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT55DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DD_BuildCall);
var
  TempStoreBuff: TKDT55DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT55DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT55DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT55DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT55DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT55DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DD_BuildMethod);
var
  TempStoreBuff: TKDT55DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT55DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT55DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT55DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT55DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT55DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT55DD_BuildProc);
var
  TempStoreBuff: TKDT55DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT55DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT55DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT55DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT55DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT55DD.Search(const Buff: TKDT55DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT55DD_Node;

var
  NearestNeighbour: PKDT55DD_Node;

  function FindParentNode(const BuffPtr: PKDT55DD_Vec; NodePtr: PKDT55DD_Node): PKDT55DD_Node;
  var
    Next       : PKDT55DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT55DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT55DD_Node; const BuffPtr: PKDT55DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT55DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT55DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT55DD_Vec; const p1, p2: PKDT55DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT55DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT55DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT55DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT55DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT55DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT55DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT55DD_Node(NearestNodes[0]);
    end;
end;

function TKDT55DD.Search(const Buff: TKDT55DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT55DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT55DD.Search(const Buff: TKDT55DD_Vec; var SearchedDistanceMin: Double): PKDT55DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT55DD.Search(const Buff: TKDT55DD_Vec): PKDT55DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT55DD.Search(const inBuff: TKDT55DD_DynamicVecBuffer; var OutBuff: TKDT55DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT55DD_DynamicVecBuffer;
  outBuffPtr : PKDT55DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT55DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT55DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT55DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT55DD.Search(const inBuff: TKDT55DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT55DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT55DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT55DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT55DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT55DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT55DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT55DD_Source));
end;

procedure TKDT55DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT55DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT55DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT55DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT55DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT55DD.PrintNodeTree(const NodePtr: PKDT55DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT55DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT55DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT55DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT55DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT55DD.KDT55DDVec(const s: SystemString): TKDT55DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT55DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT55DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT55DD.KDT55DDVec(const v: TKDT55DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT55DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT55DD.KDT55DDPow(const v: TKDT55DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT55DD.KDT55DDDistance(const v1, v2: TKDT55DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT55DD_Axis - 1 do
      Result := Result + KDT55DDPow(v2[i] - v1[i]);
end;

procedure TKDT55DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT55DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT55DD.Test;
var
  TKDT55DD_Test    : TKDT55DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT55DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT55DD_Test := TKDT55DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT55DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT55DD_Test.TestBuff) - 1 do
    for j := 0 to KDT55DD_Axis - 1 do
        TKDT55DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT55DD_Test.TestBuff), length(TKDT55DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT55DD_Test.BuildKDTreeM(length(TKDT55DD_Test.TestBuff), nil, @TKDT55DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT55DD_Test.BuildKDTreeM(length(TKDT55DD_Test.TestBuff), nil, TKDT55DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT55DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT55DD_Test.TestBuff));
  TKDT55DD_Test.Search(TKDT55DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT55DDDistance(TKDT55DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT55DD_Test.Clear;
  { kMean test }
  TKDT55DD_Test.BuildKDTreeWithCluster(TKDT55DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT55DD_Test.Search(TKDT55DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT55DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT55DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT55DD_Test);
end;


function TKDT56DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT56DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT56DD_Node;
  function SortCompare(const p1, p2: PKDT56DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT56DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT56DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT56DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT56DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT56DD.GetData(const index: NativeInt): PKDT56DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT56DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT56DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT56DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT56DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT56DD.StoreBuffPtr: PKDT56DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT56DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT56DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT56DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT56DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT56DD.BuildKDTreeWithCluster(const inBuff: TKDT56DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT56DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT56DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT56DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT56DD.BuildKDTreeWithCluster(const inBuff: TKDT56DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT56DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DD_BuildCall);
var
  TempStoreBuff: TKDT56DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT56DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT56DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT56DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT56DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DD_BuildMethod);
var
  TempStoreBuff: TKDT56DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT56DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT56DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT56DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT56DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT56DD_BuildProc);
var
  TempStoreBuff: TKDT56DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT56DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT56DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT56DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT56DD.Search(const Buff: TKDT56DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT56DD_Node;

var
  NearestNeighbour: PKDT56DD_Node;

  function FindParentNode(const BuffPtr: PKDT56DD_Vec; NodePtr: PKDT56DD_Node): PKDT56DD_Node;
  var
    Next       : PKDT56DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT56DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT56DD_Node; const BuffPtr: PKDT56DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT56DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT56DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT56DD_Vec; const p1, p2: PKDT56DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT56DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT56DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT56DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT56DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT56DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT56DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT56DD_Node(NearestNodes[0]);
    end;
end;

function TKDT56DD.Search(const Buff: TKDT56DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT56DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT56DD.Search(const Buff: TKDT56DD_Vec; var SearchedDistanceMin: Double): PKDT56DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT56DD.Search(const Buff: TKDT56DD_Vec): PKDT56DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT56DD.Search(const inBuff: TKDT56DD_DynamicVecBuffer; var OutBuff: TKDT56DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT56DD_DynamicVecBuffer;
  outBuffPtr : PKDT56DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT56DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT56DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT56DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT56DD.Search(const inBuff: TKDT56DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT56DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT56DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT56DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT56DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT56DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT56DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT56DD_Source));
end;

procedure TKDT56DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT56DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT56DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT56DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT56DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT56DD.PrintNodeTree(const NodePtr: PKDT56DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT56DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT56DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT56DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT56DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT56DD.KDT56DDVec(const s: SystemString): TKDT56DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT56DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT56DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT56DD.KDT56DDVec(const v: TKDT56DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT56DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT56DD.KDT56DDPow(const v: TKDT56DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT56DD.KDT56DDDistance(const v1, v2: TKDT56DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT56DD_Axis - 1 do
      Result := Result + KDT56DDPow(v2[i] - v1[i]);
end;

procedure TKDT56DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT56DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT56DD.Test;
var
  TKDT56DD_Test    : TKDT56DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT56DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT56DD_Test := TKDT56DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT56DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT56DD_Test.TestBuff) - 1 do
    for j := 0 to KDT56DD_Axis - 1 do
        TKDT56DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT56DD_Test.TestBuff), length(TKDT56DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT56DD_Test.BuildKDTreeM(length(TKDT56DD_Test.TestBuff), nil, @TKDT56DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT56DD_Test.BuildKDTreeM(length(TKDT56DD_Test.TestBuff), nil, TKDT56DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT56DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT56DD_Test.TestBuff));
  TKDT56DD_Test.Search(TKDT56DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT56DDDistance(TKDT56DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT56DD_Test.Clear;
  { kMean test }
  TKDT56DD_Test.BuildKDTreeWithCluster(TKDT56DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT56DD_Test.Search(TKDT56DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT56DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT56DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT56DD_Test);
end;


function TKDT57DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT57DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT57DD_Node;
  function SortCompare(const p1, p2: PKDT57DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT57DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT57DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT57DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT57DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT57DD.GetData(const index: NativeInt): PKDT57DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT57DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT57DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT57DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT57DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT57DD.StoreBuffPtr: PKDT57DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT57DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT57DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT57DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT57DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT57DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT57DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT57DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT57DD.BuildKDTreeWithCluster(const inBuff: TKDT57DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT57DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT57DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT57DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT57DD.BuildKDTreeWithCluster(const inBuff: TKDT57DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT57DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DD_BuildCall);
var
  TempStoreBuff: TKDT57DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT57DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT57DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT57DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT57DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT57DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DD_BuildMethod);
var
  TempStoreBuff: TKDT57DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT57DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT57DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT57DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT57DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT57DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT57DD_BuildProc);
var
  TempStoreBuff: TKDT57DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT57DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT57DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT57DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT57DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT57DD.Search(const Buff: TKDT57DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT57DD_Node;

var
  NearestNeighbour: PKDT57DD_Node;

  function FindParentNode(const BuffPtr: PKDT57DD_Vec; NodePtr: PKDT57DD_Node): PKDT57DD_Node;
  var
    Next       : PKDT57DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT57DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT57DD_Node; const BuffPtr: PKDT57DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT57DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT57DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT57DD_Vec; const p1, p2: PKDT57DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT57DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT57DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT57DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT57DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT57DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT57DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT57DD_Node(NearestNodes[0]);
    end;
end;

function TKDT57DD.Search(const Buff: TKDT57DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT57DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT57DD.Search(const Buff: TKDT57DD_Vec; var SearchedDistanceMin: Double): PKDT57DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT57DD.Search(const Buff: TKDT57DD_Vec): PKDT57DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT57DD.Search(const inBuff: TKDT57DD_DynamicVecBuffer; var OutBuff: TKDT57DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT57DD_DynamicVecBuffer;
  outBuffPtr : PKDT57DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT57DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT57DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT57DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT57DD.Search(const inBuff: TKDT57DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT57DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT57DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT57DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT57DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT57DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT57DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT57DD_Source));
end;

procedure TKDT57DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT57DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT57DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT57DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT57DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT57DD.PrintNodeTree(const NodePtr: PKDT57DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT57DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT57DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT57DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT57DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT57DD.KDT57DDVec(const s: SystemString): TKDT57DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT57DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT57DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT57DD.KDT57DDVec(const v: TKDT57DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT57DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT57DD.KDT57DDPow(const v: TKDT57DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT57DD.KDT57DDDistance(const v1, v2: TKDT57DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT57DD_Axis - 1 do
      Result := Result + KDT57DDPow(v2[i] - v1[i]);
end;

procedure TKDT57DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT57DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT57DD.Test;
var
  TKDT57DD_Test    : TKDT57DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT57DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT57DD_Test := TKDT57DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT57DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT57DD_Test.TestBuff) - 1 do
    for j := 0 to KDT57DD_Axis - 1 do
        TKDT57DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT57DD_Test.TestBuff), length(TKDT57DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT57DD_Test.BuildKDTreeM(length(TKDT57DD_Test.TestBuff), nil, @TKDT57DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT57DD_Test.BuildKDTreeM(length(TKDT57DD_Test.TestBuff), nil, TKDT57DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT57DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT57DD_Test.TestBuff));
  TKDT57DD_Test.Search(TKDT57DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT57DDDistance(TKDT57DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT57DD_Test.Clear;
  { kMean test }
  TKDT57DD_Test.BuildKDTreeWithCluster(TKDT57DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT57DD_Test.Search(TKDT57DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT57DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT57DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT57DD_Test);
end;


function TKDT58DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT58DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT58DD_Node;
  function SortCompare(const p1, p2: PKDT58DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT58DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT58DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT58DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT58DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT58DD.GetData(const index: NativeInt): PKDT58DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT58DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT58DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT58DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT58DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT58DD.StoreBuffPtr: PKDT58DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT58DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT58DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT58DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT58DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT58DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT58DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT58DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT58DD.BuildKDTreeWithCluster(const inBuff: TKDT58DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT58DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT58DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT58DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT58DD.BuildKDTreeWithCluster(const inBuff: TKDT58DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT58DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DD_BuildCall);
var
  TempStoreBuff: TKDT58DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT58DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT58DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT58DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT58DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT58DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DD_BuildMethod);
var
  TempStoreBuff: TKDT58DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT58DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT58DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT58DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT58DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT58DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT58DD_BuildProc);
var
  TempStoreBuff: TKDT58DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT58DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT58DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT58DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT58DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT58DD.Search(const Buff: TKDT58DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT58DD_Node;

var
  NearestNeighbour: PKDT58DD_Node;

  function FindParentNode(const BuffPtr: PKDT58DD_Vec; NodePtr: PKDT58DD_Node): PKDT58DD_Node;
  var
    Next       : PKDT58DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT58DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT58DD_Node; const BuffPtr: PKDT58DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT58DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT58DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT58DD_Vec; const p1, p2: PKDT58DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT58DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT58DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT58DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT58DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT58DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT58DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT58DD_Node(NearestNodes[0]);
    end;
end;

function TKDT58DD.Search(const Buff: TKDT58DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT58DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT58DD.Search(const Buff: TKDT58DD_Vec; var SearchedDistanceMin: Double): PKDT58DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT58DD.Search(const Buff: TKDT58DD_Vec): PKDT58DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT58DD.Search(const inBuff: TKDT58DD_DynamicVecBuffer; var OutBuff: TKDT58DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT58DD_DynamicVecBuffer;
  outBuffPtr : PKDT58DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT58DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT58DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT58DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT58DD.Search(const inBuff: TKDT58DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT58DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT58DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT58DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT58DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT58DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT58DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT58DD_Source));
end;

procedure TKDT58DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT58DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT58DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT58DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT58DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT58DD.PrintNodeTree(const NodePtr: PKDT58DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT58DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT58DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT58DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT58DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT58DD.KDT58DDVec(const s: SystemString): TKDT58DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT58DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT58DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT58DD.KDT58DDVec(const v: TKDT58DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT58DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT58DD.KDT58DDPow(const v: TKDT58DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT58DD.KDT58DDDistance(const v1, v2: TKDT58DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT58DD_Axis - 1 do
      Result := Result + KDT58DDPow(v2[i] - v1[i]);
end;

procedure TKDT58DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT58DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT58DD.Test;
var
  TKDT58DD_Test    : TKDT58DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT58DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT58DD_Test := TKDT58DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT58DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT58DD_Test.TestBuff) - 1 do
    for j := 0 to KDT58DD_Axis - 1 do
        TKDT58DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT58DD_Test.TestBuff), length(TKDT58DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT58DD_Test.BuildKDTreeM(length(TKDT58DD_Test.TestBuff), nil, @TKDT58DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT58DD_Test.BuildKDTreeM(length(TKDT58DD_Test.TestBuff), nil, TKDT58DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT58DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT58DD_Test.TestBuff));
  TKDT58DD_Test.Search(TKDT58DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT58DDDistance(TKDT58DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT58DD_Test.Clear;
  { kMean test }
  TKDT58DD_Test.BuildKDTreeWithCluster(TKDT58DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT58DD_Test.Search(TKDT58DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT58DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT58DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT58DD_Test);
end;


function TKDT59DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT59DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT59DD_Node;
  function SortCompare(const p1, p2: PKDT59DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT59DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT59DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT59DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT59DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT59DD.GetData(const index: NativeInt): PKDT59DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT59DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT59DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT59DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT59DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT59DD.StoreBuffPtr: PKDT59DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT59DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT59DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT59DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT59DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT59DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT59DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT59DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT59DD.BuildKDTreeWithCluster(const inBuff: TKDT59DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT59DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT59DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT59DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT59DD.BuildKDTreeWithCluster(const inBuff: TKDT59DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT59DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DD_BuildCall);
var
  TempStoreBuff: TKDT59DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT59DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT59DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT59DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT59DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT59DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DD_BuildMethod);
var
  TempStoreBuff: TKDT59DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT59DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT59DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT59DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT59DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT59DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT59DD_BuildProc);
var
  TempStoreBuff: TKDT59DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT59DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT59DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT59DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT59DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT59DD.Search(const Buff: TKDT59DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT59DD_Node;

var
  NearestNeighbour: PKDT59DD_Node;

  function FindParentNode(const BuffPtr: PKDT59DD_Vec; NodePtr: PKDT59DD_Node): PKDT59DD_Node;
  var
    Next       : PKDT59DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT59DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT59DD_Node; const BuffPtr: PKDT59DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT59DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT59DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT59DD_Vec; const p1, p2: PKDT59DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT59DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT59DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT59DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT59DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT59DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT59DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT59DD_Node(NearestNodes[0]);
    end;
end;

function TKDT59DD.Search(const Buff: TKDT59DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT59DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT59DD.Search(const Buff: TKDT59DD_Vec; var SearchedDistanceMin: Double): PKDT59DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT59DD.Search(const Buff: TKDT59DD_Vec): PKDT59DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT59DD.Search(const inBuff: TKDT59DD_DynamicVecBuffer; var OutBuff: TKDT59DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT59DD_DynamicVecBuffer;
  outBuffPtr : PKDT59DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT59DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT59DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT59DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT59DD.Search(const inBuff: TKDT59DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT59DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT59DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT59DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT59DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT59DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT59DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT59DD_Source));
end;

procedure TKDT59DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT59DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT59DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT59DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT59DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT59DD.PrintNodeTree(const NodePtr: PKDT59DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT59DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT59DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT59DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT59DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT59DD.KDT59DDVec(const s: SystemString): TKDT59DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT59DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT59DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT59DD.KDT59DDVec(const v: TKDT59DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT59DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT59DD.KDT59DDPow(const v: TKDT59DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT59DD.KDT59DDDistance(const v1, v2: TKDT59DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT59DD_Axis - 1 do
      Result := Result + KDT59DDPow(v2[i] - v1[i]);
end;

procedure TKDT59DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT59DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT59DD.Test;
var
  TKDT59DD_Test    : TKDT59DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT59DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT59DD_Test := TKDT59DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT59DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT59DD_Test.TestBuff) - 1 do
    for j := 0 to KDT59DD_Axis - 1 do
        TKDT59DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT59DD_Test.TestBuff), length(TKDT59DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT59DD_Test.BuildKDTreeM(length(TKDT59DD_Test.TestBuff), nil, @TKDT59DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT59DD_Test.BuildKDTreeM(length(TKDT59DD_Test.TestBuff), nil, TKDT59DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT59DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT59DD_Test.TestBuff));
  TKDT59DD_Test.Search(TKDT59DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT59DDDistance(TKDT59DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT59DD_Test.Clear;
  { kMean test }
  TKDT59DD_Test.BuildKDTreeWithCluster(TKDT59DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT59DD_Test.Search(TKDT59DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT59DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT59DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT59DD_Test);
end;


function TKDT60DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT60DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT60DD_Node;
  function SortCompare(const p1, p2: PKDT60DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT60DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT60DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT60DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT60DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT60DD.GetData(const index: NativeInt): PKDT60DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT60DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT60DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT60DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT60DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT60DD.StoreBuffPtr: PKDT60DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT60DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT60DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT60DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT60DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT60DD.BuildKDTreeWithCluster(const inBuff: TKDT60DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT60DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT60DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT60DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT60DD.BuildKDTreeWithCluster(const inBuff: TKDT60DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT60DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DD_BuildCall);
var
  TempStoreBuff: TKDT60DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT60DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT60DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT60DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT60DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DD_BuildMethod);
var
  TempStoreBuff: TKDT60DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT60DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT60DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT60DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT60DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT60DD_BuildProc);
var
  TempStoreBuff: TKDT60DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT60DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT60DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT60DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT60DD.Search(const Buff: TKDT60DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT60DD_Node;

var
  NearestNeighbour: PKDT60DD_Node;

  function FindParentNode(const BuffPtr: PKDT60DD_Vec; NodePtr: PKDT60DD_Node): PKDT60DD_Node;
  var
    Next       : PKDT60DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT60DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT60DD_Node; const BuffPtr: PKDT60DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT60DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT60DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT60DD_Vec; const p1, p2: PKDT60DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT60DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT60DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT60DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT60DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT60DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT60DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT60DD_Node(NearestNodes[0]);
    end;
end;

function TKDT60DD.Search(const Buff: TKDT60DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT60DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT60DD.Search(const Buff: TKDT60DD_Vec; var SearchedDistanceMin: Double): PKDT60DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT60DD.Search(const Buff: TKDT60DD_Vec): PKDT60DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT60DD.Search(const inBuff: TKDT60DD_DynamicVecBuffer; var OutBuff: TKDT60DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT60DD_DynamicVecBuffer;
  outBuffPtr : PKDT60DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT60DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT60DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT60DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT60DD.Search(const inBuff: TKDT60DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT60DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT60DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT60DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT60DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT60DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT60DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT60DD_Source));
end;

procedure TKDT60DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT60DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT60DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT60DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT60DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT60DD.PrintNodeTree(const NodePtr: PKDT60DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT60DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT60DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT60DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT60DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT60DD.KDT60DDVec(const s: SystemString): TKDT60DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT60DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT60DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT60DD.KDT60DDVec(const v: TKDT60DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT60DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT60DD.KDT60DDPow(const v: TKDT60DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT60DD.KDT60DDDistance(const v1, v2: TKDT60DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT60DD_Axis - 1 do
      Result := Result + KDT60DDPow(v2[i] - v1[i]);
end;

procedure TKDT60DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT60DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT60DD.Test;
var
  TKDT60DD_Test    : TKDT60DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT60DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT60DD_Test := TKDT60DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT60DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT60DD_Test.TestBuff) - 1 do
    for j := 0 to KDT60DD_Axis - 1 do
        TKDT60DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT60DD_Test.TestBuff), length(TKDT60DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT60DD_Test.BuildKDTreeM(length(TKDT60DD_Test.TestBuff), nil, @TKDT60DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT60DD_Test.BuildKDTreeM(length(TKDT60DD_Test.TestBuff), nil, TKDT60DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT60DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT60DD_Test.TestBuff));
  TKDT60DD_Test.Search(TKDT60DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT60DDDistance(TKDT60DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT60DD_Test.Clear;
  { kMean test }
  TKDT60DD_Test.BuildKDTreeWithCluster(TKDT60DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT60DD_Test.Search(TKDT60DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT60DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT60DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT60DD_Test);
end;


function TKDT61DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT61DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT61DD_Node;
  function SortCompare(const p1, p2: PKDT61DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT61DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT61DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT61DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT61DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT61DD.GetData(const index: NativeInt): PKDT61DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT61DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT61DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT61DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT61DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT61DD.StoreBuffPtr: PKDT61DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT61DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT61DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT61DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT61DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT61DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT61DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT61DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT61DD.BuildKDTreeWithCluster(const inBuff: TKDT61DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT61DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT61DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT61DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT61DD.BuildKDTreeWithCluster(const inBuff: TKDT61DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT61DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DD_BuildCall);
var
  TempStoreBuff: TKDT61DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT61DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT61DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT61DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT61DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT61DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DD_BuildMethod);
var
  TempStoreBuff: TKDT61DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT61DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT61DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT61DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT61DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT61DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT61DD_BuildProc);
var
  TempStoreBuff: TKDT61DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT61DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT61DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT61DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT61DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT61DD.Search(const Buff: TKDT61DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT61DD_Node;

var
  NearestNeighbour: PKDT61DD_Node;

  function FindParentNode(const BuffPtr: PKDT61DD_Vec; NodePtr: PKDT61DD_Node): PKDT61DD_Node;
  var
    Next       : PKDT61DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT61DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT61DD_Node; const BuffPtr: PKDT61DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT61DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT61DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT61DD_Vec; const p1, p2: PKDT61DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT61DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT61DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT61DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT61DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT61DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT61DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT61DD_Node(NearestNodes[0]);
    end;
end;

function TKDT61DD.Search(const Buff: TKDT61DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT61DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT61DD.Search(const Buff: TKDT61DD_Vec; var SearchedDistanceMin: Double): PKDT61DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT61DD.Search(const Buff: TKDT61DD_Vec): PKDT61DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT61DD.Search(const inBuff: TKDT61DD_DynamicVecBuffer; var OutBuff: TKDT61DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT61DD_DynamicVecBuffer;
  outBuffPtr : PKDT61DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT61DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT61DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT61DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT61DD.Search(const inBuff: TKDT61DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT61DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT61DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT61DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT61DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT61DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT61DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT61DD_Source));
end;

procedure TKDT61DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT61DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT61DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT61DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT61DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT61DD.PrintNodeTree(const NodePtr: PKDT61DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT61DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT61DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT61DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT61DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT61DD.KDT61DDVec(const s: SystemString): TKDT61DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT61DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT61DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT61DD.KDT61DDVec(const v: TKDT61DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT61DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT61DD.KDT61DDPow(const v: TKDT61DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT61DD.KDT61DDDistance(const v1, v2: TKDT61DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT61DD_Axis - 1 do
      Result := Result + KDT61DDPow(v2[i] - v1[i]);
end;

procedure TKDT61DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT61DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT61DD.Test;
var
  TKDT61DD_Test    : TKDT61DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT61DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT61DD_Test := TKDT61DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT61DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT61DD_Test.TestBuff) - 1 do
    for j := 0 to KDT61DD_Axis - 1 do
        TKDT61DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT61DD_Test.TestBuff), length(TKDT61DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT61DD_Test.BuildKDTreeM(length(TKDT61DD_Test.TestBuff), nil, @TKDT61DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT61DD_Test.BuildKDTreeM(length(TKDT61DD_Test.TestBuff), nil, TKDT61DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT61DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT61DD_Test.TestBuff));
  TKDT61DD_Test.Search(TKDT61DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT61DDDistance(TKDT61DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT61DD_Test.Clear;
  { kMean test }
  TKDT61DD_Test.BuildKDTreeWithCluster(TKDT61DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT61DD_Test.Search(TKDT61DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT61DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT61DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT61DD_Test);
end;


function TKDT62DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT62DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT62DD_Node;
  function SortCompare(const p1, p2: PKDT62DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT62DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT62DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT62DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT62DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT62DD.GetData(const index: NativeInt): PKDT62DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT62DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT62DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT62DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT62DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT62DD.StoreBuffPtr: PKDT62DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT62DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT62DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT62DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT62DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT62DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT62DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT62DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT62DD.BuildKDTreeWithCluster(const inBuff: TKDT62DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT62DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT62DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT62DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT62DD.BuildKDTreeWithCluster(const inBuff: TKDT62DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT62DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DD_BuildCall);
var
  TempStoreBuff: TKDT62DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT62DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT62DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT62DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT62DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT62DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DD_BuildMethod);
var
  TempStoreBuff: TKDT62DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT62DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT62DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT62DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT62DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT62DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT62DD_BuildProc);
var
  TempStoreBuff: TKDT62DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT62DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT62DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT62DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT62DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT62DD.Search(const Buff: TKDT62DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT62DD_Node;

var
  NearestNeighbour: PKDT62DD_Node;

  function FindParentNode(const BuffPtr: PKDT62DD_Vec; NodePtr: PKDT62DD_Node): PKDT62DD_Node;
  var
    Next       : PKDT62DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT62DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT62DD_Node; const BuffPtr: PKDT62DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT62DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT62DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT62DD_Vec; const p1, p2: PKDT62DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT62DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT62DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT62DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT62DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT62DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT62DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT62DD_Node(NearestNodes[0]);
    end;
end;

function TKDT62DD.Search(const Buff: TKDT62DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT62DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT62DD.Search(const Buff: TKDT62DD_Vec; var SearchedDistanceMin: Double): PKDT62DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT62DD.Search(const Buff: TKDT62DD_Vec): PKDT62DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT62DD.Search(const inBuff: TKDT62DD_DynamicVecBuffer; var OutBuff: TKDT62DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT62DD_DynamicVecBuffer;
  outBuffPtr : PKDT62DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT62DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT62DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT62DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT62DD.Search(const inBuff: TKDT62DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT62DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT62DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT62DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT62DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT62DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT62DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT62DD_Source));
end;

procedure TKDT62DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT62DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT62DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT62DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT62DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT62DD.PrintNodeTree(const NodePtr: PKDT62DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT62DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT62DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT62DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT62DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT62DD.KDT62DDVec(const s: SystemString): TKDT62DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT62DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT62DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT62DD.KDT62DDVec(const v: TKDT62DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT62DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT62DD.KDT62DDPow(const v: TKDT62DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT62DD.KDT62DDDistance(const v1, v2: TKDT62DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT62DD_Axis - 1 do
      Result := Result + KDT62DDPow(v2[i] - v1[i]);
end;

procedure TKDT62DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT62DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT62DD.Test;
var
  TKDT62DD_Test    : TKDT62DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT62DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT62DD_Test := TKDT62DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT62DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT62DD_Test.TestBuff) - 1 do
    for j := 0 to KDT62DD_Axis - 1 do
        TKDT62DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT62DD_Test.TestBuff), length(TKDT62DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT62DD_Test.BuildKDTreeM(length(TKDT62DD_Test.TestBuff), nil, @TKDT62DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT62DD_Test.BuildKDTreeM(length(TKDT62DD_Test.TestBuff), nil, TKDT62DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT62DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT62DD_Test.TestBuff));
  TKDT62DD_Test.Search(TKDT62DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT62DDDistance(TKDT62DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT62DD_Test.Clear;
  { kMean test }
  TKDT62DD_Test.BuildKDTreeWithCluster(TKDT62DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT62DD_Test.Search(TKDT62DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT62DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT62DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT62DD_Test);
end;


function TKDT63DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT63DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT63DD_Node;
  function SortCompare(const p1, p2: PKDT63DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT63DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT63DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT63DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT63DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT63DD.GetData(const index: NativeInt): PKDT63DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT63DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT63DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT63DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT63DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT63DD.StoreBuffPtr: PKDT63DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT63DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT63DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT63DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT63DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT63DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT63DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT63DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT63DD.BuildKDTreeWithCluster(const inBuff: TKDT63DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT63DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT63DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT63DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT63DD.BuildKDTreeWithCluster(const inBuff: TKDT63DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT63DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DD_BuildCall);
var
  TempStoreBuff: TKDT63DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT63DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT63DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT63DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT63DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT63DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DD_BuildMethod);
var
  TempStoreBuff: TKDT63DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT63DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT63DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT63DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT63DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT63DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT63DD_BuildProc);
var
  TempStoreBuff: TKDT63DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT63DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT63DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT63DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT63DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT63DD.Search(const Buff: TKDT63DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT63DD_Node;

var
  NearestNeighbour: PKDT63DD_Node;

  function FindParentNode(const BuffPtr: PKDT63DD_Vec; NodePtr: PKDT63DD_Node): PKDT63DD_Node;
  var
    Next       : PKDT63DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT63DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT63DD_Node; const BuffPtr: PKDT63DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT63DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT63DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT63DD_Vec; const p1, p2: PKDT63DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT63DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT63DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT63DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT63DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT63DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT63DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT63DD_Node(NearestNodes[0]);
    end;
end;

function TKDT63DD.Search(const Buff: TKDT63DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT63DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT63DD.Search(const Buff: TKDT63DD_Vec; var SearchedDistanceMin: Double): PKDT63DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT63DD.Search(const Buff: TKDT63DD_Vec): PKDT63DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT63DD.Search(const inBuff: TKDT63DD_DynamicVecBuffer; var OutBuff: TKDT63DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT63DD_DynamicVecBuffer;
  outBuffPtr : PKDT63DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT63DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT63DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT63DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT63DD.Search(const inBuff: TKDT63DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT63DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT63DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT63DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT63DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT63DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT63DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT63DD_Source));
end;

procedure TKDT63DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT63DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT63DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT63DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT63DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT63DD.PrintNodeTree(const NodePtr: PKDT63DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT63DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT63DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT63DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT63DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT63DD.KDT63DDVec(const s: SystemString): TKDT63DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT63DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT63DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT63DD.KDT63DDVec(const v: TKDT63DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT63DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT63DD.KDT63DDPow(const v: TKDT63DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT63DD.KDT63DDDistance(const v1, v2: TKDT63DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT63DD_Axis - 1 do
      Result := Result + KDT63DDPow(v2[i] - v1[i]);
end;

procedure TKDT63DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT63DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT63DD.Test;
var
  TKDT63DD_Test    : TKDT63DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT63DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT63DD_Test := TKDT63DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT63DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT63DD_Test.TestBuff) - 1 do
    for j := 0 to KDT63DD_Axis - 1 do
        TKDT63DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT63DD_Test.TestBuff), length(TKDT63DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT63DD_Test.BuildKDTreeM(length(TKDT63DD_Test.TestBuff), nil, @TKDT63DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT63DD_Test.BuildKDTreeM(length(TKDT63DD_Test.TestBuff), nil, TKDT63DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT63DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT63DD_Test.TestBuff));
  TKDT63DD_Test.Search(TKDT63DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT63DDDistance(TKDT63DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT63DD_Test.Clear;
  { kMean test }
  TKDT63DD_Test.BuildKDTreeWithCluster(TKDT63DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT63DD_Test.Search(TKDT63DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT63DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT63DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT63DD_Test);
end;


function TKDT64DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DD_Node;
  function SortCompare(const p1, p2: PKDT64DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT64DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT64DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT64DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT64DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT64DD.GetData(const index: NativeInt): PKDT64DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT64DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT64DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT64DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT64DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT64DD.StoreBuffPtr: PKDT64DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT64DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT64DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT64DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT64DD.BuildKDTreeWithCluster(const inBuff: TKDT64DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT64DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT64DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT64DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT64DD.BuildKDTreeWithCluster(const inBuff: TKDT64DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DD_BuildCall);
var
  TempStoreBuff: TKDT64DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT64DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DD_BuildMethod);
var
  TempStoreBuff: TKDT64DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT64DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT64DD_BuildProc);
var
  TempStoreBuff: TKDT64DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT64DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT64DD.Search(const Buff: TKDT64DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DD_Node;

var
  NearestNeighbour: PKDT64DD_Node;

  function FindParentNode(const BuffPtr: PKDT64DD_Vec; NodePtr: PKDT64DD_Node): PKDT64DD_Node;
  var
    Next       : PKDT64DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT64DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT64DD_Node; const BuffPtr: PKDT64DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT64DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT64DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT64DD_Vec; const p1, p2: PKDT64DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT64DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT64DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT64DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT64DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT64DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT64DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT64DD_Node(NearestNodes[0]);
    end;
end;

function TKDT64DD.Search(const Buff: TKDT64DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT64DD.Search(const Buff: TKDT64DD_Vec; var SearchedDistanceMin: Double): PKDT64DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT64DD.Search(const Buff: TKDT64DD_Vec): PKDT64DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT64DD.Search(const inBuff: TKDT64DD_DynamicVecBuffer; var OutBuff: TKDT64DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT64DD_DynamicVecBuffer;
  outBuffPtr : PKDT64DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT64DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT64DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DD.Search(const inBuff: TKDT64DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT64DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT64DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT64DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT64DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT64DD_Source));
end;

procedure TKDT64DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT64DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT64DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT64DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DD.PrintNodeTree(const NodePtr: PKDT64DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT64DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT64DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT64DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT64DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT64DD.KDT64DDVec(const s: SystemString): TKDT64DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT64DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT64DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT64DD.KDT64DDVec(const v: TKDT64DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT64DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT64DD.KDT64DDPow(const v: TKDT64DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT64DD.KDT64DDDistance(const v1, v2: TKDT64DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT64DD_Axis - 1 do
      Result := Result + KDT64DDPow(v2[i] - v1[i]);
end;

procedure TKDT64DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT64DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT64DD.Test;
var
  TKDT64DD_Test    : TKDT64DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT64DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT64DD_Test := TKDT64DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT64DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT64DD_Test.TestBuff) - 1 do
    for j := 0 to KDT64DD_Axis - 1 do
        TKDT64DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT64DD_Test.TestBuff), length(TKDT64DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT64DD_Test.BuildKDTreeM(length(TKDT64DD_Test.TestBuff), nil, @TKDT64DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT64DD_Test.BuildKDTreeM(length(TKDT64DD_Test.TestBuff), nil, TKDT64DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT64DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT64DD_Test.TestBuff));
  TKDT64DD_Test.Search(TKDT64DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT64DDDistance(TKDT64DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT64DD_Test.Clear;
  { kMean test }
  TKDT64DD_Test.BuildKDTreeWithCluster(TKDT64DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT64DD_Test.Search(TKDT64DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT64DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT64DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT64DD_Test);
end;


function TKDT65DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT65DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT65DD_Node;
  function SortCompare(const p1, p2: PKDT65DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT65DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT65DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT65DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT65DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT65DD.GetData(const index: NativeInt): PKDT65DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT65DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT65DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT65DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT65DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT65DD.StoreBuffPtr: PKDT65DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT65DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT65DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT65DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT65DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT65DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT65DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT65DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT65DD.BuildKDTreeWithCluster(const inBuff: TKDT65DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT65DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT65DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT65DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT65DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT65DD.BuildKDTreeWithCluster(const inBuff: TKDT65DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT65DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DD_BuildCall);
var
  TempStoreBuff: TKDT65DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT65DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT65DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT65DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT65DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT65DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT65DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DD_BuildMethod);
var
  TempStoreBuff: TKDT65DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT65DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT65DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT65DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT65DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT65DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT65DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT65DD_BuildProc);
var
  TempStoreBuff: TKDT65DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT65DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT65DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT65DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT65DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT65DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT65DD.Search(const Buff: TKDT65DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT65DD_Node;

var
  NearestNeighbour: PKDT65DD_Node;

  function FindParentNode(const BuffPtr: PKDT65DD_Vec; NodePtr: PKDT65DD_Node): PKDT65DD_Node;
  var
    Next       : PKDT65DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT65DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT65DD_Node; const BuffPtr: PKDT65DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT65DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT65DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT65DD_Vec; const p1, p2: PKDT65DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT65DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT65DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT65DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT65DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT65DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT65DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT65DD_Node(NearestNodes[0]);
    end;
end;

function TKDT65DD.Search(const Buff: TKDT65DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT65DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT65DD.Search(const Buff: TKDT65DD_Vec; var SearchedDistanceMin: Double): PKDT65DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT65DD.Search(const Buff: TKDT65DD_Vec): PKDT65DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT65DD.Search(const inBuff: TKDT65DD_DynamicVecBuffer; var OutBuff: TKDT65DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT65DD_DynamicVecBuffer;
  outBuffPtr : PKDT65DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT65DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT65DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT65DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT65DD.Search(const inBuff: TKDT65DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT65DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT65DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT65DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT65DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT65DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT65DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT65DD_Source));
end;

procedure TKDT65DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT65DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT65DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT65DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT65DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT65DD.PrintNodeTree(const NodePtr: PKDT65DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT65DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT65DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT65DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT65DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT65DD.KDT65DDVec(const s: SystemString): TKDT65DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT65DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT65DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT65DD.KDT65DDVec(const v: TKDT65DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT65DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT65DD.KDT65DDPow(const v: TKDT65DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT65DD.KDT65DDDistance(const v1, v2: TKDT65DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT65DD_Axis - 1 do
      Result := Result + KDT65DDPow(v2[i] - v1[i]);
end;

procedure TKDT65DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT65DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT65DD.Test;
var
  TKDT65DD_Test    : TKDT65DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT65DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT65DD_Test := TKDT65DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT65DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT65DD_Test.TestBuff) - 1 do
    for j := 0 to KDT65DD_Axis - 1 do
        TKDT65DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT65DD_Test.TestBuff), length(TKDT65DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT65DD_Test.BuildKDTreeM(length(TKDT65DD_Test.TestBuff), nil, @TKDT65DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT65DD_Test.BuildKDTreeM(length(TKDT65DD_Test.TestBuff), nil, TKDT65DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT65DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT65DD_Test.TestBuff));
  TKDT65DD_Test.Search(TKDT65DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT65DDDistance(TKDT65DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT65DD_Test.Clear;
  { kMean test }
  TKDT65DD_Test.BuildKDTreeWithCluster(TKDT65DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT65DD_Test.Search(TKDT65DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT65DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT65DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT65DD_Test);
end;


function TKDT66DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT66DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT66DD_Node;
  function SortCompare(const p1, p2: PKDT66DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT66DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT66DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT66DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT66DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT66DD.GetData(const index: NativeInt): PKDT66DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT66DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT66DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT66DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT66DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT66DD.StoreBuffPtr: PKDT66DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT66DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT66DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT66DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT66DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT66DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT66DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT66DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT66DD.BuildKDTreeWithCluster(const inBuff: TKDT66DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT66DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT66DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT66DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT66DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT66DD.BuildKDTreeWithCluster(const inBuff: TKDT66DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT66DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DD_BuildCall);
var
  TempStoreBuff: TKDT66DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT66DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT66DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT66DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT66DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT66DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT66DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DD_BuildMethod);
var
  TempStoreBuff: TKDT66DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT66DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT66DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT66DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT66DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT66DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT66DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT66DD_BuildProc);
var
  TempStoreBuff: TKDT66DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT66DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT66DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT66DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT66DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT66DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT66DD.Search(const Buff: TKDT66DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT66DD_Node;

var
  NearestNeighbour: PKDT66DD_Node;

  function FindParentNode(const BuffPtr: PKDT66DD_Vec; NodePtr: PKDT66DD_Node): PKDT66DD_Node;
  var
    Next       : PKDT66DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT66DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT66DD_Node; const BuffPtr: PKDT66DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT66DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT66DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT66DD_Vec; const p1, p2: PKDT66DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT66DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT66DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT66DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT66DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT66DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT66DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT66DD_Node(NearestNodes[0]);
    end;
end;

function TKDT66DD.Search(const Buff: TKDT66DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT66DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT66DD.Search(const Buff: TKDT66DD_Vec; var SearchedDistanceMin: Double): PKDT66DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT66DD.Search(const Buff: TKDT66DD_Vec): PKDT66DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT66DD.Search(const inBuff: TKDT66DD_DynamicVecBuffer; var OutBuff: TKDT66DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT66DD_DynamicVecBuffer;
  outBuffPtr : PKDT66DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT66DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT66DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT66DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT66DD.Search(const inBuff: TKDT66DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT66DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT66DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT66DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT66DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT66DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT66DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT66DD_Source));
end;

procedure TKDT66DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT66DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT66DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT66DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT66DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT66DD.PrintNodeTree(const NodePtr: PKDT66DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT66DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT66DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT66DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT66DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT66DD.KDT66DDVec(const s: SystemString): TKDT66DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT66DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT66DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT66DD.KDT66DDVec(const v: TKDT66DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT66DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT66DD.KDT66DDPow(const v: TKDT66DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT66DD.KDT66DDDistance(const v1, v2: TKDT66DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT66DD_Axis - 1 do
      Result := Result + KDT66DDPow(v2[i] - v1[i]);
end;

procedure TKDT66DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT66DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT66DD.Test;
var
  TKDT66DD_Test    : TKDT66DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT66DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT66DD_Test := TKDT66DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT66DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT66DD_Test.TestBuff) - 1 do
    for j := 0 to KDT66DD_Axis - 1 do
        TKDT66DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT66DD_Test.TestBuff), length(TKDT66DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT66DD_Test.BuildKDTreeM(length(TKDT66DD_Test.TestBuff), nil, @TKDT66DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT66DD_Test.BuildKDTreeM(length(TKDT66DD_Test.TestBuff), nil, TKDT66DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT66DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT66DD_Test.TestBuff));
  TKDT66DD_Test.Search(TKDT66DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT66DDDistance(TKDT66DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT66DD_Test.Clear;
  { kMean test }
  TKDT66DD_Test.BuildKDTreeWithCluster(TKDT66DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT66DD_Test.Search(TKDT66DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT66DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT66DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT66DD_Test);
end;


function TKDT67DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT67DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT67DD_Node;
  function SortCompare(const p1, p2: PKDT67DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT67DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT67DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT67DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT67DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT67DD.GetData(const index: NativeInt): PKDT67DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT67DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT67DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT67DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT67DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT67DD.StoreBuffPtr: PKDT67DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT67DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT67DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT67DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT67DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT67DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT67DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT67DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT67DD.BuildKDTreeWithCluster(const inBuff: TKDT67DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT67DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT67DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT67DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT67DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT67DD.BuildKDTreeWithCluster(const inBuff: TKDT67DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT67DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DD_BuildCall);
var
  TempStoreBuff: TKDT67DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT67DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT67DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT67DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT67DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT67DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT67DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DD_BuildMethod);
var
  TempStoreBuff: TKDT67DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT67DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT67DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT67DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT67DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT67DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT67DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT67DD_BuildProc);
var
  TempStoreBuff: TKDT67DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT67DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT67DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT67DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT67DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT67DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT67DD.Search(const Buff: TKDT67DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT67DD_Node;

var
  NearestNeighbour: PKDT67DD_Node;

  function FindParentNode(const BuffPtr: PKDT67DD_Vec; NodePtr: PKDT67DD_Node): PKDT67DD_Node;
  var
    Next       : PKDT67DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT67DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT67DD_Node; const BuffPtr: PKDT67DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT67DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT67DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT67DD_Vec; const p1, p2: PKDT67DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT67DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT67DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT67DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT67DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT67DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT67DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT67DD_Node(NearestNodes[0]);
    end;
end;

function TKDT67DD.Search(const Buff: TKDT67DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT67DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT67DD.Search(const Buff: TKDT67DD_Vec; var SearchedDistanceMin: Double): PKDT67DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT67DD.Search(const Buff: TKDT67DD_Vec): PKDT67DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT67DD.Search(const inBuff: TKDT67DD_DynamicVecBuffer; var OutBuff: TKDT67DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT67DD_DynamicVecBuffer;
  outBuffPtr : PKDT67DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT67DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT67DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT67DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT67DD.Search(const inBuff: TKDT67DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT67DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT67DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT67DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT67DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT67DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT67DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT67DD_Source));
end;

procedure TKDT67DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT67DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT67DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT67DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT67DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT67DD.PrintNodeTree(const NodePtr: PKDT67DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT67DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT67DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT67DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT67DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT67DD.KDT67DDVec(const s: SystemString): TKDT67DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT67DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT67DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT67DD.KDT67DDVec(const v: TKDT67DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT67DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT67DD.KDT67DDPow(const v: TKDT67DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT67DD.KDT67DDDistance(const v1, v2: TKDT67DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT67DD_Axis - 1 do
      Result := Result + KDT67DDPow(v2[i] - v1[i]);
end;

procedure TKDT67DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT67DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT67DD.Test;
var
  TKDT67DD_Test    : TKDT67DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT67DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT67DD_Test := TKDT67DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT67DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT67DD_Test.TestBuff) - 1 do
    for j := 0 to KDT67DD_Axis - 1 do
        TKDT67DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT67DD_Test.TestBuff), length(TKDT67DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT67DD_Test.BuildKDTreeM(length(TKDT67DD_Test.TestBuff), nil, @TKDT67DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT67DD_Test.BuildKDTreeM(length(TKDT67DD_Test.TestBuff), nil, TKDT67DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT67DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT67DD_Test.TestBuff));
  TKDT67DD_Test.Search(TKDT67DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT67DDDistance(TKDT67DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT67DD_Test.Clear;
  { kMean test }
  TKDT67DD_Test.BuildKDTreeWithCluster(TKDT67DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT67DD_Test.Search(TKDT67DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT67DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT67DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT67DD_Test);
end;


function TKDT68DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT68DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT68DD_Node;
  function SortCompare(const p1, p2: PKDT68DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT68DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT68DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT68DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT68DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT68DD.GetData(const index: NativeInt): PKDT68DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT68DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT68DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT68DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT68DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT68DD.StoreBuffPtr: PKDT68DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT68DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT68DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT68DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT68DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT68DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT68DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT68DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT68DD.BuildKDTreeWithCluster(const inBuff: TKDT68DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT68DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT68DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT68DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT68DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT68DD.BuildKDTreeWithCluster(const inBuff: TKDT68DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT68DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DD_BuildCall);
var
  TempStoreBuff: TKDT68DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT68DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT68DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT68DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT68DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT68DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT68DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DD_BuildMethod);
var
  TempStoreBuff: TKDT68DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT68DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT68DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT68DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT68DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT68DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT68DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT68DD_BuildProc);
var
  TempStoreBuff: TKDT68DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT68DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT68DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT68DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT68DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT68DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT68DD.Search(const Buff: TKDT68DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT68DD_Node;

var
  NearestNeighbour: PKDT68DD_Node;

  function FindParentNode(const BuffPtr: PKDT68DD_Vec; NodePtr: PKDT68DD_Node): PKDT68DD_Node;
  var
    Next       : PKDT68DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT68DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT68DD_Node; const BuffPtr: PKDT68DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT68DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT68DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT68DD_Vec; const p1, p2: PKDT68DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT68DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT68DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT68DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT68DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT68DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT68DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT68DD_Node(NearestNodes[0]);
    end;
end;

function TKDT68DD.Search(const Buff: TKDT68DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT68DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT68DD.Search(const Buff: TKDT68DD_Vec; var SearchedDistanceMin: Double): PKDT68DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT68DD.Search(const Buff: TKDT68DD_Vec): PKDT68DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT68DD.Search(const inBuff: TKDT68DD_DynamicVecBuffer; var OutBuff: TKDT68DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT68DD_DynamicVecBuffer;
  outBuffPtr : PKDT68DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT68DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT68DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT68DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT68DD.Search(const inBuff: TKDT68DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT68DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT68DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT68DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT68DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT68DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT68DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT68DD_Source));
end;

procedure TKDT68DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT68DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT68DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT68DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT68DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT68DD.PrintNodeTree(const NodePtr: PKDT68DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT68DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT68DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT68DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT68DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT68DD.KDT68DDVec(const s: SystemString): TKDT68DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT68DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT68DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT68DD.KDT68DDVec(const v: TKDT68DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT68DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT68DD.KDT68DDPow(const v: TKDT68DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT68DD.KDT68DDDistance(const v1, v2: TKDT68DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT68DD_Axis - 1 do
      Result := Result + KDT68DDPow(v2[i] - v1[i]);
end;

procedure TKDT68DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT68DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT68DD.Test;
var
  TKDT68DD_Test    : TKDT68DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT68DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT68DD_Test := TKDT68DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT68DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT68DD_Test.TestBuff) - 1 do
    for j := 0 to KDT68DD_Axis - 1 do
        TKDT68DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT68DD_Test.TestBuff), length(TKDT68DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT68DD_Test.BuildKDTreeM(length(TKDT68DD_Test.TestBuff), nil, @TKDT68DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT68DD_Test.BuildKDTreeM(length(TKDT68DD_Test.TestBuff), nil, TKDT68DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT68DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT68DD_Test.TestBuff));
  TKDT68DD_Test.Search(TKDT68DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT68DDDistance(TKDT68DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT68DD_Test.Clear;
  { kMean test }
  TKDT68DD_Test.BuildKDTreeWithCluster(TKDT68DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT68DD_Test.Search(TKDT68DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT68DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT68DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT68DD_Test);
end;


function TKDT69DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT69DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT69DD_Node;
  function SortCompare(const p1, p2: PKDT69DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT69DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT69DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT69DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT69DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT69DD.GetData(const index: NativeInt): PKDT69DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT69DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT69DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT69DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT69DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT69DD.StoreBuffPtr: PKDT69DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT69DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT69DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT69DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT69DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT69DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT69DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT69DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT69DD.BuildKDTreeWithCluster(const inBuff: TKDT69DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT69DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT69DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT69DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT69DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT69DD.BuildKDTreeWithCluster(const inBuff: TKDT69DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT69DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DD_BuildCall);
var
  TempStoreBuff: TKDT69DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT69DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT69DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT69DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT69DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT69DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT69DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DD_BuildMethod);
var
  TempStoreBuff: TKDT69DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT69DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT69DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT69DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT69DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT69DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT69DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT69DD_BuildProc);
var
  TempStoreBuff: TKDT69DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT69DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT69DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT69DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT69DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT69DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT69DD.Search(const Buff: TKDT69DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT69DD_Node;

var
  NearestNeighbour: PKDT69DD_Node;

  function FindParentNode(const BuffPtr: PKDT69DD_Vec; NodePtr: PKDT69DD_Node): PKDT69DD_Node;
  var
    Next       : PKDT69DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT69DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT69DD_Node; const BuffPtr: PKDT69DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT69DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT69DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT69DD_Vec; const p1, p2: PKDT69DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT69DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT69DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT69DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT69DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT69DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT69DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT69DD_Node(NearestNodes[0]);
    end;
end;

function TKDT69DD.Search(const Buff: TKDT69DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT69DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT69DD.Search(const Buff: TKDT69DD_Vec; var SearchedDistanceMin: Double): PKDT69DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT69DD.Search(const Buff: TKDT69DD_Vec): PKDT69DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT69DD.Search(const inBuff: TKDT69DD_DynamicVecBuffer; var OutBuff: TKDT69DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT69DD_DynamicVecBuffer;
  outBuffPtr : PKDT69DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT69DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT69DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT69DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT69DD.Search(const inBuff: TKDT69DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT69DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT69DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT69DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT69DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT69DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT69DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT69DD_Source));
end;

procedure TKDT69DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT69DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT69DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT69DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT69DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT69DD.PrintNodeTree(const NodePtr: PKDT69DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT69DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT69DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT69DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT69DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT69DD.KDT69DDVec(const s: SystemString): TKDT69DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT69DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT69DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT69DD.KDT69DDVec(const v: TKDT69DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT69DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT69DD.KDT69DDPow(const v: TKDT69DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT69DD.KDT69DDDistance(const v1, v2: TKDT69DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT69DD_Axis - 1 do
      Result := Result + KDT69DDPow(v2[i] - v1[i]);
end;

procedure TKDT69DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT69DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT69DD.Test;
var
  TKDT69DD_Test    : TKDT69DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT69DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT69DD_Test := TKDT69DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT69DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT69DD_Test.TestBuff) - 1 do
    for j := 0 to KDT69DD_Axis - 1 do
        TKDT69DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT69DD_Test.TestBuff), length(TKDT69DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT69DD_Test.BuildKDTreeM(length(TKDT69DD_Test.TestBuff), nil, @TKDT69DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT69DD_Test.BuildKDTreeM(length(TKDT69DD_Test.TestBuff), nil, TKDT69DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT69DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT69DD_Test.TestBuff));
  TKDT69DD_Test.Search(TKDT69DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT69DDDistance(TKDT69DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT69DD_Test.Clear;
  { kMean test }
  TKDT69DD_Test.BuildKDTreeWithCluster(TKDT69DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT69DD_Test.Search(TKDT69DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT69DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT69DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT69DD_Test);
end;


function TKDT70DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT70DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT70DD_Node;
  function SortCompare(const p1, p2: PKDT70DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT70DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT70DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT70DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT70DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT70DD.GetData(const index: NativeInt): PKDT70DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT70DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT70DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT70DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT70DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT70DD.StoreBuffPtr: PKDT70DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT70DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT70DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT70DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT70DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT70DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT70DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT70DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT70DD.BuildKDTreeWithCluster(const inBuff: TKDT70DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT70DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT70DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT70DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT70DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT70DD.BuildKDTreeWithCluster(const inBuff: TKDT70DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT70DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DD_BuildCall);
var
  TempStoreBuff: TKDT70DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT70DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT70DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT70DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT70DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT70DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT70DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DD_BuildMethod);
var
  TempStoreBuff: TKDT70DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT70DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT70DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT70DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT70DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT70DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT70DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT70DD_BuildProc);
var
  TempStoreBuff: TKDT70DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT70DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT70DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT70DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT70DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT70DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT70DD.Search(const Buff: TKDT70DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT70DD_Node;

var
  NearestNeighbour: PKDT70DD_Node;

  function FindParentNode(const BuffPtr: PKDT70DD_Vec; NodePtr: PKDT70DD_Node): PKDT70DD_Node;
  var
    Next       : PKDT70DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT70DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT70DD_Node; const BuffPtr: PKDT70DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT70DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT70DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT70DD_Vec; const p1, p2: PKDT70DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT70DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT70DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT70DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT70DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT70DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT70DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT70DD_Node(NearestNodes[0]);
    end;
end;

function TKDT70DD.Search(const Buff: TKDT70DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT70DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT70DD.Search(const Buff: TKDT70DD_Vec; var SearchedDistanceMin: Double): PKDT70DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT70DD.Search(const Buff: TKDT70DD_Vec): PKDT70DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT70DD.Search(const inBuff: TKDT70DD_DynamicVecBuffer; var OutBuff: TKDT70DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT70DD_DynamicVecBuffer;
  outBuffPtr : PKDT70DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT70DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT70DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT70DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT70DD.Search(const inBuff: TKDT70DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT70DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT70DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT70DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT70DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT70DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT70DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT70DD_Source));
end;

procedure TKDT70DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT70DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT70DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT70DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT70DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT70DD.PrintNodeTree(const NodePtr: PKDT70DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT70DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT70DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT70DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT70DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT70DD.KDT70DDVec(const s: SystemString): TKDT70DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT70DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT70DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT70DD.KDT70DDVec(const v: TKDT70DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT70DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT70DD.KDT70DDPow(const v: TKDT70DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT70DD.KDT70DDDistance(const v1, v2: TKDT70DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT70DD_Axis - 1 do
      Result := Result + KDT70DDPow(v2[i] - v1[i]);
end;

procedure TKDT70DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT70DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT70DD.Test;
var
  TKDT70DD_Test    : TKDT70DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT70DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT70DD_Test := TKDT70DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT70DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT70DD_Test.TestBuff) - 1 do
    for j := 0 to KDT70DD_Axis - 1 do
        TKDT70DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT70DD_Test.TestBuff), length(TKDT70DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT70DD_Test.BuildKDTreeM(length(TKDT70DD_Test.TestBuff), nil, @TKDT70DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT70DD_Test.BuildKDTreeM(length(TKDT70DD_Test.TestBuff), nil, TKDT70DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT70DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT70DD_Test.TestBuff));
  TKDT70DD_Test.Search(TKDT70DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT70DDDistance(TKDT70DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT70DD_Test.Clear;
  { kMean test }
  TKDT70DD_Test.BuildKDTreeWithCluster(TKDT70DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT70DD_Test.Search(TKDT70DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT70DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT70DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT70DD_Test);
end;


function TKDT71DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT71DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT71DD_Node;
  function SortCompare(const p1, p2: PKDT71DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT71DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT71DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT71DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT71DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT71DD.GetData(const index: NativeInt): PKDT71DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT71DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT71DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT71DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT71DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT71DD.StoreBuffPtr: PKDT71DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT71DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT71DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT71DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT71DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT71DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT71DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT71DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT71DD.BuildKDTreeWithCluster(const inBuff: TKDT71DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT71DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT71DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT71DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT71DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT71DD.BuildKDTreeWithCluster(const inBuff: TKDT71DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT71DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DD_BuildCall);
var
  TempStoreBuff: TKDT71DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT71DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT71DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT71DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT71DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT71DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT71DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DD_BuildMethod);
var
  TempStoreBuff: TKDT71DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT71DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT71DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT71DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT71DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT71DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT71DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT71DD_BuildProc);
var
  TempStoreBuff: TKDT71DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT71DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT71DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT71DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT71DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT71DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT71DD.Search(const Buff: TKDT71DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT71DD_Node;

var
  NearestNeighbour: PKDT71DD_Node;

  function FindParentNode(const BuffPtr: PKDT71DD_Vec; NodePtr: PKDT71DD_Node): PKDT71DD_Node;
  var
    Next       : PKDT71DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT71DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT71DD_Node; const BuffPtr: PKDT71DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT71DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT71DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT71DD_Vec; const p1, p2: PKDT71DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT71DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT71DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT71DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT71DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT71DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT71DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT71DD_Node(NearestNodes[0]);
    end;
end;

function TKDT71DD.Search(const Buff: TKDT71DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT71DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT71DD.Search(const Buff: TKDT71DD_Vec; var SearchedDistanceMin: Double): PKDT71DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT71DD.Search(const Buff: TKDT71DD_Vec): PKDT71DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT71DD.Search(const inBuff: TKDT71DD_DynamicVecBuffer; var OutBuff: TKDT71DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT71DD_DynamicVecBuffer;
  outBuffPtr : PKDT71DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT71DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT71DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT71DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT71DD.Search(const inBuff: TKDT71DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT71DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT71DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT71DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT71DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT71DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT71DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT71DD_Source));
end;

procedure TKDT71DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT71DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT71DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT71DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT71DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT71DD.PrintNodeTree(const NodePtr: PKDT71DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT71DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT71DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT71DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT71DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT71DD.KDT71DDVec(const s: SystemString): TKDT71DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT71DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT71DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT71DD.KDT71DDVec(const v: TKDT71DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT71DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT71DD.KDT71DDPow(const v: TKDT71DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT71DD.KDT71DDDistance(const v1, v2: TKDT71DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT71DD_Axis - 1 do
      Result := Result + KDT71DDPow(v2[i] - v1[i]);
end;

procedure TKDT71DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT71DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT71DD.Test;
var
  TKDT71DD_Test    : TKDT71DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT71DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT71DD_Test := TKDT71DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT71DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT71DD_Test.TestBuff) - 1 do
    for j := 0 to KDT71DD_Axis - 1 do
        TKDT71DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT71DD_Test.TestBuff), length(TKDT71DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT71DD_Test.BuildKDTreeM(length(TKDT71DD_Test.TestBuff), nil, @TKDT71DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT71DD_Test.BuildKDTreeM(length(TKDT71DD_Test.TestBuff), nil, TKDT71DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT71DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT71DD_Test.TestBuff));
  TKDT71DD_Test.Search(TKDT71DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT71DDDistance(TKDT71DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT71DD_Test.Clear;
  { kMean test }
  TKDT71DD_Test.BuildKDTreeWithCluster(TKDT71DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT71DD_Test.Search(TKDT71DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT71DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT71DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT71DD_Test);
end;


function TKDT72DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT72DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT72DD_Node;
  function SortCompare(const p1, p2: PKDT72DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT72DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT72DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT72DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT72DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT72DD.GetData(const index: NativeInt): PKDT72DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT72DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT72DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT72DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT72DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT72DD.StoreBuffPtr: PKDT72DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT72DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT72DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT72DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT72DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT72DD.BuildKDTreeWithCluster(const inBuff: TKDT72DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT72DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT72DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT72DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT72DD.BuildKDTreeWithCluster(const inBuff: TKDT72DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT72DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DD_BuildCall);
var
  TempStoreBuff: TKDT72DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT72DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT72DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT72DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT72DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DD_BuildMethod);
var
  TempStoreBuff: TKDT72DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT72DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT72DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT72DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT72DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT72DD_BuildProc);
var
  TempStoreBuff: TKDT72DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT72DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT72DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT72DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT72DD.Search(const Buff: TKDT72DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT72DD_Node;

var
  NearestNeighbour: PKDT72DD_Node;

  function FindParentNode(const BuffPtr: PKDT72DD_Vec; NodePtr: PKDT72DD_Node): PKDT72DD_Node;
  var
    Next       : PKDT72DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT72DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT72DD_Node; const BuffPtr: PKDT72DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT72DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT72DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT72DD_Vec; const p1, p2: PKDT72DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT72DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT72DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT72DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT72DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT72DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT72DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT72DD_Node(NearestNodes[0]);
    end;
end;

function TKDT72DD.Search(const Buff: TKDT72DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT72DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT72DD.Search(const Buff: TKDT72DD_Vec; var SearchedDistanceMin: Double): PKDT72DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT72DD.Search(const Buff: TKDT72DD_Vec): PKDT72DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT72DD.Search(const inBuff: TKDT72DD_DynamicVecBuffer; var OutBuff: TKDT72DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT72DD_DynamicVecBuffer;
  outBuffPtr : PKDT72DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT72DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT72DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT72DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT72DD.Search(const inBuff: TKDT72DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT72DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT72DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT72DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT72DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT72DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT72DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT72DD_Source));
end;

procedure TKDT72DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT72DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT72DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT72DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT72DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT72DD.PrintNodeTree(const NodePtr: PKDT72DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT72DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT72DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT72DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT72DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT72DD.KDT72DDVec(const s: SystemString): TKDT72DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT72DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT72DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT72DD.KDT72DDVec(const v: TKDT72DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT72DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT72DD.KDT72DDPow(const v: TKDT72DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT72DD.KDT72DDDistance(const v1, v2: TKDT72DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT72DD_Axis - 1 do
      Result := Result + KDT72DDPow(v2[i] - v1[i]);
end;

procedure TKDT72DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT72DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT72DD.Test;
var
  TKDT72DD_Test    : TKDT72DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT72DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT72DD_Test := TKDT72DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT72DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT72DD_Test.TestBuff) - 1 do
    for j := 0 to KDT72DD_Axis - 1 do
        TKDT72DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT72DD_Test.TestBuff), length(TKDT72DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT72DD_Test.BuildKDTreeM(length(TKDT72DD_Test.TestBuff), nil, @TKDT72DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT72DD_Test.BuildKDTreeM(length(TKDT72DD_Test.TestBuff), nil, TKDT72DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT72DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT72DD_Test.TestBuff));
  TKDT72DD_Test.Search(TKDT72DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT72DDDistance(TKDT72DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT72DD_Test.Clear;
  { kMean test }
  TKDT72DD_Test.BuildKDTreeWithCluster(TKDT72DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT72DD_Test.Search(TKDT72DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT72DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT72DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT72DD_Test);
end;


function TKDT84DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT84DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT84DD_Node;
  function SortCompare(const p1, p2: PKDT84DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT84DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT84DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT84DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT84DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT84DD.GetData(const index: NativeInt): PKDT84DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT84DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT84DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT84DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT84DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT84DD.StoreBuffPtr: PKDT84DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT84DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT84DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT84DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT84DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT84DD.BuildKDTreeWithCluster(const inBuff: TKDT84DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT84DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT84DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT84DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT84DD.BuildKDTreeWithCluster(const inBuff: TKDT84DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT84DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DD_BuildCall);
var
  TempStoreBuff: TKDT84DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT84DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT84DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT84DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT84DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DD_BuildMethod);
var
  TempStoreBuff: TKDT84DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT84DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT84DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT84DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT84DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT84DD_BuildProc);
var
  TempStoreBuff: TKDT84DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT84DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT84DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT84DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT84DD.Search(const Buff: TKDT84DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT84DD_Node;

var
  NearestNeighbour: PKDT84DD_Node;

  function FindParentNode(const BuffPtr: PKDT84DD_Vec; NodePtr: PKDT84DD_Node): PKDT84DD_Node;
  var
    Next       : PKDT84DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT84DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT84DD_Node; const BuffPtr: PKDT84DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT84DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT84DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT84DD_Vec; const p1, p2: PKDT84DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT84DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT84DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT84DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT84DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT84DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT84DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT84DD_Node(NearestNodes[0]);
    end;
end;

function TKDT84DD.Search(const Buff: TKDT84DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT84DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT84DD.Search(const Buff: TKDT84DD_Vec; var SearchedDistanceMin: Double): PKDT84DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT84DD.Search(const Buff: TKDT84DD_Vec): PKDT84DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT84DD.Search(const inBuff: TKDT84DD_DynamicVecBuffer; var OutBuff: TKDT84DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT84DD_DynamicVecBuffer;
  outBuffPtr : PKDT84DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT84DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT84DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT84DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT84DD.Search(const inBuff: TKDT84DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT84DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT84DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT84DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT84DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT84DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT84DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT84DD_Source));
end;

procedure TKDT84DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT84DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT84DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT84DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT84DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT84DD.PrintNodeTree(const NodePtr: PKDT84DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT84DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT84DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT84DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT84DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT84DD.KDT84DDVec(const s: SystemString): TKDT84DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT84DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT84DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT84DD.KDT84DDVec(const v: TKDT84DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT84DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT84DD.KDT84DDPow(const v: TKDT84DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT84DD.KDT84DDDistance(const v1, v2: TKDT84DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT84DD_Axis - 1 do
      Result := Result + KDT84DDPow(v2[i] - v1[i]);
end;

procedure TKDT84DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT84DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT84DD.Test;
var
  TKDT84DD_Test    : TKDT84DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT84DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT84DD_Test := TKDT84DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT84DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT84DD_Test.TestBuff) - 1 do
    for j := 0 to KDT84DD_Axis - 1 do
        TKDT84DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT84DD_Test.TestBuff), length(TKDT84DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT84DD_Test.BuildKDTreeM(length(TKDT84DD_Test.TestBuff), nil, @TKDT84DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT84DD_Test.BuildKDTreeM(length(TKDT84DD_Test.TestBuff), nil, TKDT84DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT84DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT84DD_Test.TestBuff));
  TKDT84DD_Test.Search(TKDT84DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT84DDDistance(TKDT84DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT84DD_Test.Clear;
  { kMean test }
  TKDT84DD_Test.BuildKDTreeWithCluster(TKDT84DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT84DD_Test.Search(TKDT84DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT84DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT84DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT84DD_Test);
end;


function TKDT96DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DD_Node;
  function SortCompare(const p1, p2: PKDT96DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT96DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT96DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT96DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT96DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT96DD.GetData(const index: NativeInt): PKDT96DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT96DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT96DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT96DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT96DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT96DD.StoreBuffPtr: PKDT96DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT96DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT96DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT96DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT96DD.BuildKDTreeWithCluster(const inBuff: TKDT96DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT96DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT96DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT96DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT96DD.BuildKDTreeWithCluster(const inBuff: TKDT96DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DD_BuildCall);
var
  TempStoreBuff: TKDT96DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT96DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DD_BuildMethod);
var
  TempStoreBuff: TKDT96DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT96DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT96DD_BuildProc);
var
  TempStoreBuff: TKDT96DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT96DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT96DD.Search(const Buff: TKDT96DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DD_Node;

var
  NearestNeighbour: PKDT96DD_Node;

  function FindParentNode(const BuffPtr: PKDT96DD_Vec; NodePtr: PKDT96DD_Node): PKDT96DD_Node;
  var
    Next       : PKDT96DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT96DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT96DD_Node; const BuffPtr: PKDT96DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT96DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT96DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT96DD_Vec; const p1, p2: PKDT96DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT96DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT96DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT96DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT96DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT96DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT96DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT96DD_Node(NearestNodes[0]);
    end;
end;

function TKDT96DD.Search(const Buff: TKDT96DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT96DD.Search(const Buff: TKDT96DD_Vec; var SearchedDistanceMin: Double): PKDT96DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT96DD.Search(const Buff: TKDT96DD_Vec): PKDT96DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT96DD.Search(const inBuff: TKDT96DD_DynamicVecBuffer; var OutBuff: TKDT96DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT96DD_DynamicVecBuffer;
  outBuffPtr : PKDT96DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT96DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT96DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DD.Search(const inBuff: TKDT96DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT96DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT96DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT96DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT96DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT96DD_Source));
end;

procedure TKDT96DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT96DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT96DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT96DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DD.PrintNodeTree(const NodePtr: PKDT96DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT96DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT96DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT96DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT96DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT96DD.KDT96DDVec(const s: SystemString): TKDT96DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT96DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT96DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT96DD.KDT96DDVec(const v: TKDT96DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT96DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT96DD.KDT96DDPow(const v: TKDT96DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT96DD.KDT96DDDistance(const v1, v2: TKDT96DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT96DD_Axis - 1 do
      Result := Result + KDT96DDPow(v2[i] - v1[i]);
end;

procedure TKDT96DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT96DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT96DD.Test;
var
  TKDT96DD_Test    : TKDT96DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT96DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT96DD_Test := TKDT96DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT96DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT96DD_Test.TestBuff) - 1 do
    for j := 0 to KDT96DD_Axis - 1 do
        TKDT96DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT96DD_Test.TestBuff), length(TKDT96DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT96DD_Test.BuildKDTreeM(length(TKDT96DD_Test.TestBuff), nil, @TKDT96DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT96DD_Test.BuildKDTreeM(length(TKDT96DD_Test.TestBuff), nil, TKDT96DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT96DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT96DD_Test.TestBuff));
  TKDT96DD_Test.Search(TKDT96DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT96DDDistance(TKDT96DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT96DD_Test.Clear;
  { kMean test }
  TKDT96DD_Test.BuildKDTreeWithCluster(TKDT96DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT96DD_Test.Search(TKDT96DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT96DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT96DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT96DD_Test);
end;


function TKDT128DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DD_Node;
  function SortCompare(const p1, p2: PKDT128DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT128DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT128DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT128DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT128DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT128DD.GetData(const index: NativeInt): PKDT128DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT128DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT128DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT128DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT128DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT128DD.StoreBuffPtr: PKDT128DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT128DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT128DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT128DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT128DD.BuildKDTreeWithCluster(const inBuff: TKDT128DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT128DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT128DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT128DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT128DD.BuildKDTreeWithCluster(const inBuff: TKDT128DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DD_BuildCall);
var
  TempStoreBuff: TKDT128DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT128DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DD_BuildMethod);
var
  TempStoreBuff: TKDT128DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT128DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT128DD_BuildProc);
var
  TempStoreBuff: TKDT128DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT128DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT128DD.Search(const Buff: TKDT128DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DD_Node;

var
  NearestNeighbour: PKDT128DD_Node;

  function FindParentNode(const BuffPtr: PKDT128DD_Vec; NodePtr: PKDT128DD_Node): PKDT128DD_Node;
  var
    Next       : PKDT128DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT128DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT128DD_Node; const BuffPtr: PKDT128DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT128DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT128DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT128DD_Vec; const p1, p2: PKDT128DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT128DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT128DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT128DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT128DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT128DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT128DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT128DD_Node(NearestNodes[0]);
    end;
end;

function TKDT128DD.Search(const Buff: TKDT128DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT128DD.Search(const Buff: TKDT128DD_Vec; var SearchedDistanceMin: Double): PKDT128DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT128DD.Search(const Buff: TKDT128DD_Vec): PKDT128DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT128DD.Search(const inBuff: TKDT128DD_DynamicVecBuffer; var OutBuff: TKDT128DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT128DD_DynamicVecBuffer;
  outBuffPtr : PKDT128DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT128DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT128DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DD.Search(const inBuff: TKDT128DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT128DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT128DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT128DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT128DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT128DD_Source));
end;

procedure TKDT128DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT128DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT128DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT128DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DD.PrintNodeTree(const NodePtr: PKDT128DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT128DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT128DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT128DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT128DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT128DD.KDT128DDVec(const s: SystemString): TKDT128DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT128DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT128DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT128DD.KDT128DDVec(const v: TKDT128DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT128DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT128DD.KDT128DDPow(const v: TKDT128DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT128DD.KDT128DDDistance(const v1, v2: TKDT128DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT128DD_Axis - 1 do
      Result := Result + KDT128DDPow(v2[i] - v1[i]);
end;

procedure TKDT128DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT128DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT128DD.Test;
var
  TKDT128DD_Test    : TKDT128DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT128DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT128DD_Test := TKDT128DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT128DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT128DD_Test.TestBuff) - 1 do
    for j := 0 to KDT128DD_Axis - 1 do
        TKDT128DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT128DD_Test.TestBuff), length(TKDT128DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT128DD_Test.BuildKDTreeM(length(TKDT128DD_Test.TestBuff), nil, @TKDT128DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT128DD_Test.BuildKDTreeM(length(TKDT128DD_Test.TestBuff), nil, TKDT128DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT128DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT128DD_Test.TestBuff));
  TKDT128DD_Test.Search(TKDT128DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT128DDDistance(TKDT128DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT128DD_Test.Clear;
  { kMean test }
  TKDT128DD_Test.BuildKDTreeWithCluster(TKDT128DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT128DD_Test.Search(TKDT128DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT128DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT128DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT128DD_Test);
end;


function TKDT140DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT140DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT140DD_Node;
  function SortCompare(const p1, p2: PKDT140DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT140DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT140DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT140DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT140DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT140DD.GetData(const index: NativeInt): PKDT140DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT140DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT140DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT140DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT140DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT140DD.StoreBuffPtr: PKDT140DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT140DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT140DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT140DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT140DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT140DD.BuildKDTreeWithCluster(const inBuff: TKDT140DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT140DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT140DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT140DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT140DD.BuildKDTreeWithCluster(const inBuff: TKDT140DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT140DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DD_BuildCall);
var
  TempStoreBuff: TKDT140DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT140DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT140DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT140DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT140DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DD_BuildMethod);
var
  TempStoreBuff: TKDT140DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT140DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT140DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT140DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT140DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT140DD_BuildProc);
var
  TempStoreBuff: TKDT140DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT140DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT140DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT140DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT140DD.Search(const Buff: TKDT140DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT140DD_Node;

var
  NearestNeighbour: PKDT140DD_Node;

  function FindParentNode(const BuffPtr: PKDT140DD_Vec; NodePtr: PKDT140DD_Node): PKDT140DD_Node;
  var
    Next       : PKDT140DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT140DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT140DD_Node; const BuffPtr: PKDT140DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT140DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT140DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT140DD_Vec; const p1, p2: PKDT140DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT140DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT140DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT140DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT140DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT140DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT140DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT140DD_Node(NearestNodes[0]);
    end;
end;

function TKDT140DD.Search(const Buff: TKDT140DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT140DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT140DD.Search(const Buff: TKDT140DD_Vec; var SearchedDistanceMin: Double): PKDT140DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT140DD.Search(const Buff: TKDT140DD_Vec): PKDT140DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT140DD.Search(const inBuff: TKDT140DD_DynamicVecBuffer; var OutBuff: TKDT140DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT140DD_DynamicVecBuffer;
  outBuffPtr : PKDT140DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT140DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT140DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT140DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT140DD.Search(const inBuff: TKDT140DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT140DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT140DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT140DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT140DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT140DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT140DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT140DD_Source));
end;

procedure TKDT140DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT140DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT140DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT140DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT140DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT140DD.PrintNodeTree(const NodePtr: PKDT140DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT140DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT140DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT140DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT140DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT140DD.KDT140DDVec(const s: SystemString): TKDT140DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT140DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT140DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT140DD.KDT140DDVec(const v: TKDT140DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT140DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT140DD.KDT140DDPow(const v: TKDT140DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT140DD.KDT140DDDistance(const v1, v2: TKDT140DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT140DD_Axis - 1 do
      Result := Result + KDT140DDPow(v2[i] - v1[i]);
end;

procedure TKDT140DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT140DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT140DD.Test;
var
  TKDT140DD_Test    : TKDT140DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT140DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT140DD_Test := TKDT140DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT140DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT140DD_Test.TestBuff) - 1 do
    for j := 0 to KDT140DD_Axis - 1 do
        TKDT140DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT140DD_Test.TestBuff), length(TKDT140DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT140DD_Test.BuildKDTreeM(length(TKDT140DD_Test.TestBuff), nil, @TKDT140DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT140DD_Test.BuildKDTreeM(length(TKDT140DD_Test.TestBuff), nil, TKDT140DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT140DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT140DD_Test.TestBuff));
  TKDT140DD_Test.Search(TKDT140DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT140DDDistance(TKDT140DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT140DD_Test.Clear;
  { kMean test }
  TKDT140DD_Test.BuildKDTreeWithCluster(TKDT140DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT140DD_Test.Search(TKDT140DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT140DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT140DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT140DD_Test);
end;


function TKDT160DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT160DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT160DD_Node;
  function SortCompare(const p1, p2: PKDT160DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT160DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT160DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT160DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT160DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT160DD.GetData(const index: NativeInt): PKDT160DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT160DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT160DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT160DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT160DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT160DD.StoreBuffPtr: PKDT160DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT160DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT160DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT160DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT160DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT160DD.BuildKDTreeWithCluster(const inBuff: TKDT160DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT160DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT160DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT160DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT160DD.BuildKDTreeWithCluster(const inBuff: TKDT160DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT160DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DD_BuildCall);
var
  TempStoreBuff: TKDT160DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT160DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT160DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT160DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT160DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DD_BuildMethod);
var
  TempStoreBuff: TKDT160DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT160DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT160DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT160DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT160DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT160DD_BuildProc);
var
  TempStoreBuff: TKDT160DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT160DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT160DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT160DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT160DD.Search(const Buff: TKDT160DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT160DD_Node;

var
  NearestNeighbour: PKDT160DD_Node;

  function FindParentNode(const BuffPtr: PKDT160DD_Vec; NodePtr: PKDT160DD_Node): PKDT160DD_Node;
  var
    Next       : PKDT160DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT160DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT160DD_Node; const BuffPtr: PKDT160DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT160DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT160DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT160DD_Vec; const p1, p2: PKDT160DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT160DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT160DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT160DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT160DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT160DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT160DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT160DD_Node(NearestNodes[0]);
    end;
end;

function TKDT160DD.Search(const Buff: TKDT160DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT160DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT160DD.Search(const Buff: TKDT160DD_Vec; var SearchedDistanceMin: Double): PKDT160DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT160DD.Search(const Buff: TKDT160DD_Vec): PKDT160DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT160DD.Search(const inBuff: TKDT160DD_DynamicVecBuffer; var OutBuff: TKDT160DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT160DD_DynamicVecBuffer;
  outBuffPtr : PKDT160DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT160DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT160DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT160DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT160DD.Search(const inBuff: TKDT160DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT160DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT160DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT160DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT160DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT160DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT160DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT160DD_Source));
end;

procedure TKDT160DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT160DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT160DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT160DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT160DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT160DD.PrintNodeTree(const NodePtr: PKDT160DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT160DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT160DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT160DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT160DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT160DD.KDT160DDVec(const s: SystemString): TKDT160DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT160DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT160DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT160DD.KDT160DDVec(const v: TKDT160DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT160DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT160DD.KDT160DDPow(const v: TKDT160DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT160DD.KDT160DDDistance(const v1, v2: TKDT160DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT160DD_Axis - 1 do
      Result := Result + KDT160DDPow(v2[i] - v1[i]);
end;

procedure TKDT160DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT160DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT160DD.Test;
var
  TKDT160DD_Test    : TKDT160DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT160DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT160DD_Test := TKDT160DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT160DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT160DD_Test.TestBuff) - 1 do
    for j := 0 to KDT160DD_Axis - 1 do
        TKDT160DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT160DD_Test.TestBuff), length(TKDT160DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT160DD_Test.BuildKDTreeM(length(TKDT160DD_Test.TestBuff), nil, @TKDT160DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT160DD_Test.BuildKDTreeM(length(TKDT160DD_Test.TestBuff), nil, TKDT160DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT160DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT160DD_Test.TestBuff));
  TKDT160DD_Test.Search(TKDT160DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT160DDDistance(TKDT160DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT160DD_Test.Clear;
  { kMean test }
  TKDT160DD_Test.BuildKDTreeWithCluster(TKDT160DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT160DD_Test.Search(TKDT160DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT160DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT160DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT160DD_Test);
end;


function TKDT196DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT196DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT196DD_Node;
  function SortCompare(const p1, p2: PKDT196DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT196DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT196DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT196DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT196DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT196DD.GetData(const index: NativeInt): PKDT196DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT196DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT196DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT196DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT196DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT196DD.StoreBuffPtr: PKDT196DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT196DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT196DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT196DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT196DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT196DD.BuildKDTreeWithCluster(const inBuff: TKDT196DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT196DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT196DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT196DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT196DD.BuildKDTreeWithCluster(const inBuff: TKDT196DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT196DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DD_BuildCall);
var
  TempStoreBuff: TKDT196DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT196DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT196DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT196DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT196DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DD_BuildMethod);
var
  TempStoreBuff: TKDT196DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT196DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT196DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT196DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT196DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT196DD_BuildProc);
var
  TempStoreBuff: TKDT196DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT196DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT196DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT196DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT196DD.Search(const Buff: TKDT196DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT196DD_Node;

var
  NearestNeighbour: PKDT196DD_Node;

  function FindParentNode(const BuffPtr: PKDT196DD_Vec; NodePtr: PKDT196DD_Node): PKDT196DD_Node;
  var
    Next       : PKDT196DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT196DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT196DD_Node; const BuffPtr: PKDT196DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT196DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT196DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT196DD_Vec; const p1, p2: PKDT196DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT196DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT196DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT196DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT196DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT196DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT196DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT196DD_Node(NearestNodes[0]);
    end;
end;

function TKDT196DD.Search(const Buff: TKDT196DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT196DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT196DD.Search(const Buff: TKDT196DD_Vec; var SearchedDistanceMin: Double): PKDT196DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT196DD.Search(const Buff: TKDT196DD_Vec): PKDT196DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT196DD.Search(const inBuff: TKDT196DD_DynamicVecBuffer; var OutBuff: TKDT196DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT196DD_DynamicVecBuffer;
  outBuffPtr : PKDT196DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT196DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT196DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT196DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT196DD.Search(const inBuff: TKDT196DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT196DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT196DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT196DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT196DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT196DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT196DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT196DD_Source));
end;

procedure TKDT196DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT196DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT196DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT196DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT196DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT196DD.PrintNodeTree(const NodePtr: PKDT196DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT196DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT196DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT196DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT196DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT196DD.KDT196DDVec(const s: SystemString): TKDT196DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT196DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT196DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT196DD.KDT196DDVec(const v: TKDT196DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT196DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT196DD.KDT196DDPow(const v: TKDT196DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT196DD.KDT196DDDistance(const v1, v2: TKDT196DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT196DD_Axis - 1 do
      Result := Result + KDT196DDPow(v2[i] - v1[i]);
end;

procedure TKDT196DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT196DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT196DD.Test;
var
  TKDT196DD_Test    : TKDT196DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT196DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT196DD_Test := TKDT196DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT196DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT196DD_Test.TestBuff) - 1 do
    for j := 0 to KDT196DD_Axis - 1 do
        TKDT196DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT196DD_Test.TestBuff), length(TKDT196DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT196DD_Test.BuildKDTreeM(length(TKDT196DD_Test.TestBuff), nil, @TKDT196DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT196DD_Test.BuildKDTreeM(length(TKDT196DD_Test.TestBuff), nil, TKDT196DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT196DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT196DD_Test.TestBuff));
  TKDT196DD_Test.Search(TKDT196DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT196DDDistance(TKDT196DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT196DD_Test.Clear;
  { kMean test }
  TKDT196DD_Test.BuildKDTreeWithCluster(TKDT196DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT196DD_Test.Search(TKDT196DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT196DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT196DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT196DD_Test);
end;


function TKDT256DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DD_Node;
  function SortCompare(const p1, p2: PKDT256DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT256DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT256DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT256DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT256DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT256DD.GetData(const index: NativeInt): PKDT256DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT256DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT256DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT256DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT256DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT256DD.StoreBuffPtr: PKDT256DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT256DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT256DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT256DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT256DD.BuildKDTreeWithCluster(const inBuff: TKDT256DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT256DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT256DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT256DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT256DD.BuildKDTreeWithCluster(const inBuff: TKDT256DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DD_BuildCall);
var
  TempStoreBuff: TKDT256DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT256DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DD_BuildMethod);
var
  TempStoreBuff: TKDT256DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT256DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT256DD_BuildProc);
var
  TempStoreBuff: TKDT256DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT256DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT256DD.Search(const Buff: TKDT256DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DD_Node;

var
  NearestNeighbour: PKDT256DD_Node;

  function FindParentNode(const BuffPtr: PKDT256DD_Vec; NodePtr: PKDT256DD_Node): PKDT256DD_Node;
  var
    Next       : PKDT256DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT256DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT256DD_Node; const BuffPtr: PKDT256DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT256DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT256DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT256DD_Vec; const p1, p2: PKDT256DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT256DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT256DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT256DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT256DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT256DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT256DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT256DD_Node(NearestNodes[0]);
    end;
end;

function TKDT256DD.Search(const Buff: TKDT256DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT256DD.Search(const Buff: TKDT256DD_Vec; var SearchedDistanceMin: Double): PKDT256DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT256DD.Search(const Buff: TKDT256DD_Vec): PKDT256DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT256DD.Search(const inBuff: TKDT256DD_DynamicVecBuffer; var OutBuff: TKDT256DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT256DD_DynamicVecBuffer;
  outBuffPtr : PKDT256DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT256DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT256DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DD.Search(const inBuff: TKDT256DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT256DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT256DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT256DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT256DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT256DD_Source));
end;

procedure TKDT256DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT256DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT256DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT256DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DD.PrintNodeTree(const NodePtr: PKDT256DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT256DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT256DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT256DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT256DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT256DD.KDT256DDVec(const s: SystemString): TKDT256DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT256DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT256DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT256DD.KDT256DDVec(const v: TKDT256DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT256DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT256DD.KDT256DDPow(const v: TKDT256DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT256DD.KDT256DDDistance(const v1, v2: TKDT256DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT256DD_Axis - 1 do
      Result := Result + KDT256DDPow(v2[i] - v1[i]);
end;

procedure TKDT256DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT256DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT256DD.Test;
var
  TKDT256DD_Test    : TKDT256DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT256DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT256DD_Test := TKDT256DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT256DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT256DD_Test.TestBuff) - 1 do
    for j := 0 to KDT256DD_Axis - 1 do
        TKDT256DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT256DD_Test.TestBuff), length(TKDT256DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT256DD_Test.BuildKDTreeM(length(TKDT256DD_Test.TestBuff), nil, @TKDT256DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT256DD_Test.BuildKDTreeM(length(TKDT256DD_Test.TestBuff), nil, TKDT256DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT256DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT256DD_Test.TestBuff));
  TKDT256DD_Test.Search(TKDT256DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT256DDDistance(TKDT256DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT256DD_Test.Clear;
  { kMean test }
  TKDT256DD_Test.BuildKDTreeWithCluster(TKDT256DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT256DD_Test.Search(TKDT256DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT256DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT256DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT256DD_Test);
end;


function TKDT272DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT272DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT272DD_Node;
  function SortCompare(const p1, p2: PKDT272DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT272DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT272DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT272DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT272DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT272DD.GetData(const index: NativeInt): PKDT272DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT272DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT272DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT272DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT272DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT272DD.StoreBuffPtr: PKDT272DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT272DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT272DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT272DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT272DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT272DD.BuildKDTreeWithCluster(const inBuff: TKDT272DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT272DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT272DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT272DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT272DD.BuildKDTreeWithCluster(const inBuff: TKDT272DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT272DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DD_BuildCall);
var
  TempStoreBuff: TKDT272DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT272DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT272DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT272DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT272DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DD_BuildMethod);
var
  TempStoreBuff: TKDT272DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT272DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT272DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT272DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT272DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT272DD_BuildProc);
var
  TempStoreBuff: TKDT272DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT272DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT272DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT272DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT272DD.Search(const Buff: TKDT272DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT272DD_Node;

var
  NearestNeighbour: PKDT272DD_Node;

  function FindParentNode(const BuffPtr: PKDT272DD_Vec; NodePtr: PKDT272DD_Node): PKDT272DD_Node;
  var
    Next       : PKDT272DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT272DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT272DD_Node; const BuffPtr: PKDT272DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT272DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT272DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT272DD_Vec; const p1, p2: PKDT272DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT272DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT272DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT272DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT272DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT272DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT272DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT272DD_Node(NearestNodes[0]);
    end;
end;

function TKDT272DD.Search(const Buff: TKDT272DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT272DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT272DD.Search(const Buff: TKDT272DD_Vec; var SearchedDistanceMin: Double): PKDT272DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT272DD.Search(const Buff: TKDT272DD_Vec): PKDT272DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT272DD.Search(const inBuff: TKDT272DD_DynamicVecBuffer; var OutBuff: TKDT272DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT272DD_DynamicVecBuffer;
  outBuffPtr : PKDT272DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT272DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT272DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT272DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT272DD.Search(const inBuff: TKDT272DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT272DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT272DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT272DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT272DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT272DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT272DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT272DD_Source));
end;

procedure TKDT272DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT272DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT272DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT272DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT272DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT272DD.PrintNodeTree(const NodePtr: PKDT272DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT272DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT272DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT272DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT272DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT272DD.KDT272DDVec(const s: SystemString): TKDT272DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT272DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT272DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT272DD.KDT272DDVec(const v: TKDT272DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT272DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT272DD.KDT272DDPow(const v: TKDT272DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT272DD.KDT272DDDistance(const v1, v2: TKDT272DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT272DD_Axis - 1 do
      Result := Result + KDT272DDPow(v2[i] - v1[i]);
end;

procedure TKDT272DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT272DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT272DD.Test;
var
  TKDT272DD_Test    : TKDT272DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT272DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT272DD_Test := TKDT272DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT272DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT272DD_Test.TestBuff) - 1 do
    for j := 0 to KDT272DD_Axis - 1 do
        TKDT272DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT272DD_Test.TestBuff), length(TKDT272DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT272DD_Test.BuildKDTreeM(length(TKDT272DD_Test.TestBuff), nil, @TKDT272DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT272DD_Test.BuildKDTreeM(length(TKDT272DD_Test.TestBuff), nil, TKDT272DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT272DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT272DD_Test.TestBuff));
  TKDT272DD_Test.Search(TKDT272DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT272DDDistance(TKDT272DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT272DD_Test.Clear;
  { kMean test }
  TKDT272DD_Test.BuildKDTreeWithCluster(TKDT272DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT272DD_Test.Search(TKDT272DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT272DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT272DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT272DD_Test);
end;


function TKDT288DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT288DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT288DD_Node;
  function SortCompare(const p1, p2: PKDT288DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT288DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT288DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT288DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT288DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT288DD.GetData(const index: NativeInt): PKDT288DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT288DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT288DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT288DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT288DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT288DD.StoreBuffPtr: PKDT288DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT288DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT288DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT288DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT288DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT288DD.BuildKDTreeWithCluster(const inBuff: TKDT288DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT288DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT288DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT288DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT288DD.BuildKDTreeWithCluster(const inBuff: TKDT288DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT288DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DD_BuildCall);
var
  TempStoreBuff: TKDT288DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT288DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT288DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT288DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT288DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DD_BuildMethod);
var
  TempStoreBuff: TKDT288DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT288DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT288DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT288DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT288DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT288DD_BuildProc);
var
  TempStoreBuff: TKDT288DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT288DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT288DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT288DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT288DD.Search(const Buff: TKDT288DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT288DD_Node;

var
  NearestNeighbour: PKDT288DD_Node;

  function FindParentNode(const BuffPtr: PKDT288DD_Vec; NodePtr: PKDT288DD_Node): PKDT288DD_Node;
  var
    Next       : PKDT288DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT288DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT288DD_Node; const BuffPtr: PKDT288DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT288DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT288DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT288DD_Vec; const p1, p2: PKDT288DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT288DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT288DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT288DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT288DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT288DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT288DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT288DD_Node(NearestNodes[0]);
    end;
end;

function TKDT288DD.Search(const Buff: TKDT288DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT288DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT288DD.Search(const Buff: TKDT288DD_Vec; var SearchedDistanceMin: Double): PKDT288DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT288DD.Search(const Buff: TKDT288DD_Vec): PKDT288DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT288DD.Search(const inBuff: TKDT288DD_DynamicVecBuffer; var OutBuff: TKDT288DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT288DD_DynamicVecBuffer;
  outBuffPtr : PKDT288DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT288DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT288DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT288DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT288DD.Search(const inBuff: TKDT288DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT288DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT288DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT288DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT288DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT288DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT288DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT288DD_Source));
end;

procedure TKDT288DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT288DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT288DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT288DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT288DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT288DD.PrintNodeTree(const NodePtr: PKDT288DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT288DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT288DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT288DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT288DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT288DD.KDT288DDVec(const s: SystemString): TKDT288DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT288DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT288DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT288DD.KDT288DDVec(const v: TKDT288DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT288DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT288DD.KDT288DDPow(const v: TKDT288DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT288DD.KDT288DDDistance(const v1, v2: TKDT288DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT288DD_Axis - 1 do
      Result := Result + KDT288DDPow(v2[i] - v1[i]);
end;

procedure TKDT288DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT288DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT288DD.Test;
var
  TKDT288DD_Test    : TKDT288DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT288DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT288DD_Test := TKDT288DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT288DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT288DD_Test.TestBuff) - 1 do
    for j := 0 to KDT288DD_Axis - 1 do
        TKDT288DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT288DD_Test.TestBuff), length(TKDT288DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT288DD_Test.BuildKDTreeM(length(TKDT288DD_Test.TestBuff), nil, @TKDT288DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT288DD_Test.BuildKDTreeM(length(TKDT288DD_Test.TestBuff), nil, TKDT288DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT288DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT288DD_Test.TestBuff));
  TKDT288DD_Test.Search(TKDT288DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT288DDDistance(TKDT288DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT288DD_Test.Clear;
  { kMean test }
  TKDT288DD_Test.BuildKDTreeWithCluster(TKDT288DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT288DD_Test.Search(TKDT288DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT288DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT288DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT288DD_Test);
end;


function TKDT372DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DD_Node;
  function SortCompare(const p1, p2: PKDT372DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT372DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT372DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT372DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT372DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT372DD.GetData(const index: NativeInt): PKDT372DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT372DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT372DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT372DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT372DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT372DD.StoreBuffPtr: PKDT372DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT372DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT372DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT372DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT372DD.BuildKDTreeWithCluster(const inBuff: TKDT372DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT372DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT372DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT372DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT372DD.BuildKDTreeWithCluster(const inBuff: TKDT372DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DD_BuildCall);
var
  TempStoreBuff: TKDT372DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT372DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT372DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT372DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DD_BuildMethod);
var
  TempStoreBuff: TKDT372DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT372DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT372DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT372DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT372DD_BuildProc);
var
  TempStoreBuff: TKDT372DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT372DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT372DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT372DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT372DD.Search(const Buff: TKDT372DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DD_Node;

var
  NearestNeighbour: PKDT372DD_Node;

  function FindParentNode(const BuffPtr: PKDT372DD_Vec; NodePtr: PKDT372DD_Node): PKDT372DD_Node;
  var
    Next       : PKDT372DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT372DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT372DD_Node; const BuffPtr: PKDT372DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT372DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT372DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT372DD_Vec; const p1, p2: PKDT372DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT372DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT372DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT372DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT372DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT372DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT372DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT372DD_Node(NearestNodes[0]);
    end;
end;

function TKDT372DD.Search(const Buff: TKDT372DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT372DD.Search(const Buff: TKDT372DD_Vec; var SearchedDistanceMin: Double): PKDT372DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT372DD.Search(const Buff: TKDT372DD_Vec): PKDT372DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT372DD.Search(const inBuff: TKDT372DD_DynamicVecBuffer; var OutBuff: TKDT372DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT372DD_DynamicVecBuffer;
  outBuffPtr : PKDT372DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT372DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT372DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT372DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT372DD.Search(const inBuff: TKDT372DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT372DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT372DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT372DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT372DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT372DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT372DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT372DD_Source));
end;

procedure TKDT372DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT372DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT372DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT372DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT372DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT372DD.PrintNodeTree(const NodePtr: PKDT372DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT372DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT372DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT372DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT372DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT372DD.KDT372DDVec(const s: SystemString): TKDT372DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT372DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT372DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT372DD.KDT372DDVec(const v: TKDT372DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT372DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT372DD.KDT372DDPow(const v: TKDT372DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT372DD.KDT372DDDistance(const v1, v2: TKDT372DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT372DD_Axis - 1 do
      Result := Result + KDT372DDPow(v2[i] - v1[i]);
end;

procedure TKDT372DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT372DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT372DD.Test;
var
  TKDT372DD_Test    : TKDT372DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT372DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT372DD_Test := TKDT372DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT372DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT372DD_Test.TestBuff) - 1 do
    for j := 0 to KDT372DD_Axis - 1 do
        TKDT372DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT372DD_Test.TestBuff), length(TKDT372DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT372DD_Test.BuildKDTreeM(length(TKDT372DD_Test.TestBuff), nil, @TKDT372DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT372DD_Test.BuildKDTreeM(length(TKDT372DD_Test.TestBuff), nil, TKDT372DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT372DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT372DD_Test.TestBuff));
  TKDT372DD_Test.Search(TKDT372DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT372DDDistance(TKDT372DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT372DD_Test.Clear;
  { kMean test }
  TKDT372DD_Test.BuildKDTreeWithCluster(TKDT372DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT372DD_Test.Search(TKDT372DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT372DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT372DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT372DD_Test);
end;


function TKDT512DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DD_Node;
  function SortCompare(const p1, p2: PKDT512DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT512DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT512DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT512DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT512DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT512DD.GetData(const index: NativeInt): PKDT512DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT512DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT512DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT512DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT512DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT512DD.StoreBuffPtr: PKDT512DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT512DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT512DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT512DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT512DD.BuildKDTreeWithCluster(const inBuff: TKDT512DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT512DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT512DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT512DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT512DD.BuildKDTreeWithCluster(const inBuff: TKDT512DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DD_BuildCall);
var
  TempStoreBuff: TKDT512DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT512DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DD_BuildMethod);
var
  TempStoreBuff: TKDT512DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT512DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT512DD_BuildProc);
var
  TempStoreBuff: TKDT512DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT512DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT512DD.Search(const Buff: TKDT512DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DD_Node;

var
  NearestNeighbour: PKDT512DD_Node;

  function FindParentNode(const BuffPtr: PKDT512DD_Vec; NodePtr: PKDT512DD_Node): PKDT512DD_Node;
  var
    Next       : PKDT512DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT512DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT512DD_Node; const BuffPtr: PKDT512DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT512DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT512DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT512DD_Vec; const p1, p2: PKDT512DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT512DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT512DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT512DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT512DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT512DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT512DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT512DD_Node(NearestNodes[0]);
    end;
end;

function TKDT512DD.Search(const Buff: TKDT512DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT512DD.Search(const Buff: TKDT512DD_Vec; var SearchedDistanceMin: Double): PKDT512DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT512DD.Search(const Buff: TKDT512DD_Vec): PKDT512DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT512DD.Search(const inBuff: TKDT512DD_DynamicVecBuffer; var OutBuff: TKDT512DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT512DD_DynamicVecBuffer;
  outBuffPtr : PKDT512DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT512DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT512DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DD.Search(const inBuff: TKDT512DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT512DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT512DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT512DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT512DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT512DD_Source));
end;

procedure TKDT512DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT512DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT512DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT512DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DD.PrintNodeTree(const NodePtr: PKDT512DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT512DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT512DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT512DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT512DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT512DD.KDT512DDVec(const s: SystemString): TKDT512DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT512DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT512DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT512DD.KDT512DDVec(const v: TKDT512DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT512DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT512DD.KDT512DDPow(const v: TKDT512DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT512DD.KDT512DDDistance(const v1, v2: TKDT512DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT512DD_Axis - 1 do
      Result := Result + KDT512DDPow(v2[i] - v1[i]);
end;

procedure TKDT512DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT512DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT512DD.Test;
var
  TKDT512DD_Test    : TKDT512DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT512DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT512DD_Test := TKDT512DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT512DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT512DD_Test.TestBuff) - 1 do
    for j := 0 to KDT512DD_Axis - 1 do
        TKDT512DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT512DD_Test.TestBuff), length(TKDT512DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT512DD_Test.BuildKDTreeM(length(TKDT512DD_Test.TestBuff), nil, @TKDT512DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT512DD_Test.BuildKDTreeM(length(TKDT512DD_Test.TestBuff), nil, TKDT512DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT512DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT512DD_Test.TestBuff));
  TKDT512DD_Test.Search(TKDT512DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT512DDDistance(TKDT512DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT512DD_Test.Clear;
  { kMean test }
  TKDT512DD_Test.BuildKDTreeWithCluster(TKDT512DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT512DD_Test.Search(TKDT512DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT512DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT512DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT512DD_Test);
end;


function TKDT576DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT576DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT576DD_Node;
  function SortCompare(const p1, p2: PKDT576DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT576DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT576DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT576DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT576DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT576DD.GetData(const index: NativeInt): PKDT576DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT576DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT576DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT576DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT576DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT576DD.StoreBuffPtr: PKDT576DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT576DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT576DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT576DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT576DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT576DD.BuildKDTreeWithCluster(const inBuff: TKDT576DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT576DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT576DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT576DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT576DD.BuildKDTreeWithCluster(const inBuff: TKDT576DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT576DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DD_BuildCall);
var
  TempStoreBuff: TKDT576DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT576DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT576DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT576DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT576DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DD_BuildMethod);
var
  TempStoreBuff: TKDT576DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT576DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT576DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT576DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT576DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT576DD_BuildProc);
var
  TempStoreBuff: TKDT576DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT576DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT576DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT576DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT576DD.Search(const Buff: TKDT576DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT576DD_Node;

var
  NearestNeighbour: PKDT576DD_Node;

  function FindParentNode(const BuffPtr: PKDT576DD_Vec; NodePtr: PKDT576DD_Node): PKDT576DD_Node;
  var
    Next       : PKDT576DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT576DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT576DD_Node; const BuffPtr: PKDT576DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT576DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT576DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT576DD_Vec; const p1, p2: PKDT576DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT576DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT576DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT576DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT576DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT576DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT576DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT576DD_Node(NearestNodes[0]);
    end;
end;

function TKDT576DD.Search(const Buff: TKDT576DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT576DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT576DD.Search(const Buff: TKDT576DD_Vec; var SearchedDistanceMin: Double): PKDT576DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT576DD.Search(const Buff: TKDT576DD_Vec): PKDT576DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT576DD.Search(const inBuff: TKDT576DD_DynamicVecBuffer; var OutBuff: TKDT576DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT576DD_DynamicVecBuffer;
  outBuffPtr : PKDT576DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT576DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT576DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT576DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT576DD.Search(const inBuff: TKDT576DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT576DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT576DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT576DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT576DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT576DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT576DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT576DD_Source));
end;

procedure TKDT576DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT576DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT576DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT576DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT576DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT576DD.PrintNodeTree(const NodePtr: PKDT576DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT576DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT576DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT576DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT576DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT576DD.KDT576DDVec(const s: SystemString): TKDT576DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT576DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT576DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT576DD.KDT576DDVec(const v: TKDT576DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT576DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT576DD.KDT576DDPow(const v: TKDT576DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT576DD.KDT576DDDistance(const v1, v2: TKDT576DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT576DD_Axis - 1 do
      Result := Result + KDT576DDPow(v2[i] - v1[i]);
end;

procedure TKDT576DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT576DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT576DD.Test;
var
  TKDT576DD_Test    : TKDT576DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT576DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT576DD_Test := TKDT576DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT576DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT576DD_Test.TestBuff) - 1 do
    for j := 0 to KDT576DD_Axis - 1 do
        TKDT576DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT576DD_Test.TestBuff), length(TKDT576DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT576DD_Test.BuildKDTreeM(length(TKDT576DD_Test.TestBuff), nil, @TKDT576DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT576DD_Test.BuildKDTreeM(length(TKDT576DD_Test.TestBuff), nil, TKDT576DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT576DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT576DD_Test.TestBuff));
  TKDT576DD_Test.Search(TKDT576DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT576DDDistance(TKDT576DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT576DD_Test.Clear;
  { kMean test }
  TKDT576DD_Test.BuildKDTreeWithCluster(TKDT576DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT576DD_Test.Search(TKDT576DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT576DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT576DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT576DD_Test);
end;


function TKDT768DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DD_Node;
  function SortCompare(const p1, p2: PKDT768DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT768DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT768DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT768DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT768DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT768DD.GetData(const index: NativeInt): PKDT768DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT768DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT768DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT768DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT768DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT768DD.StoreBuffPtr: PKDT768DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT768DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT768DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT768DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT768DD.BuildKDTreeWithCluster(const inBuff: TKDT768DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT768DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT768DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT768DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT768DD.BuildKDTreeWithCluster(const inBuff: TKDT768DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DD_BuildCall);
var
  TempStoreBuff: TKDT768DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT768DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT768DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT768DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DD_BuildMethod);
var
  TempStoreBuff: TKDT768DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT768DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT768DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT768DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT768DD_BuildProc);
var
  TempStoreBuff: TKDT768DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT768DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT768DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT768DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT768DD.Search(const Buff: TKDT768DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DD_Node;

var
  NearestNeighbour: PKDT768DD_Node;

  function FindParentNode(const BuffPtr: PKDT768DD_Vec; NodePtr: PKDT768DD_Node): PKDT768DD_Node;
  var
    Next       : PKDT768DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT768DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT768DD_Node; const BuffPtr: PKDT768DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT768DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT768DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT768DD_Vec; const p1, p2: PKDT768DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT768DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT768DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT768DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT768DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT768DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT768DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT768DD_Node(NearestNodes[0]);
    end;
end;

function TKDT768DD.Search(const Buff: TKDT768DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT768DD.Search(const Buff: TKDT768DD_Vec; var SearchedDistanceMin: Double): PKDT768DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT768DD.Search(const Buff: TKDT768DD_Vec): PKDT768DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT768DD.Search(const inBuff: TKDT768DD_DynamicVecBuffer; var OutBuff: TKDT768DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT768DD_DynamicVecBuffer;
  outBuffPtr : PKDT768DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT768DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT768DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT768DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT768DD.Search(const inBuff: TKDT768DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT768DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT768DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT768DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT768DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT768DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT768DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT768DD_Source));
end;

procedure TKDT768DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT768DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT768DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT768DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT768DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT768DD.PrintNodeTree(const NodePtr: PKDT768DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT768DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT768DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT768DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT768DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT768DD.KDT768DDVec(const s: SystemString): TKDT768DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT768DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT768DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT768DD.KDT768DDVec(const v: TKDT768DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT768DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT768DD.KDT768DDPow(const v: TKDT768DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT768DD.KDT768DDDistance(const v1, v2: TKDT768DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT768DD_Axis - 1 do
      Result := Result + KDT768DDPow(v2[i] - v1[i]);
end;

procedure TKDT768DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT768DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT768DD.Test;
var
  TKDT768DD_Test    : TKDT768DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT768DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT768DD_Test := TKDT768DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT768DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT768DD_Test.TestBuff) - 1 do
    for j := 0 to KDT768DD_Axis - 1 do
        TKDT768DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT768DD_Test.TestBuff), length(TKDT768DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT768DD_Test.BuildKDTreeM(length(TKDT768DD_Test.TestBuff), nil, @TKDT768DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT768DD_Test.BuildKDTreeM(length(TKDT768DD_Test.TestBuff), nil, TKDT768DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT768DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT768DD_Test.TestBuff));
  TKDT768DD_Test.Search(TKDT768DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT768DDDistance(TKDT768DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT768DD_Test.Clear;
  { kMean test }
  TKDT768DD_Test.BuildKDTreeWithCluster(TKDT768DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT768DD_Test.Search(TKDT768DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT768DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT768DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT768DD_Test);
end;


function TKDT1024DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DD_Node;
  function SortCompare(const p1, p2: PKDT1024DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1024DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1024DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1024DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1024DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1024DD.GetData(const index: NativeInt): PKDT1024DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1024DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1024DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1024DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1024DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1024DD.StoreBuffPtr: PKDT1024DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1024DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1024DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1024DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1024DD.BuildKDTreeWithCluster(const inBuff: TKDT1024DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1024DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1024DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1024DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1024DD.BuildKDTreeWithCluster(const inBuff: TKDT1024DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DD_BuildCall);
var
  TempStoreBuff: TKDT1024DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1024DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DD_BuildMethod);
var
  TempStoreBuff: TKDT1024DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1024DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1024DD_BuildProc);
var
  TempStoreBuff: TKDT1024DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1024DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1024DD.Search(const Buff: TKDT1024DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DD_Node;

var
  NearestNeighbour: PKDT1024DD_Node;

  function FindParentNode(const BuffPtr: PKDT1024DD_Vec; NodePtr: PKDT1024DD_Node): PKDT1024DD_Node;
  var
    Next       : PKDT1024DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1024DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1024DD_Node; const BuffPtr: PKDT1024DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1024DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1024DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1024DD_Vec; const p1, p2: PKDT1024DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1024DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1024DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1024DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1024DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1024DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1024DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1024DD_Node(NearestNodes[0]);
    end;
end;

function TKDT1024DD.Search(const Buff: TKDT1024DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1024DD.Search(const Buff: TKDT1024DD_Vec; var SearchedDistanceMin: Double): PKDT1024DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1024DD.Search(const Buff: TKDT1024DD_Vec): PKDT1024DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1024DD.Search(const inBuff: TKDT1024DD_DynamicVecBuffer; var OutBuff: TKDT1024DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1024DD_DynamicVecBuffer;
  outBuffPtr : PKDT1024DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1024DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1024DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DD.Search(const inBuff: TKDT1024DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1024DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1024DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1024DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1024DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1024DD_Source));
end;

procedure TKDT1024DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1024DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1024DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1024DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DD.PrintNodeTree(const NodePtr: PKDT1024DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT1024DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1024DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1024DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1024DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1024DD.KDT1024DDVec(const s: SystemString): TKDT1024DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1024DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1024DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1024DD.KDT1024DDVec(const v: TKDT1024DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1024DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1024DD.KDT1024DDPow(const v: TKDT1024DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1024DD.KDT1024DDDistance(const v1, v2: TKDT1024DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1024DD_Axis - 1 do
      Result := Result + KDT1024DDPow(v2[i] - v1[i]);
end;

procedure TKDT1024DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1024DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1024DD.Test;
var
  TKDT1024DD_Test    : TKDT1024DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1024DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1024DD_Test := TKDT1024DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1024DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT1024DD_Test.TestBuff) - 1 do
    for j := 0 to KDT1024DD_Axis - 1 do
        TKDT1024DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1024DD_Test.TestBuff), length(TKDT1024DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1024DD_Test.BuildKDTreeM(length(TKDT1024DD_Test.TestBuff), nil, @TKDT1024DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1024DD_Test.BuildKDTreeM(length(TKDT1024DD_Test.TestBuff), nil, TKDT1024DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1024DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1024DD_Test.TestBuff));
  TKDT1024DD_Test.Search(TKDT1024DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1024DDDistance(TKDT1024DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1024DD_Test.Clear;
  { kMean test }
  TKDT1024DD_Test.BuildKDTreeWithCluster(TKDT1024DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1024DD_Test.Search(TKDT1024DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1024DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1024DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1024DD_Test);
end;


function TKDT1040DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1040DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1040DD_Node;
  function SortCompare(const p1, p2: PKDT1040DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1040DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1040DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1040DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1040DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1040DD.GetData(const index: NativeInt): PKDT1040DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1040DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1040DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1040DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1040DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1040DD.StoreBuffPtr: PKDT1040DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1040DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1040DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1040DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1040DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1040DD.BuildKDTreeWithCluster(const inBuff: TKDT1040DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1040DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1040DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1040DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1040DD.BuildKDTreeWithCluster(const inBuff: TKDT1040DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1040DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DD_BuildCall);
var
  TempStoreBuff: TKDT1040DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1040DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1040DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1040DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1040DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DD_BuildMethod);
var
  TempStoreBuff: TKDT1040DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1040DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1040DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1040DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1040DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1040DD_BuildProc);
var
  TempStoreBuff: TKDT1040DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1040DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1040DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1040DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1040DD.Search(const Buff: TKDT1040DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1040DD_Node;

var
  NearestNeighbour: PKDT1040DD_Node;

  function FindParentNode(const BuffPtr: PKDT1040DD_Vec; NodePtr: PKDT1040DD_Node): PKDT1040DD_Node;
  var
    Next       : PKDT1040DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1040DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1040DD_Node; const BuffPtr: PKDT1040DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1040DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1040DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1040DD_Vec; const p1, p2: PKDT1040DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1040DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1040DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1040DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1040DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1040DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1040DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1040DD_Node(NearestNodes[0]);
    end;
end;

function TKDT1040DD.Search(const Buff: TKDT1040DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1040DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1040DD.Search(const Buff: TKDT1040DD_Vec; var SearchedDistanceMin: Double): PKDT1040DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1040DD.Search(const Buff: TKDT1040DD_Vec): PKDT1040DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1040DD.Search(const inBuff: TKDT1040DD_DynamicVecBuffer; var OutBuff: TKDT1040DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1040DD_DynamicVecBuffer;
  outBuffPtr : PKDT1040DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1040DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1040DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1040DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1040DD.Search(const inBuff: TKDT1040DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1040DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1040DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1040DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1040DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1040DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1040DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1040DD_Source));
end;

procedure TKDT1040DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1040DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1040DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1040DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1040DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1040DD.PrintNodeTree(const NodePtr: PKDT1040DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT1040DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1040DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1040DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1040DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1040DD.KDT1040DDVec(const s: SystemString): TKDT1040DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1040DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1040DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1040DD.KDT1040DDVec(const v: TKDT1040DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1040DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1040DD.KDT1040DDPow(const v: TKDT1040DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1040DD.KDT1040DDDistance(const v1, v2: TKDT1040DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1040DD_Axis - 1 do
      Result := Result + KDT1040DDPow(v2[i] - v1[i]);
end;

procedure TKDT1040DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1040DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1040DD.Test;
var
  TKDT1040DD_Test    : TKDT1040DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1040DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1040DD_Test := TKDT1040DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1040DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT1040DD_Test.TestBuff) - 1 do
    for j := 0 to KDT1040DD_Axis - 1 do
        TKDT1040DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1040DD_Test.TestBuff), length(TKDT1040DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1040DD_Test.BuildKDTreeM(length(TKDT1040DD_Test.TestBuff), nil, @TKDT1040DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1040DD_Test.BuildKDTreeM(length(TKDT1040DD_Test.TestBuff), nil, TKDT1040DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1040DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1040DD_Test.TestBuff));
  TKDT1040DD_Test.Search(TKDT1040DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1040DDDistance(TKDT1040DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1040DD_Test.Clear;
  { kMean test }
  TKDT1040DD_Test.BuildKDTreeWithCluster(TKDT1040DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1040DD_Test.Search(TKDT1040DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1040DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1040DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1040DD_Test);
end;


function TKDT1056DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1056DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1056DD_Node;
  function SortCompare(const p1, p2: PKDT1056DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1056DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1056DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1056DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1056DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1056DD.GetData(const index: NativeInt): PKDT1056DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1056DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1056DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1056DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1056DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1056DD.StoreBuffPtr: PKDT1056DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1056DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1056DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1056DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1056DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1056DD.BuildKDTreeWithCluster(const inBuff: TKDT1056DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1056DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1056DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1056DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1056DD.BuildKDTreeWithCluster(const inBuff: TKDT1056DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1056DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DD_BuildCall);
var
  TempStoreBuff: TKDT1056DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1056DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1056DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1056DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1056DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DD_BuildMethod);
var
  TempStoreBuff: TKDT1056DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1056DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1056DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1056DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1056DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1056DD_BuildProc);
var
  TempStoreBuff: TKDT1056DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1056DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1056DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1056DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1056DD.Search(const Buff: TKDT1056DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1056DD_Node;

var
  NearestNeighbour: PKDT1056DD_Node;

  function FindParentNode(const BuffPtr: PKDT1056DD_Vec; NodePtr: PKDT1056DD_Node): PKDT1056DD_Node;
  var
    Next       : PKDT1056DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1056DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1056DD_Node; const BuffPtr: PKDT1056DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1056DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1056DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1056DD_Vec; const p1, p2: PKDT1056DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1056DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1056DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1056DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1056DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1056DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1056DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1056DD_Node(NearestNodes[0]);
    end;
end;

function TKDT1056DD.Search(const Buff: TKDT1056DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1056DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1056DD.Search(const Buff: TKDT1056DD_Vec; var SearchedDistanceMin: Double): PKDT1056DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1056DD.Search(const Buff: TKDT1056DD_Vec): PKDT1056DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1056DD.Search(const inBuff: TKDT1056DD_DynamicVecBuffer; var OutBuff: TKDT1056DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1056DD_DynamicVecBuffer;
  outBuffPtr : PKDT1056DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1056DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1056DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1056DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1056DD.Search(const inBuff: TKDT1056DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1056DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1056DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1056DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1056DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1056DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1056DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1056DD_Source));
end;

procedure TKDT1056DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1056DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1056DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1056DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1056DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1056DD.PrintNodeTree(const NodePtr: PKDT1056DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT1056DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1056DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1056DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1056DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1056DD.KDT1056DDVec(const s: SystemString): TKDT1056DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1056DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1056DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1056DD.KDT1056DDVec(const v: TKDT1056DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1056DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1056DD.KDT1056DDPow(const v: TKDT1056DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1056DD.KDT1056DDDistance(const v1, v2: TKDT1056DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1056DD_Axis - 1 do
      Result := Result + KDT1056DDPow(v2[i] - v1[i]);
end;

procedure TKDT1056DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1056DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1056DD.Test;
var
  TKDT1056DD_Test    : TKDT1056DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1056DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1056DD_Test := TKDT1056DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1056DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT1056DD_Test.TestBuff) - 1 do
    for j := 0 to KDT1056DD_Axis - 1 do
        TKDT1056DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1056DD_Test.TestBuff), length(TKDT1056DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1056DD_Test.BuildKDTreeM(length(TKDT1056DD_Test.TestBuff), nil, @TKDT1056DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1056DD_Test.BuildKDTreeM(length(TKDT1056DD_Test.TestBuff), nil, TKDT1056DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1056DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1056DD_Test.TestBuff));
  TKDT1056DD_Test.Search(TKDT1056DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1056DDDistance(TKDT1056DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1056DD_Test.Clear;
  { kMean test }
  TKDT1056DD_Test.BuildKDTreeWithCluster(TKDT1056DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1056DD_Test.Search(TKDT1056DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1056DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1056DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1056DD_Test);
end;


function TKDT1536DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DD_Node;
  function SortCompare(const p1, p2: PKDT1536DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1536DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1536DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1536DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1536DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1536DD.GetData(const index: NativeInt): PKDT1536DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1536DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1536DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1536DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1536DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1536DD.StoreBuffPtr: PKDT1536DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1536DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1536DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1536DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1536DD.BuildKDTreeWithCluster(const inBuff: TKDT1536DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1536DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1536DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1536DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1536DD.BuildKDTreeWithCluster(const inBuff: TKDT1536DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DD_BuildCall);
var
  TempStoreBuff: TKDT1536DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1536DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1536DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1536DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DD_BuildMethod);
var
  TempStoreBuff: TKDT1536DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1536DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1536DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1536DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1536DD_BuildProc);
var
  TempStoreBuff: TKDT1536DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1536DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1536DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1536DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1536DD.Search(const Buff: TKDT1536DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DD_Node;

var
  NearestNeighbour: PKDT1536DD_Node;

  function FindParentNode(const BuffPtr: PKDT1536DD_Vec; NodePtr: PKDT1536DD_Node): PKDT1536DD_Node;
  var
    Next       : PKDT1536DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1536DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1536DD_Node; const BuffPtr: PKDT1536DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1536DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1536DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1536DD_Vec; const p1, p2: PKDT1536DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1536DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1536DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1536DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1536DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1536DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1536DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1536DD_Node(NearestNodes[0]);
    end;
end;

function TKDT1536DD.Search(const Buff: TKDT1536DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1536DD.Search(const Buff: TKDT1536DD_Vec; var SearchedDistanceMin: Double): PKDT1536DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1536DD.Search(const Buff: TKDT1536DD_Vec): PKDT1536DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1536DD.Search(const inBuff: TKDT1536DD_DynamicVecBuffer; var OutBuff: TKDT1536DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1536DD_DynamicVecBuffer;
  outBuffPtr : PKDT1536DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1536DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1536DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1536DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1536DD.Search(const inBuff: TKDT1536DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1536DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1536DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1536DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1536DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1536DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1536DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1536DD_Source));
end;

procedure TKDT1536DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1536DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1536DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1536DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1536DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1536DD.PrintNodeTree(const NodePtr: PKDT1536DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT1536DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1536DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1536DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1536DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1536DD.KDT1536DDVec(const s: SystemString): TKDT1536DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1536DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1536DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1536DD.KDT1536DDVec(const v: TKDT1536DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1536DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1536DD.KDT1536DDPow(const v: TKDT1536DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1536DD.KDT1536DDDistance(const v1, v2: TKDT1536DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1536DD_Axis - 1 do
      Result := Result + KDT1536DDPow(v2[i] - v1[i]);
end;

procedure TKDT1536DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1536DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1536DD.Test;
var
  TKDT1536DD_Test    : TKDT1536DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1536DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1536DD_Test := TKDT1536DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1536DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT1536DD_Test.TestBuff) - 1 do
    for j := 0 to KDT1536DD_Axis - 1 do
        TKDT1536DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1536DD_Test.TestBuff), length(TKDT1536DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1536DD_Test.BuildKDTreeM(length(TKDT1536DD_Test.TestBuff), nil, @TKDT1536DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1536DD_Test.BuildKDTreeM(length(TKDT1536DD_Test.TestBuff), nil, TKDT1536DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1536DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1536DD_Test.TestBuff));
  TKDT1536DD_Test.Search(TKDT1536DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1536DDDistance(TKDT1536DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1536DD_Test.Clear;
  { kMean test }
  TKDT1536DD_Test.BuildKDTreeWithCluster(TKDT1536DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1536DD_Test.Search(TKDT1536DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1536DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1536DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1536DD_Test);
end;


function TKDT1920DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DD_Node;
  function SortCompare(const p1, p2: PKDT1920DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1920DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1920DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1920DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1920DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1920DD.GetData(const index: NativeInt): PKDT1920DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1920DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1920DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1920DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1920DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1920DD.StoreBuffPtr: PKDT1920DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1920DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1920DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1920DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1920DD.BuildKDTreeWithCluster(const inBuff: TKDT1920DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1920DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1920DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1920DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1920DD.BuildKDTreeWithCluster(const inBuff: TKDT1920DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DD_BuildCall);
var
  TempStoreBuff: TKDT1920DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1920DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1920DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1920DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DD_BuildMethod);
var
  TempStoreBuff: TKDT1920DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1920DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1920DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1920DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1920DD_BuildProc);
var
  TempStoreBuff: TKDT1920DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1920DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1920DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1920DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1920DD.Search(const Buff: TKDT1920DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DD_Node;

var
  NearestNeighbour: PKDT1920DD_Node;

  function FindParentNode(const BuffPtr: PKDT1920DD_Vec; NodePtr: PKDT1920DD_Node): PKDT1920DD_Node;
  var
    Next       : PKDT1920DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1920DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1920DD_Node; const BuffPtr: PKDT1920DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1920DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1920DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1920DD_Vec; const p1, p2: PKDT1920DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1920DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1920DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1920DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1920DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1920DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1920DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1920DD_Node(NearestNodes[0]);
    end;
end;

function TKDT1920DD.Search(const Buff: TKDT1920DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1920DD.Search(const Buff: TKDT1920DD_Vec; var SearchedDistanceMin: Double): PKDT1920DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1920DD.Search(const Buff: TKDT1920DD_Vec): PKDT1920DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1920DD.Search(const inBuff: TKDT1920DD_DynamicVecBuffer; var OutBuff: TKDT1920DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1920DD_DynamicVecBuffer;
  outBuffPtr : PKDT1920DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1920DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1920DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1920DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1920DD.Search(const inBuff: TKDT1920DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1920DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1920DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1920DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1920DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1920DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1920DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1920DD_Source));
end;

procedure TKDT1920DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1920DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1920DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1920DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1920DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1920DD.PrintNodeTree(const NodePtr: PKDT1920DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT1920DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1920DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1920DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1920DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1920DD.KDT1920DDVec(const s: SystemString): TKDT1920DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1920DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1920DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1920DD.KDT1920DDVec(const v: TKDT1920DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1920DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1920DD.KDT1920DDPow(const v: TKDT1920DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1920DD.KDT1920DDDistance(const v1, v2: TKDT1920DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1920DD_Axis - 1 do
      Result := Result + KDT1920DDPow(v2[i] - v1[i]);
end;

procedure TKDT1920DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1920DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1920DD.Test;
var
  TKDT1920DD_Test    : TKDT1920DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1920DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1920DD_Test := TKDT1920DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1920DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT1920DD_Test.TestBuff) - 1 do
    for j := 0 to KDT1920DD_Axis - 1 do
        TKDT1920DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1920DD_Test.TestBuff), length(TKDT1920DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1920DD_Test.BuildKDTreeM(length(TKDT1920DD_Test.TestBuff), nil, @TKDT1920DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1920DD_Test.BuildKDTreeM(length(TKDT1920DD_Test.TestBuff), nil, TKDT1920DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1920DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1920DD_Test.TestBuff));
  TKDT1920DD_Test.Search(TKDT1920DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1920DDDistance(TKDT1920DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1920DD_Test.Clear;
  { kMean test }
  TKDT1920DD_Test.BuildKDTreeWithCluster(TKDT1920DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1920DD_Test.Search(TKDT1920DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1920DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1920DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1920DD_Test);
end;


function TKDT1980DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1980DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1980DD_Node;
  function SortCompare(const p1, p2: PKDT1980DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1980DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1980DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1980DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1980DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1980DD.GetData(const index: NativeInt): PKDT1980DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1980DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1980DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1980DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1980DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1980DD.StoreBuffPtr: PKDT1980DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1980DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1980DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1980DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT1980DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1980DD.BuildKDTreeWithCluster(const inBuff: TKDT1980DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1980DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1980DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1980DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1980DD.BuildKDTreeWithCluster(const inBuff: TKDT1980DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1980DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DD_BuildCall);
var
  TempStoreBuff: TKDT1980DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1980DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1980DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1980DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1980DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DD_BuildMethod);
var
  TempStoreBuff: TKDT1980DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1980DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1980DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1980DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT1980DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT1980DD_BuildProc);
var
  TempStoreBuff: TKDT1980DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1980DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1980DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1980DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT1980DD.Search(const Buff: TKDT1980DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1980DD_Node;

var
  NearestNeighbour: PKDT1980DD_Node;

  function FindParentNode(const BuffPtr: PKDT1980DD_Vec; NodePtr: PKDT1980DD_Node): PKDT1980DD_Node;
  var
    Next       : PKDT1980DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1980DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1980DD_Node; const BuffPtr: PKDT1980DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1980DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1980DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1980DD_Vec; const p1, p2: PKDT1980DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1980DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1980DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1980DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1980DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1980DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1980DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1980DD_Node(NearestNodes[0]);
    end;
end;

function TKDT1980DD.Search(const Buff: TKDT1980DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1980DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1980DD.Search(const Buff: TKDT1980DD_Vec; var SearchedDistanceMin: Double): PKDT1980DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1980DD.Search(const Buff: TKDT1980DD_Vec): PKDT1980DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1980DD.Search(const inBuff: TKDT1980DD_DynamicVecBuffer; var OutBuff: TKDT1980DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1980DD_DynamicVecBuffer;
  outBuffPtr : PKDT1980DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1980DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1980DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1980DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1980DD.Search(const inBuff: TKDT1980DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1980DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1980DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1980DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1980DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1980DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1980DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1980DD_Source));
end;

procedure TKDT1980DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1980DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1980DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1980DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1980DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1980DD.PrintNodeTree(const NodePtr: PKDT1980DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT1980DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1980DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1980DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1980DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1980DD.KDT1980DDVec(const s: SystemString): TKDT1980DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1980DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1980DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1980DD.KDT1980DDVec(const v: TKDT1980DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1980DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT1980DD.KDT1980DDPow(const v: TKDT1980DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1980DD.KDT1980DDDistance(const v1, v2: TKDT1980DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1980DD_Axis - 1 do
      Result := Result + KDT1980DDPow(v2[i] - v1[i]);
end;

procedure TKDT1980DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1980DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1980DD.Test;
var
  TKDT1980DD_Test    : TKDT1980DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1980DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1980DD_Test := TKDT1980DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1980DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT1980DD_Test.TestBuff) - 1 do
    for j := 0 to KDT1980DD_Axis - 1 do
        TKDT1980DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT1980DD_Test.TestBuff), length(TKDT1980DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1980DD_Test.BuildKDTreeM(length(TKDT1980DD_Test.TestBuff), nil, @TKDT1980DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1980DD_Test.BuildKDTreeM(length(TKDT1980DD_Test.TestBuff), nil, TKDT1980DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1980DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1980DD_Test.TestBuff));
  TKDT1980DD_Test.Search(TKDT1980DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1980DDDistance(TKDT1980DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1980DD_Test.Clear;
  { kMean test }
  TKDT1980DD_Test.BuildKDTreeWithCluster(TKDT1980DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1980DD_Test.Search(TKDT1980DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1980DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1980DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1980DD_Test);
end;


function TKDT2048DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DD_Node;
  function SortCompare(const p1, p2: PKDT2048DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2048DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2048DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2048DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT2048DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2048DD.GetData(const index: NativeInt): PKDT2048DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2048DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2048DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2048DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2048DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2048DD.StoreBuffPtr: PKDT2048DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2048DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2048DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT2048DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2048DD.BuildKDTreeWithCluster(const inBuff: TKDT2048DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT2048DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT2048DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT2048DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2048DD.BuildKDTreeWithCluster(const inBuff: TKDT2048DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DD_BuildCall);
var
  TempStoreBuff: TKDT2048DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2048DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2048DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2048DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DD_BuildMethod);
var
  TempStoreBuff: TKDT2048DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2048DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2048DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2048DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT2048DD_BuildProc);
var
  TempStoreBuff: TKDT2048DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2048DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2048DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2048DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT2048DD.Search(const Buff: TKDT2048DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DD_Node;

var
  NearestNeighbour: PKDT2048DD_Node;

  function FindParentNode(const BuffPtr: PKDT2048DD_Vec; NodePtr: PKDT2048DD_Node): PKDT2048DD_Node;
  var
    Next       : PKDT2048DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT2048DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2048DD_Node; const BuffPtr: PKDT2048DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2048DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT2048DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2048DD_Vec; const p1, p2: PKDT2048DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2048DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2048DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2048DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2048DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2048DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2048DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2048DD_Node(NearestNodes[0]);
    end;
end;

function TKDT2048DD.Search(const Buff: TKDT2048DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2048DD.Search(const Buff: TKDT2048DD_Vec; var SearchedDistanceMin: Double): PKDT2048DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2048DD.Search(const Buff: TKDT2048DD_Vec): PKDT2048DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2048DD.Search(const inBuff: TKDT2048DD_DynamicVecBuffer; var OutBuff: TKDT2048DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2048DD_DynamicVecBuffer;
  outBuffPtr : PKDT2048DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2048DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2048DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2048DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2048DD.Search(const inBuff: TKDT2048DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2048DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2048DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2048DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2048DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2048DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT2048DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2048DD_Source));
end;

procedure TKDT2048DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT2048DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2048DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2048DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2048DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2048DD.PrintNodeTree(const NodePtr: PKDT2048DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT2048DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2048DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2048DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2048DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT2048DD.KDT2048DDVec(const s: SystemString): TKDT2048DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT2048DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT2048DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT2048DD.KDT2048DDVec(const v: TKDT2048DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT2048DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT2048DD.KDT2048DDPow(const v: TKDT2048DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT2048DD.KDT2048DDDistance(const v1, v2: TKDT2048DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT2048DD_Axis - 1 do
      Result := Result + KDT2048DDPow(v2[i] - v1[i]);
end;

procedure TKDT2048DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2048DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2048DD.Test;
var
  TKDT2048DD_Test    : TKDT2048DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2048DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2048DD_Test := TKDT2048DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2048DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT2048DD_Test.TestBuff) - 1 do
    for j := 0 to KDT2048DD_Axis - 1 do
        TKDT2048DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT2048DD_Test.TestBuff), length(TKDT2048DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2048DD_Test.BuildKDTreeM(length(TKDT2048DD_Test.TestBuff), nil, @TKDT2048DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2048DD_Test.BuildKDTreeM(length(TKDT2048DD_Test.TestBuff), nil, TKDT2048DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2048DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2048DD_Test.TestBuff));
  TKDT2048DD_Test.Search(TKDT2048DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2048DDDistance(TKDT2048DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2048DD_Test.Clear;
  { kMean test }
  TKDT2048DD_Test.BuildKDTreeWithCluster(TKDT2048DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2048DD_Test.Search(TKDT2048DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2048DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2048DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2048DD_Test);
end;


function TKDT3072DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DD_Node;
  function SortCompare(const p1, p2: PKDT3072DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3072DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3072DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3072DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3072DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3072DD.GetData(const index: NativeInt): PKDT3072DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3072DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3072DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3072DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3072DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3072DD.StoreBuffPtr: PKDT3072DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3072DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3072DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3072DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3072DD.BuildKDTreeWithCluster(const inBuff: TKDT3072DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3072DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3072DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3072DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3072DD.BuildKDTreeWithCluster(const inBuff: TKDT3072DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DD_BuildCall);
var
  TempStoreBuff: TKDT3072DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3072DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3072DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3072DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DD_BuildMethod);
var
  TempStoreBuff: TKDT3072DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3072DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3072DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3072DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3072DD_BuildProc);
var
  TempStoreBuff: TKDT3072DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3072DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3072DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3072DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT3072DD.Search(const Buff: TKDT3072DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DD_Node;

var
  NearestNeighbour: PKDT3072DD_Node;

  function FindParentNode(const BuffPtr: PKDT3072DD_Vec; NodePtr: PKDT3072DD_Node): PKDT3072DD_Node;
  var
    Next       : PKDT3072DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3072DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3072DD_Node; const BuffPtr: PKDT3072DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3072DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3072DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3072DD_Vec; const p1, p2: PKDT3072DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3072DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3072DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3072DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3072DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3072DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3072DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3072DD_Node(NearestNodes[0]);
    end;
end;

function TKDT3072DD.Search(const Buff: TKDT3072DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3072DD.Search(const Buff: TKDT3072DD_Vec; var SearchedDistanceMin: Double): PKDT3072DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3072DD.Search(const Buff: TKDT3072DD_Vec): PKDT3072DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3072DD.Search(const inBuff: TKDT3072DD_DynamicVecBuffer; var OutBuff: TKDT3072DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3072DD_DynamicVecBuffer;
  outBuffPtr : PKDT3072DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3072DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3072DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3072DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3072DD.Search(const inBuff: TKDT3072DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3072DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3072DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3072DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3072DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3072DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3072DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3072DD_Source));
end;

procedure TKDT3072DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3072DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3072DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3072DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3072DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3072DD.PrintNodeTree(const NodePtr: PKDT3072DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT3072DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3072DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3072DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3072DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3072DD.KDT3072DDVec(const s: SystemString): TKDT3072DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3072DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3072DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3072DD.KDT3072DDVec(const v: TKDT3072DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3072DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT3072DD.KDT3072DDPow(const v: TKDT3072DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3072DD.KDT3072DDDistance(const v1, v2: TKDT3072DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3072DD_Axis - 1 do
      Result := Result + KDT3072DDPow(v2[i] - v1[i]);
end;

procedure TKDT3072DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3072DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3072DD.Test;
var
  TKDT3072DD_Test    : TKDT3072DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3072DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3072DD_Test := TKDT3072DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3072DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT3072DD_Test.TestBuff) - 1 do
    for j := 0 to KDT3072DD_Axis - 1 do
        TKDT3072DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3072DD_Test.TestBuff), length(TKDT3072DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3072DD_Test.BuildKDTreeM(length(TKDT3072DD_Test.TestBuff), nil, @TKDT3072DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3072DD_Test.BuildKDTreeM(length(TKDT3072DD_Test.TestBuff), nil, TKDT3072DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3072DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3072DD_Test.TestBuff));
  TKDT3072DD_Test.Search(TKDT3072DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3072DDDistance(TKDT3072DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3072DD_Test.Clear;
  { kMean test }
  TKDT3072DD_Test.BuildKDTreeWithCluster(TKDT3072DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3072DD_Test.Search(TKDT3072DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3072DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3072DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3072DD_Test);
end;


function TKDT3088DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3088DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3088DD_Node;
  function SortCompare(const p1, p2: PKDT3088DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3088DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3088DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3088DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3088DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3088DD.GetData(const index: NativeInt): PKDT3088DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3088DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3088DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3088DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3088DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3088DD.StoreBuffPtr: PKDT3088DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3088DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3088DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3088DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3088DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3088DD.BuildKDTreeWithCluster(const inBuff: TKDT3088DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3088DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3088DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3088DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3088DD.BuildKDTreeWithCluster(const inBuff: TKDT3088DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3088DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DD_BuildCall);
var
  TempStoreBuff: TKDT3088DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3088DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3088DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3088DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3088DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DD_BuildMethod);
var
  TempStoreBuff: TKDT3088DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3088DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3088DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3088DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT3088DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3088DD_BuildProc);
var
  TempStoreBuff: TKDT3088DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3088DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3088DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3088DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT3088DD.Search(const Buff: TKDT3088DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3088DD_Node;

var
  NearestNeighbour: PKDT3088DD_Node;

  function FindParentNode(const BuffPtr: PKDT3088DD_Vec; NodePtr: PKDT3088DD_Node): PKDT3088DD_Node;
  var
    Next       : PKDT3088DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3088DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3088DD_Node; const BuffPtr: PKDT3088DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3088DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3088DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3088DD_Vec; const p1, p2: PKDT3088DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3088DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3088DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3088DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3088DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3088DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3088DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3088DD_Node(NearestNodes[0]);
    end;
end;

function TKDT3088DD.Search(const Buff: TKDT3088DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3088DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3088DD.Search(const Buff: TKDT3088DD_Vec; var SearchedDistanceMin: Double): PKDT3088DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3088DD.Search(const Buff: TKDT3088DD_Vec): PKDT3088DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3088DD.Search(const inBuff: TKDT3088DD_DynamicVecBuffer; var OutBuff: TKDT3088DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3088DD_DynamicVecBuffer;
  outBuffPtr : PKDT3088DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3088DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3088DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3088DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3088DD.Search(const inBuff: TKDT3088DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3088DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3088DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3088DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3088DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3088DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3088DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3088DD_Source));
end;

procedure TKDT3088DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3088DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3088DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3088DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3088DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3088DD.PrintNodeTree(const NodePtr: PKDT3088DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT3088DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3088DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3088DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3088DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3088DD.KDT3088DDVec(const s: SystemString): TKDT3088DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3088DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3088DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3088DD.KDT3088DDVec(const v: TKDT3088DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3088DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT3088DD.KDT3088DDPow(const v: TKDT3088DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3088DD.KDT3088DDDistance(const v1, v2: TKDT3088DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3088DD_Axis - 1 do
      Result := Result + KDT3088DDPow(v2[i] - v1[i]);
end;

procedure TKDT3088DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3088DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3088DD.Test;
var
  TKDT3088DD_Test    : TKDT3088DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3088DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3088DD_Test := TKDT3088DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3088DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT3088DD_Test.TestBuff) - 1 do
    for j := 0 to KDT3088DD_Axis - 1 do
        TKDT3088DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3088DD_Test.TestBuff), length(TKDT3088DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3088DD_Test.BuildKDTreeM(length(TKDT3088DD_Test.TestBuff), nil, @TKDT3088DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3088DD_Test.BuildKDTreeM(length(TKDT3088DD_Test.TestBuff), nil, TKDT3088DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3088DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3088DD_Test.TestBuff));
  TKDT3088DD_Test.Search(TKDT3088DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3088DDDistance(TKDT3088DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3088DD_Test.Clear;
  { kMean test }
  TKDT3088DD_Test.BuildKDTreeWithCluster(TKDT3088DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3088DD_Test.Search(TKDT3088DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3088DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3088DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3088DD_Test);
end;


function TKDT3104DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3104DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3104DD_Node;
  function SortCompare(const p1, p2: PKDT3104DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3104DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3104DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3104DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3104DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3104DD.GetData(const index: NativeInt): PKDT3104DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3104DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3104DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3104DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3104DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3104DD.StoreBuffPtr: PKDT3104DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3104DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3104DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3104DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT3104DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3104DD.BuildKDTreeWithCluster(const inBuff: TKDT3104DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3104DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3104DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3104DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3104DD.BuildKDTreeWithCluster(const inBuff: TKDT3104DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3104DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DD_BuildCall);
var
  TempStoreBuff: TKDT3104DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3104DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3104DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3104DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3104DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DD_BuildMethod);
var
  TempStoreBuff: TKDT3104DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3104DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3104DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3104DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT3104DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT3104DD_BuildProc);
var
  TempStoreBuff: TKDT3104DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3104DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3104DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3104DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT3104DD.Search(const Buff: TKDT3104DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3104DD_Node;

var
  NearestNeighbour: PKDT3104DD_Node;

  function FindParentNode(const BuffPtr: PKDT3104DD_Vec; NodePtr: PKDT3104DD_Node): PKDT3104DD_Node;
  var
    Next       : PKDT3104DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3104DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3104DD_Node; const BuffPtr: PKDT3104DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3104DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3104DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3104DD_Vec; const p1, p2: PKDT3104DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3104DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3104DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3104DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3104DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3104DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3104DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3104DD_Node(NearestNodes[0]);
    end;
end;

function TKDT3104DD.Search(const Buff: TKDT3104DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3104DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3104DD.Search(const Buff: TKDT3104DD_Vec; var SearchedDistanceMin: Double): PKDT3104DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3104DD.Search(const Buff: TKDT3104DD_Vec): PKDT3104DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3104DD.Search(const inBuff: TKDT3104DD_DynamicVecBuffer; var OutBuff: TKDT3104DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3104DD_DynamicVecBuffer;
  outBuffPtr : PKDT3104DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3104DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3104DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3104DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3104DD.Search(const inBuff: TKDT3104DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3104DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3104DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3104DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3104DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3104DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3104DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3104DD_Source));
end;

procedure TKDT3104DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3104DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3104DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3104DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3104DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3104DD.PrintNodeTree(const NodePtr: PKDT3104DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT3104DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3104DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3104DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3104DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3104DD.KDT3104DDVec(const s: SystemString): TKDT3104DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3104DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3104DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3104DD.KDT3104DDVec(const v: TKDT3104DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3104DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT3104DD.KDT3104DDPow(const v: TKDT3104DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3104DD.KDT3104DDDistance(const v1, v2: TKDT3104DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3104DD_Axis - 1 do
      Result := Result + KDT3104DDPow(v2[i] - v1[i]);
end;

procedure TKDT3104DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3104DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3104DD.Test;
var
  TKDT3104DD_Test    : TKDT3104DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3104DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3104DD_Test := TKDT3104DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3104DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT3104DD_Test.TestBuff) - 1 do
    for j := 0 to KDT3104DD_Axis - 1 do
        TKDT3104DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT3104DD_Test.TestBuff), length(TKDT3104DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3104DD_Test.BuildKDTreeM(length(TKDT3104DD_Test.TestBuff), nil, @TKDT3104DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3104DD_Test.BuildKDTreeM(length(TKDT3104DD_Test.TestBuff), nil, TKDT3104DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3104DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3104DD_Test.TestBuff));
  TKDT3104DD_Test.Search(TKDT3104DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3104DDDistance(TKDT3104DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3104DD_Test.Clear;
  { kMean test }
  TKDT3104DD_Test.BuildKDTreeWithCluster(TKDT3104DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3104DD_Test.Search(TKDT3104DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3104DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3104DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3104DD_Test);
end;


function TKDT4096DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4096DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4096DD_Node;
  function SortCompare(const p1, p2: PKDT4096DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4096DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4096DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4096DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT4096DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4096DD.GetData(const index: NativeInt): PKDT4096DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4096DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4096DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4096DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4096DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4096DD.StoreBuffPtr: PKDT4096DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4096DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4096DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4096DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT4096DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4096DD.BuildKDTreeWithCluster(const inBuff: TKDT4096DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT4096DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT4096DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT4096DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4096DD.BuildKDTreeWithCluster(const inBuff: TKDT4096DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4096DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DD_BuildCall);
var
  TempStoreBuff: TKDT4096DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4096DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4096DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4096DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4096DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DD_BuildMethod);
var
  TempStoreBuff: TKDT4096DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4096DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4096DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4096DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT4096DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT4096DD_BuildProc);
var
  TempStoreBuff: TKDT4096DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4096DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4096DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4096DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT4096DD.Search(const Buff: TKDT4096DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4096DD_Node;

var
  NearestNeighbour: PKDT4096DD_Node;

  function FindParentNode(const BuffPtr: PKDT4096DD_Vec; NodePtr: PKDT4096DD_Node): PKDT4096DD_Node;
  var
    Next       : PKDT4096DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT4096DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4096DD_Node; const BuffPtr: PKDT4096DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4096DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT4096DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4096DD_Vec; const p1, p2: PKDT4096DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4096DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4096DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4096DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4096DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4096DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4096DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4096DD_Node(NearestNodes[0]);
    end;
end;

function TKDT4096DD.Search(const Buff: TKDT4096DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4096DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4096DD.Search(const Buff: TKDT4096DD_Vec; var SearchedDistanceMin: Double): PKDT4096DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4096DD.Search(const Buff: TKDT4096DD_Vec): PKDT4096DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4096DD.Search(const inBuff: TKDT4096DD_DynamicVecBuffer; var OutBuff: TKDT4096DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4096DD_DynamicVecBuffer;
  outBuffPtr : PKDT4096DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4096DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4096DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4096DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4096DD.Search(const inBuff: TKDT4096DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4096DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4096DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4096DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4096DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4096DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT4096DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4096DD_Source));
end;

procedure TKDT4096DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT4096DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4096DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4096DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4096DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4096DD.PrintNodeTree(const NodePtr: PKDT4096DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT4096DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4096DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4096DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4096DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT4096DD.KDT4096DDVec(const s: SystemString): TKDT4096DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT4096DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT4096DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT4096DD.KDT4096DDVec(const v: TKDT4096DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT4096DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT4096DD.KDT4096DDPow(const v: TKDT4096DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT4096DD.KDT4096DDDistance(const v1, v2: TKDT4096DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT4096DD_Axis - 1 do
      Result := Result + KDT4096DDPow(v2[i] - v1[i]);
end;

procedure TKDT4096DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4096DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4096DD.Test;
var
  TKDT4096DD_Test    : TKDT4096DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4096DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4096DD_Test := TKDT4096DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4096DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT4096DD_Test.TestBuff) - 1 do
    for j := 0 to KDT4096DD_Axis - 1 do
        TKDT4096DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT4096DD_Test.TestBuff), length(TKDT4096DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4096DD_Test.BuildKDTreeM(length(TKDT4096DD_Test.TestBuff), nil, @TKDT4096DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4096DD_Test.BuildKDTreeM(length(TKDT4096DD_Test.TestBuff), nil, TKDT4096DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4096DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4096DD_Test.TestBuff));
  TKDT4096DD_Test.Search(TKDT4096DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4096DDDistance(TKDT4096DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4096DD_Test.Clear;
  { kMean test }
  TKDT4096DD_Test.BuildKDTreeWithCluster(TKDT4096DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4096DD_Test.Search(TKDT4096DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4096DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4096DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4096DD_Test);
end;


function TKDT8192DD.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8192DD_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8192DD_Node;
  function SortCompare(const p1, p2: PKDT8192DD_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8192DD_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8192DD_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8192DD_SourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT8192DD_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8192DD.GetData(const index: NativeInt): PKDT8192DD_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8192DD.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8192DD.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8192DD.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8192DD_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8192DD.StoreBuffPtr: PKDT8192DDyanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8192DD.BuildKDTreeC(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DD_BuildCall);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8192DD.BuildKDTreeM(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DD_BuildMethod);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8192DD.BuildKDTreeP(const PlanCount: NativeInt; const Data: Pointer; const OnTrigger: TKDT8192DD_BuildProc);
var
  i, j: NativeInt;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DD_Vec), 0);
      OnTrigger(i, KDStoreBuff[i], Data);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8192DD.BuildKDTreeWithCluster(const inBuff: TKDT8192DD_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT8192DD_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT8192DD_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT8192DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8192DD.BuildKDTreeWithCluster(const inBuff: TKDT8192DD_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8192DD.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DD_BuildCall);
var
  TempStoreBuff: TKDT8192DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8192DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8192DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8192DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8192DD.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DD_BuildMethod);
var
  TempStoreBuff: TKDT8192DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8192DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8192DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8192DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$IFNDEF FPC}


procedure TKDT8192DD.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const Data: Pointer; const OnTrigger: TKDT8192DD_BuildProc);
var
  TempStoreBuff: TKDT8192DDyanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DD_Vec), 0);
      OnTrigger(i, TempStoreBuff[i], Data);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8192DD_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8192DD_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8192DD_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DD_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

{$ENDIF FPC}


function TKDT8192DD.Search(const Buff: TKDT8192DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8192DD_Node;

var
  NearestNeighbour: PKDT8192DD_Node;

  function FindParentNode(const BuffPtr: PKDT8192DD_Vec; NodePtr: PKDT8192DD_Node): PKDT8192DD_Node;
  var
    Next       : PKDT8192DD_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT8192DD_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8192DD_Node; const BuffPtr: PKDT8192DD_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8192DDDistance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT8192DD_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8192DD_Vec; const p1, p2: PKDT8192DD_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8192DDDistance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8192DDDistance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8192DD_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8192DD_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8192DD_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8192DDDistance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8192DD_Node(NearestNodes[0]);
    end;
end;

function TKDT8192DD.Search(const Buff: TKDT8192DD_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8192DD_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8192DD.Search(const Buff: TKDT8192DD_Vec; var SearchedDistanceMin: Double): PKDT8192DD_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8192DD.Search(const Buff: TKDT8192DD_Vec): PKDT8192DD_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8192DD.Search(const inBuff: TKDT8192DD_DynamicVecBuffer; var OutBuff: TKDT8192DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8192DD_DynamicVecBuffer;
  outBuffPtr : PKDT8192DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8192DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8192DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8192DD_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8192DD.Search(const inBuff: TKDT8192DD_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8192DD_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8192DD_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8192DD_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8192DD_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8192DD.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT8192DD_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8192DD_Source));
end;

procedure TKDT8192DD.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT8192DD_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8192DD_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8192DD.SaveToFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8192DD.LoadFromFile(fileName: SystemString);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8192DD.PrintNodeTree(const NodePtr: PKDT8192DD_Node);
  procedure DoPrintNode(prefix: SystemString; const p: PKDT8192DD_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8192DDVec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8192DD.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8192DDVec(KDStoreBuff[i].Buff)]);
end;

class function TKDT8192DD.KDT8192DDVec(const s: SystemString): TKDT8192DD_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT8192DD_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToFloat(SplitOutput[i], 0);
            inc(j);
            if j >= KDT8192DD_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT8192DD.KDT8192DDVec(const v: TKDT8192DD_Vec): SystemString;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT8192DD_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlFloatToStr(v[i]);
    end;
end;

class function TKDT8192DD.KDT8192DDPow(const v: TKDT8192DD_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT8192DD.KDT8192DDDistance(const v1, v2: TKDT8192DD_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT8192DD_Axis - 1 do
      Result := Result + KDT8192DDPow(v2[i] - v1[i]);
end;

procedure TKDT8192DD.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8192DD_Source; const Data: Pointer);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8192DD.Test;
var
  TKDT8192DD_Test    : TKDT8192DD;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8192DD_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8192DD_Test := TKDT8192DD.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8192DD_Test.TestBuff, 100);
  for i := 0 to length(TKDT8192DD_Test.TestBuff) - 1 do
    for j := 0 to KDT8192DD_Axis - 1 do
        TKDT8192DD_Test.TestBuff[i][j] := umlRandomRangeD(-length(TKDT8192DD_Test.TestBuff), length(TKDT8192DD_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8192DD_Test.BuildKDTreeM(length(TKDT8192DD_Test.TestBuff), nil, @TKDT8192DD_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8192DD_Test.BuildKDTreeM(length(TKDT8192DD_Test.TestBuff), nil, TKDT8192DD_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8192DD_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8192DD_Test.TestBuff));
  TKDT8192DD_Test.Search(TKDT8192DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8192DDDistance(TKDT8192DD_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8192DD_Test.Clear;
  { kMean test }
  TKDT8192DD_Test.BuildKDTreeWithCluster(TKDT8192DD_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8192DD_Test.Search(TKDT8192DD_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8192DD_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8192DD_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8192DD_Test);
end;


procedure Test_All;
begin
  TKDT1DD.Test();
  TKDT2DD.Test();
  TKDT3DD.Test();
  TKDT4DD.Test();
  TKDT5DD.Test();
  TKDT6DD.Test();
  TKDT7DD.Test();
  TKDT8DD.Test();
  TKDT9DD.Test();
  TKDT10DD.Test();
  TKDT11DD.Test();
  TKDT12DD.Test();
  TKDT13DD.Test();
  TKDT14DD.Test();
  TKDT15DD.Test();
  TKDT16DD.Test();
  TKDT17DD.Test();
  TKDT18DD.Test();
  TKDT19DD.Test();
  TKDT20DD.Test();
  TKDT21DD.Test();
  TKDT22DD.Test();
  TKDT23DD.Test();
  TKDT24DD.Test();
  TKDT25DD.Test();
  TKDT26DD.Test();
  TKDT27DD.Test();
  TKDT28DD.Test();
  TKDT29DD.Test();
  TKDT30DD.Test();
  TKDT31DD.Test();
  TKDT32DD.Test();
  TKDT33DD.Test();
  TKDT34DD.Test();
  TKDT35DD.Test();
  TKDT36DD.Test();
  TKDT37DD.Test();
  TKDT38DD.Test();
  TKDT39DD.Test();
  TKDT40DD.Test();
  TKDT41DD.Test();
  TKDT42DD.Test();
  TKDT43DD.Test();
  TKDT44DD.Test();
  TKDT45DD.Test();
  TKDT46DD.Test();
  TKDT47DD.Test();
  TKDT48DD.Test();
  TKDT49DD.Test();
  TKDT50DD.Test();
  TKDT51DD.Test();
  TKDT52DD.Test();
  TKDT53DD.Test();
  TKDT54DD.Test();
  TKDT55DD.Test();
  TKDT56DD.Test();
  TKDT57DD.Test();
  TKDT58DD.Test();
  TKDT59DD.Test();
  TKDT60DD.Test();
  TKDT61DD.Test();
  TKDT62DD.Test();
  TKDT63DD.Test();
  TKDT64DD.Test();
  TKDT65DD.Test();
  TKDT66DD.Test();
  TKDT67DD.Test();
  TKDT68DD.Test();
  TKDT69DD.Test();
  TKDT70DD.Test();
  TKDT71DD.Test();
  TKDT72DD.Test();
  TKDT84DD.Test();
  TKDT96DD.Test();
  TKDT128DD.Test();
  TKDT140DD.Test();
  TKDT160DD.Test();
  TKDT196DD.Test();
  TKDT256DD.Test();
  TKDT272DD.Test();
  TKDT288DD.Test();
  TKDT372DD.Test();
  TKDT512DD.Test();
  TKDT576DD.Test();
  TKDT768DD.Test();
  TKDT1024DD.Test();
  TKDT1040DD.Test();
  TKDT1056DD.Test();
  TKDT1536DD.Test();
  TKDT1920DD.Test();
  TKDT1980DD.Test();
  TKDT2048DD.Test();
  TKDT3072DD.Test();
  TKDT3088DD.Test();
  TKDT3104DD.Test();
  TKDT4096DD.Test();
  TKDT8192DD.Test();
  DoStatus('All Test Finished');
end;





initialization

finalization

end.

