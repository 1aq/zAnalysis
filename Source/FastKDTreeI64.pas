{ Fast KDTree Int64 type support                                                 }
{ ****************************************************************************** }
{ * fast KDTree Support,writen by QQ 600585@qq.com                             * }
{ * https://github.com/PassByYou888/CoreCipher                                 * }
{ * https://github.com/PassByYou888/ZServer4D                                  * }
{ * https://github.com/PassByYou888/zExpression                                * }
{ * https://github.com/PassByYou888/zTranslate                                 * }
{ * https://github.com/PassByYou888/zSound                                     * }
{ * https://github.com/PassByYou888/zAnalysis                                  * }
{ ****************************************************************************** }

unit FastKDTreeI64;

interface

uses CoreClasses, KM;

{$I zDefine.inc}

{$IFDEF FPC}
{$DEFINE DEBUG}
{$ENDIF FPC}

const

  // Int64 KDTree
  KDT1DI64_Axis = 1;
  KDT2DI64_Axis = 2;
  KDT3DI64_Axis = 3;
  KDT4DI64_Axis = 4;
  KDT5DI64_Axis = 5;
  KDT6DI64_Axis = 6;
  KDT7DI64_Axis = 7;
  KDT8DI64_Axis = 8;
  KDT9DI64_Axis = 9;
  KDT10DI64_Axis = 10;
  KDT11DI64_Axis = 11;
  KDT12DI64_Axis = 12;
  KDT13DI64_Axis = 13;
  KDT14DI64_Axis = 14;
  KDT15DI64_Axis = 15;
  KDT16DI64_Axis = 16;
  KDT17DI64_Axis = 17;
  KDT18DI64_Axis = 18;
  KDT19DI64_Axis = 19;
  KDT20DI64_Axis = 20;
  KDT21DI64_Axis = 21;
  KDT22DI64_Axis = 22;
  KDT23DI64_Axis = 23;
  KDT24DI64_Axis = 24;
  KDT25DI64_Axis = 25;
  KDT26DI64_Axis = 26;
  KDT27DI64_Axis = 27;
  KDT28DI64_Axis = 28;
  KDT29DI64_Axis = 29;
  KDT30DI64_Axis = 30;
  KDT31DI64_Axis = 31;
  KDT32DI64_Axis = 32;
  KDT33DI64_Axis = 33;
  KDT34DI64_Axis = 34;
  KDT35DI64_Axis = 35;
  KDT36DI64_Axis = 36;
  KDT37DI64_Axis = 37;
  KDT38DI64_Axis = 38;
  KDT39DI64_Axis = 39;
  KDT40DI64_Axis = 40;
  KDT41DI64_Axis = 41;
  KDT42DI64_Axis = 42;
  KDT43DI64_Axis = 43;
  KDT44DI64_Axis = 44;
  KDT45DI64_Axis = 45;
  KDT46DI64_Axis = 46;
  KDT47DI64_Axis = 47;
  KDT48DI64_Axis = 48;
  KDT49DI64_Axis = 49;
  KDT50DI64_Axis = 50;
  KDT51DI64_Axis = 51;
  KDT52DI64_Axis = 52;
  KDT53DI64_Axis = 53;
  KDT54DI64_Axis = 54;
  KDT55DI64_Axis = 55;
  KDT56DI64_Axis = 56;
  KDT57DI64_Axis = 57;
  KDT58DI64_Axis = 58;
  KDT59DI64_Axis = 59;
  KDT60DI64_Axis = 60;
  KDT61DI64_Axis = 61;
  KDT62DI64_Axis = 62;
  KDT63DI64_Axis = 63;
  KDT64DI64_Axis = 64;
  KDT72DI64_Axis = 72;
  KDT84DI64_Axis = 84;
  KDT96DI64_Axis = 96;
  KDT128DI64_Axis = 128;
  KDT140DI64_Axis = 140;
  KDT160DI64_Axis = 160;
  KDT196DI64_Axis = 196;
  KDT256DI64_Axis = 256;
  KDT272DI64_Axis = 272;
  KDT288DI64_Axis = 288;
  KDT372DI64_Axis = 372;
  KDT512DI64_Axis = 512;
  KDT576DI64_Axis = 576;
  KDT768DI64_Axis = 768;
  KDT1024DI64_Axis = 1024;
  KDT1040DI64_Axis = 1040;
  KDT1056DI64_Axis = 1056;
  KDT1536DI64_Axis = 1536;
  KDT1920DI64_Axis = 1920;
  KDT1980DI64_Axis = 1980;
  KDT2048DI64_Axis = 2048;
  KDT3072DI64_Axis = 3072;
  KDT3088DI64_Axis = 3088;
  KDT3104DI64_Axis = 3104;
  KDT4096DI64_Axis = 4096;
  KDT8192DI64_Axis = 8192;

type

  // Int64: KDTree
  TKDT1DI64 = class;  TKDT1DI64_VecType = Double; // 1D
  TKDT2DI64 = class;  TKDT2DI64_VecType = Double; // 2D
  TKDT3DI64 = class;  TKDT3DI64_VecType = Double; // 3D
  TKDT4DI64 = class;  TKDT4DI64_VecType = Double; // 4D
  TKDT5DI64 = class;  TKDT5DI64_VecType = Double; // 5D
  TKDT6DI64 = class;  TKDT6DI64_VecType = Double; // 6D
  TKDT7DI64 = class;  TKDT7DI64_VecType = Double; // 7D
  TKDT8DI64 = class;  TKDT8DI64_VecType = Double; // 8D
  TKDT9DI64 = class;  TKDT9DI64_VecType = Double; // 9D
  TKDT10DI64 = class;  TKDT10DI64_VecType = Double; // 10D
  TKDT11DI64 = class;  TKDT11DI64_VecType = Double; // 11D
  TKDT12DI64 = class;  TKDT12DI64_VecType = Double; // 12D
  TKDT13DI64 = class;  TKDT13DI64_VecType = Double; // 13D
  TKDT14DI64 = class;  TKDT14DI64_VecType = Double; // 14D
  TKDT15DI64 = class;  TKDT15DI64_VecType = Double; // 15D
  TKDT16DI64 = class;  TKDT16DI64_VecType = Double; // 16D
  TKDT17DI64 = class;  TKDT17DI64_VecType = Double; // 17D
  TKDT18DI64 = class;  TKDT18DI64_VecType = Double; // 18D
  TKDT19DI64 = class;  TKDT19DI64_VecType = Double; // 19D
  TKDT20DI64 = class;  TKDT20DI64_VecType = Double; // 20D
  TKDT21DI64 = class;  TKDT21DI64_VecType = Double; // 21D
  TKDT22DI64 = class;  TKDT22DI64_VecType = Double; // 22D
  TKDT23DI64 = class;  TKDT23DI64_VecType = Double; // 23D
  TKDT24DI64 = class;  TKDT24DI64_VecType = Double; // 24D
  TKDT25DI64 = class;  TKDT25DI64_VecType = Double; // 25D
  TKDT26DI64 = class;  TKDT26DI64_VecType = Double; // 26D
  TKDT27DI64 = class;  TKDT27DI64_VecType = Double; // 27D
  TKDT28DI64 = class;  TKDT28DI64_VecType = Double; // 28D
  TKDT29DI64 = class;  TKDT29DI64_VecType = Double; // 29D
  TKDT30DI64 = class;  TKDT30DI64_VecType = Double; // 30D
  TKDT31DI64 = class;  TKDT31DI64_VecType = Double; // 31D
  TKDT32DI64 = class;  TKDT32DI64_VecType = Double; // 32D
  TKDT33DI64 = class;  TKDT33DI64_VecType = Double; // 33D
  TKDT34DI64 = class;  TKDT34DI64_VecType = Double; // 34D
  TKDT35DI64 = class;  TKDT35DI64_VecType = Double; // 35D
  TKDT36DI64 = class;  TKDT36DI64_VecType = Double; // 36D
  TKDT37DI64 = class;  TKDT37DI64_VecType = Double; // 37D
  TKDT38DI64 = class;  TKDT38DI64_VecType = Double; // 38D
  TKDT39DI64 = class;  TKDT39DI64_VecType = Double; // 39D
  TKDT40DI64 = class;  TKDT40DI64_VecType = Double; // 40D
  TKDT41DI64 = class;  TKDT41DI64_VecType = Double; // 41D
  TKDT42DI64 = class;  TKDT42DI64_VecType = Double; // 42D
  TKDT43DI64 = class;  TKDT43DI64_VecType = Double; // 43D
  TKDT44DI64 = class;  TKDT44DI64_VecType = Double; // 44D
  TKDT45DI64 = class;  TKDT45DI64_VecType = Double; // 45D
  TKDT46DI64 = class;  TKDT46DI64_VecType = Double; // 46D
  TKDT47DI64 = class;  TKDT47DI64_VecType = Double; // 47D
  TKDT48DI64 = class;  TKDT48DI64_VecType = Double; // 48D
  TKDT49DI64 = class;  TKDT49DI64_VecType = Double; // 49D
  TKDT50DI64 = class;  TKDT50DI64_VecType = Double; // 50D
  TKDT51DI64 = class;  TKDT51DI64_VecType = Double; // 51D
  TKDT52DI64 = class;  TKDT52DI64_VecType = Double; // 52D
  TKDT53DI64 = class;  TKDT53DI64_VecType = Double; // 53D
  TKDT54DI64 = class;  TKDT54DI64_VecType = Double; // 54D
  TKDT55DI64 = class;  TKDT55DI64_VecType = Double; // 55D
  TKDT56DI64 = class;  TKDT56DI64_VecType = Double; // 56D
  TKDT57DI64 = class;  TKDT57DI64_VecType = Double; // 57D
  TKDT58DI64 = class;  TKDT58DI64_VecType = Double; // 58D
  TKDT59DI64 = class;  TKDT59DI64_VecType = Double; // 59D
  TKDT60DI64 = class;  TKDT60DI64_VecType = Double; // 60D
  TKDT61DI64 = class;  TKDT61DI64_VecType = Double; // 61D
  TKDT62DI64 = class;  TKDT62DI64_VecType = Double; // 62D
  TKDT63DI64 = class;  TKDT63DI64_VecType = Double; // 63D
  TKDT64DI64 = class;  TKDT64DI64_VecType = Double; // 64D
  TKDT72DI64 = class;  TKDT72DI64_VecType = Double; // 72D
  TKDT84DI64 = class;  TKDT84DI64_VecType = Double; // 84D
  TKDT96DI64 = class;  TKDT96DI64_VecType = Double; // 96D
  TKDT128DI64 = class;  TKDT128DI64_VecType = Double; // 128D
  TKDT140DI64 = class;  TKDT140DI64_VecType = Double; // 140D
  TKDT160DI64 = class;  TKDT160DI64_VecType = Double; // 160D
  TKDT196DI64 = class;  TKDT196DI64_VecType = Double; // 196D
  TKDT256DI64 = class;  TKDT256DI64_VecType = Double; // 256D
  TKDT272DI64 = class;  TKDT272DI64_VecType = Double; // 272D
  TKDT288DI64 = class;  TKDT288DI64_VecType = Double; // 288D
  TKDT372DI64 = class;  TKDT372DI64_VecType = Double; // 372D
  TKDT512DI64 = class;  TKDT512DI64_VecType = Double; // 512D
  TKDT576DI64 = class;  TKDT576DI64_VecType = Double; // 576D
  TKDT768DI64 = class;  TKDT768DI64_VecType = Double; // 768D
  TKDT1024DI64 = class;  TKDT1024DI64_VecType = Double; // 1024D
  TKDT1040DI64 = class;  TKDT1040DI64_VecType = Double; // 1040D
  TKDT1056DI64 = class;  TKDT1056DI64_VecType = Double; // 1056D
  TKDT1536DI64 = class;  TKDT1536DI64_VecType = Double; // 1536D
  TKDT1920DI64 = class;  TKDT1920DI64_VecType = Double; // 1920D
  TKDT1980DI64 = class;  TKDT1980DI64_VecType = Double; // 1980D
  TKDT2048DI64 = class;  TKDT2048DI64_VecType = Double; // 2048D
  TKDT3072DI64 = class;  TKDT3072DI64_VecType = Double; // 3072D
  TKDT3088DI64 = class;  TKDT3088DI64_VecType = Double; // 3088D
  TKDT3104DI64 = class;  TKDT3104DI64_VecType = Double; // 3104D
  TKDT4096DI64 = class;  TKDT4096DI64_VecType = Double; // 4096D
  TKDT8192DI64 = class;  TKDT8192DI64_VecType = Double; // 8192D










  // Int64 KDTree


  TKDT1DI64_Vec = array [0 .. KDT1DI64_Axis - 1] of TKDT1DI64_VecType;
  PKDT1DI64_Vec = ^TKDT1DI64_Vec;

  TKDT1DI64_DynamicVecBuffer = array of TKDT1DI64_Vec;
  PKDT1DI64_DynamicVecBuffer = ^TKDT1DI64_DynamicVecBuffer;

  TKDT1DI64_Source = packed record
    Buff: TKDT1DI64_Vec;
    index: Int64;
  end;

  PKDT1DI64_Source       = ^TKDT1DI64_Source;
  TKDT1DI64_SourceBuffer = array [0 .. 0] of PKDT1DI64_Source;
  PKDT1DI64_SourceBuffer = ^TKDT1DI64_SourceBuffer;

  TKDT1DI64yanmicSourceBuffer = array of PKDT1DI64_Source;
  PKDT1DI64yanmicSourceBuffer = ^TKDT1DI64yanmicSourceBuffer;

  TKDT1DI64yanmicStoreBuffer = array of TKDT1DI64_Source;
  PKDT1DI64yanmicStoreBuffer = ^TKDT1DI64yanmicStoreBuffer;

  PKDT1DI64_Node = ^TKDT1DI64_Node;

  TKDT1DI64_Node = packed record
    Parent, Right, Left: PKDT1DI64_Node;
    vec: PKDT1DI64_Source;
  end;

  TKDT1DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1DI64_Source);
  TKDT1DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1DI64_Source) of object;
  {$IFNDEF FPC} TKDT1DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1DI64_Source); {$ENDIF}

  TKDT1DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1DI64yanmicStoreBuffer;
    KDBuff     : TKDT1DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1DI64_Node;
    TestBuff   : TKDT1DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DI64_Node;
    function GetData(const index: NativeInt): PKDT1DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT1DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT1DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT1DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DI64_Node; overload;
    function Search(const Buff: TKDT1DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DI64_Node; overload;
    function Search(const Buff: TKDT1DI64_Vec; var SearchedDistanceMin: Double): PKDT1DI64_Node; overload;
    function Search(const Buff: TKDT1DI64_Vec): PKDT1DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1DI64_DynamicVecBuffer; var OutBuff: TKDT1DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1DI64_Node);
    procedure PrintBuffer;

    class function KDT1DI64Vec(const s: string): TKDT1DI64_Vec; overload;
    class function KDT1DI64Vec(const v: TKDT1DI64_Vec): string; overload;
    class function KDT1DI64Pow(const v: TKDT1DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1DI64Distance(const v1, v2: TKDT1DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1DI64_Source);
    class procedure Test;
  end;



  TKDT2DI64_Vec = array [0 .. KDT2DI64_Axis - 1] of TKDT2DI64_VecType;
  PKDT2DI64_Vec = ^TKDT2DI64_Vec;

  TKDT2DI64_DynamicVecBuffer = array of TKDT2DI64_Vec;
  PKDT2DI64_DynamicVecBuffer = ^TKDT2DI64_DynamicVecBuffer;

  TKDT2DI64_Source = packed record
    Buff: TKDT2DI64_Vec;
    index: Int64;
  end;

  PKDT2DI64_Source       = ^TKDT2DI64_Source;
  TKDT2DI64_SourceBuffer = array [0 .. 0] of PKDT2DI64_Source;
  PKDT2DI64_SourceBuffer = ^TKDT2DI64_SourceBuffer;

  TKDT2DI64yanmicSourceBuffer = array of PKDT2DI64_Source;
  PKDT2DI64yanmicSourceBuffer = ^TKDT2DI64yanmicSourceBuffer;

  TKDT2DI64yanmicStoreBuffer = array of TKDT2DI64_Source;
  PKDT2DI64yanmicStoreBuffer = ^TKDT2DI64yanmicStoreBuffer;

  PKDT2DI64_Node = ^TKDT2DI64_Node;

  TKDT2DI64_Node = packed record
    Parent, Right, Left: PKDT2DI64_Node;
    vec: PKDT2DI64_Source;
  end;

  TKDT2DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT2DI64_Source);
  TKDT2DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT2DI64_Source) of object;
  {$IFNDEF FPC} TKDT2DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT2DI64_Source); {$ENDIF}

  TKDT2DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT2DI64yanmicStoreBuffer;
    KDBuff     : TKDT2DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2DI64_Node;
    TestBuff   : TKDT2DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DI64_Node;
    function GetData(const index: NativeInt): PKDT2DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT2DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT2DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT2DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT2DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DI64_Node; overload;
    function Search(const Buff: TKDT2DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DI64_Node; overload;
    function Search(const Buff: TKDT2DI64_Vec; var SearchedDistanceMin: Double): PKDT2DI64_Node; overload;
    function Search(const Buff: TKDT2DI64_Vec): PKDT2DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2DI64_DynamicVecBuffer; var OutBuff: TKDT2DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT2DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT2DI64_Node);
    procedure PrintBuffer;

    class function KDT2DI64Vec(const s: string): TKDT2DI64_Vec; overload;
    class function KDT2DI64Vec(const v: TKDT2DI64_Vec): string; overload;
    class function KDT2DI64Pow(const v: TKDT2DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT2DI64Distance(const v1, v2: TKDT2DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2DI64_Source);
    class procedure Test;
  end;



  TKDT3DI64_Vec = array [0 .. KDT3DI64_Axis - 1] of TKDT3DI64_VecType;
  PKDT3DI64_Vec = ^TKDT3DI64_Vec;

  TKDT3DI64_DynamicVecBuffer = array of TKDT3DI64_Vec;
  PKDT3DI64_DynamicVecBuffer = ^TKDT3DI64_DynamicVecBuffer;

  TKDT3DI64_Source = packed record
    Buff: TKDT3DI64_Vec;
    index: Int64;
  end;

  PKDT3DI64_Source       = ^TKDT3DI64_Source;
  TKDT3DI64_SourceBuffer = array [0 .. 0] of PKDT3DI64_Source;
  PKDT3DI64_SourceBuffer = ^TKDT3DI64_SourceBuffer;

  TKDT3DI64yanmicSourceBuffer = array of PKDT3DI64_Source;
  PKDT3DI64yanmicSourceBuffer = ^TKDT3DI64yanmicSourceBuffer;

  TKDT3DI64yanmicStoreBuffer = array of TKDT3DI64_Source;
  PKDT3DI64yanmicStoreBuffer = ^TKDT3DI64yanmicStoreBuffer;

  PKDT3DI64_Node = ^TKDT3DI64_Node;

  TKDT3DI64_Node = packed record
    Parent, Right, Left: PKDT3DI64_Node;
    vec: PKDT3DI64_Source;
  end;

  TKDT3DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3DI64_Source);
  TKDT3DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3DI64_Source) of object;
  {$IFNDEF FPC} TKDT3DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3DI64_Source); {$ENDIF}

  TKDT3DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3DI64yanmicStoreBuffer;
    KDBuff     : TKDT3DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3DI64_Node;
    TestBuff   : TKDT3DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DI64_Node;
    function GetData(const index: NativeInt): PKDT3DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT3DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT3DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT3DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DI64_Node; overload;
    function Search(const Buff: TKDT3DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DI64_Node; overload;
    function Search(const Buff: TKDT3DI64_Vec; var SearchedDistanceMin: Double): PKDT3DI64_Node; overload;
    function Search(const Buff: TKDT3DI64_Vec): PKDT3DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3DI64_DynamicVecBuffer; var OutBuff: TKDT3DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT3DI64_Node);
    procedure PrintBuffer;

    class function KDT3DI64Vec(const s: string): TKDT3DI64_Vec; overload;
    class function KDT3DI64Vec(const v: TKDT3DI64_Vec): string; overload;
    class function KDT3DI64Pow(const v: TKDT3DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3DI64Distance(const v1, v2: TKDT3DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3DI64_Source);
    class procedure Test;
  end;



  TKDT4DI64_Vec = array [0 .. KDT4DI64_Axis - 1] of TKDT4DI64_VecType;
  PKDT4DI64_Vec = ^TKDT4DI64_Vec;

  TKDT4DI64_DynamicVecBuffer = array of TKDT4DI64_Vec;
  PKDT4DI64_DynamicVecBuffer = ^TKDT4DI64_DynamicVecBuffer;

  TKDT4DI64_Source = packed record
    Buff: TKDT4DI64_Vec;
    index: Int64;
  end;

  PKDT4DI64_Source       = ^TKDT4DI64_Source;
  TKDT4DI64_SourceBuffer = array [0 .. 0] of PKDT4DI64_Source;
  PKDT4DI64_SourceBuffer = ^TKDT4DI64_SourceBuffer;

  TKDT4DI64yanmicSourceBuffer = array of PKDT4DI64_Source;
  PKDT4DI64yanmicSourceBuffer = ^TKDT4DI64yanmicSourceBuffer;

  TKDT4DI64yanmicStoreBuffer = array of TKDT4DI64_Source;
  PKDT4DI64yanmicStoreBuffer = ^TKDT4DI64yanmicStoreBuffer;

  PKDT4DI64_Node = ^TKDT4DI64_Node;

  TKDT4DI64_Node = packed record
    Parent, Right, Left: PKDT4DI64_Node;
    vec: PKDT4DI64_Source;
  end;

  TKDT4DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT4DI64_Source);
  TKDT4DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT4DI64_Source) of object;
  {$IFNDEF FPC} TKDT4DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT4DI64_Source); {$ENDIF}

  TKDT4DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT4DI64yanmicStoreBuffer;
    KDBuff     : TKDT4DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT4DI64_Node;
    TestBuff   : TKDT4DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DI64_Node;
    function GetData(const index: NativeInt): PKDT4DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT4DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT4DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT4DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT4DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DI64_Node; overload;
    function Search(const Buff: TKDT4DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DI64_Node; overload;
    function Search(const Buff: TKDT4DI64_Vec; var SearchedDistanceMin: Double): PKDT4DI64_Node; overload;
    function Search(const Buff: TKDT4DI64_Vec): PKDT4DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4DI64_DynamicVecBuffer; var OutBuff: TKDT4DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT4DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT4DI64_Node);
    procedure PrintBuffer;

    class function KDT4DI64Vec(const s: string): TKDT4DI64_Vec; overload;
    class function KDT4DI64Vec(const v: TKDT4DI64_Vec): string; overload;
    class function KDT4DI64Pow(const v: TKDT4DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT4DI64Distance(const v1, v2: TKDT4DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4DI64_Source);
    class procedure Test;
  end;



  TKDT5DI64_Vec = array [0 .. KDT5DI64_Axis - 1] of TKDT5DI64_VecType;
  PKDT5DI64_Vec = ^TKDT5DI64_Vec;

  TKDT5DI64_DynamicVecBuffer = array of TKDT5DI64_Vec;
  PKDT5DI64_DynamicVecBuffer = ^TKDT5DI64_DynamicVecBuffer;

  TKDT5DI64_Source = packed record
    Buff: TKDT5DI64_Vec;
    index: Int64;
  end;

  PKDT5DI64_Source       = ^TKDT5DI64_Source;
  TKDT5DI64_SourceBuffer = array [0 .. 0] of PKDT5DI64_Source;
  PKDT5DI64_SourceBuffer = ^TKDT5DI64_SourceBuffer;

  TKDT5DI64yanmicSourceBuffer = array of PKDT5DI64_Source;
  PKDT5DI64yanmicSourceBuffer = ^TKDT5DI64yanmicSourceBuffer;

  TKDT5DI64yanmicStoreBuffer = array of TKDT5DI64_Source;
  PKDT5DI64yanmicStoreBuffer = ^TKDT5DI64yanmicStoreBuffer;

  PKDT5DI64_Node = ^TKDT5DI64_Node;

  TKDT5DI64_Node = packed record
    Parent, Right, Left: PKDT5DI64_Node;
    vec: PKDT5DI64_Source;
  end;

  TKDT5DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT5DI64_Source);
  TKDT5DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT5DI64_Source) of object;
  {$IFNDEF FPC} TKDT5DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT5DI64_Source); {$ENDIF}

  TKDT5DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT5DI64yanmicStoreBuffer;
    KDBuff     : TKDT5DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT5DI64_Node;
    TestBuff   : TKDT5DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DI64_Node;
    function GetData(const index: NativeInt): PKDT5DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT5DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT5DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT5DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT5DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT5DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT5DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT5DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT5DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DI64_Node; overload;
    function Search(const Buff: TKDT5DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DI64_Node; overload;
    function Search(const Buff: TKDT5DI64_Vec; var SearchedDistanceMin: Double): PKDT5DI64_Node; overload;
    function Search(const Buff: TKDT5DI64_Vec): PKDT5DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT5DI64_DynamicVecBuffer; var OutBuff: TKDT5DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT5DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT5DI64_Node);
    procedure PrintBuffer;

    class function KDT5DI64Vec(const s: string): TKDT5DI64_Vec; overload;
    class function KDT5DI64Vec(const v: TKDT5DI64_Vec): string; overload;
    class function KDT5DI64Pow(const v: TKDT5DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT5DI64Distance(const v1, v2: TKDT5DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT5DI64_Source);
    class procedure Test;
  end;



  TKDT6DI64_Vec = array [0 .. KDT6DI64_Axis - 1] of TKDT6DI64_VecType;
  PKDT6DI64_Vec = ^TKDT6DI64_Vec;

  TKDT6DI64_DynamicVecBuffer = array of TKDT6DI64_Vec;
  PKDT6DI64_DynamicVecBuffer = ^TKDT6DI64_DynamicVecBuffer;

  TKDT6DI64_Source = packed record
    Buff: TKDT6DI64_Vec;
    index: Int64;
  end;

  PKDT6DI64_Source       = ^TKDT6DI64_Source;
  TKDT6DI64_SourceBuffer = array [0 .. 0] of PKDT6DI64_Source;
  PKDT6DI64_SourceBuffer = ^TKDT6DI64_SourceBuffer;

  TKDT6DI64yanmicSourceBuffer = array of PKDT6DI64_Source;
  PKDT6DI64yanmicSourceBuffer = ^TKDT6DI64yanmicSourceBuffer;

  TKDT6DI64yanmicStoreBuffer = array of TKDT6DI64_Source;
  PKDT6DI64yanmicStoreBuffer = ^TKDT6DI64yanmicStoreBuffer;

  PKDT6DI64_Node = ^TKDT6DI64_Node;

  TKDT6DI64_Node = packed record
    Parent, Right, Left: PKDT6DI64_Node;
    vec: PKDT6DI64_Source;
  end;

  TKDT6DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT6DI64_Source);
  TKDT6DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT6DI64_Source) of object;
  {$IFNDEF FPC} TKDT6DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT6DI64_Source); {$ENDIF}

  TKDT6DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT6DI64yanmicStoreBuffer;
    KDBuff     : TKDT6DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT6DI64_Node;
    TestBuff   : TKDT6DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DI64_Node;
    function GetData(const index: NativeInt): PKDT6DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT6DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT6DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT6DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT6DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT6DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT6DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT6DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT6DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DI64_Node; overload;
    function Search(const Buff: TKDT6DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DI64_Node; overload;
    function Search(const Buff: TKDT6DI64_Vec; var SearchedDistanceMin: Double): PKDT6DI64_Node; overload;
    function Search(const Buff: TKDT6DI64_Vec): PKDT6DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT6DI64_DynamicVecBuffer; var OutBuff: TKDT6DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT6DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT6DI64_Node);
    procedure PrintBuffer;

    class function KDT6DI64Vec(const s: string): TKDT6DI64_Vec; overload;
    class function KDT6DI64Vec(const v: TKDT6DI64_Vec): string; overload;
    class function KDT6DI64Pow(const v: TKDT6DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT6DI64Distance(const v1, v2: TKDT6DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT6DI64_Source);
    class procedure Test;
  end;



  TKDT7DI64_Vec = array [0 .. KDT7DI64_Axis - 1] of TKDT7DI64_VecType;
  PKDT7DI64_Vec = ^TKDT7DI64_Vec;

  TKDT7DI64_DynamicVecBuffer = array of TKDT7DI64_Vec;
  PKDT7DI64_DynamicVecBuffer = ^TKDT7DI64_DynamicVecBuffer;

  TKDT7DI64_Source = packed record
    Buff: TKDT7DI64_Vec;
    index: Int64;
  end;

  PKDT7DI64_Source       = ^TKDT7DI64_Source;
  TKDT7DI64_SourceBuffer = array [0 .. 0] of PKDT7DI64_Source;
  PKDT7DI64_SourceBuffer = ^TKDT7DI64_SourceBuffer;

  TKDT7DI64yanmicSourceBuffer = array of PKDT7DI64_Source;
  PKDT7DI64yanmicSourceBuffer = ^TKDT7DI64yanmicSourceBuffer;

  TKDT7DI64yanmicStoreBuffer = array of TKDT7DI64_Source;
  PKDT7DI64yanmicStoreBuffer = ^TKDT7DI64yanmicStoreBuffer;

  PKDT7DI64_Node = ^TKDT7DI64_Node;

  TKDT7DI64_Node = packed record
    Parent, Right, Left: PKDT7DI64_Node;
    vec: PKDT7DI64_Source;
  end;

  TKDT7DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT7DI64_Source);
  TKDT7DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT7DI64_Source) of object;
  {$IFNDEF FPC} TKDT7DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT7DI64_Source); {$ENDIF}

  TKDT7DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT7DI64yanmicStoreBuffer;
    KDBuff     : TKDT7DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT7DI64_Node;
    TestBuff   : TKDT7DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DI64_Node;
    function GetData(const index: NativeInt): PKDT7DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT7DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT7DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT7DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT7DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT7DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT7DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT7DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT7DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DI64_Node; overload;
    function Search(const Buff: TKDT7DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DI64_Node; overload;
    function Search(const Buff: TKDT7DI64_Vec; var SearchedDistanceMin: Double): PKDT7DI64_Node; overload;
    function Search(const Buff: TKDT7DI64_Vec): PKDT7DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT7DI64_DynamicVecBuffer; var OutBuff: TKDT7DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT7DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT7DI64_Node);
    procedure PrintBuffer;

    class function KDT7DI64Vec(const s: string): TKDT7DI64_Vec; overload;
    class function KDT7DI64Vec(const v: TKDT7DI64_Vec): string; overload;
    class function KDT7DI64Pow(const v: TKDT7DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT7DI64Distance(const v1, v2: TKDT7DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT7DI64_Source);
    class procedure Test;
  end;



  TKDT8DI64_Vec = array [0 .. KDT8DI64_Axis - 1] of TKDT8DI64_VecType;
  PKDT8DI64_Vec = ^TKDT8DI64_Vec;

  TKDT8DI64_DynamicVecBuffer = array of TKDT8DI64_Vec;
  PKDT8DI64_DynamicVecBuffer = ^TKDT8DI64_DynamicVecBuffer;

  TKDT8DI64_Source = packed record
    Buff: TKDT8DI64_Vec;
    index: Int64;
  end;

  PKDT8DI64_Source       = ^TKDT8DI64_Source;
  TKDT8DI64_SourceBuffer = array [0 .. 0] of PKDT8DI64_Source;
  PKDT8DI64_SourceBuffer = ^TKDT8DI64_SourceBuffer;

  TKDT8DI64yanmicSourceBuffer = array of PKDT8DI64_Source;
  PKDT8DI64yanmicSourceBuffer = ^TKDT8DI64yanmicSourceBuffer;

  TKDT8DI64yanmicStoreBuffer = array of TKDT8DI64_Source;
  PKDT8DI64yanmicStoreBuffer = ^TKDT8DI64yanmicStoreBuffer;

  PKDT8DI64_Node = ^TKDT8DI64_Node;

  TKDT8DI64_Node = packed record
    Parent, Right, Left: PKDT8DI64_Node;
    vec: PKDT8DI64_Source;
  end;

  TKDT8DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT8DI64_Source);
  TKDT8DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT8DI64_Source) of object;
  {$IFNDEF FPC} TKDT8DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT8DI64_Source); {$ENDIF}

  TKDT8DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT8DI64yanmicStoreBuffer;
    KDBuff     : TKDT8DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT8DI64_Node;
    TestBuff   : TKDT8DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DI64_Node;
    function GetData(const index: NativeInt): PKDT8DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT8DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT8DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT8DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT8DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DI64_Node; overload;
    function Search(const Buff: TKDT8DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DI64_Node; overload;
    function Search(const Buff: TKDT8DI64_Vec; var SearchedDistanceMin: Double): PKDT8DI64_Node; overload;
    function Search(const Buff: TKDT8DI64_Vec): PKDT8DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8DI64_DynamicVecBuffer; var OutBuff: TKDT8DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT8DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT8DI64_Node);
    procedure PrintBuffer;

    class function KDT8DI64Vec(const s: string): TKDT8DI64_Vec; overload;
    class function KDT8DI64Vec(const v: TKDT8DI64_Vec): string; overload;
    class function KDT8DI64Pow(const v: TKDT8DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT8DI64Distance(const v1, v2: TKDT8DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8DI64_Source);
    class procedure Test;
  end;



  TKDT9DI64_Vec = array [0 .. KDT9DI64_Axis - 1] of TKDT9DI64_VecType;
  PKDT9DI64_Vec = ^TKDT9DI64_Vec;

  TKDT9DI64_DynamicVecBuffer = array of TKDT9DI64_Vec;
  PKDT9DI64_DynamicVecBuffer = ^TKDT9DI64_DynamicVecBuffer;

  TKDT9DI64_Source = packed record
    Buff: TKDT9DI64_Vec;
    index: Int64;
  end;

  PKDT9DI64_Source       = ^TKDT9DI64_Source;
  TKDT9DI64_SourceBuffer = array [0 .. 0] of PKDT9DI64_Source;
  PKDT9DI64_SourceBuffer = ^TKDT9DI64_SourceBuffer;

  TKDT9DI64yanmicSourceBuffer = array of PKDT9DI64_Source;
  PKDT9DI64yanmicSourceBuffer = ^TKDT9DI64yanmicSourceBuffer;

  TKDT9DI64yanmicStoreBuffer = array of TKDT9DI64_Source;
  PKDT9DI64yanmicStoreBuffer = ^TKDT9DI64yanmicStoreBuffer;

  PKDT9DI64_Node = ^TKDT9DI64_Node;

  TKDT9DI64_Node = packed record
    Parent, Right, Left: PKDT9DI64_Node;
    vec: PKDT9DI64_Source;
  end;

  TKDT9DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT9DI64_Source);
  TKDT9DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT9DI64_Source) of object;
  {$IFNDEF FPC} TKDT9DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT9DI64_Source); {$ENDIF}

  TKDT9DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT9DI64yanmicStoreBuffer;
    KDBuff     : TKDT9DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT9DI64_Node;
    TestBuff   : TKDT9DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DI64_Node;
    function GetData(const index: NativeInt): PKDT9DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT9DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT9DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT9DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT9DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT9DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT9DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT9DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT9DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DI64_Node; overload;
    function Search(const Buff: TKDT9DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DI64_Node; overload;
    function Search(const Buff: TKDT9DI64_Vec; var SearchedDistanceMin: Double): PKDT9DI64_Node; overload;
    function Search(const Buff: TKDT9DI64_Vec): PKDT9DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT9DI64_DynamicVecBuffer; var OutBuff: TKDT9DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT9DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT9DI64_Node);
    procedure PrintBuffer;

    class function KDT9DI64Vec(const s: string): TKDT9DI64_Vec; overload;
    class function KDT9DI64Vec(const v: TKDT9DI64_Vec): string; overload;
    class function KDT9DI64Pow(const v: TKDT9DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT9DI64Distance(const v1, v2: TKDT9DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT9DI64_Source);
    class procedure Test;
  end;



  TKDT10DI64_Vec = array [0 .. KDT10DI64_Axis - 1] of TKDT10DI64_VecType;
  PKDT10DI64_Vec = ^TKDT10DI64_Vec;

  TKDT10DI64_DynamicVecBuffer = array of TKDT10DI64_Vec;
  PKDT10DI64_DynamicVecBuffer = ^TKDT10DI64_DynamicVecBuffer;

  TKDT10DI64_Source = packed record
    Buff: TKDT10DI64_Vec;
    index: Int64;
  end;

  PKDT10DI64_Source       = ^TKDT10DI64_Source;
  TKDT10DI64_SourceBuffer = array [0 .. 0] of PKDT10DI64_Source;
  PKDT10DI64_SourceBuffer = ^TKDT10DI64_SourceBuffer;

  TKDT10DI64yanmicSourceBuffer = array of PKDT10DI64_Source;
  PKDT10DI64yanmicSourceBuffer = ^TKDT10DI64yanmicSourceBuffer;

  TKDT10DI64yanmicStoreBuffer = array of TKDT10DI64_Source;
  PKDT10DI64yanmicStoreBuffer = ^TKDT10DI64yanmicStoreBuffer;

  PKDT10DI64_Node = ^TKDT10DI64_Node;

  TKDT10DI64_Node = packed record
    Parent, Right, Left: PKDT10DI64_Node;
    vec: PKDT10DI64_Source;
  end;

  TKDT10DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT10DI64_Source);
  TKDT10DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT10DI64_Source) of object;
  {$IFNDEF FPC} TKDT10DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT10DI64_Source); {$ENDIF}

  TKDT10DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT10DI64yanmicStoreBuffer;
    KDBuff     : TKDT10DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT10DI64_Node;
    TestBuff   : TKDT10DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DI64_Node;
    function GetData(const index: NativeInt): PKDT10DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT10DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT10DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT10DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT10DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT10DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT10DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT10DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT10DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DI64_Node; overload;
    function Search(const Buff: TKDT10DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DI64_Node; overload;
    function Search(const Buff: TKDT10DI64_Vec; var SearchedDistanceMin: Double): PKDT10DI64_Node; overload;
    function Search(const Buff: TKDT10DI64_Vec): PKDT10DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT10DI64_DynamicVecBuffer; var OutBuff: TKDT10DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT10DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT10DI64_Node);
    procedure PrintBuffer;

    class function KDT10DI64Vec(const s: string): TKDT10DI64_Vec; overload;
    class function KDT10DI64Vec(const v: TKDT10DI64_Vec): string; overload;
    class function KDT10DI64Pow(const v: TKDT10DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT10DI64Distance(const v1, v2: TKDT10DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT10DI64_Source);
    class procedure Test;
  end;



  TKDT11DI64_Vec = array [0 .. KDT11DI64_Axis - 1] of TKDT11DI64_VecType;
  PKDT11DI64_Vec = ^TKDT11DI64_Vec;

  TKDT11DI64_DynamicVecBuffer = array of TKDT11DI64_Vec;
  PKDT11DI64_DynamicVecBuffer = ^TKDT11DI64_DynamicVecBuffer;

  TKDT11DI64_Source = packed record
    Buff: TKDT11DI64_Vec;
    index: Int64;
  end;

  PKDT11DI64_Source       = ^TKDT11DI64_Source;
  TKDT11DI64_SourceBuffer = array [0 .. 0] of PKDT11DI64_Source;
  PKDT11DI64_SourceBuffer = ^TKDT11DI64_SourceBuffer;

  TKDT11DI64yanmicSourceBuffer = array of PKDT11DI64_Source;
  PKDT11DI64yanmicSourceBuffer = ^TKDT11DI64yanmicSourceBuffer;

  TKDT11DI64yanmicStoreBuffer = array of TKDT11DI64_Source;
  PKDT11DI64yanmicStoreBuffer = ^TKDT11DI64yanmicStoreBuffer;

  PKDT11DI64_Node = ^TKDT11DI64_Node;

  TKDT11DI64_Node = packed record
    Parent, Right, Left: PKDT11DI64_Node;
    vec: PKDT11DI64_Source;
  end;

  TKDT11DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT11DI64_Source);
  TKDT11DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT11DI64_Source) of object;
  {$IFNDEF FPC} TKDT11DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT11DI64_Source); {$ENDIF}

  TKDT11DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT11DI64yanmicStoreBuffer;
    KDBuff     : TKDT11DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT11DI64_Node;
    TestBuff   : TKDT11DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DI64_Node;
    function GetData(const index: NativeInt): PKDT11DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT11DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT11DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT11DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT11DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT11DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT11DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT11DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT11DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DI64_Node; overload;
    function Search(const Buff: TKDT11DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DI64_Node; overload;
    function Search(const Buff: TKDT11DI64_Vec; var SearchedDistanceMin: Double): PKDT11DI64_Node; overload;
    function Search(const Buff: TKDT11DI64_Vec): PKDT11DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT11DI64_DynamicVecBuffer; var OutBuff: TKDT11DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT11DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT11DI64_Node);
    procedure PrintBuffer;

    class function KDT11DI64Vec(const s: string): TKDT11DI64_Vec; overload;
    class function KDT11DI64Vec(const v: TKDT11DI64_Vec): string; overload;
    class function KDT11DI64Pow(const v: TKDT11DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT11DI64Distance(const v1, v2: TKDT11DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT11DI64_Source);
    class procedure Test;
  end;



  TKDT12DI64_Vec = array [0 .. KDT12DI64_Axis - 1] of TKDT12DI64_VecType;
  PKDT12DI64_Vec = ^TKDT12DI64_Vec;

  TKDT12DI64_DynamicVecBuffer = array of TKDT12DI64_Vec;
  PKDT12DI64_DynamicVecBuffer = ^TKDT12DI64_DynamicVecBuffer;

  TKDT12DI64_Source = packed record
    Buff: TKDT12DI64_Vec;
    index: Int64;
  end;

  PKDT12DI64_Source       = ^TKDT12DI64_Source;
  TKDT12DI64_SourceBuffer = array [0 .. 0] of PKDT12DI64_Source;
  PKDT12DI64_SourceBuffer = ^TKDT12DI64_SourceBuffer;

  TKDT12DI64yanmicSourceBuffer = array of PKDT12DI64_Source;
  PKDT12DI64yanmicSourceBuffer = ^TKDT12DI64yanmicSourceBuffer;

  TKDT12DI64yanmicStoreBuffer = array of TKDT12DI64_Source;
  PKDT12DI64yanmicStoreBuffer = ^TKDT12DI64yanmicStoreBuffer;

  PKDT12DI64_Node = ^TKDT12DI64_Node;

  TKDT12DI64_Node = packed record
    Parent, Right, Left: PKDT12DI64_Node;
    vec: PKDT12DI64_Source;
  end;

  TKDT12DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT12DI64_Source);
  TKDT12DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT12DI64_Source) of object;
  {$IFNDEF FPC} TKDT12DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT12DI64_Source); {$ENDIF}

  TKDT12DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT12DI64yanmicStoreBuffer;
    KDBuff     : TKDT12DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT12DI64_Node;
    TestBuff   : TKDT12DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DI64_Node;
    function GetData(const index: NativeInt): PKDT12DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT12DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT12DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT12DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT12DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT12DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT12DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT12DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT12DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DI64_Node; overload;
    function Search(const Buff: TKDT12DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DI64_Node; overload;
    function Search(const Buff: TKDT12DI64_Vec; var SearchedDistanceMin: Double): PKDT12DI64_Node; overload;
    function Search(const Buff: TKDT12DI64_Vec): PKDT12DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT12DI64_DynamicVecBuffer; var OutBuff: TKDT12DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT12DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT12DI64_Node);
    procedure PrintBuffer;

    class function KDT12DI64Vec(const s: string): TKDT12DI64_Vec; overload;
    class function KDT12DI64Vec(const v: TKDT12DI64_Vec): string; overload;
    class function KDT12DI64Pow(const v: TKDT12DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT12DI64Distance(const v1, v2: TKDT12DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT12DI64_Source);
    class procedure Test;
  end;



  TKDT13DI64_Vec = array [0 .. KDT13DI64_Axis - 1] of TKDT13DI64_VecType;
  PKDT13DI64_Vec = ^TKDT13DI64_Vec;

  TKDT13DI64_DynamicVecBuffer = array of TKDT13DI64_Vec;
  PKDT13DI64_DynamicVecBuffer = ^TKDT13DI64_DynamicVecBuffer;

  TKDT13DI64_Source = packed record
    Buff: TKDT13DI64_Vec;
    index: Int64;
  end;

  PKDT13DI64_Source       = ^TKDT13DI64_Source;
  TKDT13DI64_SourceBuffer = array [0 .. 0] of PKDT13DI64_Source;
  PKDT13DI64_SourceBuffer = ^TKDT13DI64_SourceBuffer;

  TKDT13DI64yanmicSourceBuffer = array of PKDT13DI64_Source;
  PKDT13DI64yanmicSourceBuffer = ^TKDT13DI64yanmicSourceBuffer;

  TKDT13DI64yanmicStoreBuffer = array of TKDT13DI64_Source;
  PKDT13DI64yanmicStoreBuffer = ^TKDT13DI64yanmicStoreBuffer;

  PKDT13DI64_Node = ^TKDT13DI64_Node;

  TKDT13DI64_Node = packed record
    Parent, Right, Left: PKDT13DI64_Node;
    vec: PKDT13DI64_Source;
  end;

  TKDT13DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT13DI64_Source);
  TKDT13DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT13DI64_Source) of object;
  {$IFNDEF FPC} TKDT13DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT13DI64_Source); {$ENDIF}

  TKDT13DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT13DI64yanmicStoreBuffer;
    KDBuff     : TKDT13DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT13DI64_Node;
    TestBuff   : TKDT13DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DI64_Node;
    function GetData(const index: NativeInt): PKDT13DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT13DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT13DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT13DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT13DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT13DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT13DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT13DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT13DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DI64_Node; overload;
    function Search(const Buff: TKDT13DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DI64_Node; overload;
    function Search(const Buff: TKDT13DI64_Vec; var SearchedDistanceMin: Double): PKDT13DI64_Node; overload;
    function Search(const Buff: TKDT13DI64_Vec): PKDT13DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT13DI64_DynamicVecBuffer; var OutBuff: TKDT13DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT13DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT13DI64_Node);
    procedure PrintBuffer;

    class function KDT13DI64Vec(const s: string): TKDT13DI64_Vec; overload;
    class function KDT13DI64Vec(const v: TKDT13DI64_Vec): string; overload;
    class function KDT13DI64Pow(const v: TKDT13DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT13DI64Distance(const v1, v2: TKDT13DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT13DI64_Source);
    class procedure Test;
  end;



  TKDT14DI64_Vec = array [0 .. KDT14DI64_Axis - 1] of TKDT14DI64_VecType;
  PKDT14DI64_Vec = ^TKDT14DI64_Vec;

  TKDT14DI64_DynamicVecBuffer = array of TKDT14DI64_Vec;
  PKDT14DI64_DynamicVecBuffer = ^TKDT14DI64_DynamicVecBuffer;

  TKDT14DI64_Source = packed record
    Buff: TKDT14DI64_Vec;
    index: Int64;
  end;

  PKDT14DI64_Source       = ^TKDT14DI64_Source;
  TKDT14DI64_SourceBuffer = array [0 .. 0] of PKDT14DI64_Source;
  PKDT14DI64_SourceBuffer = ^TKDT14DI64_SourceBuffer;

  TKDT14DI64yanmicSourceBuffer = array of PKDT14DI64_Source;
  PKDT14DI64yanmicSourceBuffer = ^TKDT14DI64yanmicSourceBuffer;

  TKDT14DI64yanmicStoreBuffer = array of TKDT14DI64_Source;
  PKDT14DI64yanmicStoreBuffer = ^TKDT14DI64yanmicStoreBuffer;

  PKDT14DI64_Node = ^TKDT14DI64_Node;

  TKDT14DI64_Node = packed record
    Parent, Right, Left: PKDT14DI64_Node;
    vec: PKDT14DI64_Source;
  end;

  TKDT14DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT14DI64_Source);
  TKDT14DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT14DI64_Source) of object;
  {$IFNDEF FPC} TKDT14DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT14DI64_Source); {$ENDIF}

  TKDT14DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT14DI64yanmicStoreBuffer;
    KDBuff     : TKDT14DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT14DI64_Node;
    TestBuff   : TKDT14DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DI64_Node;
    function GetData(const index: NativeInt): PKDT14DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT14DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT14DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT14DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT14DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT14DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT14DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT14DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT14DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DI64_Node; overload;
    function Search(const Buff: TKDT14DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DI64_Node; overload;
    function Search(const Buff: TKDT14DI64_Vec; var SearchedDistanceMin: Double): PKDT14DI64_Node; overload;
    function Search(const Buff: TKDT14DI64_Vec): PKDT14DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT14DI64_DynamicVecBuffer; var OutBuff: TKDT14DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT14DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT14DI64_Node);
    procedure PrintBuffer;

    class function KDT14DI64Vec(const s: string): TKDT14DI64_Vec; overload;
    class function KDT14DI64Vec(const v: TKDT14DI64_Vec): string; overload;
    class function KDT14DI64Pow(const v: TKDT14DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT14DI64Distance(const v1, v2: TKDT14DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT14DI64_Source);
    class procedure Test;
  end;



  TKDT15DI64_Vec = array [0 .. KDT15DI64_Axis - 1] of TKDT15DI64_VecType;
  PKDT15DI64_Vec = ^TKDT15DI64_Vec;

  TKDT15DI64_DynamicVecBuffer = array of TKDT15DI64_Vec;
  PKDT15DI64_DynamicVecBuffer = ^TKDT15DI64_DynamicVecBuffer;

  TKDT15DI64_Source = packed record
    Buff: TKDT15DI64_Vec;
    index: Int64;
  end;

  PKDT15DI64_Source       = ^TKDT15DI64_Source;
  TKDT15DI64_SourceBuffer = array [0 .. 0] of PKDT15DI64_Source;
  PKDT15DI64_SourceBuffer = ^TKDT15DI64_SourceBuffer;

  TKDT15DI64yanmicSourceBuffer = array of PKDT15DI64_Source;
  PKDT15DI64yanmicSourceBuffer = ^TKDT15DI64yanmicSourceBuffer;

  TKDT15DI64yanmicStoreBuffer = array of TKDT15DI64_Source;
  PKDT15DI64yanmicStoreBuffer = ^TKDT15DI64yanmicStoreBuffer;

  PKDT15DI64_Node = ^TKDT15DI64_Node;

  TKDT15DI64_Node = packed record
    Parent, Right, Left: PKDT15DI64_Node;
    vec: PKDT15DI64_Source;
  end;

  TKDT15DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT15DI64_Source);
  TKDT15DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT15DI64_Source) of object;
  {$IFNDEF FPC} TKDT15DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT15DI64_Source); {$ENDIF}

  TKDT15DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT15DI64yanmicStoreBuffer;
    KDBuff     : TKDT15DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT15DI64_Node;
    TestBuff   : TKDT15DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DI64_Node;
    function GetData(const index: NativeInt): PKDT15DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT15DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT15DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT15DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT15DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT15DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT15DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT15DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT15DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DI64_Node; overload;
    function Search(const Buff: TKDT15DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DI64_Node; overload;
    function Search(const Buff: TKDT15DI64_Vec; var SearchedDistanceMin: Double): PKDT15DI64_Node; overload;
    function Search(const Buff: TKDT15DI64_Vec): PKDT15DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT15DI64_DynamicVecBuffer; var OutBuff: TKDT15DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT15DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT15DI64_Node);
    procedure PrintBuffer;

    class function KDT15DI64Vec(const s: string): TKDT15DI64_Vec; overload;
    class function KDT15DI64Vec(const v: TKDT15DI64_Vec): string; overload;
    class function KDT15DI64Pow(const v: TKDT15DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT15DI64Distance(const v1, v2: TKDT15DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT15DI64_Source);
    class procedure Test;
  end;



  TKDT16DI64_Vec = array [0 .. KDT16DI64_Axis - 1] of TKDT16DI64_VecType;
  PKDT16DI64_Vec = ^TKDT16DI64_Vec;

  TKDT16DI64_DynamicVecBuffer = array of TKDT16DI64_Vec;
  PKDT16DI64_DynamicVecBuffer = ^TKDT16DI64_DynamicVecBuffer;

  TKDT16DI64_Source = packed record
    Buff: TKDT16DI64_Vec;
    index: Int64;
  end;

  PKDT16DI64_Source       = ^TKDT16DI64_Source;
  TKDT16DI64_SourceBuffer = array [0 .. 0] of PKDT16DI64_Source;
  PKDT16DI64_SourceBuffer = ^TKDT16DI64_SourceBuffer;

  TKDT16DI64yanmicSourceBuffer = array of PKDT16DI64_Source;
  PKDT16DI64yanmicSourceBuffer = ^TKDT16DI64yanmicSourceBuffer;

  TKDT16DI64yanmicStoreBuffer = array of TKDT16DI64_Source;
  PKDT16DI64yanmicStoreBuffer = ^TKDT16DI64yanmicStoreBuffer;

  PKDT16DI64_Node = ^TKDT16DI64_Node;

  TKDT16DI64_Node = packed record
    Parent, Right, Left: PKDT16DI64_Node;
    vec: PKDT16DI64_Source;
  end;

  TKDT16DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT16DI64_Source);
  TKDT16DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT16DI64_Source) of object;
  {$IFNDEF FPC} TKDT16DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT16DI64_Source); {$ENDIF}

  TKDT16DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT16DI64yanmicStoreBuffer;
    KDBuff     : TKDT16DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT16DI64_Node;
    TestBuff   : TKDT16DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DI64_Node;
    function GetData(const index: NativeInt): PKDT16DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT16DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT16DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT16DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT16DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT16DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT16DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT16DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT16DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DI64_Node; overload;
    function Search(const Buff: TKDT16DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DI64_Node; overload;
    function Search(const Buff: TKDT16DI64_Vec; var SearchedDistanceMin: Double): PKDT16DI64_Node; overload;
    function Search(const Buff: TKDT16DI64_Vec): PKDT16DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT16DI64_DynamicVecBuffer; var OutBuff: TKDT16DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT16DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT16DI64_Node);
    procedure PrintBuffer;

    class function KDT16DI64Vec(const s: string): TKDT16DI64_Vec; overload;
    class function KDT16DI64Vec(const v: TKDT16DI64_Vec): string; overload;
    class function KDT16DI64Pow(const v: TKDT16DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT16DI64Distance(const v1, v2: TKDT16DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT16DI64_Source);
    class procedure Test;
  end;



  TKDT17DI64_Vec = array [0 .. KDT17DI64_Axis - 1] of TKDT17DI64_VecType;
  PKDT17DI64_Vec = ^TKDT17DI64_Vec;

  TKDT17DI64_DynamicVecBuffer = array of TKDT17DI64_Vec;
  PKDT17DI64_DynamicVecBuffer = ^TKDT17DI64_DynamicVecBuffer;

  TKDT17DI64_Source = packed record
    Buff: TKDT17DI64_Vec;
    index: Int64;
  end;

  PKDT17DI64_Source       = ^TKDT17DI64_Source;
  TKDT17DI64_SourceBuffer = array [0 .. 0] of PKDT17DI64_Source;
  PKDT17DI64_SourceBuffer = ^TKDT17DI64_SourceBuffer;

  TKDT17DI64yanmicSourceBuffer = array of PKDT17DI64_Source;
  PKDT17DI64yanmicSourceBuffer = ^TKDT17DI64yanmicSourceBuffer;

  TKDT17DI64yanmicStoreBuffer = array of TKDT17DI64_Source;
  PKDT17DI64yanmicStoreBuffer = ^TKDT17DI64yanmicStoreBuffer;

  PKDT17DI64_Node = ^TKDT17DI64_Node;

  TKDT17DI64_Node = packed record
    Parent, Right, Left: PKDT17DI64_Node;
    vec: PKDT17DI64_Source;
  end;

  TKDT17DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT17DI64_Source);
  TKDT17DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT17DI64_Source) of object;
  {$IFNDEF FPC} TKDT17DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT17DI64_Source); {$ENDIF}

  TKDT17DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT17DI64yanmicStoreBuffer;
    KDBuff     : TKDT17DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT17DI64_Node;
    TestBuff   : TKDT17DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DI64_Node;
    function GetData(const index: NativeInt): PKDT17DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT17DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT17DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT17DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT17DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT17DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT17DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT17DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT17DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DI64_Node; overload;
    function Search(const Buff: TKDT17DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DI64_Node; overload;
    function Search(const Buff: TKDT17DI64_Vec; var SearchedDistanceMin: Double): PKDT17DI64_Node; overload;
    function Search(const Buff: TKDT17DI64_Vec): PKDT17DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT17DI64_DynamicVecBuffer; var OutBuff: TKDT17DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT17DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT17DI64_Node);
    procedure PrintBuffer;

    class function KDT17DI64Vec(const s: string): TKDT17DI64_Vec; overload;
    class function KDT17DI64Vec(const v: TKDT17DI64_Vec): string; overload;
    class function KDT17DI64Pow(const v: TKDT17DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT17DI64Distance(const v1, v2: TKDT17DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT17DI64_Source);
    class procedure Test;
  end;



  TKDT18DI64_Vec = array [0 .. KDT18DI64_Axis - 1] of TKDT18DI64_VecType;
  PKDT18DI64_Vec = ^TKDT18DI64_Vec;

  TKDT18DI64_DynamicVecBuffer = array of TKDT18DI64_Vec;
  PKDT18DI64_DynamicVecBuffer = ^TKDT18DI64_DynamicVecBuffer;

  TKDT18DI64_Source = packed record
    Buff: TKDT18DI64_Vec;
    index: Int64;
  end;

  PKDT18DI64_Source       = ^TKDT18DI64_Source;
  TKDT18DI64_SourceBuffer = array [0 .. 0] of PKDT18DI64_Source;
  PKDT18DI64_SourceBuffer = ^TKDT18DI64_SourceBuffer;

  TKDT18DI64yanmicSourceBuffer = array of PKDT18DI64_Source;
  PKDT18DI64yanmicSourceBuffer = ^TKDT18DI64yanmicSourceBuffer;

  TKDT18DI64yanmicStoreBuffer = array of TKDT18DI64_Source;
  PKDT18DI64yanmicStoreBuffer = ^TKDT18DI64yanmicStoreBuffer;

  PKDT18DI64_Node = ^TKDT18DI64_Node;

  TKDT18DI64_Node = packed record
    Parent, Right, Left: PKDT18DI64_Node;
    vec: PKDT18DI64_Source;
  end;

  TKDT18DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT18DI64_Source);
  TKDT18DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT18DI64_Source) of object;
  {$IFNDEF FPC} TKDT18DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT18DI64_Source); {$ENDIF}

  TKDT18DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT18DI64yanmicStoreBuffer;
    KDBuff     : TKDT18DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT18DI64_Node;
    TestBuff   : TKDT18DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DI64_Node;
    function GetData(const index: NativeInt): PKDT18DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT18DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT18DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT18DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT18DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT18DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT18DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT18DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT18DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DI64_Node; overload;
    function Search(const Buff: TKDT18DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DI64_Node; overload;
    function Search(const Buff: TKDT18DI64_Vec; var SearchedDistanceMin: Double): PKDT18DI64_Node; overload;
    function Search(const Buff: TKDT18DI64_Vec): PKDT18DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT18DI64_DynamicVecBuffer; var OutBuff: TKDT18DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT18DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT18DI64_Node);
    procedure PrintBuffer;

    class function KDT18DI64Vec(const s: string): TKDT18DI64_Vec; overload;
    class function KDT18DI64Vec(const v: TKDT18DI64_Vec): string; overload;
    class function KDT18DI64Pow(const v: TKDT18DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT18DI64Distance(const v1, v2: TKDT18DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT18DI64_Source);
    class procedure Test;
  end;



  TKDT19DI64_Vec = array [0 .. KDT19DI64_Axis - 1] of TKDT19DI64_VecType;
  PKDT19DI64_Vec = ^TKDT19DI64_Vec;

  TKDT19DI64_DynamicVecBuffer = array of TKDT19DI64_Vec;
  PKDT19DI64_DynamicVecBuffer = ^TKDT19DI64_DynamicVecBuffer;

  TKDT19DI64_Source = packed record
    Buff: TKDT19DI64_Vec;
    index: Int64;
  end;

  PKDT19DI64_Source       = ^TKDT19DI64_Source;
  TKDT19DI64_SourceBuffer = array [0 .. 0] of PKDT19DI64_Source;
  PKDT19DI64_SourceBuffer = ^TKDT19DI64_SourceBuffer;

  TKDT19DI64yanmicSourceBuffer = array of PKDT19DI64_Source;
  PKDT19DI64yanmicSourceBuffer = ^TKDT19DI64yanmicSourceBuffer;

  TKDT19DI64yanmicStoreBuffer = array of TKDT19DI64_Source;
  PKDT19DI64yanmicStoreBuffer = ^TKDT19DI64yanmicStoreBuffer;

  PKDT19DI64_Node = ^TKDT19DI64_Node;

  TKDT19DI64_Node = packed record
    Parent, Right, Left: PKDT19DI64_Node;
    vec: PKDT19DI64_Source;
  end;

  TKDT19DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT19DI64_Source);
  TKDT19DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT19DI64_Source) of object;
  {$IFNDEF FPC} TKDT19DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT19DI64_Source); {$ENDIF}

  TKDT19DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT19DI64yanmicStoreBuffer;
    KDBuff     : TKDT19DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT19DI64_Node;
    TestBuff   : TKDT19DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DI64_Node;
    function GetData(const index: NativeInt): PKDT19DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT19DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT19DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT19DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT19DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT19DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT19DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT19DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT19DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DI64_Node; overload;
    function Search(const Buff: TKDT19DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DI64_Node; overload;
    function Search(const Buff: TKDT19DI64_Vec; var SearchedDistanceMin: Double): PKDT19DI64_Node; overload;
    function Search(const Buff: TKDT19DI64_Vec): PKDT19DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT19DI64_DynamicVecBuffer; var OutBuff: TKDT19DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT19DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT19DI64_Node);
    procedure PrintBuffer;

    class function KDT19DI64Vec(const s: string): TKDT19DI64_Vec; overload;
    class function KDT19DI64Vec(const v: TKDT19DI64_Vec): string; overload;
    class function KDT19DI64Pow(const v: TKDT19DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT19DI64Distance(const v1, v2: TKDT19DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT19DI64_Source);
    class procedure Test;
  end;



  TKDT20DI64_Vec = array [0 .. KDT20DI64_Axis - 1] of TKDT20DI64_VecType;
  PKDT20DI64_Vec = ^TKDT20DI64_Vec;

  TKDT20DI64_DynamicVecBuffer = array of TKDT20DI64_Vec;
  PKDT20DI64_DynamicVecBuffer = ^TKDT20DI64_DynamicVecBuffer;

  TKDT20DI64_Source = packed record
    Buff: TKDT20DI64_Vec;
    index: Int64;
  end;

  PKDT20DI64_Source       = ^TKDT20DI64_Source;
  TKDT20DI64_SourceBuffer = array [0 .. 0] of PKDT20DI64_Source;
  PKDT20DI64_SourceBuffer = ^TKDT20DI64_SourceBuffer;

  TKDT20DI64yanmicSourceBuffer = array of PKDT20DI64_Source;
  PKDT20DI64yanmicSourceBuffer = ^TKDT20DI64yanmicSourceBuffer;

  TKDT20DI64yanmicStoreBuffer = array of TKDT20DI64_Source;
  PKDT20DI64yanmicStoreBuffer = ^TKDT20DI64yanmicStoreBuffer;

  PKDT20DI64_Node = ^TKDT20DI64_Node;

  TKDT20DI64_Node = packed record
    Parent, Right, Left: PKDT20DI64_Node;
    vec: PKDT20DI64_Source;
  end;

  TKDT20DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT20DI64_Source);
  TKDT20DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT20DI64_Source) of object;
  {$IFNDEF FPC} TKDT20DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT20DI64_Source); {$ENDIF}

  TKDT20DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT20DI64yanmicStoreBuffer;
    KDBuff     : TKDT20DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT20DI64_Node;
    TestBuff   : TKDT20DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DI64_Node;
    function GetData(const index: NativeInt): PKDT20DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT20DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT20DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT20DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT20DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT20DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT20DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT20DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT20DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DI64_Node; overload;
    function Search(const Buff: TKDT20DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DI64_Node; overload;
    function Search(const Buff: TKDT20DI64_Vec; var SearchedDistanceMin: Double): PKDT20DI64_Node; overload;
    function Search(const Buff: TKDT20DI64_Vec): PKDT20DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT20DI64_DynamicVecBuffer; var OutBuff: TKDT20DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT20DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT20DI64_Node);
    procedure PrintBuffer;

    class function KDT20DI64Vec(const s: string): TKDT20DI64_Vec; overload;
    class function KDT20DI64Vec(const v: TKDT20DI64_Vec): string; overload;
    class function KDT20DI64Pow(const v: TKDT20DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT20DI64Distance(const v1, v2: TKDT20DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT20DI64_Source);
    class procedure Test;
  end;



  TKDT21DI64_Vec = array [0 .. KDT21DI64_Axis - 1] of TKDT21DI64_VecType;
  PKDT21DI64_Vec = ^TKDT21DI64_Vec;

  TKDT21DI64_DynamicVecBuffer = array of TKDT21DI64_Vec;
  PKDT21DI64_DynamicVecBuffer = ^TKDT21DI64_DynamicVecBuffer;

  TKDT21DI64_Source = packed record
    Buff: TKDT21DI64_Vec;
    index: Int64;
  end;

  PKDT21DI64_Source       = ^TKDT21DI64_Source;
  TKDT21DI64_SourceBuffer = array [0 .. 0] of PKDT21DI64_Source;
  PKDT21DI64_SourceBuffer = ^TKDT21DI64_SourceBuffer;

  TKDT21DI64yanmicSourceBuffer = array of PKDT21DI64_Source;
  PKDT21DI64yanmicSourceBuffer = ^TKDT21DI64yanmicSourceBuffer;

  TKDT21DI64yanmicStoreBuffer = array of TKDT21DI64_Source;
  PKDT21DI64yanmicStoreBuffer = ^TKDT21DI64yanmicStoreBuffer;

  PKDT21DI64_Node = ^TKDT21DI64_Node;

  TKDT21DI64_Node = packed record
    Parent, Right, Left: PKDT21DI64_Node;
    vec: PKDT21DI64_Source;
  end;

  TKDT21DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT21DI64_Source);
  TKDT21DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT21DI64_Source) of object;
  {$IFNDEF FPC} TKDT21DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT21DI64_Source); {$ENDIF}

  TKDT21DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT21DI64yanmicStoreBuffer;
    KDBuff     : TKDT21DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT21DI64_Node;
    TestBuff   : TKDT21DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DI64_Node;
    function GetData(const index: NativeInt): PKDT21DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT21DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT21DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT21DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT21DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT21DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT21DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT21DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT21DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DI64_Node; overload;
    function Search(const Buff: TKDT21DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DI64_Node; overload;
    function Search(const Buff: TKDT21DI64_Vec; var SearchedDistanceMin: Double): PKDT21DI64_Node; overload;
    function Search(const Buff: TKDT21DI64_Vec): PKDT21DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT21DI64_DynamicVecBuffer; var OutBuff: TKDT21DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT21DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT21DI64_Node);
    procedure PrintBuffer;

    class function KDT21DI64Vec(const s: string): TKDT21DI64_Vec; overload;
    class function KDT21DI64Vec(const v: TKDT21DI64_Vec): string; overload;
    class function KDT21DI64Pow(const v: TKDT21DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT21DI64Distance(const v1, v2: TKDT21DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT21DI64_Source);
    class procedure Test;
  end;



  TKDT22DI64_Vec = array [0 .. KDT22DI64_Axis - 1] of TKDT22DI64_VecType;
  PKDT22DI64_Vec = ^TKDT22DI64_Vec;

  TKDT22DI64_DynamicVecBuffer = array of TKDT22DI64_Vec;
  PKDT22DI64_DynamicVecBuffer = ^TKDT22DI64_DynamicVecBuffer;

  TKDT22DI64_Source = packed record
    Buff: TKDT22DI64_Vec;
    index: Int64;
  end;

  PKDT22DI64_Source       = ^TKDT22DI64_Source;
  TKDT22DI64_SourceBuffer = array [0 .. 0] of PKDT22DI64_Source;
  PKDT22DI64_SourceBuffer = ^TKDT22DI64_SourceBuffer;

  TKDT22DI64yanmicSourceBuffer = array of PKDT22DI64_Source;
  PKDT22DI64yanmicSourceBuffer = ^TKDT22DI64yanmicSourceBuffer;

  TKDT22DI64yanmicStoreBuffer = array of TKDT22DI64_Source;
  PKDT22DI64yanmicStoreBuffer = ^TKDT22DI64yanmicStoreBuffer;

  PKDT22DI64_Node = ^TKDT22DI64_Node;

  TKDT22DI64_Node = packed record
    Parent, Right, Left: PKDT22DI64_Node;
    vec: PKDT22DI64_Source;
  end;

  TKDT22DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT22DI64_Source);
  TKDT22DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT22DI64_Source) of object;
  {$IFNDEF FPC} TKDT22DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT22DI64_Source); {$ENDIF}

  TKDT22DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT22DI64yanmicStoreBuffer;
    KDBuff     : TKDT22DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT22DI64_Node;
    TestBuff   : TKDT22DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DI64_Node;
    function GetData(const index: NativeInt): PKDT22DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT22DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT22DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT22DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT22DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT22DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT22DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT22DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT22DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DI64_Node; overload;
    function Search(const Buff: TKDT22DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DI64_Node; overload;
    function Search(const Buff: TKDT22DI64_Vec; var SearchedDistanceMin: Double): PKDT22DI64_Node; overload;
    function Search(const Buff: TKDT22DI64_Vec): PKDT22DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT22DI64_DynamicVecBuffer; var OutBuff: TKDT22DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT22DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT22DI64_Node);
    procedure PrintBuffer;

    class function KDT22DI64Vec(const s: string): TKDT22DI64_Vec; overload;
    class function KDT22DI64Vec(const v: TKDT22DI64_Vec): string; overload;
    class function KDT22DI64Pow(const v: TKDT22DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT22DI64Distance(const v1, v2: TKDT22DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT22DI64_Source);
    class procedure Test;
  end;



  TKDT23DI64_Vec = array [0 .. KDT23DI64_Axis - 1] of TKDT23DI64_VecType;
  PKDT23DI64_Vec = ^TKDT23DI64_Vec;

  TKDT23DI64_DynamicVecBuffer = array of TKDT23DI64_Vec;
  PKDT23DI64_DynamicVecBuffer = ^TKDT23DI64_DynamicVecBuffer;

  TKDT23DI64_Source = packed record
    Buff: TKDT23DI64_Vec;
    index: Int64;
  end;

  PKDT23DI64_Source       = ^TKDT23DI64_Source;
  TKDT23DI64_SourceBuffer = array [0 .. 0] of PKDT23DI64_Source;
  PKDT23DI64_SourceBuffer = ^TKDT23DI64_SourceBuffer;

  TKDT23DI64yanmicSourceBuffer = array of PKDT23DI64_Source;
  PKDT23DI64yanmicSourceBuffer = ^TKDT23DI64yanmicSourceBuffer;

  TKDT23DI64yanmicStoreBuffer = array of TKDT23DI64_Source;
  PKDT23DI64yanmicStoreBuffer = ^TKDT23DI64yanmicStoreBuffer;

  PKDT23DI64_Node = ^TKDT23DI64_Node;

  TKDT23DI64_Node = packed record
    Parent, Right, Left: PKDT23DI64_Node;
    vec: PKDT23DI64_Source;
  end;

  TKDT23DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT23DI64_Source);
  TKDT23DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT23DI64_Source) of object;
  {$IFNDEF FPC} TKDT23DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT23DI64_Source); {$ENDIF}

  TKDT23DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT23DI64yanmicStoreBuffer;
    KDBuff     : TKDT23DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT23DI64_Node;
    TestBuff   : TKDT23DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DI64_Node;
    function GetData(const index: NativeInt): PKDT23DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT23DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT23DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT23DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT23DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT23DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT23DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT23DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT23DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DI64_Node; overload;
    function Search(const Buff: TKDT23DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DI64_Node; overload;
    function Search(const Buff: TKDT23DI64_Vec; var SearchedDistanceMin: Double): PKDT23DI64_Node; overload;
    function Search(const Buff: TKDT23DI64_Vec): PKDT23DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT23DI64_DynamicVecBuffer; var OutBuff: TKDT23DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT23DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT23DI64_Node);
    procedure PrintBuffer;

    class function KDT23DI64Vec(const s: string): TKDT23DI64_Vec; overload;
    class function KDT23DI64Vec(const v: TKDT23DI64_Vec): string; overload;
    class function KDT23DI64Pow(const v: TKDT23DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT23DI64Distance(const v1, v2: TKDT23DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT23DI64_Source);
    class procedure Test;
  end;



  TKDT24DI64_Vec = array [0 .. KDT24DI64_Axis - 1] of TKDT24DI64_VecType;
  PKDT24DI64_Vec = ^TKDT24DI64_Vec;

  TKDT24DI64_DynamicVecBuffer = array of TKDT24DI64_Vec;
  PKDT24DI64_DynamicVecBuffer = ^TKDT24DI64_DynamicVecBuffer;

  TKDT24DI64_Source = packed record
    Buff: TKDT24DI64_Vec;
    index: Int64;
  end;

  PKDT24DI64_Source       = ^TKDT24DI64_Source;
  TKDT24DI64_SourceBuffer = array [0 .. 0] of PKDT24DI64_Source;
  PKDT24DI64_SourceBuffer = ^TKDT24DI64_SourceBuffer;

  TKDT24DI64yanmicSourceBuffer = array of PKDT24DI64_Source;
  PKDT24DI64yanmicSourceBuffer = ^TKDT24DI64yanmicSourceBuffer;

  TKDT24DI64yanmicStoreBuffer = array of TKDT24DI64_Source;
  PKDT24DI64yanmicStoreBuffer = ^TKDT24DI64yanmicStoreBuffer;

  PKDT24DI64_Node = ^TKDT24DI64_Node;

  TKDT24DI64_Node = packed record
    Parent, Right, Left: PKDT24DI64_Node;
    vec: PKDT24DI64_Source;
  end;

  TKDT24DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT24DI64_Source);
  TKDT24DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT24DI64_Source) of object;
  {$IFNDEF FPC} TKDT24DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT24DI64_Source); {$ENDIF}

  TKDT24DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT24DI64yanmicStoreBuffer;
    KDBuff     : TKDT24DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT24DI64_Node;
    TestBuff   : TKDT24DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DI64_Node;
    function GetData(const index: NativeInt): PKDT24DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT24DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT24DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT24DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT24DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT24DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT24DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT24DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT24DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DI64_Node; overload;
    function Search(const Buff: TKDT24DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DI64_Node; overload;
    function Search(const Buff: TKDT24DI64_Vec; var SearchedDistanceMin: Double): PKDT24DI64_Node; overload;
    function Search(const Buff: TKDT24DI64_Vec): PKDT24DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT24DI64_DynamicVecBuffer; var OutBuff: TKDT24DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT24DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT24DI64_Node);
    procedure PrintBuffer;

    class function KDT24DI64Vec(const s: string): TKDT24DI64_Vec; overload;
    class function KDT24DI64Vec(const v: TKDT24DI64_Vec): string; overload;
    class function KDT24DI64Pow(const v: TKDT24DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT24DI64Distance(const v1, v2: TKDT24DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT24DI64_Source);
    class procedure Test;
  end;



  TKDT25DI64_Vec = array [0 .. KDT25DI64_Axis - 1] of TKDT25DI64_VecType;
  PKDT25DI64_Vec = ^TKDT25DI64_Vec;

  TKDT25DI64_DynamicVecBuffer = array of TKDT25DI64_Vec;
  PKDT25DI64_DynamicVecBuffer = ^TKDT25DI64_DynamicVecBuffer;

  TKDT25DI64_Source = packed record
    Buff: TKDT25DI64_Vec;
    index: Int64;
  end;

  PKDT25DI64_Source       = ^TKDT25DI64_Source;
  TKDT25DI64_SourceBuffer = array [0 .. 0] of PKDT25DI64_Source;
  PKDT25DI64_SourceBuffer = ^TKDT25DI64_SourceBuffer;

  TKDT25DI64yanmicSourceBuffer = array of PKDT25DI64_Source;
  PKDT25DI64yanmicSourceBuffer = ^TKDT25DI64yanmicSourceBuffer;

  TKDT25DI64yanmicStoreBuffer = array of TKDT25DI64_Source;
  PKDT25DI64yanmicStoreBuffer = ^TKDT25DI64yanmicStoreBuffer;

  PKDT25DI64_Node = ^TKDT25DI64_Node;

  TKDT25DI64_Node = packed record
    Parent, Right, Left: PKDT25DI64_Node;
    vec: PKDT25DI64_Source;
  end;

  TKDT25DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT25DI64_Source);
  TKDT25DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT25DI64_Source) of object;
  {$IFNDEF FPC} TKDT25DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT25DI64_Source); {$ENDIF}

  TKDT25DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT25DI64yanmicStoreBuffer;
    KDBuff     : TKDT25DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT25DI64_Node;
    TestBuff   : TKDT25DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT25DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT25DI64_Node;
    function GetData(const index: NativeInt): PKDT25DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT25DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT25DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT25DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT25DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT25DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT25DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT25DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT25DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT25DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT25DI64_Node; overload;
    function Search(const Buff: TKDT25DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT25DI64_Node; overload;
    function Search(const Buff: TKDT25DI64_Vec; var SearchedDistanceMin: Double): PKDT25DI64_Node; overload;
    function Search(const Buff: TKDT25DI64_Vec): PKDT25DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT25DI64_DynamicVecBuffer; var OutBuff: TKDT25DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT25DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT25DI64_Node);
    procedure PrintBuffer;

    class function KDT25DI64Vec(const s: string): TKDT25DI64_Vec; overload;
    class function KDT25DI64Vec(const v: TKDT25DI64_Vec): string; overload;
    class function KDT25DI64Pow(const v: TKDT25DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT25DI64Distance(const v1, v2: TKDT25DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT25DI64_Source);
    class procedure Test;
  end;



  TKDT26DI64_Vec = array [0 .. KDT26DI64_Axis - 1] of TKDT26DI64_VecType;
  PKDT26DI64_Vec = ^TKDT26DI64_Vec;

  TKDT26DI64_DynamicVecBuffer = array of TKDT26DI64_Vec;
  PKDT26DI64_DynamicVecBuffer = ^TKDT26DI64_DynamicVecBuffer;

  TKDT26DI64_Source = packed record
    Buff: TKDT26DI64_Vec;
    index: Int64;
  end;

  PKDT26DI64_Source       = ^TKDT26DI64_Source;
  TKDT26DI64_SourceBuffer = array [0 .. 0] of PKDT26DI64_Source;
  PKDT26DI64_SourceBuffer = ^TKDT26DI64_SourceBuffer;

  TKDT26DI64yanmicSourceBuffer = array of PKDT26DI64_Source;
  PKDT26DI64yanmicSourceBuffer = ^TKDT26DI64yanmicSourceBuffer;

  TKDT26DI64yanmicStoreBuffer = array of TKDT26DI64_Source;
  PKDT26DI64yanmicStoreBuffer = ^TKDT26DI64yanmicStoreBuffer;

  PKDT26DI64_Node = ^TKDT26DI64_Node;

  TKDT26DI64_Node = packed record
    Parent, Right, Left: PKDT26DI64_Node;
    vec: PKDT26DI64_Source;
  end;

  TKDT26DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT26DI64_Source);
  TKDT26DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT26DI64_Source) of object;
  {$IFNDEF FPC} TKDT26DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT26DI64_Source); {$ENDIF}

  TKDT26DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT26DI64yanmicStoreBuffer;
    KDBuff     : TKDT26DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT26DI64_Node;
    TestBuff   : TKDT26DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT26DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT26DI64_Node;
    function GetData(const index: NativeInt): PKDT26DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT26DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT26DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT26DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT26DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT26DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT26DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT26DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT26DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT26DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT26DI64_Node; overload;
    function Search(const Buff: TKDT26DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT26DI64_Node; overload;
    function Search(const Buff: TKDT26DI64_Vec; var SearchedDistanceMin: Double): PKDT26DI64_Node; overload;
    function Search(const Buff: TKDT26DI64_Vec): PKDT26DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT26DI64_DynamicVecBuffer; var OutBuff: TKDT26DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT26DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT26DI64_Node);
    procedure PrintBuffer;

    class function KDT26DI64Vec(const s: string): TKDT26DI64_Vec; overload;
    class function KDT26DI64Vec(const v: TKDT26DI64_Vec): string; overload;
    class function KDT26DI64Pow(const v: TKDT26DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT26DI64Distance(const v1, v2: TKDT26DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT26DI64_Source);
    class procedure Test;
  end;



  TKDT27DI64_Vec = array [0 .. KDT27DI64_Axis - 1] of TKDT27DI64_VecType;
  PKDT27DI64_Vec = ^TKDT27DI64_Vec;

  TKDT27DI64_DynamicVecBuffer = array of TKDT27DI64_Vec;
  PKDT27DI64_DynamicVecBuffer = ^TKDT27DI64_DynamicVecBuffer;

  TKDT27DI64_Source = packed record
    Buff: TKDT27DI64_Vec;
    index: Int64;
  end;

  PKDT27DI64_Source       = ^TKDT27DI64_Source;
  TKDT27DI64_SourceBuffer = array [0 .. 0] of PKDT27DI64_Source;
  PKDT27DI64_SourceBuffer = ^TKDT27DI64_SourceBuffer;

  TKDT27DI64yanmicSourceBuffer = array of PKDT27DI64_Source;
  PKDT27DI64yanmicSourceBuffer = ^TKDT27DI64yanmicSourceBuffer;

  TKDT27DI64yanmicStoreBuffer = array of TKDT27DI64_Source;
  PKDT27DI64yanmicStoreBuffer = ^TKDT27DI64yanmicStoreBuffer;

  PKDT27DI64_Node = ^TKDT27DI64_Node;

  TKDT27DI64_Node = packed record
    Parent, Right, Left: PKDT27DI64_Node;
    vec: PKDT27DI64_Source;
  end;

  TKDT27DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT27DI64_Source);
  TKDT27DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT27DI64_Source) of object;
  {$IFNDEF FPC} TKDT27DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT27DI64_Source); {$ENDIF}

  TKDT27DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT27DI64yanmicStoreBuffer;
    KDBuff     : TKDT27DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT27DI64_Node;
    TestBuff   : TKDT27DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT27DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT27DI64_Node;
    function GetData(const index: NativeInt): PKDT27DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT27DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT27DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT27DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT27DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT27DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT27DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT27DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT27DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT27DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT27DI64_Node; overload;
    function Search(const Buff: TKDT27DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT27DI64_Node; overload;
    function Search(const Buff: TKDT27DI64_Vec; var SearchedDistanceMin: Double): PKDT27DI64_Node; overload;
    function Search(const Buff: TKDT27DI64_Vec): PKDT27DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT27DI64_DynamicVecBuffer; var OutBuff: TKDT27DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT27DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT27DI64_Node);
    procedure PrintBuffer;

    class function KDT27DI64Vec(const s: string): TKDT27DI64_Vec; overload;
    class function KDT27DI64Vec(const v: TKDT27DI64_Vec): string; overload;
    class function KDT27DI64Pow(const v: TKDT27DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT27DI64Distance(const v1, v2: TKDT27DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT27DI64_Source);
    class procedure Test;
  end;



  TKDT28DI64_Vec = array [0 .. KDT28DI64_Axis - 1] of TKDT28DI64_VecType;
  PKDT28DI64_Vec = ^TKDT28DI64_Vec;

  TKDT28DI64_DynamicVecBuffer = array of TKDT28DI64_Vec;
  PKDT28DI64_DynamicVecBuffer = ^TKDT28DI64_DynamicVecBuffer;

  TKDT28DI64_Source = packed record
    Buff: TKDT28DI64_Vec;
    index: Int64;
  end;

  PKDT28DI64_Source       = ^TKDT28DI64_Source;
  TKDT28DI64_SourceBuffer = array [0 .. 0] of PKDT28DI64_Source;
  PKDT28DI64_SourceBuffer = ^TKDT28DI64_SourceBuffer;

  TKDT28DI64yanmicSourceBuffer = array of PKDT28DI64_Source;
  PKDT28DI64yanmicSourceBuffer = ^TKDT28DI64yanmicSourceBuffer;

  TKDT28DI64yanmicStoreBuffer = array of TKDT28DI64_Source;
  PKDT28DI64yanmicStoreBuffer = ^TKDT28DI64yanmicStoreBuffer;

  PKDT28DI64_Node = ^TKDT28DI64_Node;

  TKDT28DI64_Node = packed record
    Parent, Right, Left: PKDT28DI64_Node;
    vec: PKDT28DI64_Source;
  end;

  TKDT28DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT28DI64_Source);
  TKDT28DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT28DI64_Source) of object;
  {$IFNDEF FPC} TKDT28DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT28DI64_Source); {$ENDIF}

  TKDT28DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT28DI64yanmicStoreBuffer;
    KDBuff     : TKDT28DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT28DI64_Node;
    TestBuff   : TKDT28DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DI64_Node;
    function GetData(const index: NativeInt): PKDT28DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT28DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT28DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT28DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT28DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT28DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT28DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT28DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT28DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DI64_Node; overload;
    function Search(const Buff: TKDT28DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DI64_Node; overload;
    function Search(const Buff: TKDT28DI64_Vec; var SearchedDistanceMin: Double): PKDT28DI64_Node; overload;
    function Search(const Buff: TKDT28DI64_Vec): PKDT28DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT28DI64_DynamicVecBuffer; var OutBuff: TKDT28DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT28DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT28DI64_Node);
    procedure PrintBuffer;

    class function KDT28DI64Vec(const s: string): TKDT28DI64_Vec; overload;
    class function KDT28DI64Vec(const v: TKDT28DI64_Vec): string; overload;
    class function KDT28DI64Pow(const v: TKDT28DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT28DI64Distance(const v1, v2: TKDT28DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT28DI64_Source);
    class procedure Test;
  end;



  TKDT29DI64_Vec = array [0 .. KDT29DI64_Axis - 1] of TKDT29DI64_VecType;
  PKDT29DI64_Vec = ^TKDT29DI64_Vec;

  TKDT29DI64_DynamicVecBuffer = array of TKDT29DI64_Vec;
  PKDT29DI64_DynamicVecBuffer = ^TKDT29DI64_DynamicVecBuffer;

  TKDT29DI64_Source = packed record
    Buff: TKDT29DI64_Vec;
    index: Int64;
  end;

  PKDT29DI64_Source       = ^TKDT29DI64_Source;
  TKDT29DI64_SourceBuffer = array [0 .. 0] of PKDT29DI64_Source;
  PKDT29DI64_SourceBuffer = ^TKDT29DI64_SourceBuffer;

  TKDT29DI64yanmicSourceBuffer = array of PKDT29DI64_Source;
  PKDT29DI64yanmicSourceBuffer = ^TKDT29DI64yanmicSourceBuffer;

  TKDT29DI64yanmicStoreBuffer = array of TKDT29DI64_Source;
  PKDT29DI64yanmicStoreBuffer = ^TKDT29DI64yanmicStoreBuffer;

  PKDT29DI64_Node = ^TKDT29DI64_Node;

  TKDT29DI64_Node = packed record
    Parent, Right, Left: PKDT29DI64_Node;
    vec: PKDT29DI64_Source;
  end;

  TKDT29DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT29DI64_Source);
  TKDT29DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT29DI64_Source) of object;
  {$IFNDEF FPC} TKDT29DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT29DI64_Source); {$ENDIF}

  TKDT29DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT29DI64yanmicStoreBuffer;
    KDBuff     : TKDT29DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT29DI64_Node;
    TestBuff   : TKDT29DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT29DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT29DI64_Node;
    function GetData(const index: NativeInt): PKDT29DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT29DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT29DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT29DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT29DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT29DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT29DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT29DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT29DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT29DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT29DI64_Node; overload;
    function Search(const Buff: TKDT29DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT29DI64_Node; overload;
    function Search(const Buff: TKDT29DI64_Vec; var SearchedDistanceMin: Double): PKDT29DI64_Node; overload;
    function Search(const Buff: TKDT29DI64_Vec): PKDT29DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT29DI64_DynamicVecBuffer; var OutBuff: TKDT29DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT29DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT29DI64_Node);
    procedure PrintBuffer;

    class function KDT29DI64Vec(const s: string): TKDT29DI64_Vec; overload;
    class function KDT29DI64Vec(const v: TKDT29DI64_Vec): string; overload;
    class function KDT29DI64Pow(const v: TKDT29DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT29DI64Distance(const v1, v2: TKDT29DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT29DI64_Source);
    class procedure Test;
  end;



  TKDT30DI64_Vec = array [0 .. KDT30DI64_Axis - 1] of TKDT30DI64_VecType;
  PKDT30DI64_Vec = ^TKDT30DI64_Vec;

  TKDT30DI64_DynamicVecBuffer = array of TKDT30DI64_Vec;
  PKDT30DI64_DynamicVecBuffer = ^TKDT30DI64_DynamicVecBuffer;

  TKDT30DI64_Source = packed record
    Buff: TKDT30DI64_Vec;
    index: Int64;
  end;

  PKDT30DI64_Source       = ^TKDT30DI64_Source;
  TKDT30DI64_SourceBuffer = array [0 .. 0] of PKDT30DI64_Source;
  PKDT30DI64_SourceBuffer = ^TKDT30DI64_SourceBuffer;

  TKDT30DI64yanmicSourceBuffer = array of PKDT30DI64_Source;
  PKDT30DI64yanmicSourceBuffer = ^TKDT30DI64yanmicSourceBuffer;

  TKDT30DI64yanmicStoreBuffer = array of TKDT30DI64_Source;
  PKDT30DI64yanmicStoreBuffer = ^TKDT30DI64yanmicStoreBuffer;

  PKDT30DI64_Node = ^TKDT30DI64_Node;

  TKDT30DI64_Node = packed record
    Parent, Right, Left: PKDT30DI64_Node;
    vec: PKDT30DI64_Source;
  end;

  TKDT30DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT30DI64_Source);
  TKDT30DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT30DI64_Source) of object;
  {$IFNDEF FPC} TKDT30DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT30DI64_Source); {$ENDIF}

  TKDT30DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT30DI64yanmicStoreBuffer;
    KDBuff     : TKDT30DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT30DI64_Node;
    TestBuff   : TKDT30DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DI64_Node;
    function GetData(const index: NativeInt): PKDT30DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT30DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT30DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT30DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT30DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT30DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT30DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT30DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT30DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DI64_Node; overload;
    function Search(const Buff: TKDT30DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DI64_Node; overload;
    function Search(const Buff: TKDT30DI64_Vec; var SearchedDistanceMin: Double): PKDT30DI64_Node; overload;
    function Search(const Buff: TKDT30DI64_Vec): PKDT30DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT30DI64_DynamicVecBuffer; var OutBuff: TKDT30DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT30DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT30DI64_Node);
    procedure PrintBuffer;

    class function KDT30DI64Vec(const s: string): TKDT30DI64_Vec; overload;
    class function KDT30DI64Vec(const v: TKDT30DI64_Vec): string; overload;
    class function KDT30DI64Pow(const v: TKDT30DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT30DI64Distance(const v1, v2: TKDT30DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT30DI64_Source);
    class procedure Test;
  end;



  TKDT31DI64_Vec = array [0 .. KDT31DI64_Axis - 1] of TKDT31DI64_VecType;
  PKDT31DI64_Vec = ^TKDT31DI64_Vec;

  TKDT31DI64_DynamicVecBuffer = array of TKDT31DI64_Vec;
  PKDT31DI64_DynamicVecBuffer = ^TKDT31DI64_DynamicVecBuffer;

  TKDT31DI64_Source = packed record
    Buff: TKDT31DI64_Vec;
    index: Int64;
  end;

  PKDT31DI64_Source       = ^TKDT31DI64_Source;
  TKDT31DI64_SourceBuffer = array [0 .. 0] of PKDT31DI64_Source;
  PKDT31DI64_SourceBuffer = ^TKDT31DI64_SourceBuffer;

  TKDT31DI64yanmicSourceBuffer = array of PKDT31DI64_Source;
  PKDT31DI64yanmicSourceBuffer = ^TKDT31DI64yanmicSourceBuffer;

  TKDT31DI64yanmicStoreBuffer = array of TKDT31DI64_Source;
  PKDT31DI64yanmicStoreBuffer = ^TKDT31DI64yanmicStoreBuffer;

  PKDT31DI64_Node = ^TKDT31DI64_Node;

  TKDT31DI64_Node = packed record
    Parent, Right, Left: PKDT31DI64_Node;
    vec: PKDT31DI64_Source;
  end;

  TKDT31DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT31DI64_Source);
  TKDT31DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT31DI64_Source) of object;
  {$IFNDEF FPC} TKDT31DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT31DI64_Source); {$ENDIF}

  TKDT31DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT31DI64yanmicStoreBuffer;
    KDBuff     : TKDT31DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT31DI64_Node;
    TestBuff   : TKDT31DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT31DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT31DI64_Node;
    function GetData(const index: NativeInt): PKDT31DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT31DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT31DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT31DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT31DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT31DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT31DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT31DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT31DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT31DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT31DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT31DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT31DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT31DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT31DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT31DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT31DI64_Node; overload;
    function Search(const Buff: TKDT31DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT31DI64_Node; overload;
    function Search(const Buff: TKDT31DI64_Vec; var SearchedDistanceMin: Double): PKDT31DI64_Node; overload;
    function Search(const Buff: TKDT31DI64_Vec): PKDT31DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT31DI64_DynamicVecBuffer; var OutBuff: TKDT31DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT31DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT31DI64_Node);
    procedure PrintBuffer;

    class function KDT31DI64Vec(const s: string): TKDT31DI64_Vec; overload;
    class function KDT31DI64Vec(const v: TKDT31DI64_Vec): string; overload;
    class function KDT31DI64Pow(const v: TKDT31DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT31DI64Distance(const v1, v2: TKDT31DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT31DI64_Source);
    class procedure Test;
  end;



  TKDT32DI64_Vec = array [0 .. KDT32DI64_Axis - 1] of TKDT32DI64_VecType;
  PKDT32DI64_Vec = ^TKDT32DI64_Vec;

  TKDT32DI64_DynamicVecBuffer = array of TKDT32DI64_Vec;
  PKDT32DI64_DynamicVecBuffer = ^TKDT32DI64_DynamicVecBuffer;

  TKDT32DI64_Source = packed record
    Buff: TKDT32DI64_Vec;
    index: Int64;
  end;

  PKDT32DI64_Source       = ^TKDT32DI64_Source;
  TKDT32DI64_SourceBuffer = array [0 .. 0] of PKDT32DI64_Source;
  PKDT32DI64_SourceBuffer = ^TKDT32DI64_SourceBuffer;

  TKDT32DI64yanmicSourceBuffer = array of PKDT32DI64_Source;
  PKDT32DI64yanmicSourceBuffer = ^TKDT32DI64yanmicSourceBuffer;

  TKDT32DI64yanmicStoreBuffer = array of TKDT32DI64_Source;
  PKDT32DI64yanmicStoreBuffer = ^TKDT32DI64yanmicStoreBuffer;

  PKDT32DI64_Node = ^TKDT32DI64_Node;

  TKDT32DI64_Node = packed record
    Parent, Right, Left: PKDT32DI64_Node;
    vec: PKDT32DI64_Source;
  end;

  TKDT32DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT32DI64_Source);
  TKDT32DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT32DI64_Source) of object;
  {$IFNDEF FPC} TKDT32DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT32DI64_Source); {$ENDIF}

  TKDT32DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT32DI64yanmicStoreBuffer;
    KDBuff     : TKDT32DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT32DI64_Node;
    TestBuff   : TKDT32DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DI64_Node;
    function GetData(const index: NativeInt): PKDT32DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT32DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT32DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT32DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT32DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT32DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT32DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT32DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT32DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DI64_Node; overload;
    function Search(const Buff: TKDT32DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DI64_Node; overload;
    function Search(const Buff: TKDT32DI64_Vec; var SearchedDistanceMin: Double): PKDT32DI64_Node; overload;
    function Search(const Buff: TKDT32DI64_Vec): PKDT32DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT32DI64_DynamicVecBuffer; var OutBuff: TKDT32DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT32DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT32DI64_Node);
    procedure PrintBuffer;

    class function KDT32DI64Vec(const s: string): TKDT32DI64_Vec; overload;
    class function KDT32DI64Vec(const v: TKDT32DI64_Vec): string; overload;
    class function KDT32DI64Pow(const v: TKDT32DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT32DI64Distance(const v1, v2: TKDT32DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT32DI64_Source);
    class procedure Test;
  end;



  TKDT33DI64_Vec = array [0 .. KDT33DI64_Axis - 1] of TKDT33DI64_VecType;
  PKDT33DI64_Vec = ^TKDT33DI64_Vec;

  TKDT33DI64_DynamicVecBuffer = array of TKDT33DI64_Vec;
  PKDT33DI64_DynamicVecBuffer = ^TKDT33DI64_DynamicVecBuffer;

  TKDT33DI64_Source = packed record
    Buff: TKDT33DI64_Vec;
    index: Int64;
  end;

  PKDT33DI64_Source       = ^TKDT33DI64_Source;
  TKDT33DI64_SourceBuffer = array [0 .. 0] of PKDT33DI64_Source;
  PKDT33DI64_SourceBuffer = ^TKDT33DI64_SourceBuffer;

  TKDT33DI64yanmicSourceBuffer = array of PKDT33DI64_Source;
  PKDT33DI64yanmicSourceBuffer = ^TKDT33DI64yanmicSourceBuffer;

  TKDT33DI64yanmicStoreBuffer = array of TKDT33DI64_Source;
  PKDT33DI64yanmicStoreBuffer = ^TKDT33DI64yanmicStoreBuffer;

  PKDT33DI64_Node = ^TKDT33DI64_Node;

  TKDT33DI64_Node = packed record
    Parent, Right, Left: PKDT33DI64_Node;
    vec: PKDT33DI64_Source;
  end;

  TKDT33DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT33DI64_Source);
  TKDT33DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT33DI64_Source) of object;
  {$IFNDEF FPC} TKDT33DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT33DI64_Source); {$ENDIF}

  TKDT33DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT33DI64yanmicStoreBuffer;
    KDBuff     : TKDT33DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT33DI64_Node;
    TestBuff   : TKDT33DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT33DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT33DI64_Node;
    function GetData(const index: NativeInt): PKDT33DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT33DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT33DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT33DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT33DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT33DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT33DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT33DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT33DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT33DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT33DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT33DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT33DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT33DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT33DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT33DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT33DI64_Node; overload;
    function Search(const Buff: TKDT33DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT33DI64_Node; overload;
    function Search(const Buff: TKDT33DI64_Vec; var SearchedDistanceMin: Double): PKDT33DI64_Node; overload;
    function Search(const Buff: TKDT33DI64_Vec): PKDT33DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT33DI64_DynamicVecBuffer; var OutBuff: TKDT33DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT33DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT33DI64_Node);
    procedure PrintBuffer;

    class function KDT33DI64Vec(const s: string): TKDT33DI64_Vec; overload;
    class function KDT33DI64Vec(const v: TKDT33DI64_Vec): string; overload;
    class function KDT33DI64Pow(const v: TKDT33DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT33DI64Distance(const v1, v2: TKDT33DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT33DI64_Source);
    class procedure Test;
  end;



  TKDT34DI64_Vec = array [0 .. KDT34DI64_Axis - 1] of TKDT34DI64_VecType;
  PKDT34DI64_Vec = ^TKDT34DI64_Vec;

  TKDT34DI64_DynamicVecBuffer = array of TKDT34DI64_Vec;
  PKDT34DI64_DynamicVecBuffer = ^TKDT34DI64_DynamicVecBuffer;

  TKDT34DI64_Source = packed record
    Buff: TKDT34DI64_Vec;
    index: Int64;
  end;

  PKDT34DI64_Source       = ^TKDT34DI64_Source;
  TKDT34DI64_SourceBuffer = array [0 .. 0] of PKDT34DI64_Source;
  PKDT34DI64_SourceBuffer = ^TKDT34DI64_SourceBuffer;

  TKDT34DI64yanmicSourceBuffer = array of PKDT34DI64_Source;
  PKDT34DI64yanmicSourceBuffer = ^TKDT34DI64yanmicSourceBuffer;

  TKDT34DI64yanmicStoreBuffer = array of TKDT34DI64_Source;
  PKDT34DI64yanmicStoreBuffer = ^TKDT34DI64yanmicStoreBuffer;

  PKDT34DI64_Node = ^TKDT34DI64_Node;

  TKDT34DI64_Node = packed record
    Parent, Right, Left: PKDT34DI64_Node;
    vec: PKDT34DI64_Source;
  end;

  TKDT34DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT34DI64_Source);
  TKDT34DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT34DI64_Source) of object;
  {$IFNDEF FPC} TKDT34DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT34DI64_Source); {$ENDIF}

  TKDT34DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT34DI64yanmicStoreBuffer;
    KDBuff     : TKDT34DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT34DI64_Node;
    TestBuff   : TKDT34DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DI64_Node;
    function GetData(const index: NativeInt): PKDT34DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT34DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT34DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT34DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT34DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT34DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT34DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT34DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT34DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DI64_Node; overload;
    function Search(const Buff: TKDT34DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DI64_Node; overload;
    function Search(const Buff: TKDT34DI64_Vec; var SearchedDistanceMin: Double): PKDT34DI64_Node; overload;
    function Search(const Buff: TKDT34DI64_Vec): PKDT34DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT34DI64_DynamicVecBuffer; var OutBuff: TKDT34DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT34DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT34DI64_Node);
    procedure PrintBuffer;

    class function KDT34DI64Vec(const s: string): TKDT34DI64_Vec; overload;
    class function KDT34DI64Vec(const v: TKDT34DI64_Vec): string; overload;
    class function KDT34DI64Pow(const v: TKDT34DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT34DI64Distance(const v1, v2: TKDT34DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT34DI64_Source);
    class procedure Test;
  end;



  TKDT35DI64_Vec = array [0 .. KDT35DI64_Axis - 1] of TKDT35DI64_VecType;
  PKDT35DI64_Vec = ^TKDT35DI64_Vec;

  TKDT35DI64_DynamicVecBuffer = array of TKDT35DI64_Vec;
  PKDT35DI64_DynamicVecBuffer = ^TKDT35DI64_DynamicVecBuffer;

  TKDT35DI64_Source = packed record
    Buff: TKDT35DI64_Vec;
    index: Int64;
  end;

  PKDT35DI64_Source       = ^TKDT35DI64_Source;
  TKDT35DI64_SourceBuffer = array [0 .. 0] of PKDT35DI64_Source;
  PKDT35DI64_SourceBuffer = ^TKDT35DI64_SourceBuffer;

  TKDT35DI64yanmicSourceBuffer = array of PKDT35DI64_Source;
  PKDT35DI64yanmicSourceBuffer = ^TKDT35DI64yanmicSourceBuffer;

  TKDT35DI64yanmicStoreBuffer = array of TKDT35DI64_Source;
  PKDT35DI64yanmicStoreBuffer = ^TKDT35DI64yanmicStoreBuffer;

  PKDT35DI64_Node = ^TKDT35DI64_Node;

  TKDT35DI64_Node = packed record
    Parent, Right, Left: PKDT35DI64_Node;
    vec: PKDT35DI64_Source;
  end;

  TKDT35DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT35DI64_Source);
  TKDT35DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT35DI64_Source) of object;
  {$IFNDEF FPC} TKDT35DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT35DI64_Source); {$ENDIF}

  TKDT35DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT35DI64yanmicStoreBuffer;
    KDBuff     : TKDT35DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT35DI64_Node;
    TestBuff   : TKDT35DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT35DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT35DI64_Node;
    function GetData(const index: NativeInt): PKDT35DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT35DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT35DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT35DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT35DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT35DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT35DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT35DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT35DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT35DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT35DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT35DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT35DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT35DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT35DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT35DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT35DI64_Node; overload;
    function Search(const Buff: TKDT35DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT35DI64_Node; overload;
    function Search(const Buff: TKDT35DI64_Vec; var SearchedDistanceMin: Double): PKDT35DI64_Node; overload;
    function Search(const Buff: TKDT35DI64_Vec): PKDT35DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT35DI64_DynamicVecBuffer; var OutBuff: TKDT35DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT35DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT35DI64_Node);
    procedure PrintBuffer;

    class function KDT35DI64Vec(const s: string): TKDT35DI64_Vec; overload;
    class function KDT35DI64Vec(const v: TKDT35DI64_Vec): string; overload;
    class function KDT35DI64Pow(const v: TKDT35DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT35DI64Distance(const v1, v2: TKDT35DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT35DI64_Source);
    class procedure Test;
  end;



  TKDT36DI64_Vec = array [0 .. KDT36DI64_Axis - 1] of TKDT36DI64_VecType;
  PKDT36DI64_Vec = ^TKDT36DI64_Vec;

  TKDT36DI64_DynamicVecBuffer = array of TKDT36DI64_Vec;
  PKDT36DI64_DynamicVecBuffer = ^TKDT36DI64_DynamicVecBuffer;

  TKDT36DI64_Source = packed record
    Buff: TKDT36DI64_Vec;
    index: Int64;
  end;

  PKDT36DI64_Source       = ^TKDT36DI64_Source;
  TKDT36DI64_SourceBuffer = array [0 .. 0] of PKDT36DI64_Source;
  PKDT36DI64_SourceBuffer = ^TKDT36DI64_SourceBuffer;

  TKDT36DI64yanmicSourceBuffer = array of PKDT36DI64_Source;
  PKDT36DI64yanmicSourceBuffer = ^TKDT36DI64yanmicSourceBuffer;

  TKDT36DI64yanmicStoreBuffer = array of TKDT36DI64_Source;
  PKDT36DI64yanmicStoreBuffer = ^TKDT36DI64yanmicStoreBuffer;

  PKDT36DI64_Node = ^TKDT36DI64_Node;

  TKDT36DI64_Node = packed record
    Parent, Right, Left: PKDT36DI64_Node;
    vec: PKDT36DI64_Source;
  end;

  TKDT36DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT36DI64_Source);
  TKDT36DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT36DI64_Source) of object;
  {$IFNDEF FPC} TKDT36DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT36DI64_Source); {$ENDIF}

  TKDT36DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT36DI64yanmicStoreBuffer;
    KDBuff     : TKDT36DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT36DI64_Node;
    TestBuff   : TKDT36DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DI64_Node;
    function GetData(const index: NativeInt): PKDT36DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT36DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT36DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT36DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT36DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT36DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT36DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT36DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT36DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DI64_Node; overload;
    function Search(const Buff: TKDT36DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DI64_Node; overload;
    function Search(const Buff: TKDT36DI64_Vec; var SearchedDistanceMin: Double): PKDT36DI64_Node; overload;
    function Search(const Buff: TKDT36DI64_Vec): PKDT36DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT36DI64_DynamicVecBuffer; var OutBuff: TKDT36DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT36DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT36DI64_Node);
    procedure PrintBuffer;

    class function KDT36DI64Vec(const s: string): TKDT36DI64_Vec; overload;
    class function KDT36DI64Vec(const v: TKDT36DI64_Vec): string; overload;
    class function KDT36DI64Pow(const v: TKDT36DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT36DI64Distance(const v1, v2: TKDT36DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT36DI64_Source);
    class procedure Test;
  end;



  TKDT37DI64_Vec = array [0 .. KDT37DI64_Axis - 1] of TKDT37DI64_VecType;
  PKDT37DI64_Vec = ^TKDT37DI64_Vec;

  TKDT37DI64_DynamicVecBuffer = array of TKDT37DI64_Vec;
  PKDT37DI64_DynamicVecBuffer = ^TKDT37DI64_DynamicVecBuffer;

  TKDT37DI64_Source = packed record
    Buff: TKDT37DI64_Vec;
    index: Int64;
  end;

  PKDT37DI64_Source       = ^TKDT37DI64_Source;
  TKDT37DI64_SourceBuffer = array [0 .. 0] of PKDT37DI64_Source;
  PKDT37DI64_SourceBuffer = ^TKDT37DI64_SourceBuffer;

  TKDT37DI64yanmicSourceBuffer = array of PKDT37DI64_Source;
  PKDT37DI64yanmicSourceBuffer = ^TKDT37DI64yanmicSourceBuffer;

  TKDT37DI64yanmicStoreBuffer = array of TKDT37DI64_Source;
  PKDT37DI64yanmicStoreBuffer = ^TKDT37DI64yanmicStoreBuffer;

  PKDT37DI64_Node = ^TKDT37DI64_Node;

  TKDT37DI64_Node = packed record
    Parent, Right, Left: PKDT37DI64_Node;
    vec: PKDT37DI64_Source;
  end;

  TKDT37DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT37DI64_Source);
  TKDT37DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT37DI64_Source) of object;
  {$IFNDEF FPC} TKDT37DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT37DI64_Source); {$ENDIF}

  TKDT37DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT37DI64yanmicStoreBuffer;
    KDBuff     : TKDT37DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT37DI64_Node;
    TestBuff   : TKDT37DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT37DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT37DI64_Node;
    function GetData(const index: NativeInt): PKDT37DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT37DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT37DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT37DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT37DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT37DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT37DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT37DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT37DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT37DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT37DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT37DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT37DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT37DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT37DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT37DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT37DI64_Node; overload;
    function Search(const Buff: TKDT37DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT37DI64_Node; overload;
    function Search(const Buff: TKDT37DI64_Vec; var SearchedDistanceMin: Double): PKDT37DI64_Node; overload;
    function Search(const Buff: TKDT37DI64_Vec): PKDT37DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT37DI64_DynamicVecBuffer; var OutBuff: TKDT37DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT37DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT37DI64_Node);
    procedure PrintBuffer;

    class function KDT37DI64Vec(const s: string): TKDT37DI64_Vec; overload;
    class function KDT37DI64Vec(const v: TKDT37DI64_Vec): string; overload;
    class function KDT37DI64Pow(const v: TKDT37DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT37DI64Distance(const v1, v2: TKDT37DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT37DI64_Source);
    class procedure Test;
  end;



  TKDT38DI64_Vec = array [0 .. KDT38DI64_Axis - 1] of TKDT38DI64_VecType;
  PKDT38DI64_Vec = ^TKDT38DI64_Vec;

  TKDT38DI64_DynamicVecBuffer = array of TKDT38DI64_Vec;
  PKDT38DI64_DynamicVecBuffer = ^TKDT38DI64_DynamicVecBuffer;

  TKDT38DI64_Source = packed record
    Buff: TKDT38DI64_Vec;
    index: Int64;
  end;

  PKDT38DI64_Source       = ^TKDT38DI64_Source;
  TKDT38DI64_SourceBuffer = array [0 .. 0] of PKDT38DI64_Source;
  PKDT38DI64_SourceBuffer = ^TKDT38DI64_SourceBuffer;

  TKDT38DI64yanmicSourceBuffer = array of PKDT38DI64_Source;
  PKDT38DI64yanmicSourceBuffer = ^TKDT38DI64yanmicSourceBuffer;

  TKDT38DI64yanmicStoreBuffer = array of TKDT38DI64_Source;
  PKDT38DI64yanmicStoreBuffer = ^TKDT38DI64yanmicStoreBuffer;

  PKDT38DI64_Node = ^TKDT38DI64_Node;

  TKDT38DI64_Node = packed record
    Parent, Right, Left: PKDT38DI64_Node;
    vec: PKDT38DI64_Source;
  end;

  TKDT38DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT38DI64_Source);
  TKDT38DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT38DI64_Source) of object;
  {$IFNDEF FPC} TKDT38DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT38DI64_Source); {$ENDIF}

  TKDT38DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT38DI64yanmicStoreBuffer;
    KDBuff     : TKDT38DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT38DI64_Node;
    TestBuff   : TKDT38DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT38DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT38DI64_Node;
    function GetData(const index: NativeInt): PKDT38DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT38DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT38DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT38DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT38DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT38DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT38DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT38DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT38DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT38DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT38DI64_Node; overload;
    function Search(const Buff: TKDT38DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT38DI64_Node; overload;
    function Search(const Buff: TKDT38DI64_Vec; var SearchedDistanceMin: Double): PKDT38DI64_Node; overload;
    function Search(const Buff: TKDT38DI64_Vec): PKDT38DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT38DI64_DynamicVecBuffer; var OutBuff: TKDT38DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT38DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT38DI64_Node);
    procedure PrintBuffer;

    class function KDT38DI64Vec(const s: string): TKDT38DI64_Vec; overload;
    class function KDT38DI64Vec(const v: TKDT38DI64_Vec): string; overload;
    class function KDT38DI64Pow(const v: TKDT38DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT38DI64Distance(const v1, v2: TKDT38DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT38DI64_Source);
    class procedure Test;
  end;



  TKDT39DI64_Vec = array [0 .. KDT39DI64_Axis - 1] of TKDT39DI64_VecType;
  PKDT39DI64_Vec = ^TKDT39DI64_Vec;

  TKDT39DI64_DynamicVecBuffer = array of TKDT39DI64_Vec;
  PKDT39DI64_DynamicVecBuffer = ^TKDT39DI64_DynamicVecBuffer;

  TKDT39DI64_Source = packed record
    Buff: TKDT39DI64_Vec;
    index: Int64;
  end;

  PKDT39DI64_Source       = ^TKDT39DI64_Source;
  TKDT39DI64_SourceBuffer = array [0 .. 0] of PKDT39DI64_Source;
  PKDT39DI64_SourceBuffer = ^TKDT39DI64_SourceBuffer;

  TKDT39DI64yanmicSourceBuffer = array of PKDT39DI64_Source;
  PKDT39DI64yanmicSourceBuffer = ^TKDT39DI64yanmicSourceBuffer;

  TKDT39DI64yanmicStoreBuffer = array of TKDT39DI64_Source;
  PKDT39DI64yanmicStoreBuffer = ^TKDT39DI64yanmicStoreBuffer;

  PKDT39DI64_Node = ^TKDT39DI64_Node;

  TKDT39DI64_Node = packed record
    Parent, Right, Left: PKDT39DI64_Node;
    vec: PKDT39DI64_Source;
  end;

  TKDT39DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT39DI64_Source);
  TKDT39DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT39DI64_Source) of object;
  {$IFNDEF FPC} TKDT39DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT39DI64_Source); {$ENDIF}

  TKDT39DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT39DI64yanmicStoreBuffer;
    KDBuff     : TKDT39DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT39DI64_Node;
    TestBuff   : TKDT39DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT39DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT39DI64_Node;
    function GetData(const index: NativeInt): PKDT39DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT39DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT39DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT39DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT39DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT39DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT39DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT39DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT39DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT39DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT39DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT39DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT39DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT39DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT39DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT39DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT39DI64_Node; overload;
    function Search(const Buff: TKDT39DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT39DI64_Node; overload;
    function Search(const Buff: TKDT39DI64_Vec; var SearchedDistanceMin: Double): PKDT39DI64_Node; overload;
    function Search(const Buff: TKDT39DI64_Vec): PKDT39DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT39DI64_DynamicVecBuffer; var OutBuff: TKDT39DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT39DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT39DI64_Node);
    procedure PrintBuffer;

    class function KDT39DI64Vec(const s: string): TKDT39DI64_Vec; overload;
    class function KDT39DI64Vec(const v: TKDT39DI64_Vec): string; overload;
    class function KDT39DI64Pow(const v: TKDT39DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT39DI64Distance(const v1, v2: TKDT39DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT39DI64_Source);
    class procedure Test;
  end;



  TKDT40DI64_Vec = array [0 .. KDT40DI64_Axis - 1] of TKDT40DI64_VecType;
  PKDT40DI64_Vec = ^TKDT40DI64_Vec;

  TKDT40DI64_DynamicVecBuffer = array of TKDT40DI64_Vec;
  PKDT40DI64_DynamicVecBuffer = ^TKDT40DI64_DynamicVecBuffer;

  TKDT40DI64_Source = packed record
    Buff: TKDT40DI64_Vec;
    index: Int64;
  end;

  PKDT40DI64_Source       = ^TKDT40DI64_Source;
  TKDT40DI64_SourceBuffer = array [0 .. 0] of PKDT40DI64_Source;
  PKDT40DI64_SourceBuffer = ^TKDT40DI64_SourceBuffer;

  TKDT40DI64yanmicSourceBuffer = array of PKDT40DI64_Source;
  PKDT40DI64yanmicSourceBuffer = ^TKDT40DI64yanmicSourceBuffer;

  TKDT40DI64yanmicStoreBuffer = array of TKDT40DI64_Source;
  PKDT40DI64yanmicStoreBuffer = ^TKDT40DI64yanmicStoreBuffer;

  PKDT40DI64_Node = ^TKDT40DI64_Node;

  TKDT40DI64_Node = packed record
    Parent, Right, Left: PKDT40DI64_Node;
    vec: PKDT40DI64_Source;
  end;

  TKDT40DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT40DI64_Source);
  TKDT40DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT40DI64_Source) of object;
  {$IFNDEF FPC} TKDT40DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT40DI64_Source); {$ENDIF}

  TKDT40DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT40DI64yanmicStoreBuffer;
    KDBuff     : TKDT40DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT40DI64_Node;
    TestBuff   : TKDT40DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DI64_Node;
    function GetData(const index: NativeInt): PKDT40DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT40DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT40DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT40DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT40DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT40DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT40DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT40DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT40DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DI64_Node; overload;
    function Search(const Buff: TKDT40DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DI64_Node; overload;
    function Search(const Buff: TKDT40DI64_Vec; var SearchedDistanceMin: Double): PKDT40DI64_Node; overload;
    function Search(const Buff: TKDT40DI64_Vec): PKDT40DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT40DI64_DynamicVecBuffer; var OutBuff: TKDT40DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT40DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT40DI64_Node);
    procedure PrintBuffer;

    class function KDT40DI64Vec(const s: string): TKDT40DI64_Vec; overload;
    class function KDT40DI64Vec(const v: TKDT40DI64_Vec): string; overload;
    class function KDT40DI64Pow(const v: TKDT40DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT40DI64Distance(const v1, v2: TKDT40DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT40DI64_Source);
    class procedure Test;
  end;



  TKDT41DI64_Vec = array [0 .. KDT41DI64_Axis - 1] of TKDT41DI64_VecType;
  PKDT41DI64_Vec = ^TKDT41DI64_Vec;

  TKDT41DI64_DynamicVecBuffer = array of TKDT41DI64_Vec;
  PKDT41DI64_DynamicVecBuffer = ^TKDT41DI64_DynamicVecBuffer;

  TKDT41DI64_Source = packed record
    Buff: TKDT41DI64_Vec;
    index: Int64;
  end;

  PKDT41DI64_Source       = ^TKDT41DI64_Source;
  TKDT41DI64_SourceBuffer = array [0 .. 0] of PKDT41DI64_Source;
  PKDT41DI64_SourceBuffer = ^TKDT41DI64_SourceBuffer;

  TKDT41DI64yanmicSourceBuffer = array of PKDT41DI64_Source;
  PKDT41DI64yanmicSourceBuffer = ^TKDT41DI64yanmicSourceBuffer;

  TKDT41DI64yanmicStoreBuffer = array of TKDT41DI64_Source;
  PKDT41DI64yanmicStoreBuffer = ^TKDT41DI64yanmicStoreBuffer;

  PKDT41DI64_Node = ^TKDT41DI64_Node;

  TKDT41DI64_Node = packed record
    Parent, Right, Left: PKDT41DI64_Node;
    vec: PKDT41DI64_Source;
  end;

  TKDT41DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT41DI64_Source);
  TKDT41DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT41DI64_Source) of object;
  {$IFNDEF FPC} TKDT41DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT41DI64_Source); {$ENDIF}

  TKDT41DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT41DI64yanmicStoreBuffer;
    KDBuff     : TKDT41DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT41DI64_Node;
    TestBuff   : TKDT41DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT41DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT41DI64_Node;
    function GetData(const index: NativeInt): PKDT41DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT41DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT41DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT41DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT41DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT41DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT41DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT41DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT41DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT41DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT41DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT41DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT41DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT41DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT41DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT41DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT41DI64_Node; overload;
    function Search(const Buff: TKDT41DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT41DI64_Node; overload;
    function Search(const Buff: TKDT41DI64_Vec; var SearchedDistanceMin: Double): PKDT41DI64_Node; overload;
    function Search(const Buff: TKDT41DI64_Vec): PKDT41DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT41DI64_DynamicVecBuffer; var OutBuff: TKDT41DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT41DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT41DI64_Node);
    procedure PrintBuffer;

    class function KDT41DI64Vec(const s: string): TKDT41DI64_Vec; overload;
    class function KDT41DI64Vec(const v: TKDT41DI64_Vec): string; overload;
    class function KDT41DI64Pow(const v: TKDT41DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT41DI64Distance(const v1, v2: TKDT41DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT41DI64_Source);
    class procedure Test;
  end;



  TKDT42DI64_Vec = array [0 .. KDT42DI64_Axis - 1] of TKDT42DI64_VecType;
  PKDT42DI64_Vec = ^TKDT42DI64_Vec;

  TKDT42DI64_DynamicVecBuffer = array of TKDT42DI64_Vec;
  PKDT42DI64_DynamicVecBuffer = ^TKDT42DI64_DynamicVecBuffer;

  TKDT42DI64_Source = packed record
    Buff: TKDT42DI64_Vec;
    index: Int64;
  end;

  PKDT42DI64_Source       = ^TKDT42DI64_Source;
  TKDT42DI64_SourceBuffer = array [0 .. 0] of PKDT42DI64_Source;
  PKDT42DI64_SourceBuffer = ^TKDT42DI64_SourceBuffer;

  TKDT42DI64yanmicSourceBuffer = array of PKDT42DI64_Source;
  PKDT42DI64yanmicSourceBuffer = ^TKDT42DI64yanmicSourceBuffer;

  TKDT42DI64yanmicStoreBuffer = array of TKDT42DI64_Source;
  PKDT42DI64yanmicStoreBuffer = ^TKDT42DI64yanmicStoreBuffer;

  PKDT42DI64_Node = ^TKDT42DI64_Node;

  TKDT42DI64_Node = packed record
    Parent, Right, Left: PKDT42DI64_Node;
    vec: PKDT42DI64_Source;
  end;

  TKDT42DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT42DI64_Source);
  TKDT42DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT42DI64_Source) of object;
  {$IFNDEF FPC} TKDT42DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT42DI64_Source); {$ENDIF}

  TKDT42DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT42DI64yanmicStoreBuffer;
    KDBuff     : TKDT42DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT42DI64_Node;
    TestBuff   : TKDT42DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT42DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT42DI64_Node;
    function GetData(const index: NativeInt): PKDT42DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT42DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT42DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT42DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT42DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT42DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT42DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT42DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT42DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT42DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT42DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT42DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT42DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT42DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT42DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT42DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT42DI64_Node; overload;
    function Search(const Buff: TKDT42DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT42DI64_Node; overload;
    function Search(const Buff: TKDT42DI64_Vec; var SearchedDistanceMin: Double): PKDT42DI64_Node; overload;
    function Search(const Buff: TKDT42DI64_Vec): PKDT42DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT42DI64_DynamicVecBuffer; var OutBuff: TKDT42DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT42DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT42DI64_Node);
    procedure PrintBuffer;

    class function KDT42DI64Vec(const s: string): TKDT42DI64_Vec; overload;
    class function KDT42DI64Vec(const v: TKDT42DI64_Vec): string; overload;
    class function KDT42DI64Pow(const v: TKDT42DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT42DI64Distance(const v1, v2: TKDT42DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT42DI64_Source);
    class procedure Test;
  end;



  TKDT43DI64_Vec = array [0 .. KDT43DI64_Axis - 1] of TKDT43DI64_VecType;
  PKDT43DI64_Vec = ^TKDT43DI64_Vec;

  TKDT43DI64_DynamicVecBuffer = array of TKDT43DI64_Vec;
  PKDT43DI64_DynamicVecBuffer = ^TKDT43DI64_DynamicVecBuffer;

  TKDT43DI64_Source = packed record
    Buff: TKDT43DI64_Vec;
    index: Int64;
  end;

  PKDT43DI64_Source       = ^TKDT43DI64_Source;
  TKDT43DI64_SourceBuffer = array [0 .. 0] of PKDT43DI64_Source;
  PKDT43DI64_SourceBuffer = ^TKDT43DI64_SourceBuffer;

  TKDT43DI64yanmicSourceBuffer = array of PKDT43DI64_Source;
  PKDT43DI64yanmicSourceBuffer = ^TKDT43DI64yanmicSourceBuffer;

  TKDT43DI64yanmicStoreBuffer = array of TKDT43DI64_Source;
  PKDT43DI64yanmicStoreBuffer = ^TKDT43DI64yanmicStoreBuffer;

  PKDT43DI64_Node = ^TKDT43DI64_Node;

  TKDT43DI64_Node = packed record
    Parent, Right, Left: PKDT43DI64_Node;
    vec: PKDT43DI64_Source;
  end;

  TKDT43DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT43DI64_Source);
  TKDT43DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT43DI64_Source) of object;
  {$IFNDEF FPC} TKDT43DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT43DI64_Source); {$ENDIF}

  TKDT43DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT43DI64yanmicStoreBuffer;
    KDBuff     : TKDT43DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT43DI64_Node;
    TestBuff   : TKDT43DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT43DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT43DI64_Node;
    function GetData(const index: NativeInt): PKDT43DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT43DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT43DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT43DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT43DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT43DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT43DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT43DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT43DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT43DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT43DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT43DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT43DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT43DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT43DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT43DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT43DI64_Node; overload;
    function Search(const Buff: TKDT43DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT43DI64_Node; overload;
    function Search(const Buff: TKDT43DI64_Vec; var SearchedDistanceMin: Double): PKDT43DI64_Node; overload;
    function Search(const Buff: TKDT43DI64_Vec): PKDT43DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT43DI64_DynamicVecBuffer; var OutBuff: TKDT43DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT43DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT43DI64_Node);
    procedure PrintBuffer;

    class function KDT43DI64Vec(const s: string): TKDT43DI64_Vec; overload;
    class function KDT43DI64Vec(const v: TKDT43DI64_Vec): string; overload;
    class function KDT43DI64Pow(const v: TKDT43DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT43DI64Distance(const v1, v2: TKDT43DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT43DI64_Source);
    class procedure Test;
  end;



  TKDT44DI64_Vec = array [0 .. KDT44DI64_Axis - 1] of TKDT44DI64_VecType;
  PKDT44DI64_Vec = ^TKDT44DI64_Vec;

  TKDT44DI64_DynamicVecBuffer = array of TKDT44DI64_Vec;
  PKDT44DI64_DynamicVecBuffer = ^TKDT44DI64_DynamicVecBuffer;

  TKDT44DI64_Source = packed record
    Buff: TKDT44DI64_Vec;
    index: Int64;
  end;

  PKDT44DI64_Source       = ^TKDT44DI64_Source;
  TKDT44DI64_SourceBuffer = array [0 .. 0] of PKDT44DI64_Source;
  PKDT44DI64_SourceBuffer = ^TKDT44DI64_SourceBuffer;

  TKDT44DI64yanmicSourceBuffer = array of PKDT44DI64_Source;
  PKDT44DI64yanmicSourceBuffer = ^TKDT44DI64yanmicSourceBuffer;

  TKDT44DI64yanmicStoreBuffer = array of TKDT44DI64_Source;
  PKDT44DI64yanmicStoreBuffer = ^TKDT44DI64yanmicStoreBuffer;

  PKDT44DI64_Node = ^TKDT44DI64_Node;

  TKDT44DI64_Node = packed record
    Parent, Right, Left: PKDT44DI64_Node;
    vec: PKDT44DI64_Source;
  end;

  TKDT44DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT44DI64_Source);
  TKDT44DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT44DI64_Source) of object;
  {$IFNDEF FPC} TKDT44DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT44DI64_Source); {$ENDIF}

  TKDT44DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT44DI64yanmicStoreBuffer;
    KDBuff     : TKDT44DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT44DI64_Node;
    TestBuff   : TKDT44DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT44DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT44DI64_Node;
    function GetData(const index: NativeInt): PKDT44DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT44DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT44DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT44DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT44DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT44DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT44DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT44DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT44DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT44DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT44DI64_Node; overload;
    function Search(const Buff: TKDT44DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT44DI64_Node; overload;
    function Search(const Buff: TKDT44DI64_Vec; var SearchedDistanceMin: Double): PKDT44DI64_Node; overload;
    function Search(const Buff: TKDT44DI64_Vec): PKDT44DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT44DI64_DynamicVecBuffer; var OutBuff: TKDT44DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT44DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT44DI64_Node);
    procedure PrintBuffer;

    class function KDT44DI64Vec(const s: string): TKDT44DI64_Vec; overload;
    class function KDT44DI64Vec(const v: TKDT44DI64_Vec): string; overload;
    class function KDT44DI64Pow(const v: TKDT44DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT44DI64Distance(const v1, v2: TKDT44DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT44DI64_Source);
    class procedure Test;
  end;



  TKDT45DI64_Vec = array [0 .. KDT45DI64_Axis - 1] of TKDT45DI64_VecType;
  PKDT45DI64_Vec = ^TKDT45DI64_Vec;

  TKDT45DI64_DynamicVecBuffer = array of TKDT45DI64_Vec;
  PKDT45DI64_DynamicVecBuffer = ^TKDT45DI64_DynamicVecBuffer;

  TKDT45DI64_Source = packed record
    Buff: TKDT45DI64_Vec;
    index: Int64;
  end;

  PKDT45DI64_Source       = ^TKDT45DI64_Source;
  TKDT45DI64_SourceBuffer = array [0 .. 0] of PKDT45DI64_Source;
  PKDT45DI64_SourceBuffer = ^TKDT45DI64_SourceBuffer;

  TKDT45DI64yanmicSourceBuffer = array of PKDT45DI64_Source;
  PKDT45DI64yanmicSourceBuffer = ^TKDT45DI64yanmicSourceBuffer;

  TKDT45DI64yanmicStoreBuffer = array of TKDT45DI64_Source;
  PKDT45DI64yanmicStoreBuffer = ^TKDT45DI64yanmicStoreBuffer;

  PKDT45DI64_Node = ^TKDT45DI64_Node;

  TKDT45DI64_Node = packed record
    Parent, Right, Left: PKDT45DI64_Node;
    vec: PKDT45DI64_Source;
  end;

  TKDT45DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT45DI64_Source);
  TKDT45DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT45DI64_Source) of object;
  {$IFNDEF FPC} TKDT45DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT45DI64_Source); {$ENDIF}

  TKDT45DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT45DI64yanmicStoreBuffer;
    KDBuff     : TKDT45DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT45DI64_Node;
    TestBuff   : TKDT45DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT45DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT45DI64_Node;
    function GetData(const index: NativeInt): PKDT45DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT45DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT45DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT45DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT45DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT45DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT45DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT45DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT45DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT45DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT45DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT45DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT45DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT45DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT45DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT45DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT45DI64_Node; overload;
    function Search(const Buff: TKDT45DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT45DI64_Node; overload;
    function Search(const Buff: TKDT45DI64_Vec; var SearchedDistanceMin: Double): PKDT45DI64_Node; overload;
    function Search(const Buff: TKDT45DI64_Vec): PKDT45DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT45DI64_DynamicVecBuffer; var OutBuff: TKDT45DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT45DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT45DI64_Node);
    procedure PrintBuffer;

    class function KDT45DI64Vec(const s: string): TKDT45DI64_Vec; overload;
    class function KDT45DI64Vec(const v: TKDT45DI64_Vec): string; overload;
    class function KDT45DI64Pow(const v: TKDT45DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT45DI64Distance(const v1, v2: TKDT45DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT45DI64_Source);
    class procedure Test;
  end;



  TKDT46DI64_Vec = array [0 .. KDT46DI64_Axis - 1] of TKDT46DI64_VecType;
  PKDT46DI64_Vec = ^TKDT46DI64_Vec;

  TKDT46DI64_DynamicVecBuffer = array of TKDT46DI64_Vec;
  PKDT46DI64_DynamicVecBuffer = ^TKDT46DI64_DynamicVecBuffer;

  TKDT46DI64_Source = packed record
    Buff: TKDT46DI64_Vec;
    index: Int64;
  end;

  PKDT46DI64_Source       = ^TKDT46DI64_Source;
  TKDT46DI64_SourceBuffer = array [0 .. 0] of PKDT46DI64_Source;
  PKDT46DI64_SourceBuffer = ^TKDT46DI64_SourceBuffer;

  TKDT46DI64yanmicSourceBuffer = array of PKDT46DI64_Source;
  PKDT46DI64yanmicSourceBuffer = ^TKDT46DI64yanmicSourceBuffer;

  TKDT46DI64yanmicStoreBuffer = array of TKDT46DI64_Source;
  PKDT46DI64yanmicStoreBuffer = ^TKDT46DI64yanmicStoreBuffer;

  PKDT46DI64_Node = ^TKDT46DI64_Node;

  TKDT46DI64_Node = packed record
    Parent, Right, Left: PKDT46DI64_Node;
    vec: PKDT46DI64_Source;
  end;

  TKDT46DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT46DI64_Source);
  TKDT46DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT46DI64_Source) of object;
  {$IFNDEF FPC} TKDT46DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT46DI64_Source); {$ENDIF}

  TKDT46DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT46DI64yanmicStoreBuffer;
    KDBuff     : TKDT46DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT46DI64_Node;
    TestBuff   : TKDT46DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT46DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT46DI64_Node;
    function GetData(const index: NativeInt): PKDT46DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT46DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT46DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT46DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT46DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT46DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT46DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT46DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT46DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT46DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT46DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT46DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT46DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT46DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT46DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT46DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT46DI64_Node; overload;
    function Search(const Buff: TKDT46DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT46DI64_Node; overload;
    function Search(const Buff: TKDT46DI64_Vec; var SearchedDistanceMin: Double): PKDT46DI64_Node; overload;
    function Search(const Buff: TKDT46DI64_Vec): PKDT46DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT46DI64_DynamicVecBuffer; var OutBuff: TKDT46DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT46DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT46DI64_Node);
    procedure PrintBuffer;

    class function KDT46DI64Vec(const s: string): TKDT46DI64_Vec; overload;
    class function KDT46DI64Vec(const v: TKDT46DI64_Vec): string; overload;
    class function KDT46DI64Pow(const v: TKDT46DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT46DI64Distance(const v1, v2: TKDT46DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT46DI64_Source);
    class procedure Test;
  end;



  TKDT47DI64_Vec = array [0 .. KDT47DI64_Axis - 1] of TKDT47DI64_VecType;
  PKDT47DI64_Vec = ^TKDT47DI64_Vec;

  TKDT47DI64_DynamicVecBuffer = array of TKDT47DI64_Vec;
  PKDT47DI64_DynamicVecBuffer = ^TKDT47DI64_DynamicVecBuffer;

  TKDT47DI64_Source = packed record
    Buff: TKDT47DI64_Vec;
    index: Int64;
  end;

  PKDT47DI64_Source       = ^TKDT47DI64_Source;
  TKDT47DI64_SourceBuffer = array [0 .. 0] of PKDT47DI64_Source;
  PKDT47DI64_SourceBuffer = ^TKDT47DI64_SourceBuffer;

  TKDT47DI64yanmicSourceBuffer = array of PKDT47DI64_Source;
  PKDT47DI64yanmicSourceBuffer = ^TKDT47DI64yanmicSourceBuffer;

  TKDT47DI64yanmicStoreBuffer = array of TKDT47DI64_Source;
  PKDT47DI64yanmicStoreBuffer = ^TKDT47DI64yanmicStoreBuffer;

  PKDT47DI64_Node = ^TKDT47DI64_Node;

  TKDT47DI64_Node = packed record
    Parent, Right, Left: PKDT47DI64_Node;
    vec: PKDT47DI64_Source;
  end;

  TKDT47DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT47DI64_Source);
  TKDT47DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT47DI64_Source) of object;
  {$IFNDEF FPC} TKDT47DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT47DI64_Source); {$ENDIF}

  TKDT47DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT47DI64yanmicStoreBuffer;
    KDBuff     : TKDT47DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT47DI64_Node;
    TestBuff   : TKDT47DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT47DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT47DI64_Node;
    function GetData(const index: NativeInt): PKDT47DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT47DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT47DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT47DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT47DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT47DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT47DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT47DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT47DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT47DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT47DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT47DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT47DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT47DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT47DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT47DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT47DI64_Node; overload;
    function Search(const Buff: TKDT47DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT47DI64_Node; overload;
    function Search(const Buff: TKDT47DI64_Vec; var SearchedDistanceMin: Double): PKDT47DI64_Node; overload;
    function Search(const Buff: TKDT47DI64_Vec): PKDT47DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT47DI64_DynamicVecBuffer; var OutBuff: TKDT47DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT47DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT47DI64_Node);
    procedure PrintBuffer;

    class function KDT47DI64Vec(const s: string): TKDT47DI64_Vec; overload;
    class function KDT47DI64Vec(const v: TKDT47DI64_Vec): string; overload;
    class function KDT47DI64Pow(const v: TKDT47DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT47DI64Distance(const v1, v2: TKDT47DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT47DI64_Source);
    class procedure Test;
  end;



  TKDT48DI64_Vec = array [0 .. KDT48DI64_Axis - 1] of TKDT48DI64_VecType;
  PKDT48DI64_Vec = ^TKDT48DI64_Vec;

  TKDT48DI64_DynamicVecBuffer = array of TKDT48DI64_Vec;
  PKDT48DI64_DynamicVecBuffer = ^TKDT48DI64_DynamicVecBuffer;

  TKDT48DI64_Source = packed record
    Buff: TKDT48DI64_Vec;
    index: Int64;
  end;

  PKDT48DI64_Source       = ^TKDT48DI64_Source;
  TKDT48DI64_SourceBuffer = array [0 .. 0] of PKDT48DI64_Source;
  PKDT48DI64_SourceBuffer = ^TKDT48DI64_SourceBuffer;

  TKDT48DI64yanmicSourceBuffer = array of PKDT48DI64_Source;
  PKDT48DI64yanmicSourceBuffer = ^TKDT48DI64yanmicSourceBuffer;

  TKDT48DI64yanmicStoreBuffer = array of TKDT48DI64_Source;
  PKDT48DI64yanmicStoreBuffer = ^TKDT48DI64yanmicStoreBuffer;

  PKDT48DI64_Node = ^TKDT48DI64_Node;

  TKDT48DI64_Node = packed record
    Parent, Right, Left: PKDT48DI64_Node;
    vec: PKDT48DI64_Source;
  end;

  TKDT48DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT48DI64_Source);
  TKDT48DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT48DI64_Source) of object;
  {$IFNDEF FPC} TKDT48DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT48DI64_Source); {$ENDIF}

  TKDT48DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT48DI64yanmicStoreBuffer;
    KDBuff     : TKDT48DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT48DI64_Node;
    TestBuff   : TKDT48DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DI64_Node;
    function GetData(const index: NativeInt): PKDT48DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT48DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT48DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT48DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT48DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT48DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT48DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT48DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT48DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DI64_Node; overload;
    function Search(const Buff: TKDT48DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DI64_Node; overload;
    function Search(const Buff: TKDT48DI64_Vec; var SearchedDistanceMin: Double): PKDT48DI64_Node; overload;
    function Search(const Buff: TKDT48DI64_Vec): PKDT48DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT48DI64_DynamicVecBuffer; var OutBuff: TKDT48DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT48DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT48DI64_Node);
    procedure PrintBuffer;

    class function KDT48DI64Vec(const s: string): TKDT48DI64_Vec; overload;
    class function KDT48DI64Vec(const v: TKDT48DI64_Vec): string; overload;
    class function KDT48DI64Pow(const v: TKDT48DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT48DI64Distance(const v1, v2: TKDT48DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT48DI64_Source);
    class procedure Test;
  end;



  TKDT49DI64_Vec = array [0 .. KDT49DI64_Axis - 1] of TKDT49DI64_VecType;
  PKDT49DI64_Vec = ^TKDT49DI64_Vec;

  TKDT49DI64_DynamicVecBuffer = array of TKDT49DI64_Vec;
  PKDT49DI64_DynamicVecBuffer = ^TKDT49DI64_DynamicVecBuffer;

  TKDT49DI64_Source = packed record
    Buff: TKDT49DI64_Vec;
    index: Int64;
  end;

  PKDT49DI64_Source       = ^TKDT49DI64_Source;
  TKDT49DI64_SourceBuffer = array [0 .. 0] of PKDT49DI64_Source;
  PKDT49DI64_SourceBuffer = ^TKDT49DI64_SourceBuffer;

  TKDT49DI64yanmicSourceBuffer = array of PKDT49DI64_Source;
  PKDT49DI64yanmicSourceBuffer = ^TKDT49DI64yanmicSourceBuffer;

  TKDT49DI64yanmicStoreBuffer = array of TKDT49DI64_Source;
  PKDT49DI64yanmicStoreBuffer = ^TKDT49DI64yanmicStoreBuffer;

  PKDT49DI64_Node = ^TKDT49DI64_Node;

  TKDT49DI64_Node = packed record
    Parent, Right, Left: PKDT49DI64_Node;
    vec: PKDT49DI64_Source;
  end;

  TKDT49DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT49DI64_Source);
  TKDT49DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT49DI64_Source) of object;
  {$IFNDEF FPC} TKDT49DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT49DI64_Source); {$ENDIF}

  TKDT49DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT49DI64yanmicStoreBuffer;
    KDBuff     : TKDT49DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT49DI64_Node;
    TestBuff   : TKDT49DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT49DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT49DI64_Node;
    function GetData(const index: NativeInt): PKDT49DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT49DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT49DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT49DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT49DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT49DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT49DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT49DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT49DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT49DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT49DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT49DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT49DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT49DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT49DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT49DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT49DI64_Node; overload;
    function Search(const Buff: TKDT49DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT49DI64_Node; overload;
    function Search(const Buff: TKDT49DI64_Vec; var SearchedDistanceMin: Double): PKDT49DI64_Node; overload;
    function Search(const Buff: TKDT49DI64_Vec): PKDT49DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT49DI64_DynamicVecBuffer; var OutBuff: TKDT49DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT49DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT49DI64_Node);
    procedure PrintBuffer;

    class function KDT49DI64Vec(const s: string): TKDT49DI64_Vec; overload;
    class function KDT49DI64Vec(const v: TKDT49DI64_Vec): string; overload;
    class function KDT49DI64Pow(const v: TKDT49DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT49DI64Distance(const v1, v2: TKDT49DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT49DI64_Source);
    class procedure Test;
  end;



  TKDT50DI64_Vec = array [0 .. KDT50DI64_Axis - 1] of TKDT50DI64_VecType;
  PKDT50DI64_Vec = ^TKDT50DI64_Vec;

  TKDT50DI64_DynamicVecBuffer = array of TKDT50DI64_Vec;
  PKDT50DI64_DynamicVecBuffer = ^TKDT50DI64_DynamicVecBuffer;

  TKDT50DI64_Source = packed record
    Buff: TKDT50DI64_Vec;
    index: Int64;
  end;

  PKDT50DI64_Source       = ^TKDT50DI64_Source;
  TKDT50DI64_SourceBuffer = array [0 .. 0] of PKDT50DI64_Source;
  PKDT50DI64_SourceBuffer = ^TKDT50DI64_SourceBuffer;

  TKDT50DI64yanmicSourceBuffer = array of PKDT50DI64_Source;
  PKDT50DI64yanmicSourceBuffer = ^TKDT50DI64yanmicSourceBuffer;

  TKDT50DI64yanmicStoreBuffer = array of TKDT50DI64_Source;
  PKDT50DI64yanmicStoreBuffer = ^TKDT50DI64yanmicStoreBuffer;

  PKDT50DI64_Node = ^TKDT50DI64_Node;

  TKDT50DI64_Node = packed record
    Parent, Right, Left: PKDT50DI64_Node;
    vec: PKDT50DI64_Source;
  end;

  TKDT50DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT50DI64_Source);
  TKDT50DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT50DI64_Source) of object;
  {$IFNDEF FPC} TKDT50DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT50DI64_Source); {$ENDIF}

  TKDT50DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT50DI64yanmicStoreBuffer;
    KDBuff     : TKDT50DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT50DI64_Node;
    TestBuff   : TKDT50DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT50DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT50DI64_Node;
    function GetData(const index: NativeInt): PKDT50DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT50DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT50DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT50DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT50DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT50DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT50DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT50DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT50DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT50DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT50DI64_Node; overload;
    function Search(const Buff: TKDT50DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT50DI64_Node; overload;
    function Search(const Buff: TKDT50DI64_Vec; var SearchedDistanceMin: Double): PKDT50DI64_Node; overload;
    function Search(const Buff: TKDT50DI64_Vec): PKDT50DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT50DI64_DynamicVecBuffer; var OutBuff: TKDT50DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT50DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT50DI64_Node);
    procedure PrintBuffer;

    class function KDT50DI64Vec(const s: string): TKDT50DI64_Vec; overload;
    class function KDT50DI64Vec(const v: TKDT50DI64_Vec): string; overload;
    class function KDT50DI64Pow(const v: TKDT50DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT50DI64Distance(const v1, v2: TKDT50DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT50DI64_Source);
    class procedure Test;
  end;



  TKDT51DI64_Vec = array [0 .. KDT51DI64_Axis - 1] of TKDT51DI64_VecType;
  PKDT51DI64_Vec = ^TKDT51DI64_Vec;

  TKDT51DI64_DynamicVecBuffer = array of TKDT51DI64_Vec;
  PKDT51DI64_DynamicVecBuffer = ^TKDT51DI64_DynamicVecBuffer;

  TKDT51DI64_Source = packed record
    Buff: TKDT51DI64_Vec;
    index: Int64;
  end;

  PKDT51DI64_Source       = ^TKDT51DI64_Source;
  TKDT51DI64_SourceBuffer = array [0 .. 0] of PKDT51DI64_Source;
  PKDT51DI64_SourceBuffer = ^TKDT51DI64_SourceBuffer;

  TKDT51DI64yanmicSourceBuffer = array of PKDT51DI64_Source;
  PKDT51DI64yanmicSourceBuffer = ^TKDT51DI64yanmicSourceBuffer;

  TKDT51DI64yanmicStoreBuffer = array of TKDT51DI64_Source;
  PKDT51DI64yanmicStoreBuffer = ^TKDT51DI64yanmicStoreBuffer;

  PKDT51DI64_Node = ^TKDT51DI64_Node;

  TKDT51DI64_Node = packed record
    Parent, Right, Left: PKDT51DI64_Node;
    vec: PKDT51DI64_Source;
  end;

  TKDT51DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT51DI64_Source);
  TKDT51DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT51DI64_Source) of object;
  {$IFNDEF FPC} TKDT51DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT51DI64_Source); {$ENDIF}

  TKDT51DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT51DI64yanmicStoreBuffer;
    KDBuff     : TKDT51DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT51DI64_Node;
    TestBuff   : TKDT51DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT51DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT51DI64_Node;
    function GetData(const index: NativeInt): PKDT51DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT51DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT51DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT51DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT51DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT51DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT51DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT51DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT51DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT51DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT51DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT51DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT51DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT51DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT51DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT51DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT51DI64_Node; overload;
    function Search(const Buff: TKDT51DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT51DI64_Node; overload;
    function Search(const Buff: TKDT51DI64_Vec; var SearchedDistanceMin: Double): PKDT51DI64_Node; overload;
    function Search(const Buff: TKDT51DI64_Vec): PKDT51DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT51DI64_DynamicVecBuffer; var OutBuff: TKDT51DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT51DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT51DI64_Node);
    procedure PrintBuffer;

    class function KDT51DI64Vec(const s: string): TKDT51DI64_Vec; overload;
    class function KDT51DI64Vec(const v: TKDT51DI64_Vec): string; overload;
    class function KDT51DI64Pow(const v: TKDT51DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT51DI64Distance(const v1, v2: TKDT51DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT51DI64_Source);
    class procedure Test;
  end;



  TKDT52DI64_Vec = array [0 .. KDT52DI64_Axis - 1] of TKDT52DI64_VecType;
  PKDT52DI64_Vec = ^TKDT52DI64_Vec;

  TKDT52DI64_DynamicVecBuffer = array of TKDT52DI64_Vec;
  PKDT52DI64_DynamicVecBuffer = ^TKDT52DI64_DynamicVecBuffer;

  TKDT52DI64_Source = packed record
    Buff: TKDT52DI64_Vec;
    index: Int64;
  end;

  PKDT52DI64_Source       = ^TKDT52DI64_Source;
  TKDT52DI64_SourceBuffer = array [0 .. 0] of PKDT52DI64_Source;
  PKDT52DI64_SourceBuffer = ^TKDT52DI64_SourceBuffer;

  TKDT52DI64yanmicSourceBuffer = array of PKDT52DI64_Source;
  PKDT52DI64yanmicSourceBuffer = ^TKDT52DI64yanmicSourceBuffer;

  TKDT52DI64yanmicStoreBuffer = array of TKDT52DI64_Source;
  PKDT52DI64yanmicStoreBuffer = ^TKDT52DI64yanmicStoreBuffer;

  PKDT52DI64_Node = ^TKDT52DI64_Node;

  TKDT52DI64_Node = packed record
    Parent, Right, Left: PKDT52DI64_Node;
    vec: PKDT52DI64_Source;
  end;

  TKDT52DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT52DI64_Source);
  TKDT52DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT52DI64_Source) of object;
  {$IFNDEF FPC} TKDT52DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT52DI64_Source); {$ENDIF}

  TKDT52DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT52DI64yanmicStoreBuffer;
    KDBuff     : TKDT52DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT52DI64_Node;
    TestBuff   : TKDT52DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT52DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT52DI64_Node;
    function GetData(const index: NativeInt): PKDT52DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT52DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT52DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT52DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT52DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT52DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT52DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT52DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT52DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT52DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT52DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT52DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT52DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT52DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT52DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT52DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT52DI64_Node; overload;
    function Search(const Buff: TKDT52DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT52DI64_Node; overload;
    function Search(const Buff: TKDT52DI64_Vec; var SearchedDistanceMin: Double): PKDT52DI64_Node; overload;
    function Search(const Buff: TKDT52DI64_Vec): PKDT52DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT52DI64_DynamicVecBuffer; var OutBuff: TKDT52DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT52DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT52DI64_Node);
    procedure PrintBuffer;

    class function KDT52DI64Vec(const s: string): TKDT52DI64_Vec; overload;
    class function KDT52DI64Vec(const v: TKDT52DI64_Vec): string; overload;
    class function KDT52DI64Pow(const v: TKDT52DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT52DI64Distance(const v1, v2: TKDT52DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT52DI64_Source);
    class procedure Test;
  end;



  TKDT53DI64_Vec = array [0 .. KDT53DI64_Axis - 1] of TKDT53DI64_VecType;
  PKDT53DI64_Vec = ^TKDT53DI64_Vec;

  TKDT53DI64_DynamicVecBuffer = array of TKDT53DI64_Vec;
  PKDT53DI64_DynamicVecBuffer = ^TKDT53DI64_DynamicVecBuffer;

  TKDT53DI64_Source = packed record
    Buff: TKDT53DI64_Vec;
    index: Int64;
  end;

  PKDT53DI64_Source       = ^TKDT53DI64_Source;
  TKDT53DI64_SourceBuffer = array [0 .. 0] of PKDT53DI64_Source;
  PKDT53DI64_SourceBuffer = ^TKDT53DI64_SourceBuffer;

  TKDT53DI64yanmicSourceBuffer = array of PKDT53DI64_Source;
  PKDT53DI64yanmicSourceBuffer = ^TKDT53DI64yanmicSourceBuffer;

  TKDT53DI64yanmicStoreBuffer = array of TKDT53DI64_Source;
  PKDT53DI64yanmicStoreBuffer = ^TKDT53DI64yanmicStoreBuffer;

  PKDT53DI64_Node = ^TKDT53DI64_Node;

  TKDT53DI64_Node = packed record
    Parent, Right, Left: PKDT53DI64_Node;
    vec: PKDT53DI64_Source;
  end;

  TKDT53DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT53DI64_Source);
  TKDT53DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT53DI64_Source) of object;
  {$IFNDEF FPC} TKDT53DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT53DI64_Source); {$ENDIF}

  TKDT53DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT53DI64yanmicStoreBuffer;
    KDBuff     : TKDT53DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT53DI64_Node;
    TestBuff   : TKDT53DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT53DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT53DI64_Node;
    function GetData(const index: NativeInt): PKDT53DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT53DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT53DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT53DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT53DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT53DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT53DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT53DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT53DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT53DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT53DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT53DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT53DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT53DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT53DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT53DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT53DI64_Node; overload;
    function Search(const Buff: TKDT53DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT53DI64_Node; overload;
    function Search(const Buff: TKDT53DI64_Vec; var SearchedDistanceMin: Double): PKDT53DI64_Node; overload;
    function Search(const Buff: TKDT53DI64_Vec): PKDT53DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT53DI64_DynamicVecBuffer; var OutBuff: TKDT53DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT53DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT53DI64_Node);
    procedure PrintBuffer;

    class function KDT53DI64Vec(const s: string): TKDT53DI64_Vec; overload;
    class function KDT53DI64Vec(const v: TKDT53DI64_Vec): string; overload;
    class function KDT53DI64Pow(const v: TKDT53DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT53DI64Distance(const v1, v2: TKDT53DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT53DI64_Source);
    class procedure Test;
  end;



  TKDT54DI64_Vec = array [0 .. KDT54DI64_Axis - 1] of TKDT54DI64_VecType;
  PKDT54DI64_Vec = ^TKDT54DI64_Vec;

  TKDT54DI64_DynamicVecBuffer = array of TKDT54DI64_Vec;
  PKDT54DI64_DynamicVecBuffer = ^TKDT54DI64_DynamicVecBuffer;

  TKDT54DI64_Source = packed record
    Buff: TKDT54DI64_Vec;
    index: Int64;
  end;

  PKDT54DI64_Source       = ^TKDT54DI64_Source;
  TKDT54DI64_SourceBuffer = array [0 .. 0] of PKDT54DI64_Source;
  PKDT54DI64_SourceBuffer = ^TKDT54DI64_SourceBuffer;

  TKDT54DI64yanmicSourceBuffer = array of PKDT54DI64_Source;
  PKDT54DI64yanmicSourceBuffer = ^TKDT54DI64yanmicSourceBuffer;

  TKDT54DI64yanmicStoreBuffer = array of TKDT54DI64_Source;
  PKDT54DI64yanmicStoreBuffer = ^TKDT54DI64yanmicStoreBuffer;

  PKDT54DI64_Node = ^TKDT54DI64_Node;

  TKDT54DI64_Node = packed record
    Parent, Right, Left: PKDT54DI64_Node;
    vec: PKDT54DI64_Source;
  end;

  TKDT54DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT54DI64_Source);
  TKDT54DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT54DI64_Source) of object;
  {$IFNDEF FPC} TKDT54DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT54DI64_Source); {$ENDIF}

  TKDT54DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT54DI64yanmicStoreBuffer;
    KDBuff     : TKDT54DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT54DI64_Node;
    TestBuff   : TKDT54DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT54DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT54DI64_Node;
    function GetData(const index: NativeInt): PKDT54DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT54DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT54DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT54DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT54DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT54DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT54DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT54DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT54DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT54DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT54DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT54DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT54DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT54DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT54DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT54DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT54DI64_Node; overload;
    function Search(const Buff: TKDT54DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT54DI64_Node; overload;
    function Search(const Buff: TKDT54DI64_Vec; var SearchedDistanceMin: Double): PKDT54DI64_Node; overload;
    function Search(const Buff: TKDT54DI64_Vec): PKDT54DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT54DI64_DynamicVecBuffer; var OutBuff: TKDT54DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT54DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT54DI64_Node);
    procedure PrintBuffer;

    class function KDT54DI64Vec(const s: string): TKDT54DI64_Vec; overload;
    class function KDT54DI64Vec(const v: TKDT54DI64_Vec): string; overload;
    class function KDT54DI64Pow(const v: TKDT54DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT54DI64Distance(const v1, v2: TKDT54DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT54DI64_Source);
    class procedure Test;
  end;



  TKDT55DI64_Vec = array [0 .. KDT55DI64_Axis - 1] of TKDT55DI64_VecType;
  PKDT55DI64_Vec = ^TKDT55DI64_Vec;

  TKDT55DI64_DynamicVecBuffer = array of TKDT55DI64_Vec;
  PKDT55DI64_DynamicVecBuffer = ^TKDT55DI64_DynamicVecBuffer;

  TKDT55DI64_Source = packed record
    Buff: TKDT55DI64_Vec;
    index: Int64;
  end;

  PKDT55DI64_Source       = ^TKDT55DI64_Source;
  TKDT55DI64_SourceBuffer = array [0 .. 0] of PKDT55DI64_Source;
  PKDT55DI64_SourceBuffer = ^TKDT55DI64_SourceBuffer;

  TKDT55DI64yanmicSourceBuffer = array of PKDT55DI64_Source;
  PKDT55DI64yanmicSourceBuffer = ^TKDT55DI64yanmicSourceBuffer;

  TKDT55DI64yanmicStoreBuffer = array of TKDT55DI64_Source;
  PKDT55DI64yanmicStoreBuffer = ^TKDT55DI64yanmicStoreBuffer;

  PKDT55DI64_Node = ^TKDT55DI64_Node;

  TKDT55DI64_Node = packed record
    Parent, Right, Left: PKDT55DI64_Node;
    vec: PKDT55DI64_Source;
  end;

  TKDT55DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT55DI64_Source);
  TKDT55DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT55DI64_Source) of object;
  {$IFNDEF FPC} TKDT55DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT55DI64_Source); {$ENDIF}

  TKDT55DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT55DI64yanmicStoreBuffer;
    KDBuff     : TKDT55DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT55DI64_Node;
    TestBuff   : TKDT55DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT55DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT55DI64_Node;
    function GetData(const index: NativeInt): PKDT55DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT55DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT55DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT55DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT55DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT55DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT55DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT55DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT55DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT55DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT55DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT55DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT55DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT55DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT55DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT55DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT55DI64_Node; overload;
    function Search(const Buff: TKDT55DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT55DI64_Node; overload;
    function Search(const Buff: TKDT55DI64_Vec; var SearchedDistanceMin: Double): PKDT55DI64_Node; overload;
    function Search(const Buff: TKDT55DI64_Vec): PKDT55DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT55DI64_DynamicVecBuffer; var OutBuff: TKDT55DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT55DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT55DI64_Node);
    procedure PrintBuffer;

    class function KDT55DI64Vec(const s: string): TKDT55DI64_Vec; overload;
    class function KDT55DI64Vec(const v: TKDT55DI64_Vec): string; overload;
    class function KDT55DI64Pow(const v: TKDT55DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT55DI64Distance(const v1, v2: TKDT55DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT55DI64_Source);
    class procedure Test;
  end;



  TKDT56DI64_Vec = array [0 .. KDT56DI64_Axis - 1] of TKDT56DI64_VecType;
  PKDT56DI64_Vec = ^TKDT56DI64_Vec;

  TKDT56DI64_DynamicVecBuffer = array of TKDT56DI64_Vec;
  PKDT56DI64_DynamicVecBuffer = ^TKDT56DI64_DynamicVecBuffer;

  TKDT56DI64_Source = packed record
    Buff: TKDT56DI64_Vec;
    index: Int64;
  end;

  PKDT56DI64_Source       = ^TKDT56DI64_Source;
  TKDT56DI64_SourceBuffer = array [0 .. 0] of PKDT56DI64_Source;
  PKDT56DI64_SourceBuffer = ^TKDT56DI64_SourceBuffer;

  TKDT56DI64yanmicSourceBuffer = array of PKDT56DI64_Source;
  PKDT56DI64yanmicSourceBuffer = ^TKDT56DI64yanmicSourceBuffer;

  TKDT56DI64yanmicStoreBuffer = array of TKDT56DI64_Source;
  PKDT56DI64yanmicStoreBuffer = ^TKDT56DI64yanmicStoreBuffer;

  PKDT56DI64_Node = ^TKDT56DI64_Node;

  TKDT56DI64_Node = packed record
    Parent, Right, Left: PKDT56DI64_Node;
    vec: PKDT56DI64_Source;
  end;

  TKDT56DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT56DI64_Source);
  TKDT56DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT56DI64_Source) of object;
  {$IFNDEF FPC} TKDT56DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT56DI64_Source); {$ENDIF}

  TKDT56DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT56DI64yanmicStoreBuffer;
    KDBuff     : TKDT56DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT56DI64_Node;
    TestBuff   : TKDT56DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT56DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT56DI64_Node;
    function GetData(const index: NativeInt): PKDT56DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT56DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT56DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT56DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT56DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT56DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT56DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT56DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT56DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT56DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT56DI64_Node; overload;
    function Search(const Buff: TKDT56DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT56DI64_Node; overload;
    function Search(const Buff: TKDT56DI64_Vec; var SearchedDistanceMin: Double): PKDT56DI64_Node; overload;
    function Search(const Buff: TKDT56DI64_Vec): PKDT56DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT56DI64_DynamicVecBuffer; var OutBuff: TKDT56DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT56DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT56DI64_Node);
    procedure PrintBuffer;

    class function KDT56DI64Vec(const s: string): TKDT56DI64_Vec; overload;
    class function KDT56DI64Vec(const v: TKDT56DI64_Vec): string; overload;
    class function KDT56DI64Pow(const v: TKDT56DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT56DI64Distance(const v1, v2: TKDT56DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT56DI64_Source);
    class procedure Test;
  end;



  TKDT57DI64_Vec = array [0 .. KDT57DI64_Axis - 1] of TKDT57DI64_VecType;
  PKDT57DI64_Vec = ^TKDT57DI64_Vec;

  TKDT57DI64_DynamicVecBuffer = array of TKDT57DI64_Vec;
  PKDT57DI64_DynamicVecBuffer = ^TKDT57DI64_DynamicVecBuffer;

  TKDT57DI64_Source = packed record
    Buff: TKDT57DI64_Vec;
    index: Int64;
  end;

  PKDT57DI64_Source       = ^TKDT57DI64_Source;
  TKDT57DI64_SourceBuffer = array [0 .. 0] of PKDT57DI64_Source;
  PKDT57DI64_SourceBuffer = ^TKDT57DI64_SourceBuffer;

  TKDT57DI64yanmicSourceBuffer = array of PKDT57DI64_Source;
  PKDT57DI64yanmicSourceBuffer = ^TKDT57DI64yanmicSourceBuffer;

  TKDT57DI64yanmicStoreBuffer = array of TKDT57DI64_Source;
  PKDT57DI64yanmicStoreBuffer = ^TKDT57DI64yanmicStoreBuffer;

  PKDT57DI64_Node = ^TKDT57DI64_Node;

  TKDT57DI64_Node = packed record
    Parent, Right, Left: PKDT57DI64_Node;
    vec: PKDT57DI64_Source;
  end;

  TKDT57DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT57DI64_Source);
  TKDT57DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT57DI64_Source) of object;
  {$IFNDEF FPC} TKDT57DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT57DI64_Source); {$ENDIF}

  TKDT57DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT57DI64yanmicStoreBuffer;
    KDBuff     : TKDT57DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT57DI64_Node;
    TestBuff   : TKDT57DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT57DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT57DI64_Node;
    function GetData(const index: NativeInt): PKDT57DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT57DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT57DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT57DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT57DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT57DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT57DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT57DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT57DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT57DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT57DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT57DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT57DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT57DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT57DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT57DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT57DI64_Node; overload;
    function Search(const Buff: TKDT57DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT57DI64_Node; overload;
    function Search(const Buff: TKDT57DI64_Vec; var SearchedDistanceMin: Double): PKDT57DI64_Node; overload;
    function Search(const Buff: TKDT57DI64_Vec): PKDT57DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT57DI64_DynamicVecBuffer; var OutBuff: TKDT57DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT57DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT57DI64_Node);
    procedure PrintBuffer;

    class function KDT57DI64Vec(const s: string): TKDT57DI64_Vec; overload;
    class function KDT57DI64Vec(const v: TKDT57DI64_Vec): string; overload;
    class function KDT57DI64Pow(const v: TKDT57DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT57DI64Distance(const v1, v2: TKDT57DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT57DI64_Source);
    class procedure Test;
  end;



  TKDT58DI64_Vec = array [0 .. KDT58DI64_Axis - 1] of TKDT58DI64_VecType;
  PKDT58DI64_Vec = ^TKDT58DI64_Vec;

  TKDT58DI64_DynamicVecBuffer = array of TKDT58DI64_Vec;
  PKDT58DI64_DynamicVecBuffer = ^TKDT58DI64_DynamicVecBuffer;

  TKDT58DI64_Source = packed record
    Buff: TKDT58DI64_Vec;
    index: Int64;
  end;

  PKDT58DI64_Source       = ^TKDT58DI64_Source;
  TKDT58DI64_SourceBuffer = array [0 .. 0] of PKDT58DI64_Source;
  PKDT58DI64_SourceBuffer = ^TKDT58DI64_SourceBuffer;

  TKDT58DI64yanmicSourceBuffer = array of PKDT58DI64_Source;
  PKDT58DI64yanmicSourceBuffer = ^TKDT58DI64yanmicSourceBuffer;

  TKDT58DI64yanmicStoreBuffer = array of TKDT58DI64_Source;
  PKDT58DI64yanmicStoreBuffer = ^TKDT58DI64yanmicStoreBuffer;

  PKDT58DI64_Node = ^TKDT58DI64_Node;

  TKDT58DI64_Node = packed record
    Parent, Right, Left: PKDT58DI64_Node;
    vec: PKDT58DI64_Source;
  end;

  TKDT58DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT58DI64_Source);
  TKDT58DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT58DI64_Source) of object;
  {$IFNDEF FPC} TKDT58DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT58DI64_Source); {$ENDIF}

  TKDT58DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT58DI64yanmicStoreBuffer;
    KDBuff     : TKDT58DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT58DI64_Node;
    TestBuff   : TKDT58DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT58DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT58DI64_Node;
    function GetData(const index: NativeInt): PKDT58DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT58DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT58DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT58DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT58DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT58DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT58DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT58DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT58DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT58DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT58DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT58DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT58DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT58DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT58DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT58DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT58DI64_Node; overload;
    function Search(const Buff: TKDT58DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT58DI64_Node; overload;
    function Search(const Buff: TKDT58DI64_Vec; var SearchedDistanceMin: Double): PKDT58DI64_Node; overload;
    function Search(const Buff: TKDT58DI64_Vec): PKDT58DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT58DI64_DynamicVecBuffer; var OutBuff: TKDT58DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT58DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT58DI64_Node);
    procedure PrintBuffer;

    class function KDT58DI64Vec(const s: string): TKDT58DI64_Vec; overload;
    class function KDT58DI64Vec(const v: TKDT58DI64_Vec): string; overload;
    class function KDT58DI64Pow(const v: TKDT58DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT58DI64Distance(const v1, v2: TKDT58DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT58DI64_Source);
    class procedure Test;
  end;



  TKDT59DI64_Vec = array [0 .. KDT59DI64_Axis - 1] of TKDT59DI64_VecType;
  PKDT59DI64_Vec = ^TKDT59DI64_Vec;

  TKDT59DI64_DynamicVecBuffer = array of TKDT59DI64_Vec;
  PKDT59DI64_DynamicVecBuffer = ^TKDT59DI64_DynamicVecBuffer;

  TKDT59DI64_Source = packed record
    Buff: TKDT59DI64_Vec;
    index: Int64;
  end;

  PKDT59DI64_Source       = ^TKDT59DI64_Source;
  TKDT59DI64_SourceBuffer = array [0 .. 0] of PKDT59DI64_Source;
  PKDT59DI64_SourceBuffer = ^TKDT59DI64_SourceBuffer;

  TKDT59DI64yanmicSourceBuffer = array of PKDT59DI64_Source;
  PKDT59DI64yanmicSourceBuffer = ^TKDT59DI64yanmicSourceBuffer;

  TKDT59DI64yanmicStoreBuffer = array of TKDT59DI64_Source;
  PKDT59DI64yanmicStoreBuffer = ^TKDT59DI64yanmicStoreBuffer;

  PKDT59DI64_Node = ^TKDT59DI64_Node;

  TKDT59DI64_Node = packed record
    Parent, Right, Left: PKDT59DI64_Node;
    vec: PKDT59DI64_Source;
  end;

  TKDT59DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT59DI64_Source);
  TKDT59DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT59DI64_Source) of object;
  {$IFNDEF FPC} TKDT59DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT59DI64_Source); {$ENDIF}

  TKDT59DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT59DI64yanmicStoreBuffer;
    KDBuff     : TKDT59DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT59DI64_Node;
    TestBuff   : TKDT59DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT59DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT59DI64_Node;
    function GetData(const index: NativeInt): PKDT59DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT59DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT59DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT59DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT59DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT59DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT59DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT59DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT59DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT59DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT59DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT59DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT59DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT59DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT59DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT59DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT59DI64_Node; overload;
    function Search(const Buff: TKDT59DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT59DI64_Node; overload;
    function Search(const Buff: TKDT59DI64_Vec; var SearchedDistanceMin: Double): PKDT59DI64_Node; overload;
    function Search(const Buff: TKDT59DI64_Vec): PKDT59DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT59DI64_DynamicVecBuffer; var OutBuff: TKDT59DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT59DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT59DI64_Node);
    procedure PrintBuffer;

    class function KDT59DI64Vec(const s: string): TKDT59DI64_Vec; overload;
    class function KDT59DI64Vec(const v: TKDT59DI64_Vec): string; overload;
    class function KDT59DI64Pow(const v: TKDT59DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT59DI64Distance(const v1, v2: TKDT59DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT59DI64_Source);
    class procedure Test;
  end;



  TKDT60DI64_Vec = array [0 .. KDT60DI64_Axis - 1] of TKDT60DI64_VecType;
  PKDT60DI64_Vec = ^TKDT60DI64_Vec;

  TKDT60DI64_DynamicVecBuffer = array of TKDT60DI64_Vec;
  PKDT60DI64_DynamicVecBuffer = ^TKDT60DI64_DynamicVecBuffer;

  TKDT60DI64_Source = packed record
    Buff: TKDT60DI64_Vec;
    index: Int64;
  end;

  PKDT60DI64_Source       = ^TKDT60DI64_Source;
  TKDT60DI64_SourceBuffer = array [0 .. 0] of PKDT60DI64_Source;
  PKDT60DI64_SourceBuffer = ^TKDT60DI64_SourceBuffer;

  TKDT60DI64yanmicSourceBuffer = array of PKDT60DI64_Source;
  PKDT60DI64yanmicSourceBuffer = ^TKDT60DI64yanmicSourceBuffer;

  TKDT60DI64yanmicStoreBuffer = array of TKDT60DI64_Source;
  PKDT60DI64yanmicStoreBuffer = ^TKDT60DI64yanmicStoreBuffer;

  PKDT60DI64_Node = ^TKDT60DI64_Node;

  TKDT60DI64_Node = packed record
    Parent, Right, Left: PKDT60DI64_Node;
    vec: PKDT60DI64_Source;
  end;

  TKDT60DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT60DI64_Source);
  TKDT60DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT60DI64_Source) of object;
  {$IFNDEF FPC} TKDT60DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT60DI64_Source); {$ENDIF}

  TKDT60DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT60DI64yanmicStoreBuffer;
    KDBuff     : TKDT60DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT60DI64_Node;
    TestBuff   : TKDT60DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT60DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT60DI64_Node;
    function GetData(const index: NativeInt): PKDT60DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT60DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT60DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT60DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT60DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT60DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT60DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT60DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT60DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT60DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT60DI64_Node; overload;
    function Search(const Buff: TKDT60DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT60DI64_Node; overload;
    function Search(const Buff: TKDT60DI64_Vec; var SearchedDistanceMin: Double): PKDT60DI64_Node; overload;
    function Search(const Buff: TKDT60DI64_Vec): PKDT60DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT60DI64_DynamicVecBuffer; var OutBuff: TKDT60DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT60DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT60DI64_Node);
    procedure PrintBuffer;

    class function KDT60DI64Vec(const s: string): TKDT60DI64_Vec; overload;
    class function KDT60DI64Vec(const v: TKDT60DI64_Vec): string; overload;
    class function KDT60DI64Pow(const v: TKDT60DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT60DI64Distance(const v1, v2: TKDT60DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT60DI64_Source);
    class procedure Test;
  end;



  TKDT61DI64_Vec = array [0 .. KDT61DI64_Axis - 1] of TKDT61DI64_VecType;
  PKDT61DI64_Vec = ^TKDT61DI64_Vec;

  TKDT61DI64_DynamicVecBuffer = array of TKDT61DI64_Vec;
  PKDT61DI64_DynamicVecBuffer = ^TKDT61DI64_DynamicVecBuffer;

  TKDT61DI64_Source = packed record
    Buff: TKDT61DI64_Vec;
    index: Int64;
  end;

  PKDT61DI64_Source       = ^TKDT61DI64_Source;
  TKDT61DI64_SourceBuffer = array [0 .. 0] of PKDT61DI64_Source;
  PKDT61DI64_SourceBuffer = ^TKDT61DI64_SourceBuffer;

  TKDT61DI64yanmicSourceBuffer = array of PKDT61DI64_Source;
  PKDT61DI64yanmicSourceBuffer = ^TKDT61DI64yanmicSourceBuffer;

  TKDT61DI64yanmicStoreBuffer = array of TKDT61DI64_Source;
  PKDT61DI64yanmicStoreBuffer = ^TKDT61DI64yanmicStoreBuffer;

  PKDT61DI64_Node = ^TKDT61DI64_Node;

  TKDT61DI64_Node = packed record
    Parent, Right, Left: PKDT61DI64_Node;
    vec: PKDT61DI64_Source;
  end;

  TKDT61DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT61DI64_Source);
  TKDT61DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT61DI64_Source) of object;
  {$IFNDEF FPC} TKDT61DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT61DI64_Source); {$ENDIF}

  TKDT61DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT61DI64yanmicStoreBuffer;
    KDBuff     : TKDT61DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT61DI64_Node;
    TestBuff   : TKDT61DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT61DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT61DI64_Node;
    function GetData(const index: NativeInt): PKDT61DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT61DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT61DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT61DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT61DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT61DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT61DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT61DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT61DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT61DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT61DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT61DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT61DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT61DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT61DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT61DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT61DI64_Node; overload;
    function Search(const Buff: TKDT61DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT61DI64_Node; overload;
    function Search(const Buff: TKDT61DI64_Vec; var SearchedDistanceMin: Double): PKDT61DI64_Node; overload;
    function Search(const Buff: TKDT61DI64_Vec): PKDT61DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT61DI64_DynamicVecBuffer; var OutBuff: TKDT61DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT61DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT61DI64_Node);
    procedure PrintBuffer;

    class function KDT61DI64Vec(const s: string): TKDT61DI64_Vec; overload;
    class function KDT61DI64Vec(const v: TKDT61DI64_Vec): string; overload;
    class function KDT61DI64Pow(const v: TKDT61DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT61DI64Distance(const v1, v2: TKDT61DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT61DI64_Source);
    class procedure Test;
  end;



  TKDT62DI64_Vec = array [0 .. KDT62DI64_Axis - 1] of TKDT62DI64_VecType;
  PKDT62DI64_Vec = ^TKDT62DI64_Vec;

  TKDT62DI64_DynamicVecBuffer = array of TKDT62DI64_Vec;
  PKDT62DI64_DynamicVecBuffer = ^TKDT62DI64_DynamicVecBuffer;

  TKDT62DI64_Source = packed record
    Buff: TKDT62DI64_Vec;
    index: Int64;
  end;

  PKDT62DI64_Source       = ^TKDT62DI64_Source;
  TKDT62DI64_SourceBuffer = array [0 .. 0] of PKDT62DI64_Source;
  PKDT62DI64_SourceBuffer = ^TKDT62DI64_SourceBuffer;

  TKDT62DI64yanmicSourceBuffer = array of PKDT62DI64_Source;
  PKDT62DI64yanmicSourceBuffer = ^TKDT62DI64yanmicSourceBuffer;

  TKDT62DI64yanmicStoreBuffer = array of TKDT62DI64_Source;
  PKDT62DI64yanmicStoreBuffer = ^TKDT62DI64yanmicStoreBuffer;

  PKDT62DI64_Node = ^TKDT62DI64_Node;

  TKDT62DI64_Node = packed record
    Parent, Right, Left: PKDT62DI64_Node;
    vec: PKDT62DI64_Source;
  end;

  TKDT62DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT62DI64_Source);
  TKDT62DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT62DI64_Source) of object;
  {$IFNDEF FPC} TKDT62DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT62DI64_Source); {$ENDIF}

  TKDT62DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT62DI64yanmicStoreBuffer;
    KDBuff     : TKDT62DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT62DI64_Node;
    TestBuff   : TKDT62DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT62DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT62DI64_Node;
    function GetData(const index: NativeInt): PKDT62DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT62DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT62DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT62DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT62DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT62DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT62DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT62DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT62DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT62DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT62DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT62DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT62DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT62DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT62DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT62DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT62DI64_Node; overload;
    function Search(const Buff: TKDT62DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT62DI64_Node; overload;
    function Search(const Buff: TKDT62DI64_Vec; var SearchedDistanceMin: Double): PKDT62DI64_Node; overload;
    function Search(const Buff: TKDT62DI64_Vec): PKDT62DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT62DI64_DynamicVecBuffer; var OutBuff: TKDT62DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT62DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT62DI64_Node);
    procedure PrintBuffer;

    class function KDT62DI64Vec(const s: string): TKDT62DI64_Vec; overload;
    class function KDT62DI64Vec(const v: TKDT62DI64_Vec): string; overload;
    class function KDT62DI64Pow(const v: TKDT62DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT62DI64Distance(const v1, v2: TKDT62DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT62DI64_Source);
    class procedure Test;
  end;



  TKDT63DI64_Vec = array [0 .. KDT63DI64_Axis - 1] of TKDT63DI64_VecType;
  PKDT63DI64_Vec = ^TKDT63DI64_Vec;

  TKDT63DI64_DynamicVecBuffer = array of TKDT63DI64_Vec;
  PKDT63DI64_DynamicVecBuffer = ^TKDT63DI64_DynamicVecBuffer;

  TKDT63DI64_Source = packed record
    Buff: TKDT63DI64_Vec;
    index: Int64;
  end;

  PKDT63DI64_Source       = ^TKDT63DI64_Source;
  TKDT63DI64_SourceBuffer = array [0 .. 0] of PKDT63DI64_Source;
  PKDT63DI64_SourceBuffer = ^TKDT63DI64_SourceBuffer;

  TKDT63DI64yanmicSourceBuffer = array of PKDT63DI64_Source;
  PKDT63DI64yanmicSourceBuffer = ^TKDT63DI64yanmicSourceBuffer;

  TKDT63DI64yanmicStoreBuffer = array of TKDT63DI64_Source;
  PKDT63DI64yanmicStoreBuffer = ^TKDT63DI64yanmicStoreBuffer;

  PKDT63DI64_Node = ^TKDT63DI64_Node;

  TKDT63DI64_Node = packed record
    Parent, Right, Left: PKDT63DI64_Node;
    vec: PKDT63DI64_Source;
  end;

  TKDT63DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT63DI64_Source);
  TKDT63DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT63DI64_Source) of object;
  {$IFNDEF FPC} TKDT63DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT63DI64_Source); {$ENDIF}

  TKDT63DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT63DI64yanmicStoreBuffer;
    KDBuff     : TKDT63DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT63DI64_Node;
    TestBuff   : TKDT63DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT63DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT63DI64_Node;
    function GetData(const index: NativeInt): PKDT63DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT63DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT63DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT63DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT63DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT63DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT63DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT63DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT63DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT63DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT63DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT63DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT63DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT63DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT63DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT63DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT63DI64_Node; overload;
    function Search(const Buff: TKDT63DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT63DI64_Node; overload;
    function Search(const Buff: TKDT63DI64_Vec; var SearchedDistanceMin: Double): PKDT63DI64_Node; overload;
    function Search(const Buff: TKDT63DI64_Vec): PKDT63DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT63DI64_DynamicVecBuffer; var OutBuff: TKDT63DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT63DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT63DI64_Node);
    procedure PrintBuffer;

    class function KDT63DI64Vec(const s: string): TKDT63DI64_Vec; overload;
    class function KDT63DI64Vec(const v: TKDT63DI64_Vec): string; overload;
    class function KDT63DI64Pow(const v: TKDT63DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT63DI64Distance(const v1, v2: TKDT63DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT63DI64_Source);
    class procedure Test;
  end;



  TKDT64DI64_Vec = array [0 .. KDT64DI64_Axis - 1] of TKDT64DI64_VecType;
  PKDT64DI64_Vec = ^TKDT64DI64_Vec;

  TKDT64DI64_DynamicVecBuffer = array of TKDT64DI64_Vec;
  PKDT64DI64_DynamicVecBuffer = ^TKDT64DI64_DynamicVecBuffer;

  TKDT64DI64_Source = packed record
    Buff: TKDT64DI64_Vec;
    index: Int64;
  end;

  PKDT64DI64_Source       = ^TKDT64DI64_Source;
  TKDT64DI64_SourceBuffer = array [0 .. 0] of PKDT64DI64_Source;
  PKDT64DI64_SourceBuffer = ^TKDT64DI64_SourceBuffer;

  TKDT64DI64yanmicSourceBuffer = array of PKDT64DI64_Source;
  PKDT64DI64yanmicSourceBuffer = ^TKDT64DI64yanmicSourceBuffer;

  TKDT64DI64yanmicStoreBuffer = array of TKDT64DI64_Source;
  PKDT64DI64yanmicStoreBuffer = ^TKDT64DI64yanmicStoreBuffer;

  PKDT64DI64_Node = ^TKDT64DI64_Node;

  TKDT64DI64_Node = packed record
    Parent, Right, Left: PKDT64DI64_Node;
    vec: PKDT64DI64_Source;
  end;

  TKDT64DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT64DI64_Source);
  TKDT64DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT64DI64_Source) of object;
  {$IFNDEF FPC} TKDT64DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT64DI64_Source); {$ENDIF}

  TKDT64DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT64DI64yanmicStoreBuffer;
    KDBuff     : TKDT64DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT64DI64_Node;
    TestBuff   : TKDT64DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DI64_Node;
    function GetData(const index: NativeInt): PKDT64DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT64DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT64DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT64DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT64DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT64DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT64DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT64DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT64DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DI64_Node; overload;
    function Search(const Buff: TKDT64DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DI64_Node; overload;
    function Search(const Buff: TKDT64DI64_Vec; var SearchedDistanceMin: Double): PKDT64DI64_Node; overload;
    function Search(const Buff: TKDT64DI64_Vec): PKDT64DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT64DI64_DynamicVecBuffer; var OutBuff: TKDT64DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT64DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT64DI64_Node);
    procedure PrintBuffer;

    class function KDT64DI64Vec(const s: string): TKDT64DI64_Vec; overload;
    class function KDT64DI64Vec(const v: TKDT64DI64_Vec): string; overload;
    class function KDT64DI64Pow(const v: TKDT64DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT64DI64Distance(const v1, v2: TKDT64DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT64DI64_Source);
    class procedure Test;
  end;



  TKDT72DI64_Vec = array [0 .. KDT72DI64_Axis - 1] of TKDT72DI64_VecType;
  PKDT72DI64_Vec = ^TKDT72DI64_Vec;

  TKDT72DI64_DynamicVecBuffer = array of TKDT72DI64_Vec;
  PKDT72DI64_DynamicVecBuffer = ^TKDT72DI64_DynamicVecBuffer;

  TKDT72DI64_Source = packed record
    Buff: TKDT72DI64_Vec;
    index: Int64;
  end;

  PKDT72DI64_Source       = ^TKDT72DI64_Source;
  TKDT72DI64_SourceBuffer = array [0 .. 0] of PKDT72DI64_Source;
  PKDT72DI64_SourceBuffer = ^TKDT72DI64_SourceBuffer;

  TKDT72DI64yanmicSourceBuffer = array of PKDT72DI64_Source;
  PKDT72DI64yanmicSourceBuffer = ^TKDT72DI64yanmicSourceBuffer;

  TKDT72DI64yanmicStoreBuffer = array of TKDT72DI64_Source;
  PKDT72DI64yanmicStoreBuffer = ^TKDT72DI64yanmicStoreBuffer;

  PKDT72DI64_Node = ^TKDT72DI64_Node;

  TKDT72DI64_Node = packed record
    Parent, Right, Left: PKDT72DI64_Node;
    vec: PKDT72DI64_Source;
  end;

  TKDT72DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT72DI64_Source);
  TKDT72DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT72DI64_Source) of object;
  {$IFNDEF FPC} TKDT72DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT72DI64_Source); {$ENDIF}

  TKDT72DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT72DI64yanmicStoreBuffer;
    KDBuff     : TKDT72DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT72DI64_Node;
    TestBuff   : TKDT72DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT72DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT72DI64_Node;
    function GetData(const index: NativeInt): PKDT72DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT72DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT72DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT72DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT72DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT72DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT72DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT72DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT72DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT72DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT72DI64_Node; overload;
    function Search(const Buff: TKDT72DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT72DI64_Node; overload;
    function Search(const Buff: TKDT72DI64_Vec; var SearchedDistanceMin: Double): PKDT72DI64_Node; overload;
    function Search(const Buff: TKDT72DI64_Vec): PKDT72DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT72DI64_DynamicVecBuffer; var OutBuff: TKDT72DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT72DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT72DI64_Node);
    procedure PrintBuffer;

    class function KDT72DI64Vec(const s: string): TKDT72DI64_Vec; overload;
    class function KDT72DI64Vec(const v: TKDT72DI64_Vec): string; overload;
    class function KDT72DI64Pow(const v: TKDT72DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT72DI64Distance(const v1, v2: TKDT72DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT72DI64_Source);
    class procedure Test;
  end;



  TKDT84DI64_Vec = array [0 .. KDT84DI64_Axis - 1] of TKDT84DI64_VecType;
  PKDT84DI64_Vec = ^TKDT84DI64_Vec;

  TKDT84DI64_DynamicVecBuffer = array of TKDT84DI64_Vec;
  PKDT84DI64_DynamicVecBuffer = ^TKDT84DI64_DynamicVecBuffer;

  TKDT84DI64_Source = packed record
    Buff: TKDT84DI64_Vec;
    index: Int64;
  end;

  PKDT84DI64_Source       = ^TKDT84DI64_Source;
  TKDT84DI64_SourceBuffer = array [0 .. 0] of PKDT84DI64_Source;
  PKDT84DI64_SourceBuffer = ^TKDT84DI64_SourceBuffer;

  TKDT84DI64yanmicSourceBuffer = array of PKDT84DI64_Source;
  PKDT84DI64yanmicSourceBuffer = ^TKDT84DI64yanmicSourceBuffer;

  TKDT84DI64yanmicStoreBuffer = array of TKDT84DI64_Source;
  PKDT84DI64yanmicStoreBuffer = ^TKDT84DI64yanmicStoreBuffer;

  PKDT84DI64_Node = ^TKDT84DI64_Node;

  TKDT84DI64_Node = packed record
    Parent, Right, Left: PKDT84DI64_Node;
    vec: PKDT84DI64_Source;
  end;

  TKDT84DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT84DI64_Source);
  TKDT84DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT84DI64_Source) of object;
  {$IFNDEF FPC} TKDT84DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT84DI64_Source); {$ENDIF}

  TKDT84DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT84DI64yanmicStoreBuffer;
    KDBuff     : TKDT84DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT84DI64_Node;
    TestBuff   : TKDT84DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT84DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT84DI64_Node;
    function GetData(const index: NativeInt): PKDT84DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT84DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT84DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT84DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT84DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT84DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT84DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT84DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT84DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT84DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT84DI64_Node; overload;
    function Search(const Buff: TKDT84DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT84DI64_Node; overload;
    function Search(const Buff: TKDT84DI64_Vec; var SearchedDistanceMin: Double): PKDT84DI64_Node; overload;
    function Search(const Buff: TKDT84DI64_Vec): PKDT84DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT84DI64_DynamicVecBuffer; var OutBuff: TKDT84DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT84DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT84DI64_Node);
    procedure PrintBuffer;

    class function KDT84DI64Vec(const s: string): TKDT84DI64_Vec; overload;
    class function KDT84DI64Vec(const v: TKDT84DI64_Vec): string; overload;
    class function KDT84DI64Pow(const v: TKDT84DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT84DI64Distance(const v1, v2: TKDT84DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT84DI64_Source);
    class procedure Test;
  end;



  TKDT96DI64_Vec = array [0 .. KDT96DI64_Axis - 1] of TKDT96DI64_VecType;
  PKDT96DI64_Vec = ^TKDT96DI64_Vec;

  TKDT96DI64_DynamicVecBuffer = array of TKDT96DI64_Vec;
  PKDT96DI64_DynamicVecBuffer = ^TKDT96DI64_DynamicVecBuffer;

  TKDT96DI64_Source = packed record
    Buff: TKDT96DI64_Vec;
    index: Int64;
  end;

  PKDT96DI64_Source       = ^TKDT96DI64_Source;
  TKDT96DI64_SourceBuffer = array [0 .. 0] of PKDT96DI64_Source;
  PKDT96DI64_SourceBuffer = ^TKDT96DI64_SourceBuffer;

  TKDT96DI64yanmicSourceBuffer = array of PKDT96DI64_Source;
  PKDT96DI64yanmicSourceBuffer = ^TKDT96DI64yanmicSourceBuffer;

  TKDT96DI64yanmicStoreBuffer = array of TKDT96DI64_Source;
  PKDT96DI64yanmicStoreBuffer = ^TKDT96DI64yanmicStoreBuffer;

  PKDT96DI64_Node = ^TKDT96DI64_Node;

  TKDT96DI64_Node = packed record
    Parent, Right, Left: PKDT96DI64_Node;
    vec: PKDT96DI64_Source;
  end;

  TKDT96DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT96DI64_Source);
  TKDT96DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT96DI64_Source) of object;
  {$IFNDEF FPC} TKDT96DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT96DI64_Source); {$ENDIF}

  TKDT96DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT96DI64yanmicStoreBuffer;
    KDBuff     : TKDT96DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT96DI64_Node;
    TestBuff   : TKDT96DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DI64_Node;
    function GetData(const index: NativeInt): PKDT96DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT96DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT96DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT96DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT96DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT96DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT96DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT96DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT96DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DI64_Node; overload;
    function Search(const Buff: TKDT96DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DI64_Node; overload;
    function Search(const Buff: TKDT96DI64_Vec; var SearchedDistanceMin: Double): PKDT96DI64_Node; overload;
    function Search(const Buff: TKDT96DI64_Vec): PKDT96DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT96DI64_DynamicVecBuffer; var OutBuff: TKDT96DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT96DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT96DI64_Node);
    procedure PrintBuffer;

    class function KDT96DI64Vec(const s: string): TKDT96DI64_Vec; overload;
    class function KDT96DI64Vec(const v: TKDT96DI64_Vec): string; overload;
    class function KDT96DI64Pow(const v: TKDT96DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT96DI64Distance(const v1, v2: TKDT96DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT96DI64_Source);
    class procedure Test;
  end;



  TKDT128DI64_Vec = array [0 .. KDT128DI64_Axis - 1] of TKDT128DI64_VecType;
  PKDT128DI64_Vec = ^TKDT128DI64_Vec;

  TKDT128DI64_DynamicVecBuffer = array of TKDT128DI64_Vec;
  PKDT128DI64_DynamicVecBuffer = ^TKDT128DI64_DynamicVecBuffer;

  TKDT128DI64_Source = packed record
    Buff: TKDT128DI64_Vec;
    index: Int64;
  end;

  PKDT128DI64_Source       = ^TKDT128DI64_Source;
  TKDT128DI64_SourceBuffer = array [0 .. 0] of PKDT128DI64_Source;
  PKDT128DI64_SourceBuffer = ^TKDT128DI64_SourceBuffer;

  TKDT128DI64yanmicSourceBuffer = array of PKDT128DI64_Source;
  PKDT128DI64yanmicSourceBuffer = ^TKDT128DI64yanmicSourceBuffer;

  TKDT128DI64yanmicStoreBuffer = array of TKDT128DI64_Source;
  PKDT128DI64yanmicStoreBuffer = ^TKDT128DI64yanmicStoreBuffer;

  PKDT128DI64_Node = ^TKDT128DI64_Node;

  TKDT128DI64_Node = packed record
    Parent, Right, Left: PKDT128DI64_Node;
    vec: PKDT128DI64_Source;
  end;

  TKDT128DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT128DI64_Source);
  TKDT128DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT128DI64_Source) of object;
  {$IFNDEF FPC} TKDT128DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT128DI64_Source); {$ENDIF}

  TKDT128DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT128DI64yanmicStoreBuffer;
    KDBuff     : TKDT128DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT128DI64_Node;
    TestBuff   : TKDT128DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DI64_Node;
    function GetData(const index: NativeInt): PKDT128DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT128DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT128DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT128DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT128DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT128DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT128DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT128DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT128DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DI64_Node; overload;
    function Search(const Buff: TKDT128DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DI64_Node; overload;
    function Search(const Buff: TKDT128DI64_Vec; var SearchedDistanceMin: Double): PKDT128DI64_Node; overload;
    function Search(const Buff: TKDT128DI64_Vec): PKDT128DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT128DI64_DynamicVecBuffer; var OutBuff: TKDT128DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT128DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT128DI64_Node);
    procedure PrintBuffer;

    class function KDT128DI64Vec(const s: string): TKDT128DI64_Vec; overload;
    class function KDT128DI64Vec(const v: TKDT128DI64_Vec): string; overload;
    class function KDT128DI64Pow(const v: TKDT128DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT128DI64Distance(const v1, v2: TKDT128DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT128DI64_Source);
    class procedure Test;
  end;



  TKDT140DI64_Vec = array [0 .. KDT140DI64_Axis - 1] of TKDT140DI64_VecType;
  PKDT140DI64_Vec = ^TKDT140DI64_Vec;

  TKDT140DI64_DynamicVecBuffer = array of TKDT140DI64_Vec;
  PKDT140DI64_DynamicVecBuffer = ^TKDT140DI64_DynamicVecBuffer;

  TKDT140DI64_Source = packed record
    Buff: TKDT140DI64_Vec;
    index: Int64;
  end;

  PKDT140DI64_Source       = ^TKDT140DI64_Source;
  TKDT140DI64_SourceBuffer = array [0 .. 0] of PKDT140DI64_Source;
  PKDT140DI64_SourceBuffer = ^TKDT140DI64_SourceBuffer;

  TKDT140DI64yanmicSourceBuffer = array of PKDT140DI64_Source;
  PKDT140DI64yanmicSourceBuffer = ^TKDT140DI64yanmicSourceBuffer;

  TKDT140DI64yanmicStoreBuffer = array of TKDT140DI64_Source;
  PKDT140DI64yanmicStoreBuffer = ^TKDT140DI64yanmicStoreBuffer;

  PKDT140DI64_Node = ^TKDT140DI64_Node;

  TKDT140DI64_Node = packed record
    Parent, Right, Left: PKDT140DI64_Node;
    vec: PKDT140DI64_Source;
  end;

  TKDT140DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT140DI64_Source);
  TKDT140DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT140DI64_Source) of object;
  {$IFNDEF FPC} TKDT140DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT140DI64_Source); {$ENDIF}

  TKDT140DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT140DI64yanmicStoreBuffer;
    KDBuff     : TKDT140DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT140DI64_Node;
    TestBuff   : TKDT140DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT140DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT140DI64_Node;
    function GetData(const index: NativeInt): PKDT140DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT140DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT140DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT140DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT140DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT140DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT140DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT140DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT140DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT140DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT140DI64_Node; overload;
    function Search(const Buff: TKDT140DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT140DI64_Node; overload;
    function Search(const Buff: TKDT140DI64_Vec; var SearchedDistanceMin: Double): PKDT140DI64_Node; overload;
    function Search(const Buff: TKDT140DI64_Vec): PKDT140DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT140DI64_DynamicVecBuffer; var OutBuff: TKDT140DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT140DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT140DI64_Node);
    procedure PrintBuffer;

    class function KDT140DI64Vec(const s: string): TKDT140DI64_Vec; overload;
    class function KDT140DI64Vec(const v: TKDT140DI64_Vec): string; overload;
    class function KDT140DI64Pow(const v: TKDT140DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT140DI64Distance(const v1, v2: TKDT140DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT140DI64_Source);
    class procedure Test;
  end;



  TKDT160DI64_Vec = array [0 .. KDT160DI64_Axis - 1] of TKDT160DI64_VecType;
  PKDT160DI64_Vec = ^TKDT160DI64_Vec;

  TKDT160DI64_DynamicVecBuffer = array of TKDT160DI64_Vec;
  PKDT160DI64_DynamicVecBuffer = ^TKDT160DI64_DynamicVecBuffer;

  TKDT160DI64_Source = packed record
    Buff: TKDT160DI64_Vec;
    index: Int64;
  end;

  PKDT160DI64_Source       = ^TKDT160DI64_Source;
  TKDT160DI64_SourceBuffer = array [0 .. 0] of PKDT160DI64_Source;
  PKDT160DI64_SourceBuffer = ^TKDT160DI64_SourceBuffer;

  TKDT160DI64yanmicSourceBuffer = array of PKDT160DI64_Source;
  PKDT160DI64yanmicSourceBuffer = ^TKDT160DI64yanmicSourceBuffer;

  TKDT160DI64yanmicStoreBuffer = array of TKDT160DI64_Source;
  PKDT160DI64yanmicStoreBuffer = ^TKDT160DI64yanmicStoreBuffer;

  PKDT160DI64_Node = ^TKDT160DI64_Node;

  TKDT160DI64_Node = packed record
    Parent, Right, Left: PKDT160DI64_Node;
    vec: PKDT160DI64_Source;
  end;

  TKDT160DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT160DI64_Source);
  TKDT160DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT160DI64_Source) of object;
  {$IFNDEF FPC} TKDT160DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT160DI64_Source); {$ENDIF}

  TKDT160DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT160DI64yanmicStoreBuffer;
    KDBuff     : TKDT160DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT160DI64_Node;
    TestBuff   : TKDT160DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT160DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT160DI64_Node;
    function GetData(const index: NativeInt): PKDT160DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT160DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT160DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT160DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT160DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT160DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT160DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT160DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT160DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT160DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT160DI64_Node; overload;
    function Search(const Buff: TKDT160DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT160DI64_Node; overload;
    function Search(const Buff: TKDT160DI64_Vec; var SearchedDistanceMin: Double): PKDT160DI64_Node; overload;
    function Search(const Buff: TKDT160DI64_Vec): PKDT160DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT160DI64_DynamicVecBuffer; var OutBuff: TKDT160DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT160DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT160DI64_Node);
    procedure PrintBuffer;

    class function KDT160DI64Vec(const s: string): TKDT160DI64_Vec; overload;
    class function KDT160DI64Vec(const v: TKDT160DI64_Vec): string; overload;
    class function KDT160DI64Pow(const v: TKDT160DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT160DI64Distance(const v1, v2: TKDT160DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT160DI64_Source);
    class procedure Test;
  end;



  TKDT196DI64_Vec = array [0 .. KDT196DI64_Axis - 1] of TKDT196DI64_VecType;
  PKDT196DI64_Vec = ^TKDT196DI64_Vec;

  TKDT196DI64_DynamicVecBuffer = array of TKDT196DI64_Vec;
  PKDT196DI64_DynamicVecBuffer = ^TKDT196DI64_DynamicVecBuffer;

  TKDT196DI64_Source = packed record
    Buff: TKDT196DI64_Vec;
    index: Int64;
  end;

  PKDT196DI64_Source       = ^TKDT196DI64_Source;
  TKDT196DI64_SourceBuffer = array [0 .. 0] of PKDT196DI64_Source;
  PKDT196DI64_SourceBuffer = ^TKDT196DI64_SourceBuffer;

  TKDT196DI64yanmicSourceBuffer = array of PKDT196DI64_Source;
  PKDT196DI64yanmicSourceBuffer = ^TKDT196DI64yanmicSourceBuffer;

  TKDT196DI64yanmicStoreBuffer = array of TKDT196DI64_Source;
  PKDT196DI64yanmicStoreBuffer = ^TKDT196DI64yanmicStoreBuffer;

  PKDT196DI64_Node = ^TKDT196DI64_Node;

  TKDT196DI64_Node = packed record
    Parent, Right, Left: PKDT196DI64_Node;
    vec: PKDT196DI64_Source;
  end;

  TKDT196DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT196DI64_Source);
  TKDT196DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT196DI64_Source) of object;
  {$IFNDEF FPC} TKDT196DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT196DI64_Source); {$ENDIF}

  TKDT196DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT196DI64yanmicStoreBuffer;
    KDBuff     : TKDT196DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT196DI64_Node;
    TestBuff   : TKDT196DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT196DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT196DI64_Node;
    function GetData(const index: NativeInt): PKDT196DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT196DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT196DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT196DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT196DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT196DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT196DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT196DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT196DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT196DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT196DI64_Node; overload;
    function Search(const Buff: TKDT196DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT196DI64_Node; overload;
    function Search(const Buff: TKDT196DI64_Vec; var SearchedDistanceMin: Double): PKDT196DI64_Node; overload;
    function Search(const Buff: TKDT196DI64_Vec): PKDT196DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT196DI64_DynamicVecBuffer; var OutBuff: TKDT196DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT196DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT196DI64_Node);
    procedure PrintBuffer;

    class function KDT196DI64Vec(const s: string): TKDT196DI64_Vec; overload;
    class function KDT196DI64Vec(const v: TKDT196DI64_Vec): string; overload;
    class function KDT196DI64Pow(const v: TKDT196DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT196DI64Distance(const v1, v2: TKDT196DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT196DI64_Source);
    class procedure Test;
  end;



  TKDT256DI64_Vec = array [0 .. KDT256DI64_Axis - 1] of TKDT256DI64_VecType;
  PKDT256DI64_Vec = ^TKDT256DI64_Vec;

  TKDT256DI64_DynamicVecBuffer = array of TKDT256DI64_Vec;
  PKDT256DI64_DynamicVecBuffer = ^TKDT256DI64_DynamicVecBuffer;

  TKDT256DI64_Source = packed record
    Buff: TKDT256DI64_Vec;
    index: Int64;
  end;

  PKDT256DI64_Source       = ^TKDT256DI64_Source;
  TKDT256DI64_SourceBuffer = array [0 .. 0] of PKDT256DI64_Source;
  PKDT256DI64_SourceBuffer = ^TKDT256DI64_SourceBuffer;

  TKDT256DI64yanmicSourceBuffer = array of PKDT256DI64_Source;
  PKDT256DI64yanmicSourceBuffer = ^TKDT256DI64yanmicSourceBuffer;

  TKDT256DI64yanmicStoreBuffer = array of TKDT256DI64_Source;
  PKDT256DI64yanmicStoreBuffer = ^TKDT256DI64yanmicStoreBuffer;

  PKDT256DI64_Node = ^TKDT256DI64_Node;

  TKDT256DI64_Node = packed record
    Parent, Right, Left: PKDT256DI64_Node;
    vec: PKDT256DI64_Source;
  end;

  TKDT256DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT256DI64_Source);
  TKDT256DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT256DI64_Source) of object;
  {$IFNDEF FPC} TKDT256DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT256DI64_Source); {$ENDIF}

  TKDT256DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT256DI64yanmicStoreBuffer;
    KDBuff     : TKDT256DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT256DI64_Node;
    TestBuff   : TKDT256DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DI64_Node;
    function GetData(const index: NativeInt): PKDT256DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT256DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT256DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT256DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT256DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT256DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT256DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT256DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT256DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DI64_Node; overload;
    function Search(const Buff: TKDT256DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DI64_Node; overload;
    function Search(const Buff: TKDT256DI64_Vec; var SearchedDistanceMin: Double): PKDT256DI64_Node; overload;
    function Search(const Buff: TKDT256DI64_Vec): PKDT256DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT256DI64_DynamicVecBuffer; var OutBuff: TKDT256DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT256DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT256DI64_Node);
    procedure PrintBuffer;

    class function KDT256DI64Vec(const s: string): TKDT256DI64_Vec; overload;
    class function KDT256DI64Vec(const v: TKDT256DI64_Vec): string; overload;
    class function KDT256DI64Pow(const v: TKDT256DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT256DI64Distance(const v1, v2: TKDT256DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT256DI64_Source);
    class procedure Test;
  end;



  TKDT272DI64_Vec = array [0 .. KDT272DI64_Axis - 1] of TKDT272DI64_VecType;
  PKDT272DI64_Vec = ^TKDT272DI64_Vec;

  TKDT272DI64_DynamicVecBuffer = array of TKDT272DI64_Vec;
  PKDT272DI64_DynamicVecBuffer = ^TKDT272DI64_DynamicVecBuffer;

  TKDT272DI64_Source = packed record
    Buff: TKDT272DI64_Vec;
    index: Int64;
  end;

  PKDT272DI64_Source       = ^TKDT272DI64_Source;
  TKDT272DI64_SourceBuffer = array [0 .. 0] of PKDT272DI64_Source;
  PKDT272DI64_SourceBuffer = ^TKDT272DI64_SourceBuffer;

  TKDT272DI64yanmicSourceBuffer = array of PKDT272DI64_Source;
  PKDT272DI64yanmicSourceBuffer = ^TKDT272DI64yanmicSourceBuffer;

  TKDT272DI64yanmicStoreBuffer = array of TKDT272DI64_Source;
  PKDT272DI64yanmicStoreBuffer = ^TKDT272DI64yanmicStoreBuffer;

  PKDT272DI64_Node = ^TKDT272DI64_Node;

  TKDT272DI64_Node = packed record
    Parent, Right, Left: PKDT272DI64_Node;
    vec: PKDT272DI64_Source;
  end;

  TKDT272DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT272DI64_Source);
  TKDT272DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT272DI64_Source) of object;
  {$IFNDEF FPC} TKDT272DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT272DI64_Source); {$ENDIF}

  TKDT272DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT272DI64yanmicStoreBuffer;
    KDBuff     : TKDT272DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT272DI64_Node;
    TestBuff   : TKDT272DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT272DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT272DI64_Node;
    function GetData(const index: NativeInt): PKDT272DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT272DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT272DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT272DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT272DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT272DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT272DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT272DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT272DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT272DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT272DI64_Node; overload;
    function Search(const Buff: TKDT272DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT272DI64_Node; overload;
    function Search(const Buff: TKDT272DI64_Vec; var SearchedDistanceMin: Double): PKDT272DI64_Node; overload;
    function Search(const Buff: TKDT272DI64_Vec): PKDT272DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT272DI64_DynamicVecBuffer; var OutBuff: TKDT272DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT272DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT272DI64_Node);
    procedure PrintBuffer;

    class function KDT272DI64Vec(const s: string): TKDT272DI64_Vec; overload;
    class function KDT272DI64Vec(const v: TKDT272DI64_Vec): string; overload;
    class function KDT272DI64Pow(const v: TKDT272DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT272DI64Distance(const v1, v2: TKDT272DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT272DI64_Source);
    class procedure Test;
  end;



  TKDT288DI64_Vec = array [0 .. KDT288DI64_Axis - 1] of TKDT288DI64_VecType;
  PKDT288DI64_Vec = ^TKDT288DI64_Vec;

  TKDT288DI64_DynamicVecBuffer = array of TKDT288DI64_Vec;
  PKDT288DI64_DynamicVecBuffer = ^TKDT288DI64_DynamicVecBuffer;

  TKDT288DI64_Source = packed record
    Buff: TKDT288DI64_Vec;
    index: Int64;
  end;

  PKDT288DI64_Source       = ^TKDT288DI64_Source;
  TKDT288DI64_SourceBuffer = array [0 .. 0] of PKDT288DI64_Source;
  PKDT288DI64_SourceBuffer = ^TKDT288DI64_SourceBuffer;

  TKDT288DI64yanmicSourceBuffer = array of PKDT288DI64_Source;
  PKDT288DI64yanmicSourceBuffer = ^TKDT288DI64yanmicSourceBuffer;

  TKDT288DI64yanmicStoreBuffer = array of TKDT288DI64_Source;
  PKDT288DI64yanmicStoreBuffer = ^TKDT288DI64yanmicStoreBuffer;

  PKDT288DI64_Node = ^TKDT288DI64_Node;

  TKDT288DI64_Node = packed record
    Parent, Right, Left: PKDT288DI64_Node;
    vec: PKDT288DI64_Source;
  end;

  TKDT288DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT288DI64_Source);
  TKDT288DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT288DI64_Source) of object;
  {$IFNDEF FPC} TKDT288DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT288DI64_Source); {$ENDIF}

  TKDT288DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT288DI64yanmicStoreBuffer;
    KDBuff     : TKDT288DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT288DI64_Node;
    TestBuff   : TKDT288DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT288DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT288DI64_Node;
    function GetData(const index: NativeInt): PKDT288DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT288DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT288DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT288DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT288DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT288DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT288DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT288DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT288DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT288DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT288DI64_Node; overload;
    function Search(const Buff: TKDT288DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT288DI64_Node; overload;
    function Search(const Buff: TKDT288DI64_Vec; var SearchedDistanceMin: Double): PKDT288DI64_Node; overload;
    function Search(const Buff: TKDT288DI64_Vec): PKDT288DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT288DI64_DynamicVecBuffer; var OutBuff: TKDT288DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT288DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT288DI64_Node);
    procedure PrintBuffer;

    class function KDT288DI64Vec(const s: string): TKDT288DI64_Vec; overload;
    class function KDT288DI64Vec(const v: TKDT288DI64_Vec): string; overload;
    class function KDT288DI64Pow(const v: TKDT288DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT288DI64Distance(const v1, v2: TKDT288DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT288DI64_Source);
    class procedure Test;
  end;



  TKDT372DI64_Vec = array [0 .. KDT372DI64_Axis - 1] of TKDT372DI64_VecType;
  PKDT372DI64_Vec = ^TKDT372DI64_Vec;

  TKDT372DI64_DynamicVecBuffer = array of TKDT372DI64_Vec;
  PKDT372DI64_DynamicVecBuffer = ^TKDT372DI64_DynamicVecBuffer;

  TKDT372DI64_Source = packed record
    Buff: TKDT372DI64_Vec;
    index: Int64;
  end;

  PKDT372DI64_Source       = ^TKDT372DI64_Source;
  TKDT372DI64_SourceBuffer = array [0 .. 0] of PKDT372DI64_Source;
  PKDT372DI64_SourceBuffer = ^TKDT372DI64_SourceBuffer;

  TKDT372DI64yanmicSourceBuffer = array of PKDT372DI64_Source;
  PKDT372DI64yanmicSourceBuffer = ^TKDT372DI64yanmicSourceBuffer;

  TKDT372DI64yanmicStoreBuffer = array of TKDT372DI64_Source;
  PKDT372DI64yanmicStoreBuffer = ^TKDT372DI64yanmicStoreBuffer;

  PKDT372DI64_Node = ^TKDT372DI64_Node;

  TKDT372DI64_Node = packed record
    Parent, Right, Left: PKDT372DI64_Node;
    vec: PKDT372DI64_Source;
  end;

  TKDT372DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT372DI64_Source);
  TKDT372DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT372DI64_Source) of object;
  {$IFNDEF FPC} TKDT372DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT372DI64_Source); {$ENDIF}

  TKDT372DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT372DI64yanmicStoreBuffer;
    KDBuff     : TKDT372DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT372DI64_Node;
    TestBuff   : TKDT372DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DI64_Node;
    function GetData(const index: NativeInt): PKDT372DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT372DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT372DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT372DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT372DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT372DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT372DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT372DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT372DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DI64_Node; overload;
    function Search(const Buff: TKDT372DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DI64_Node; overload;
    function Search(const Buff: TKDT372DI64_Vec; var SearchedDistanceMin: Double): PKDT372DI64_Node; overload;
    function Search(const Buff: TKDT372DI64_Vec): PKDT372DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT372DI64_DynamicVecBuffer; var OutBuff: TKDT372DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT372DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT372DI64_Node);
    procedure PrintBuffer;

    class function KDT372DI64Vec(const s: string): TKDT372DI64_Vec; overload;
    class function KDT372DI64Vec(const v: TKDT372DI64_Vec): string; overload;
    class function KDT372DI64Pow(const v: TKDT372DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT372DI64Distance(const v1, v2: TKDT372DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT372DI64_Source);
    class procedure Test;
  end;



  TKDT512DI64_Vec = array [0 .. KDT512DI64_Axis - 1] of TKDT512DI64_VecType;
  PKDT512DI64_Vec = ^TKDT512DI64_Vec;

  TKDT512DI64_DynamicVecBuffer = array of TKDT512DI64_Vec;
  PKDT512DI64_DynamicVecBuffer = ^TKDT512DI64_DynamicVecBuffer;

  TKDT512DI64_Source = packed record
    Buff: TKDT512DI64_Vec;
    index: Int64;
  end;

  PKDT512DI64_Source       = ^TKDT512DI64_Source;
  TKDT512DI64_SourceBuffer = array [0 .. 0] of PKDT512DI64_Source;
  PKDT512DI64_SourceBuffer = ^TKDT512DI64_SourceBuffer;

  TKDT512DI64yanmicSourceBuffer = array of PKDT512DI64_Source;
  PKDT512DI64yanmicSourceBuffer = ^TKDT512DI64yanmicSourceBuffer;

  TKDT512DI64yanmicStoreBuffer = array of TKDT512DI64_Source;
  PKDT512DI64yanmicStoreBuffer = ^TKDT512DI64yanmicStoreBuffer;

  PKDT512DI64_Node = ^TKDT512DI64_Node;

  TKDT512DI64_Node = packed record
    Parent, Right, Left: PKDT512DI64_Node;
    vec: PKDT512DI64_Source;
  end;

  TKDT512DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT512DI64_Source);
  TKDT512DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT512DI64_Source) of object;
  {$IFNDEF FPC} TKDT512DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT512DI64_Source); {$ENDIF}

  TKDT512DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT512DI64yanmicStoreBuffer;
    KDBuff     : TKDT512DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT512DI64_Node;
    TestBuff   : TKDT512DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DI64_Node;
    function GetData(const index: NativeInt): PKDT512DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT512DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT512DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT512DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT512DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT512DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT512DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT512DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT512DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DI64_Node; overload;
    function Search(const Buff: TKDT512DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DI64_Node; overload;
    function Search(const Buff: TKDT512DI64_Vec; var SearchedDistanceMin: Double): PKDT512DI64_Node; overload;
    function Search(const Buff: TKDT512DI64_Vec): PKDT512DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT512DI64_DynamicVecBuffer; var OutBuff: TKDT512DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT512DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT512DI64_Node);
    procedure PrintBuffer;

    class function KDT512DI64Vec(const s: string): TKDT512DI64_Vec; overload;
    class function KDT512DI64Vec(const v: TKDT512DI64_Vec): string; overload;
    class function KDT512DI64Pow(const v: TKDT512DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT512DI64Distance(const v1, v2: TKDT512DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT512DI64_Source);
    class procedure Test;
  end;



  TKDT576DI64_Vec = array [0 .. KDT576DI64_Axis - 1] of TKDT576DI64_VecType;
  PKDT576DI64_Vec = ^TKDT576DI64_Vec;

  TKDT576DI64_DynamicVecBuffer = array of TKDT576DI64_Vec;
  PKDT576DI64_DynamicVecBuffer = ^TKDT576DI64_DynamicVecBuffer;

  TKDT576DI64_Source = packed record
    Buff: TKDT576DI64_Vec;
    index: Int64;
  end;

  PKDT576DI64_Source       = ^TKDT576DI64_Source;
  TKDT576DI64_SourceBuffer = array [0 .. 0] of PKDT576DI64_Source;
  PKDT576DI64_SourceBuffer = ^TKDT576DI64_SourceBuffer;

  TKDT576DI64yanmicSourceBuffer = array of PKDT576DI64_Source;
  PKDT576DI64yanmicSourceBuffer = ^TKDT576DI64yanmicSourceBuffer;

  TKDT576DI64yanmicStoreBuffer = array of TKDT576DI64_Source;
  PKDT576DI64yanmicStoreBuffer = ^TKDT576DI64yanmicStoreBuffer;

  PKDT576DI64_Node = ^TKDT576DI64_Node;

  TKDT576DI64_Node = packed record
    Parent, Right, Left: PKDT576DI64_Node;
    vec: PKDT576DI64_Source;
  end;

  TKDT576DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT576DI64_Source);
  TKDT576DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT576DI64_Source) of object;
  {$IFNDEF FPC} TKDT576DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT576DI64_Source); {$ENDIF}

  TKDT576DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT576DI64yanmicStoreBuffer;
    KDBuff     : TKDT576DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT576DI64_Node;
    TestBuff   : TKDT576DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT576DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT576DI64_Node;
    function GetData(const index: NativeInt): PKDT576DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT576DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT576DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT576DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT576DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT576DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT576DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT576DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT576DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT576DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT576DI64_Node; overload;
    function Search(const Buff: TKDT576DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT576DI64_Node; overload;
    function Search(const Buff: TKDT576DI64_Vec; var SearchedDistanceMin: Double): PKDT576DI64_Node; overload;
    function Search(const Buff: TKDT576DI64_Vec): PKDT576DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT576DI64_DynamicVecBuffer; var OutBuff: TKDT576DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT576DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT576DI64_Node);
    procedure PrintBuffer;

    class function KDT576DI64Vec(const s: string): TKDT576DI64_Vec; overload;
    class function KDT576DI64Vec(const v: TKDT576DI64_Vec): string; overload;
    class function KDT576DI64Pow(const v: TKDT576DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT576DI64Distance(const v1, v2: TKDT576DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT576DI64_Source);
    class procedure Test;
  end;



  TKDT768DI64_Vec = array [0 .. KDT768DI64_Axis - 1] of TKDT768DI64_VecType;
  PKDT768DI64_Vec = ^TKDT768DI64_Vec;

  TKDT768DI64_DynamicVecBuffer = array of TKDT768DI64_Vec;
  PKDT768DI64_DynamicVecBuffer = ^TKDT768DI64_DynamicVecBuffer;

  TKDT768DI64_Source = packed record
    Buff: TKDT768DI64_Vec;
    index: Int64;
  end;

  PKDT768DI64_Source       = ^TKDT768DI64_Source;
  TKDT768DI64_SourceBuffer = array [0 .. 0] of PKDT768DI64_Source;
  PKDT768DI64_SourceBuffer = ^TKDT768DI64_SourceBuffer;

  TKDT768DI64yanmicSourceBuffer = array of PKDT768DI64_Source;
  PKDT768DI64yanmicSourceBuffer = ^TKDT768DI64yanmicSourceBuffer;

  TKDT768DI64yanmicStoreBuffer = array of TKDT768DI64_Source;
  PKDT768DI64yanmicStoreBuffer = ^TKDT768DI64yanmicStoreBuffer;

  PKDT768DI64_Node = ^TKDT768DI64_Node;

  TKDT768DI64_Node = packed record
    Parent, Right, Left: PKDT768DI64_Node;
    vec: PKDT768DI64_Source;
  end;

  TKDT768DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT768DI64_Source);
  TKDT768DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT768DI64_Source) of object;
  {$IFNDEF FPC} TKDT768DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT768DI64_Source); {$ENDIF}

  TKDT768DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT768DI64yanmicStoreBuffer;
    KDBuff     : TKDT768DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT768DI64_Node;
    TestBuff   : TKDT768DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DI64_Node;
    function GetData(const index: NativeInt): PKDT768DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT768DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT768DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT768DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT768DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT768DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT768DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT768DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT768DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DI64_Node; overload;
    function Search(const Buff: TKDT768DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DI64_Node; overload;
    function Search(const Buff: TKDT768DI64_Vec; var SearchedDistanceMin: Double): PKDT768DI64_Node; overload;
    function Search(const Buff: TKDT768DI64_Vec): PKDT768DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT768DI64_DynamicVecBuffer; var OutBuff: TKDT768DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT768DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT768DI64_Node);
    procedure PrintBuffer;

    class function KDT768DI64Vec(const s: string): TKDT768DI64_Vec; overload;
    class function KDT768DI64Vec(const v: TKDT768DI64_Vec): string; overload;
    class function KDT768DI64Pow(const v: TKDT768DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT768DI64Distance(const v1, v2: TKDT768DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT768DI64_Source);
    class procedure Test;
  end;



  TKDT1024DI64_Vec = array [0 .. KDT1024DI64_Axis - 1] of TKDT1024DI64_VecType;
  PKDT1024DI64_Vec = ^TKDT1024DI64_Vec;

  TKDT1024DI64_DynamicVecBuffer = array of TKDT1024DI64_Vec;
  PKDT1024DI64_DynamicVecBuffer = ^TKDT1024DI64_DynamicVecBuffer;

  TKDT1024DI64_Source = packed record
    Buff: TKDT1024DI64_Vec;
    index: Int64;
  end;

  PKDT1024DI64_Source       = ^TKDT1024DI64_Source;
  TKDT1024DI64_SourceBuffer = array [0 .. 0] of PKDT1024DI64_Source;
  PKDT1024DI64_SourceBuffer = ^TKDT1024DI64_SourceBuffer;

  TKDT1024DI64yanmicSourceBuffer = array of PKDT1024DI64_Source;
  PKDT1024DI64yanmicSourceBuffer = ^TKDT1024DI64yanmicSourceBuffer;

  TKDT1024DI64yanmicStoreBuffer = array of TKDT1024DI64_Source;
  PKDT1024DI64yanmicStoreBuffer = ^TKDT1024DI64yanmicStoreBuffer;

  PKDT1024DI64_Node = ^TKDT1024DI64_Node;

  TKDT1024DI64_Node = packed record
    Parent, Right, Left: PKDT1024DI64_Node;
    vec: PKDT1024DI64_Source;
  end;

  TKDT1024DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1024DI64_Source);
  TKDT1024DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1024DI64_Source) of object;
  {$IFNDEF FPC} TKDT1024DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1024DI64_Source); {$ENDIF}

  TKDT1024DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1024DI64yanmicStoreBuffer;
    KDBuff     : TKDT1024DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1024DI64_Node;
    TestBuff   : TKDT1024DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DI64_Node;
    function GetData(const index: NativeInt): PKDT1024DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1024DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1024DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1024DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT1024DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT1024DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT1024DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1024DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1024DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DI64_Node; overload;
    function Search(const Buff: TKDT1024DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DI64_Node; overload;
    function Search(const Buff: TKDT1024DI64_Vec; var SearchedDistanceMin: Double): PKDT1024DI64_Node; overload;
    function Search(const Buff: TKDT1024DI64_Vec): PKDT1024DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1024DI64_DynamicVecBuffer; var OutBuff: TKDT1024DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1024DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1024DI64_Node);
    procedure PrintBuffer;

    class function KDT1024DI64Vec(const s: string): TKDT1024DI64_Vec; overload;
    class function KDT1024DI64Vec(const v: TKDT1024DI64_Vec): string; overload;
    class function KDT1024DI64Pow(const v: TKDT1024DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1024DI64Distance(const v1, v2: TKDT1024DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1024DI64_Source);
    class procedure Test;
  end;



  TKDT1040DI64_Vec = array [0 .. KDT1040DI64_Axis - 1] of TKDT1040DI64_VecType;
  PKDT1040DI64_Vec = ^TKDT1040DI64_Vec;

  TKDT1040DI64_DynamicVecBuffer = array of TKDT1040DI64_Vec;
  PKDT1040DI64_DynamicVecBuffer = ^TKDT1040DI64_DynamicVecBuffer;

  TKDT1040DI64_Source = packed record
    Buff: TKDT1040DI64_Vec;
    index: Int64;
  end;

  PKDT1040DI64_Source       = ^TKDT1040DI64_Source;
  TKDT1040DI64_SourceBuffer = array [0 .. 0] of PKDT1040DI64_Source;
  PKDT1040DI64_SourceBuffer = ^TKDT1040DI64_SourceBuffer;

  TKDT1040DI64yanmicSourceBuffer = array of PKDT1040DI64_Source;
  PKDT1040DI64yanmicSourceBuffer = ^TKDT1040DI64yanmicSourceBuffer;

  TKDT1040DI64yanmicStoreBuffer = array of TKDT1040DI64_Source;
  PKDT1040DI64yanmicStoreBuffer = ^TKDT1040DI64yanmicStoreBuffer;

  PKDT1040DI64_Node = ^TKDT1040DI64_Node;

  TKDT1040DI64_Node = packed record
    Parent, Right, Left: PKDT1040DI64_Node;
    vec: PKDT1040DI64_Source;
  end;

  TKDT1040DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1040DI64_Source);
  TKDT1040DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1040DI64_Source) of object;
  {$IFNDEF FPC} TKDT1040DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1040DI64_Source); {$ENDIF}

  TKDT1040DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1040DI64yanmicStoreBuffer;
    KDBuff     : TKDT1040DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1040DI64_Node;
    TestBuff   : TKDT1040DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1040DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1040DI64_Node;
    function GetData(const index: NativeInt): PKDT1040DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1040DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1040DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1040DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT1040DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT1040DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT1040DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1040DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1040DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1040DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1040DI64_Node; overload;
    function Search(const Buff: TKDT1040DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1040DI64_Node; overload;
    function Search(const Buff: TKDT1040DI64_Vec; var SearchedDistanceMin: Double): PKDT1040DI64_Node; overload;
    function Search(const Buff: TKDT1040DI64_Vec): PKDT1040DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1040DI64_DynamicVecBuffer; var OutBuff: TKDT1040DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1040DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1040DI64_Node);
    procedure PrintBuffer;

    class function KDT1040DI64Vec(const s: string): TKDT1040DI64_Vec; overload;
    class function KDT1040DI64Vec(const v: TKDT1040DI64_Vec): string; overload;
    class function KDT1040DI64Pow(const v: TKDT1040DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1040DI64Distance(const v1, v2: TKDT1040DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1040DI64_Source);
    class procedure Test;
  end;



  TKDT1056DI64_Vec = array [0 .. KDT1056DI64_Axis - 1] of TKDT1056DI64_VecType;
  PKDT1056DI64_Vec = ^TKDT1056DI64_Vec;

  TKDT1056DI64_DynamicVecBuffer = array of TKDT1056DI64_Vec;
  PKDT1056DI64_DynamicVecBuffer = ^TKDT1056DI64_DynamicVecBuffer;

  TKDT1056DI64_Source = packed record
    Buff: TKDT1056DI64_Vec;
    index: Int64;
  end;

  PKDT1056DI64_Source       = ^TKDT1056DI64_Source;
  TKDT1056DI64_SourceBuffer = array [0 .. 0] of PKDT1056DI64_Source;
  PKDT1056DI64_SourceBuffer = ^TKDT1056DI64_SourceBuffer;

  TKDT1056DI64yanmicSourceBuffer = array of PKDT1056DI64_Source;
  PKDT1056DI64yanmicSourceBuffer = ^TKDT1056DI64yanmicSourceBuffer;

  TKDT1056DI64yanmicStoreBuffer = array of TKDT1056DI64_Source;
  PKDT1056DI64yanmicStoreBuffer = ^TKDT1056DI64yanmicStoreBuffer;

  PKDT1056DI64_Node = ^TKDT1056DI64_Node;

  TKDT1056DI64_Node = packed record
    Parent, Right, Left: PKDT1056DI64_Node;
    vec: PKDT1056DI64_Source;
  end;

  TKDT1056DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1056DI64_Source);
  TKDT1056DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1056DI64_Source) of object;
  {$IFNDEF FPC} TKDT1056DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1056DI64_Source); {$ENDIF}

  TKDT1056DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1056DI64yanmicStoreBuffer;
    KDBuff     : TKDT1056DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1056DI64_Node;
    TestBuff   : TKDT1056DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1056DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1056DI64_Node;
    function GetData(const index: NativeInt): PKDT1056DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1056DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1056DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1056DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT1056DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT1056DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT1056DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1056DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1056DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1056DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1056DI64_Node; overload;
    function Search(const Buff: TKDT1056DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1056DI64_Node; overload;
    function Search(const Buff: TKDT1056DI64_Vec; var SearchedDistanceMin: Double): PKDT1056DI64_Node; overload;
    function Search(const Buff: TKDT1056DI64_Vec): PKDT1056DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1056DI64_DynamicVecBuffer; var OutBuff: TKDT1056DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1056DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1056DI64_Node);
    procedure PrintBuffer;

    class function KDT1056DI64Vec(const s: string): TKDT1056DI64_Vec; overload;
    class function KDT1056DI64Vec(const v: TKDT1056DI64_Vec): string; overload;
    class function KDT1056DI64Pow(const v: TKDT1056DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1056DI64Distance(const v1, v2: TKDT1056DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1056DI64_Source);
    class procedure Test;
  end;



  TKDT1536DI64_Vec = array [0 .. KDT1536DI64_Axis - 1] of TKDT1536DI64_VecType;
  PKDT1536DI64_Vec = ^TKDT1536DI64_Vec;

  TKDT1536DI64_DynamicVecBuffer = array of TKDT1536DI64_Vec;
  PKDT1536DI64_DynamicVecBuffer = ^TKDT1536DI64_DynamicVecBuffer;

  TKDT1536DI64_Source = packed record
    Buff: TKDT1536DI64_Vec;
    index: Int64;
  end;

  PKDT1536DI64_Source       = ^TKDT1536DI64_Source;
  TKDT1536DI64_SourceBuffer = array [0 .. 0] of PKDT1536DI64_Source;
  PKDT1536DI64_SourceBuffer = ^TKDT1536DI64_SourceBuffer;

  TKDT1536DI64yanmicSourceBuffer = array of PKDT1536DI64_Source;
  PKDT1536DI64yanmicSourceBuffer = ^TKDT1536DI64yanmicSourceBuffer;

  TKDT1536DI64yanmicStoreBuffer = array of TKDT1536DI64_Source;
  PKDT1536DI64yanmicStoreBuffer = ^TKDT1536DI64yanmicStoreBuffer;

  PKDT1536DI64_Node = ^TKDT1536DI64_Node;

  TKDT1536DI64_Node = packed record
    Parent, Right, Left: PKDT1536DI64_Node;
    vec: PKDT1536DI64_Source;
  end;

  TKDT1536DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1536DI64_Source);
  TKDT1536DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1536DI64_Source) of object;
  {$IFNDEF FPC} TKDT1536DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1536DI64_Source); {$ENDIF}

  TKDT1536DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1536DI64yanmicStoreBuffer;
    KDBuff     : TKDT1536DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1536DI64_Node;
    TestBuff   : TKDT1536DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DI64_Node;
    function GetData(const index: NativeInt): PKDT1536DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1536DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1536DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1536DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT1536DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT1536DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT1536DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1536DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1536DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DI64_Node; overload;
    function Search(const Buff: TKDT1536DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DI64_Node; overload;
    function Search(const Buff: TKDT1536DI64_Vec; var SearchedDistanceMin: Double): PKDT1536DI64_Node; overload;
    function Search(const Buff: TKDT1536DI64_Vec): PKDT1536DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1536DI64_DynamicVecBuffer; var OutBuff: TKDT1536DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1536DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1536DI64_Node);
    procedure PrintBuffer;

    class function KDT1536DI64Vec(const s: string): TKDT1536DI64_Vec; overload;
    class function KDT1536DI64Vec(const v: TKDT1536DI64_Vec): string; overload;
    class function KDT1536DI64Pow(const v: TKDT1536DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1536DI64Distance(const v1, v2: TKDT1536DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1536DI64_Source);
    class procedure Test;
  end;



  TKDT1920DI64_Vec = array [0 .. KDT1920DI64_Axis - 1] of TKDT1920DI64_VecType;
  PKDT1920DI64_Vec = ^TKDT1920DI64_Vec;

  TKDT1920DI64_DynamicVecBuffer = array of TKDT1920DI64_Vec;
  PKDT1920DI64_DynamicVecBuffer = ^TKDT1920DI64_DynamicVecBuffer;

  TKDT1920DI64_Source = packed record
    Buff: TKDT1920DI64_Vec;
    index: Int64;
  end;

  PKDT1920DI64_Source       = ^TKDT1920DI64_Source;
  TKDT1920DI64_SourceBuffer = array [0 .. 0] of PKDT1920DI64_Source;
  PKDT1920DI64_SourceBuffer = ^TKDT1920DI64_SourceBuffer;

  TKDT1920DI64yanmicSourceBuffer = array of PKDT1920DI64_Source;
  PKDT1920DI64yanmicSourceBuffer = ^TKDT1920DI64yanmicSourceBuffer;

  TKDT1920DI64yanmicStoreBuffer = array of TKDT1920DI64_Source;
  PKDT1920DI64yanmicStoreBuffer = ^TKDT1920DI64yanmicStoreBuffer;

  PKDT1920DI64_Node = ^TKDT1920DI64_Node;

  TKDT1920DI64_Node = packed record
    Parent, Right, Left: PKDT1920DI64_Node;
    vec: PKDT1920DI64_Source;
  end;

  TKDT1920DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1920DI64_Source);
  TKDT1920DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1920DI64_Source) of object;
  {$IFNDEF FPC} TKDT1920DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1920DI64_Source); {$ENDIF}

  TKDT1920DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1920DI64yanmicStoreBuffer;
    KDBuff     : TKDT1920DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1920DI64_Node;
    TestBuff   : TKDT1920DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DI64_Node;
    function GetData(const index: NativeInt): PKDT1920DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1920DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1920DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1920DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT1920DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT1920DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT1920DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1920DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1920DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DI64_Node; overload;
    function Search(const Buff: TKDT1920DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DI64_Node; overload;
    function Search(const Buff: TKDT1920DI64_Vec; var SearchedDistanceMin: Double): PKDT1920DI64_Node; overload;
    function Search(const Buff: TKDT1920DI64_Vec): PKDT1920DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1920DI64_DynamicVecBuffer; var OutBuff: TKDT1920DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1920DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1920DI64_Node);
    procedure PrintBuffer;

    class function KDT1920DI64Vec(const s: string): TKDT1920DI64_Vec; overload;
    class function KDT1920DI64Vec(const v: TKDT1920DI64_Vec): string; overload;
    class function KDT1920DI64Pow(const v: TKDT1920DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1920DI64Distance(const v1, v2: TKDT1920DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1920DI64_Source);
    class procedure Test;
  end;



  TKDT1980DI64_Vec = array [0 .. KDT1980DI64_Axis - 1] of TKDT1980DI64_VecType;
  PKDT1980DI64_Vec = ^TKDT1980DI64_Vec;

  TKDT1980DI64_DynamicVecBuffer = array of TKDT1980DI64_Vec;
  PKDT1980DI64_DynamicVecBuffer = ^TKDT1980DI64_DynamicVecBuffer;

  TKDT1980DI64_Source = packed record
    Buff: TKDT1980DI64_Vec;
    index: Int64;
  end;

  PKDT1980DI64_Source       = ^TKDT1980DI64_Source;
  TKDT1980DI64_SourceBuffer = array [0 .. 0] of PKDT1980DI64_Source;
  PKDT1980DI64_SourceBuffer = ^TKDT1980DI64_SourceBuffer;

  TKDT1980DI64yanmicSourceBuffer = array of PKDT1980DI64_Source;
  PKDT1980DI64yanmicSourceBuffer = ^TKDT1980DI64yanmicSourceBuffer;

  TKDT1980DI64yanmicStoreBuffer = array of TKDT1980DI64_Source;
  PKDT1980DI64yanmicStoreBuffer = ^TKDT1980DI64yanmicStoreBuffer;

  PKDT1980DI64_Node = ^TKDT1980DI64_Node;

  TKDT1980DI64_Node = packed record
    Parent, Right, Left: PKDT1980DI64_Node;
    vec: PKDT1980DI64_Source;
  end;

  TKDT1980DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT1980DI64_Source);
  TKDT1980DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT1980DI64_Source) of object;
  {$IFNDEF FPC} TKDT1980DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT1980DI64_Source); {$ENDIF}

  TKDT1980DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT1980DI64yanmicStoreBuffer;
    KDBuff     : TKDT1980DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT1980DI64_Node;
    TestBuff   : TKDT1980DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT1980DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1980DI64_Node;
    function GetData(const index: NativeInt): PKDT1980DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT1980DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT1980DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT1980DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT1980DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT1980DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT1980DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1980DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT1980DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT1980DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1980DI64_Node; overload;
    function Search(const Buff: TKDT1980DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1980DI64_Node; overload;
    function Search(const Buff: TKDT1980DI64_Vec; var SearchedDistanceMin: Double): PKDT1980DI64_Node; overload;
    function Search(const Buff: TKDT1980DI64_Vec): PKDT1980DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT1980DI64_DynamicVecBuffer; var OutBuff: TKDT1980DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT1980DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT1980DI64_Node);
    procedure PrintBuffer;

    class function KDT1980DI64Vec(const s: string): TKDT1980DI64_Vec; overload;
    class function KDT1980DI64Vec(const v: TKDT1980DI64_Vec): string; overload;
    class function KDT1980DI64Pow(const v: TKDT1980DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT1980DI64Distance(const v1, v2: TKDT1980DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1980DI64_Source);
    class procedure Test;
  end;



  TKDT2048DI64_Vec = array [0 .. KDT2048DI64_Axis - 1] of TKDT2048DI64_VecType;
  PKDT2048DI64_Vec = ^TKDT2048DI64_Vec;

  TKDT2048DI64_DynamicVecBuffer = array of TKDT2048DI64_Vec;
  PKDT2048DI64_DynamicVecBuffer = ^TKDT2048DI64_DynamicVecBuffer;

  TKDT2048DI64_Source = packed record
    Buff: TKDT2048DI64_Vec;
    index: Int64;
  end;

  PKDT2048DI64_Source       = ^TKDT2048DI64_Source;
  TKDT2048DI64_SourceBuffer = array [0 .. 0] of PKDT2048DI64_Source;
  PKDT2048DI64_SourceBuffer = ^TKDT2048DI64_SourceBuffer;

  TKDT2048DI64yanmicSourceBuffer = array of PKDT2048DI64_Source;
  PKDT2048DI64yanmicSourceBuffer = ^TKDT2048DI64yanmicSourceBuffer;

  TKDT2048DI64yanmicStoreBuffer = array of TKDT2048DI64_Source;
  PKDT2048DI64yanmicStoreBuffer = ^TKDT2048DI64yanmicStoreBuffer;

  PKDT2048DI64_Node = ^TKDT2048DI64_Node;

  TKDT2048DI64_Node = packed record
    Parent, Right, Left: PKDT2048DI64_Node;
    vec: PKDT2048DI64_Source;
  end;

  TKDT2048DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT2048DI64_Source);
  TKDT2048DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT2048DI64_Source) of object;
  {$IFNDEF FPC} TKDT2048DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT2048DI64_Source); {$ENDIF}

  TKDT2048DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT2048DI64yanmicStoreBuffer;
    KDBuff     : TKDT2048DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT2048DI64_Node;
    TestBuff   : TKDT2048DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DI64_Node;
    function GetData(const index: NativeInt): PKDT2048DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT2048DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT2048DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT2048DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT2048DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT2048DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT2048DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT2048DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT2048DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DI64_Node; overload;
    function Search(const Buff: TKDT2048DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DI64_Node; overload;
    function Search(const Buff: TKDT2048DI64_Vec; var SearchedDistanceMin: Double): PKDT2048DI64_Node; overload;
    function Search(const Buff: TKDT2048DI64_Vec): PKDT2048DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT2048DI64_DynamicVecBuffer; var OutBuff: TKDT2048DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT2048DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT2048DI64_Node);
    procedure PrintBuffer;

    class function KDT2048DI64Vec(const s: string): TKDT2048DI64_Vec; overload;
    class function KDT2048DI64Vec(const v: TKDT2048DI64_Vec): string; overload;
    class function KDT2048DI64Pow(const v: TKDT2048DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT2048DI64Distance(const v1, v2: TKDT2048DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2048DI64_Source);
    class procedure Test;
  end;



  TKDT3072DI64_Vec = array [0 .. KDT3072DI64_Axis - 1] of TKDT3072DI64_VecType;
  PKDT3072DI64_Vec = ^TKDT3072DI64_Vec;

  TKDT3072DI64_DynamicVecBuffer = array of TKDT3072DI64_Vec;
  PKDT3072DI64_DynamicVecBuffer = ^TKDT3072DI64_DynamicVecBuffer;

  TKDT3072DI64_Source = packed record
    Buff: TKDT3072DI64_Vec;
    index: Int64;
  end;

  PKDT3072DI64_Source       = ^TKDT3072DI64_Source;
  TKDT3072DI64_SourceBuffer = array [0 .. 0] of PKDT3072DI64_Source;
  PKDT3072DI64_SourceBuffer = ^TKDT3072DI64_SourceBuffer;

  TKDT3072DI64yanmicSourceBuffer = array of PKDT3072DI64_Source;
  PKDT3072DI64yanmicSourceBuffer = ^TKDT3072DI64yanmicSourceBuffer;

  TKDT3072DI64yanmicStoreBuffer = array of TKDT3072DI64_Source;
  PKDT3072DI64yanmicStoreBuffer = ^TKDT3072DI64yanmicStoreBuffer;

  PKDT3072DI64_Node = ^TKDT3072DI64_Node;

  TKDT3072DI64_Node = packed record
    Parent, Right, Left: PKDT3072DI64_Node;
    vec: PKDT3072DI64_Source;
  end;

  TKDT3072DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3072DI64_Source);
  TKDT3072DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3072DI64_Source) of object;
  {$IFNDEF FPC} TKDT3072DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3072DI64_Source); {$ENDIF}

  TKDT3072DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3072DI64yanmicStoreBuffer;
    KDBuff     : TKDT3072DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3072DI64_Node;
    TestBuff   : TKDT3072DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DI64_Node;
    function GetData(const index: NativeInt): PKDT3072DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3072DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3072DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3072DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT3072DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT3072DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT3072DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3072DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3072DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DI64_Node; overload;
    function Search(const Buff: TKDT3072DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DI64_Node; overload;
    function Search(const Buff: TKDT3072DI64_Vec; var SearchedDistanceMin: Double): PKDT3072DI64_Node; overload;
    function Search(const Buff: TKDT3072DI64_Vec): PKDT3072DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3072DI64_DynamicVecBuffer; var OutBuff: TKDT3072DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3072DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT3072DI64_Node);
    procedure PrintBuffer;

    class function KDT3072DI64Vec(const s: string): TKDT3072DI64_Vec; overload;
    class function KDT3072DI64Vec(const v: TKDT3072DI64_Vec): string; overload;
    class function KDT3072DI64Pow(const v: TKDT3072DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3072DI64Distance(const v1, v2: TKDT3072DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3072DI64_Source);
    class procedure Test;
  end;



  TKDT3088DI64_Vec = array [0 .. KDT3088DI64_Axis - 1] of TKDT3088DI64_VecType;
  PKDT3088DI64_Vec = ^TKDT3088DI64_Vec;

  TKDT3088DI64_DynamicVecBuffer = array of TKDT3088DI64_Vec;
  PKDT3088DI64_DynamicVecBuffer = ^TKDT3088DI64_DynamicVecBuffer;

  TKDT3088DI64_Source = packed record
    Buff: TKDT3088DI64_Vec;
    index: Int64;
  end;

  PKDT3088DI64_Source       = ^TKDT3088DI64_Source;
  TKDT3088DI64_SourceBuffer = array [0 .. 0] of PKDT3088DI64_Source;
  PKDT3088DI64_SourceBuffer = ^TKDT3088DI64_SourceBuffer;

  TKDT3088DI64yanmicSourceBuffer = array of PKDT3088DI64_Source;
  PKDT3088DI64yanmicSourceBuffer = ^TKDT3088DI64yanmicSourceBuffer;

  TKDT3088DI64yanmicStoreBuffer = array of TKDT3088DI64_Source;
  PKDT3088DI64yanmicStoreBuffer = ^TKDT3088DI64yanmicStoreBuffer;

  PKDT3088DI64_Node = ^TKDT3088DI64_Node;

  TKDT3088DI64_Node = packed record
    Parent, Right, Left: PKDT3088DI64_Node;
    vec: PKDT3088DI64_Source;
  end;

  TKDT3088DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3088DI64_Source);
  TKDT3088DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3088DI64_Source) of object;
  {$IFNDEF FPC} TKDT3088DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3088DI64_Source); {$ENDIF}

  TKDT3088DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3088DI64yanmicStoreBuffer;
    KDBuff     : TKDT3088DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3088DI64_Node;
    TestBuff   : TKDT3088DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3088DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3088DI64_Node;
    function GetData(const index: NativeInt): PKDT3088DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3088DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3088DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3088DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT3088DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT3088DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT3088DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3088DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3088DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3088DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3088DI64_Node; overload;
    function Search(const Buff: TKDT3088DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3088DI64_Node; overload;
    function Search(const Buff: TKDT3088DI64_Vec; var SearchedDistanceMin: Double): PKDT3088DI64_Node; overload;
    function Search(const Buff: TKDT3088DI64_Vec): PKDT3088DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3088DI64_DynamicVecBuffer; var OutBuff: TKDT3088DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3088DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT3088DI64_Node);
    procedure PrintBuffer;

    class function KDT3088DI64Vec(const s: string): TKDT3088DI64_Vec; overload;
    class function KDT3088DI64Vec(const v: TKDT3088DI64_Vec): string; overload;
    class function KDT3088DI64Pow(const v: TKDT3088DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3088DI64Distance(const v1, v2: TKDT3088DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3088DI64_Source);
    class procedure Test;
  end;



  TKDT3104DI64_Vec = array [0 .. KDT3104DI64_Axis - 1] of TKDT3104DI64_VecType;
  PKDT3104DI64_Vec = ^TKDT3104DI64_Vec;

  TKDT3104DI64_DynamicVecBuffer = array of TKDT3104DI64_Vec;
  PKDT3104DI64_DynamicVecBuffer = ^TKDT3104DI64_DynamicVecBuffer;

  TKDT3104DI64_Source = packed record
    Buff: TKDT3104DI64_Vec;
    index: Int64;
  end;

  PKDT3104DI64_Source       = ^TKDT3104DI64_Source;
  TKDT3104DI64_SourceBuffer = array [0 .. 0] of PKDT3104DI64_Source;
  PKDT3104DI64_SourceBuffer = ^TKDT3104DI64_SourceBuffer;

  TKDT3104DI64yanmicSourceBuffer = array of PKDT3104DI64_Source;
  PKDT3104DI64yanmicSourceBuffer = ^TKDT3104DI64yanmicSourceBuffer;

  TKDT3104DI64yanmicStoreBuffer = array of TKDT3104DI64_Source;
  PKDT3104DI64yanmicStoreBuffer = ^TKDT3104DI64yanmicStoreBuffer;

  PKDT3104DI64_Node = ^TKDT3104DI64_Node;

  TKDT3104DI64_Node = packed record
    Parent, Right, Left: PKDT3104DI64_Node;
    vec: PKDT3104DI64_Source;
  end;

  TKDT3104DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT3104DI64_Source);
  TKDT3104DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT3104DI64_Source) of object;
  {$IFNDEF FPC} TKDT3104DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT3104DI64_Source); {$ENDIF}

  TKDT3104DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT3104DI64yanmicStoreBuffer;
    KDBuff     : TKDT3104DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT3104DI64_Node;
    TestBuff   : TKDT3104DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT3104DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3104DI64_Node;
    function GetData(const index: NativeInt): PKDT3104DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT3104DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT3104DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT3104DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT3104DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT3104DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT3104DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3104DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT3104DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT3104DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3104DI64_Node; overload;
    function Search(const Buff: TKDT3104DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3104DI64_Node; overload;
    function Search(const Buff: TKDT3104DI64_Vec; var SearchedDistanceMin: Double): PKDT3104DI64_Node; overload;
    function Search(const Buff: TKDT3104DI64_Vec): PKDT3104DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT3104DI64_DynamicVecBuffer; var OutBuff: TKDT3104DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT3104DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT3104DI64_Node);
    procedure PrintBuffer;

    class function KDT3104DI64Vec(const s: string): TKDT3104DI64_Vec; overload;
    class function KDT3104DI64Vec(const v: TKDT3104DI64_Vec): string; overload;
    class function KDT3104DI64Pow(const v: TKDT3104DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT3104DI64Distance(const v1, v2: TKDT3104DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3104DI64_Source);
    class procedure Test;
  end;



  TKDT4096DI64_Vec = array [0 .. KDT4096DI64_Axis - 1] of TKDT4096DI64_VecType;
  PKDT4096DI64_Vec = ^TKDT4096DI64_Vec;

  TKDT4096DI64_DynamicVecBuffer = array of TKDT4096DI64_Vec;
  PKDT4096DI64_DynamicVecBuffer = ^TKDT4096DI64_DynamicVecBuffer;

  TKDT4096DI64_Source = packed record
    Buff: TKDT4096DI64_Vec;
    index: Int64;
  end;

  PKDT4096DI64_Source       = ^TKDT4096DI64_Source;
  TKDT4096DI64_SourceBuffer = array [0 .. 0] of PKDT4096DI64_Source;
  PKDT4096DI64_SourceBuffer = ^TKDT4096DI64_SourceBuffer;

  TKDT4096DI64yanmicSourceBuffer = array of PKDT4096DI64_Source;
  PKDT4096DI64yanmicSourceBuffer = ^TKDT4096DI64yanmicSourceBuffer;

  TKDT4096DI64yanmicStoreBuffer = array of TKDT4096DI64_Source;
  PKDT4096DI64yanmicStoreBuffer = ^TKDT4096DI64yanmicStoreBuffer;

  PKDT4096DI64_Node = ^TKDT4096DI64_Node;

  TKDT4096DI64_Node = packed record
    Parent, Right, Left: PKDT4096DI64_Node;
    vec: PKDT4096DI64_Source;
  end;

  TKDT4096DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT4096DI64_Source);
  TKDT4096DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT4096DI64_Source) of object;
  {$IFNDEF FPC} TKDT4096DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT4096DI64_Source); {$ENDIF}

  TKDT4096DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT4096DI64yanmicStoreBuffer;
    KDBuff     : TKDT4096DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT4096DI64_Node;
    TestBuff   : TKDT4096DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT4096DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4096DI64_Node;
    function GetData(const index: NativeInt): PKDT4096DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT4096DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT4096DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT4096DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT4096DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT4096DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT4096DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4096DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT4096DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT4096DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4096DI64_Node; overload;
    function Search(const Buff: TKDT4096DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4096DI64_Node; overload;
    function Search(const Buff: TKDT4096DI64_Vec; var SearchedDistanceMin: Double): PKDT4096DI64_Node; overload;
    function Search(const Buff: TKDT4096DI64_Vec): PKDT4096DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT4096DI64_DynamicVecBuffer; var OutBuff: TKDT4096DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT4096DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT4096DI64_Node);
    procedure PrintBuffer;

    class function KDT4096DI64Vec(const s: string): TKDT4096DI64_Vec; overload;
    class function KDT4096DI64Vec(const v: TKDT4096DI64_Vec): string; overload;
    class function KDT4096DI64Pow(const v: TKDT4096DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT4096DI64Distance(const v1, v2: TKDT4096DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4096DI64_Source);
    class procedure Test;
  end;



  TKDT8192DI64_Vec = array [0 .. KDT8192DI64_Axis - 1] of TKDT8192DI64_VecType;
  PKDT8192DI64_Vec = ^TKDT8192DI64_Vec;

  TKDT8192DI64_DynamicVecBuffer = array of TKDT8192DI64_Vec;
  PKDT8192DI64_DynamicVecBuffer = ^TKDT8192DI64_DynamicVecBuffer;

  TKDT8192DI64_Source = packed record
    Buff: TKDT8192DI64_Vec;
    index: Int64;
  end;

  PKDT8192DI64_Source       = ^TKDT8192DI64_Source;
  TKDT8192DI64_SourceBuffer = array [0 .. 0] of PKDT8192DI64_Source;
  PKDT8192DI64_SourceBuffer = ^TKDT8192DI64_SourceBuffer;

  TKDT8192DI64yanmicSourceBuffer = array of PKDT8192DI64_Source;
  PKDT8192DI64yanmicSourceBuffer = ^TKDT8192DI64yanmicSourceBuffer;

  TKDT8192DI64yanmicStoreBuffer = array of TKDT8192DI64_Source;
  PKDT8192DI64yanmicStoreBuffer = ^TKDT8192DI64yanmicStoreBuffer;

  PKDT8192DI64_Node = ^TKDT8192DI64_Node;

  TKDT8192DI64_Node = packed record
    Parent, Right, Left: PKDT8192DI64_Node;
    vec: PKDT8192DI64_Source;
  end;

  TKDT8192DI64_BuildCall               = procedure(const IndexFor: NativeInt; var Source: TKDT8192DI64_Source);
  TKDT8192DI64_BuildMethod             = procedure(const IndexFor: NativeInt; var Source: TKDT8192DI64_Source) of object;
  {$IFNDEF FPC} TKDT8192DI64_BuildProc = reference to procedure(const IndexFor: NativeInt; var Source: TKDT8192DI64_Source); {$ENDIF}

  TKDT8192DI64 = class(TCoreClassObject)
  private
    KDStoreBuff: TKDT8192DI64yanmicStoreBuffer;
    KDBuff     : TKDT8192DI64yanmicSourceBuffer;
    NodeCounter: NativeInt;
    KDNodes    : array of PKDT8192DI64_Node;
    TestBuff   : TKDT8192DI64_DynamicVecBuffer;
    function InternalBuildKdTree(const KDSourceBufferPtr: PKDT8192DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8192DI64_Node;
    function GetData(const index: NativeInt): PKDT8192DI64_Source; {$IFDEF INLINE_ASM} inline; {$ENDIF}
  public
    RootNode: PKDT8192DI64_Node;

    constructor Create;
    destructor Destroy; override;

    procedure Clear;

    property Count: NativeInt read NodeCounter;
    function StoreBuffPtr: PKDT8192DI64yanmicStoreBuffer;
    property Data[const index: NativeInt]: PKDT8192DI64_Source read GetData; default;

    procedure BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT8192DI64_BuildCall);
    procedure BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT8192DI64_BuildMethod);
    {$IFNDEF FPC} procedure BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT8192DI64_BuildProc); {$ENDIF}
    { direct k-means++ clusterization }
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8192DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray); overload;
    procedure BuildKDTreeWithCluster(const inBuff: TKDT8192DI64_DynamicVecBuffer; const k, Restarts: NativeInt); overload;
    { backcall k-means++ clusterization }
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DI64_BuildCall); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DI64_BuildMethod); overload;
    procedure BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DI64_BuildMethod); overload;
    {$IFNDEF FPC}
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DI64_BuildProc); overload;
    procedure BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DI64_BuildProc); overload;
    {$ENDIF FPC}
    { search }
    function Search(const Buff: TKDT8192DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8192DI64_Node; overload;
    function Search(const Buff: TKDT8192DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8192DI64_Node; overload;
    function Search(const Buff: TKDT8192DI64_Vec; var SearchedDistanceMin: Double): PKDT8192DI64_Node; overload;
    function Search(const Buff: TKDT8192DI64_Vec): PKDT8192DI64_Node; overload;
    { parallel support }
    procedure Search(const inBuff: TKDT8192DI64_DynamicVecBuffer; var OutBuff: TKDT8192DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;
    procedure Search(const inBuff: TKDT8192DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray); overload;

    procedure SaveToStream(stream: TCoreClassStream);
    procedure LoadFromStream(stream: TCoreClassStream);

    procedure SaveToFile(fileName: string);
    procedure LoadFromFile(fileName: string);

    procedure PrintNodeTree(const NodePtr: PKDT8192DI64_Node);
    procedure PrintBuffer;

    class function KDT8192DI64Vec(const s: string): TKDT8192DI64_Vec; overload;
    class function KDT8192DI64Vec(const v: TKDT8192DI64_Vec): string; overload;
    class function KDT8192DI64Pow(const v: TKDT8192DI64_VecType): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    class function KDT8192DI64Distance(const v1, v2: TKDT8192DI64_Vec): Double; {$IFDEF INLINE_ASM} inline; {$ENDIF}
    // debug time
    procedure Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8192DI64_Source);
    class procedure Test;
  end;






procedure Test_All;



implementation

uses
  {$IFDEF FPC}
  mtprocs,
  {$ELSE FPC}
  Threading,
  {$ENDIF FPC}
  PascalStrings, TextParsing, UnicodeMixedLib, DoStatusIO;





const
  SaveToken = $66;



function TKDT1DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1DI64_Node;
  function SortCompare(const p1, p2: PKDT1DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1DI64_SourceBuffer;
  dynBuff  : PKDT1DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1DI64.GetData(const index: NativeInt): PKDT1DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1DI64.StoreBuffPtr: PKDT1DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT1DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT1DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT1DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1DI64.BuildKDTreeWithCluster(const inBuff: TKDT1DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1DI64.BuildKDTreeWithCluster(const inBuff: TKDT1DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI64_BuildCall);
var
  TempStoreBuff: TKDT1DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI64_BuildMethod);
var
  TempStoreBuff: TKDT1DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1DI64_BuildProc);
var
  TempStoreBuff: TKDT1DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1DI64.Search(const Buff: TKDT1DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1DI64_Node;

var
  NearestNeighbour: PKDT1DI64_Node;

  function FindParentNode(const BuffPtr: PKDT1DI64_Vec; NodePtr: PKDT1DI64_Node): PKDT1DI64_Node;
  var
    Next       : PKDT1DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1DI64_Node; const BuffPtr: PKDT1DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1DI64_Vec; const p1, p2: PKDT1DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT1DI64.Search(const Buff: TKDT1DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1DI64.Search(const Buff: TKDT1DI64_Vec; var SearchedDistanceMin: Double): PKDT1DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1DI64.Search(const Buff: TKDT1DI64_Vec): PKDT1DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1DI64.Search(const inBuff: TKDT1DI64_DynamicVecBuffer; var OutBuff: TKDT1DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1DI64_DynamicVecBuffer;
  outBuffPtr : PKDT1DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DI64.Search(const inBuff: TKDT1DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1DI64_Source));
end;

procedure TKDT1DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1DI64.PrintNodeTree(const NodePtr: PKDT1DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1DI64.KDT1DI64Vec(const s: string): TKDT1DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1DI64.KDT1DI64Vec(const v: TKDT1DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT1DI64.KDT1DI64Pow(const v: TKDT1DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1DI64.KDT1DI64Distance(const v1, v2: TKDT1DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1DI64_Axis - 1 do
      Result := Result + KDT1DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT1DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1DI64.Test;
var
  TKDT1DI64_Test    : TKDT1DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1DI64_Test := TKDT1DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT1DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT1DI64_Axis - 1 do
        TKDT1DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1DI64_Test.TestBuff), length(TKDT1DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1DI64_Test.BuildKDTreeM(length(TKDT1DI64_Test.TestBuff), @TKDT1DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1DI64_Test.BuildKDTreeM(length(TKDT1DI64_Test.TestBuff), TKDT1DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1DI64_Test.TestBuff));
  TKDT1DI64_Test.Search(TKDT1DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1DI64Distance(TKDT1DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1DI64_Test.Clear;
  { kMean test }
  TKDT1DI64_Test.BuildKDTreeWithCluster(TKDT1DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1DI64_Test.Search(TKDT1DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1DI64_Test);
end;


function TKDT2DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2DI64_Node;
  function SortCompare(const p1, p2: PKDT2DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2DI64_SourceBuffer;
  dynBuff  : PKDT2DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT2DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2DI64.GetData(const index: NativeInt): PKDT2DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2DI64.StoreBuffPtr: PKDT2DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT2DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT2DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT2DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2DI64.BuildKDTreeWithCluster(const inBuff: TKDT2DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT2DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT2DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT2DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2DI64.BuildKDTreeWithCluster(const inBuff: TKDT2DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI64_BuildCall);
var
  TempStoreBuff: TKDT2DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT2DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI64_BuildMethod);
var
  TempStoreBuff: TKDT2DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT2DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2DI64_BuildProc);
var
  TempStoreBuff: TKDT2DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT2DI64.Search(const Buff: TKDT2DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2DI64_Node;

var
  NearestNeighbour: PKDT2DI64_Node;

  function FindParentNode(const BuffPtr: PKDT2DI64_Vec; NodePtr: PKDT2DI64_Node): PKDT2DI64_Node;
  var
    Next       : PKDT2DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT2DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2DI64_Node; const BuffPtr: PKDT2DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT2DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2DI64_Vec; const p1, p2: PKDT2DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT2DI64.Search(const Buff: TKDT2DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2DI64.Search(const Buff: TKDT2DI64_Vec; var SearchedDistanceMin: Double): PKDT2DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2DI64.Search(const Buff: TKDT2DI64_Vec): PKDT2DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2DI64.Search(const inBuff: TKDT2DI64_DynamicVecBuffer; var OutBuff: TKDT2DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2DI64_DynamicVecBuffer;
  outBuffPtr : PKDT2DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DI64.Search(const inBuff: TKDT2DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT2DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2DI64_Source));
end;

procedure TKDT2DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT2DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2DI64.PrintNodeTree(const NodePtr: PKDT2DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT2DI64.KDT2DI64Vec(const s: string): TKDT2DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT2DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT2DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT2DI64.KDT2DI64Vec(const v: TKDT2DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT2DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT2DI64.KDT2DI64Pow(const v: TKDT2DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT2DI64.KDT2DI64Distance(const v1, v2: TKDT2DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT2DI64_Axis - 1 do
      Result := Result + KDT2DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT2DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2DI64.Test;
var
  TKDT2DI64_Test    : TKDT2DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2DI64_Test := TKDT2DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT2DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT2DI64_Axis - 1 do
        TKDT2DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT2DI64_Test.TestBuff), length(TKDT2DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2DI64_Test.BuildKDTreeM(length(TKDT2DI64_Test.TestBuff), @TKDT2DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2DI64_Test.BuildKDTreeM(length(TKDT2DI64_Test.TestBuff), TKDT2DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2DI64_Test.TestBuff));
  TKDT2DI64_Test.Search(TKDT2DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2DI64Distance(TKDT2DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2DI64_Test.Clear;
  { kMean test }
  TKDT2DI64_Test.BuildKDTreeWithCluster(TKDT2DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2DI64_Test.Search(TKDT2DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2DI64_Test);
end;


function TKDT3DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3DI64_Node;
  function SortCompare(const p1, p2: PKDT3DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3DI64_SourceBuffer;
  dynBuff  : PKDT3DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3DI64.GetData(const index: NativeInt): PKDT3DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3DI64.StoreBuffPtr: PKDT3DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT3DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT3DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT3DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3DI64.BuildKDTreeWithCluster(const inBuff: TKDT3DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3DI64.BuildKDTreeWithCluster(const inBuff: TKDT3DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI64_BuildCall);
var
  TempStoreBuff: TKDT3DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI64_BuildMethod);
var
  TempStoreBuff: TKDT3DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3DI64_BuildProc);
var
  TempStoreBuff: TKDT3DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3DI64.Search(const Buff: TKDT3DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3DI64_Node;

var
  NearestNeighbour: PKDT3DI64_Node;

  function FindParentNode(const BuffPtr: PKDT3DI64_Vec; NodePtr: PKDT3DI64_Node): PKDT3DI64_Node;
  var
    Next       : PKDT3DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3DI64_Node; const BuffPtr: PKDT3DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3DI64_Vec; const p1, p2: PKDT3DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT3DI64.Search(const Buff: TKDT3DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3DI64.Search(const Buff: TKDT3DI64_Vec; var SearchedDistanceMin: Double): PKDT3DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3DI64.Search(const Buff: TKDT3DI64_Vec): PKDT3DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3DI64.Search(const inBuff: TKDT3DI64_DynamicVecBuffer; var OutBuff: TKDT3DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3DI64_DynamicVecBuffer;
  outBuffPtr : PKDT3DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DI64.Search(const inBuff: TKDT3DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3DI64_Source));
end;

procedure TKDT3DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3DI64.PrintNodeTree(const NodePtr: PKDT3DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3DI64.KDT3DI64Vec(const s: string): TKDT3DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3DI64.KDT3DI64Vec(const v: TKDT3DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT3DI64.KDT3DI64Pow(const v: TKDT3DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3DI64.KDT3DI64Distance(const v1, v2: TKDT3DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3DI64_Axis - 1 do
      Result := Result + KDT3DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT3DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3DI64.Test;
var
  TKDT3DI64_Test    : TKDT3DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3DI64_Test := TKDT3DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT3DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT3DI64_Axis - 1 do
        TKDT3DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT3DI64_Test.TestBuff), length(TKDT3DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3DI64_Test.BuildKDTreeM(length(TKDT3DI64_Test.TestBuff), @TKDT3DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3DI64_Test.BuildKDTreeM(length(TKDT3DI64_Test.TestBuff), TKDT3DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3DI64_Test.TestBuff));
  TKDT3DI64_Test.Search(TKDT3DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3DI64Distance(TKDT3DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3DI64_Test.Clear;
  { kMean test }
  TKDT3DI64_Test.BuildKDTreeWithCluster(TKDT3DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3DI64_Test.Search(TKDT3DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3DI64_Test);
end;


function TKDT4DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4DI64_Node;
  function SortCompare(const p1, p2: PKDT4DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4DI64_SourceBuffer;
  dynBuff  : PKDT4DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT4DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4DI64.GetData(const index: NativeInt): PKDT4DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4DI64.StoreBuffPtr: PKDT4DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT4DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT4DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT4DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4DI64.BuildKDTreeWithCluster(const inBuff: TKDT4DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT4DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT4DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT4DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4DI64.BuildKDTreeWithCluster(const inBuff: TKDT4DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI64_BuildCall);
var
  TempStoreBuff: TKDT4DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT4DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI64_BuildMethod);
var
  TempStoreBuff: TKDT4DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT4DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4DI64_BuildProc);
var
  TempStoreBuff: TKDT4DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT4DI64.Search(const Buff: TKDT4DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4DI64_Node;

var
  NearestNeighbour: PKDT4DI64_Node;

  function FindParentNode(const BuffPtr: PKDT4DI64_Vec; NodePtr: PKDT4DI64_Node): PKDT4DI64_Node;
  var
    Next       : PKDT4DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT4DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4DI64_Node; const BuffPtr: PKDT4DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT4DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4DI64_Vec; const p1, p2: PKDT4DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT4DI64.Search(const Buff: TKDT4DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4DI64.Search(const Buff: TKDT4DI64_Vec; var SearchedDistanceMin: Double): PKDT4DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4DI64.Search(const Buff: TKDT4DI64_Vec): PKDT4DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4DI64.Search(const inBuff: TKDT4DI64_DynamicVecBuffer; var OutBuff: TKDT4DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4DI64_DynamicVecBuffer;
  outBuffPtr : PKDT4DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DI64.Search(const inBuff: TKDT4DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT4DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4DI64_Source));
end;

procedure TKDT4DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT4DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4DI64.PrintNodeTree(const NodePtr: PKDT4DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT4DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT4DI64.KDT4DI64Vec(const s: string): TKDT4DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT4DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT4DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT4DI64.KDT4DI64Vec(const v: TKDT4DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT4DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT4DI64.KDT4DI64Pow(const v: TKDT4DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT4DI64.KDT4DI64Distance(const v1, v2: TKDT4DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT4DI64_Axis - 1 do
      Result := Result + KDT4DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT4DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4DI64.Test;
var
  TKDT4DI64_Test    : TKDT4DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4DI64_Test := TKDT4DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT4DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT4DI64_Axis - 1 do
        TKDT4DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT4DI64_Test.TestBuff), length(TKDT4DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4DI64_Test.BuildKDTreeM(length(TKDT4DI64_Test.TestBuff), @TKDT4DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4DI64_Test.BuildKDTreeM(length(TKDT4DI64_Test.TestBuff), TKDT4DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4DI64_Test.TestBuff));
  TKDT4DI64_Test.Search(TKDT4DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4DI64Distance(TKDT4DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4DI64_Test.Clear;
  { kMean test }
  TKDT4DI64_Test.BuildKDTreeWithCluster(TKDT4DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4DI64_Test.Search(TKDT4DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4DI64_Test);
end;


function TKDT5DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT5DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT5DI64_Node;
  function SortCompare(const p1, p2: PKDT5DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT5DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT5DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT5DI64_SourceBuffer;
  dynBuff  : PKDT5DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT5DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT5DI64.GetData(const index: NativeInt): PKDT5DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT5DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT5DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT5DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT5DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT5DI64.StoreBuffPtr: PKDT5DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT5DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT5DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT5DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT5DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT5DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT5DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT5DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT5DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT5DI64.BuildKDTreeWithCluster(const inBuff: TKDT5DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT5DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT5DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT5DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT5DI64.BuildKDTreeWithCluster(const inBuff: TKDT5DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT5DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DI64_BuildCall);
var
  TempStoreBuff: TKDT5DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT5DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT5DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DI64_BuildMethod);
var
  TempStoreBuff: TKDT5DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT5DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT5DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT5DI64_BuildProc);
var
  TempStoreBuff: TKDT5DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT5DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT5DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT5DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT5DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT5DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT5DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT5DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT5DI64.Search(const Buff: TKDT5DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT5DI64_Node;

var
  NearestNeighbour: PKDT5DI64_Node;

  function FindParentNode(const BuffPtr: PKDT5DI64_Vec; NodePtr: PKDT5DI64_Node): PKDT5DI64_Node;
  var
    Next       : PKDT5DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT5DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT5DI64_Node; const BuffPtr: PKDT5DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT5DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT5DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT5DI64_Vec; const p1, p2: PKDT5DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT5DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT5DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT5DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT5DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT5DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT5DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT5DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT5DI64.Search(const Buff: TKDT5DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT5DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT5DI64.Search(const Buff: TKDT5DI64_Vec; var SearchedDistanceMin: Double): PKDT5DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT5DI64.Search(const Buff: TKDT5DI64_Vec): PKDT5DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT5DI64.Search(const inBuff: TKDT5DI64_DynamicVecBuffer; var OutBuff: TKDT5DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT5DI64_DynamicVecBuffer;
  outBuffPtr : PKDT5DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT5DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT5DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT5DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT5DI64.Search(const inBuff: TKDT5DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT5DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT5DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT5DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT5DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT5DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT5DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT5DI64_Source));
end;

procedure TKDT5DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT5DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT5DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT5DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT5DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT5DI64.PrintNodeTree(const NodePtr: PKDT5DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT5DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT5DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT5DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT5DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT5DI64.KDT5DI64Vec(const s: string): TKDT5DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT5DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT5DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT5DI64.KDT5DI64Vec(const v: TKDT5DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT5DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT5DI64.KDT5DI64Pow(const v: TKDT5DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT5DI64.KDT5DI64Distance(const v1, v2: TKDT5DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT5DI64_Axis - 1 do
      Result := Result + KDT5DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT5DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT5DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT5DI64.Test;
var
  TKDT5DI64_Test    : TKDT5DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT5DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT5DI64_Test := TKDT5DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT5DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT5DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT5DI64_Axis - 1 do
        TKDT5DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT5DI64_Test.TestBuff), length(TKDT5DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT5DI64_Test.BuildKDTreeM(length(TKDT5DI64_Test.TestBuff), @TKDT5DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT5DI64_Test.BuildKDTreeM(length(TKDT5DI64_Test.TestBuff), TKDT5DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT5DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT5DI64_Test.TestBuff));
  TKDT5DI64_Test.Search(TKDT5DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT5DI64Distance(TKDT5DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT5DI64_Test.Clear;
  { kMean test }
  TKDT5DI64_Test.BuildKDTreeWithCluster(TKDT5DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT5DI64_Test.Search(TKDT5DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT5DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT5DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT5DI64_Test);
end;


function TKDT6DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT6DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT6DI64_Node;
  function SortCompare(const p1, p2: PKDT6DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT6DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT6DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT6DI64_SourceBuffer;
  dynBuff  : PKDT6DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT6DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT6DI64.GetData(const index: NativeInt): PKDT6DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT6DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT6DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT6DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT6DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT6DI64.StoreBuffPtr: PKDT6DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT6DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT6DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT6DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT6DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT6DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT6DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT6DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT6DI64.BuildKDTreeWithCluster(const inBuff: TKDT6DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT6DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT6DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT6DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT6DI64.BuildKDTreeWithCluster(const inBuff: TKDT6DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI64_BuildCall);
var
  TempStoreBuff: TKDT6DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT6DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT6DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI64_BuildMethod);
var
  TempStoreBuff: TKDT6DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT6DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT6DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT6DI64_BuildProc);
var
  TempStoreBuff: TKDT6DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT6DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT6DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT6DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT6DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT6DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT6DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT6DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT6DI64.Search(const Buff: TKDT6DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT6DI64_Node;

var
  NearestNeighbour: PKDT6DI64_Node;

  function FindParentNode(const BuffPtr: PKDT6DI64_Vec; NodePtr: PKDT6DI64_Node): PKDT6DI64_Node;
  var
    Next       : PKDT6DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT6DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT6DI64_Node; const BuffPtr: PKDT6DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT6DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT6DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT6DI64_Vec; const p1, p2: PKDT6DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT6DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT6DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT6DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT6DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT6DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT6DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT6DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT6DI64.Search(const Buff: TKDT6DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT6DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT6DI64.Search(const Buff: TKDT6DI64_Vec; var SearchedDistanceMin: Double): PKDT6DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT6DI64.Search(const Buff: TKDT6DI64_Vec): PKDT6DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT6DI64.Search(const inBuff: TKDT6DI64_DynamicVecBuffer; var OutBuff: TKDT6DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT6DI64_DynamicVecBuffer;
  outBuffPtr : PKDT6DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT6DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT6DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DI64.Search(const inBuff: TKDT6DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT6DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT6DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT6DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT6DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT6DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT6DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT6DI64_Source));
end;

procedure TKDT6DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT6DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT6DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT6DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT6DI64.PrintNodeTree(const NodePtr: PKDT6DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT6DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT6DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT6DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT6DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT6DI64.KDT6DI64Vec(const s: string): TKDT6DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT6DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT6DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT6DI64.KDT6DI64Vec(const v: TKDT6DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT6DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT6DI64.KDT6DI64Pow(const v: TKDT6DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT6DI64.KDT6DI64Distance(const v1, v2: TKDT6DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT6DI64_Axis - 1 do
      Result := Result + KDT6DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT6DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT6DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT6DI64.Test;
var
  TKDT6DI64_Test    : TKDT6DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT6DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT6DI64_Test := TKDT6DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT6DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT6DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT6DI64_Axis - 1 do
        TKDT6DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT6DI64_Test.TestBuff), length(TKDT6DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT6DI64_Test.BuildKDTreeM(length(TKDT6DI64_Test.TestBuff), @TKDT6DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT6DI64_Test.BuildKDTreeM(length(TKDT6DI64_Test.TestBuff), TKDT6DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT6DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT6DI64_Test.TestBuff));
  TKDT6DI64_Test.Search(TKDT6DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT6DI64Distance(TKDT6DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT6DI64_Test.Clear;
  { kMean test }
  TKDT6DI64_Test.BuildKDTreeWithCluster(TKDT6DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT6DI64_Test.Search(TKDT6DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT6DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT6DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT6DI64_Test);
end;


function TKDT7DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT7DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT7DI64_Node;
  function SortCompare(const p1, p2: PKDT7DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT7DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT7DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT7DI64_SourceBuffer;
  dynBuff  : PKDT7DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT7DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT7DI64.GetData(const index: NativeInt): PKDT7DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT7DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT7DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT7DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT7DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT7DI64.StoreBuffPtr: PKDT7DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT7DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT7DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT7DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT7DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT7DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT7DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT7DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT7DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT7DI64.BuildKDTreeWithCluster(const inBuff: TKDT7DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT7DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT7DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT7DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT7DI64.BuildKDTreeWithCluster(const inBuff: TKDT7DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT7DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DI64_BuildCall);
var
  TempStoreBuff: TKDT7DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT7DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT7DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DI64_BuildMethod);
var
  TempStoreBuff: TKDT7DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT7DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT7DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT7DI64_BuildProc);
var
  TempStoreBuff: TKDT7DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT7DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT7DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT7DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT7DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT7DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT7DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT7DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT7DI64.Search(const Buff: TKDT7DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT7DI64_Node;

var
  NearestNeighbour: PKDT7DI64_Node;

  function FindParentNode(const BuffPtr: PKDT7DI64_Vec; NodePtr: PKDT7DI64_Node): PKDT7DI64_Node;
  var
    Next       : PKDT7DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT7DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT7DI64_Node; const BuffPtr: PKDT7DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT7DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT7DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT7DI64_Vec; const p1, p2: PKDT7DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT7DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT7DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT7DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT7DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT7DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT7DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT7DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT7DI64.Search(const Buff: TKDT7DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT7DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT7DI64.Search(const Buff: TKDT7DI64_Vec; var SearchedDistanceMin: Double): PKDT7DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT7DI64.Search(const Buff: TKDT7DI64_Vec): PKDT7DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT7DI64.Search(const inBuff: TKDT7DI64_DynamicVecBuffer; var OutBuff: TKDT7DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT7DI64_DynamicVecBuffer;
  outBuffPtr : PKDT7DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT7DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT7DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT7DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT7DI64.Search(const inBuff: TKDT7DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT7DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT7DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT7DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT7DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT7DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT7DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT7DI64_Source));
end;

procedure TKDT7DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT7DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT7DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT7DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT7DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT7DI64.PrintNodeTree(const NodePtr: PKDT7DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT7DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT7DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT7DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT7DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT7DI64.KDT7DI64Vec(const s: string): TKDT7DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT7DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT7DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT7DI64.KDT7DI64Vec(const v: TKDT7DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT7DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT7DI64.KDT7DI64Pow(const v: TKDT7DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT7DI64.KDT7DI64Distance(const v1, v2: TKDT7DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT7DI64_Axis - 1 do
      Result := Result + KDT7DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT7DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT7DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT7DI64.Test;
var
  TKDT7DI64_Test    : TKDT7DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT7DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT7DI64_Test := TKDT7DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT7DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT7DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT7DI64_Axis - 1 do
        TKDT7DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT7DI64_Test.TestBuff), length(TKDT7DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT7DI64_Test.BuildKDTreeM(length(TKDT7DI64_Test.TestBuff), @TKDT7DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT7DI64_Test.BuildKDTreeM(length(TKDT7DI64_Test.TestBuff), TKDT7DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT7DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT7DI64_Test.TestBuff));
  TKDT7DI64_Test.Search(TKDT7DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT7DI64Distance(TKDT7DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT7DI64_Test.Clear;
  { kMean test }
  TKDT7DI64_Test.BuildKDTreeWithCluster(TKDT7DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT7DI64_Test.Search(TKDT7DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT7DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT7DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT7DI64_Test);
end;


function TKDT8DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8DI64_Node;
  function SortCompare(const p1, p2: PKDT8DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8DI64_SourceBuffer;
  dynBuff  : PKDT8DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT8DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8DI64.GetData(const index: NativeInt): PKDT8DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8DI64.StoreBuffPtr: PKDT8DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT8DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT8DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT8DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8DI64.BuildKDTreeWithCluster(const inBuff: TKDT8DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT8DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT8DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT8DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8DI64.BuildKDTreeWithCluster(const inBuff: TKDT8DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI64_BuildCall);
var
  TempStoreBuff: TKDT8DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT8DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI64_BuildMethod);
var
  TempStoreBuff: TKDT8DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT8DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8DI64_BuildProc);
var
  TempStoreBuff: TKDT8DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT8DI64.Search(const Buff: TKDT8DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8DI64_Node;

var
  NearestNeighbour: PKDT8DI64_Node;

  function FindParentNode(const BuffPtr: PKDT8DI64_Vec; NodePtr: PKDT8DI64_Node): PKDT8DI64_Node;
  var
    Next       : PKDT8DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT8DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8DI64_Node; const BuffPtr: PKDT8DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT8DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8DI64_Vec; const p1, p2: PKDT8DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT8DI64.Search(const Buff: TKDT8DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8DI64.Search(const Buff: TKDT8DI64_Vec; var SearchedDistanceMin: Double): PKDT8DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8DI64.Search(const Buff: TKDT8DI64_Vec): PKDT8DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8DI64.Search(const inBuff: TKDT8DI64_DynamicVecBuffer; var OutBuff: TKDT8DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8DI64_DynamicVecBuffer;
  outBuffPtr : PKDT8DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DI64.Search(const inBuff: TKDT8DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT8DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8DI64_Source));
end;

procedure TKDT8DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT8DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8DI64.PrintNodeTree(const NodePtr: PKDT8DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT8DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT8DI64.KDT8DI64Vec(const s: string): TKDT8DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT8DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT8DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT8DI64.KDT8DI64Vec(const v: TKDT8DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT8DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT8DI64.KDT8DI64Pow(const v: TKDT8DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT8DI64.KDT8DI64Distance(const v1, v2: TKDT8DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT8DI64_Axis - 1 do
      Result := Result + KDT8DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT8DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8DI64.Test;
var
  TKDT8DI64_Test    : TKDT8DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8DI64_Test := TKDT8DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT8DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT8DI64_Axis - 1 do
        TKDT8DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT8DI64_Test.TestBuff), length(TKDT8DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8DI64_Test.BuildKDTreeM(length(TKDT8DI64_Test.TestBuff), @TKDT8DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8DI64_Test.BuildKDTreeM(length(TKDT8DI64_Test.TestBuff), TKDT8DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8DI64_Test.TestBuff));
  TKDT8DI64_Test.Search(TKDT8DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8DI64Distance(TKDT8DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8DI64_Test.Clear;
  { kMean test }
  TKDT8DI64_Test.BuildKDTreeWithCluster(TKDT8DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8DI64_Test.Search(TKDT8DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8DI64_Test);
end;


function TKDT9DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT9DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT9DI64_Node;
  function SortCompare(const p1, p2: PKDT9DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT9DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT9DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT9DI64_SourceBuffer;
  dynBuff  : PKDT9DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT9DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT9DI64.GetData(const index: NativeInt): PKDT9DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT9DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT9DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT9DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT9DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT9DI64.StoreBuffPtr: PKDT9DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT9DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT9DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT9DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT9DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT9DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT9DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT9DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT9DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT9DI64.BuildKDTreeWithCluster(const inBuff: TKDT9DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT9DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT9DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT9DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT9DI64.BuildKDTreeWithCluster(const inBuff: TKDT9DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT9DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DI64_BuildCall);
var
  TempStoreBuff: TKDT9DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT9DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT9DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DI64_BuildMethod);
var
  TempStoreBuff: TKDT9DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT9DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT9DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT9DI64_BuildProc);
var
  TempStoreBuff: TKDT9DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT9DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT9DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT9DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT9DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT9DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT9DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT9DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT9DI64.Search(const Buff: TKDT9DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT9DI64_Node;

var
  NearestNeighbour: PKDT9DI64_Node;

  function FindParentNode(const BuffPtr: PKDT9DI64_Vec; NodePtr: PKDT9DI64_Node): PKDT9DI64_Node;
  var
    Next       : PKDT9DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT9DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT9DI64_Node; const BuffPtr: PKDT9DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT9DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT9DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT9DI64_Vec; const p1, p2: PKDT9DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT9DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT9DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT9DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT9DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT9DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT9DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT9DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT9DI64.Search(const Buff: TKDT9DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT9DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT9DI64.Search(const Buff: TKDT9DI64_Vec; var SearchedDistanceMin: Double): PKDT9DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT9DI64.Search(const Buff: TKDT9DI64_Vec): PKDT9DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT9DI64.Search(const inBuff: TKDT9DI64_DynamicVecBuffer; var OutBuff: TKDT9DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT9DI64_DynamicVecBuffer;
  outBuffPtr : PKDT9DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT9DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT9DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT9DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT9DI64.Search(const inBuff: TKDT9DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT9DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT9DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT9DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT9DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT9DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT9DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT9DI64_Source));
end;

procedure TKDT9DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT9DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT9DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT9DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT9DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT9DI64.PrintNodeTree(const NodePtr: PKDT9DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT9DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT9DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT9DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT9DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT9DI64.KDT9DI64Vec(const s: string): TKDT9DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT9DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT9DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT9DI64.KDT9DI64Vec(const v: TKDT9DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT9DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT9DI64.KDT9DI64Pow(const v: TKDT9DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT9DI64.KDT9DI64Distance(const v1, v2: TKDT9DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT9DI64_Axis - 1 do
      Result := Result + KDT9DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT9DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT9DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT9DI64.Test;
var
  TKDT9DI64_Test    : TKDT9DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT9DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT9DI64_Test := TKDT9DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT9DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT9DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT9DI64_Axis - 1 do
        TKDT9DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT9DI64_Test.TestBuff), length(TKDT9DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT9DI64_Test.BuildKDTreeM(length(TKDT9DI64_Test.TestBuff), @TKDT9DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT9DI64_Test.BuildKDTreeM(length(TKDT9DI64_Test.TestBuff), TKDT9DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT9DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT9DI64_Test.TestBuff));
  TKDT9DI64_Test.Search(TKDT9DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT9DI64Distance(TKDT9DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT9DI64_Test.Clear;
  { kMean test }
  TKDT9DI64_Test.BuildKDTreeWithCluster(TKDT9DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT9DI64_Test.Search(TKDT9DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT9DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT9DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT9DI64_Test);
end;


function TKDT10DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT10DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT10DI64_Node;
  function SortCompare(const p1, p2: PKDT10DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT10DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT10DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT10DI64_SourceBuffer;
  dynBuff  : PKDT10DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT10DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT10DI64.GetData(const index: NativeInt): PKDT10DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT10DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT10DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT10DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT10DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT10DI64.StoreBuffPtr: PKDT10DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT10DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT10DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT10DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT10DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT10DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT10DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT10DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT10DI64.BuildKDTreeWithCluster(const inBuff: TKDT10DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT10DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT10DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT10DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT10DI64.BuildKDTreeWithCluster(const inBuff: TKDT10DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI64_BuildCall);
var
  TempStoreBuff: TKDT10DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT10DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT10DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI64_BuildMethod);
var
  TempStoreBuff: TKDT10DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT10DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT10DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT10DI64_BuildProc);
var
  TempStoreBuff: TKDT10DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT10DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT10DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT10DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT10DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT10DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT10DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT10DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT10DI64.Search(const Buff: TKDT10DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT10DI64_Node;

var
  NearestNeighbour: PKDT10DI64_Node;

  function FindParentNode(const BuffPtr: PKDT10DI64_Vec; NodePtr: PKDT10DI64_Node): PKDT10DI64_Node;
  var
    Next       : PKDT10DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT10DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT10DI64_Node; const BuffPtr: PKDT10DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT10DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT10DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT10DI64_Vec; const p1, p2: PKDT10DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT10DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT10DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT10DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT10DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT10DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT10DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT10DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT10DI64.Search(const Buff: TKDT10DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT10DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT10DI64.Search(const Buff: TKDT10DI64_Vec; var SearchedDistanceMin: Double): PKDT10DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT10DI64.Search(const Buff: TKDT10DI64_Vec): PKDT10DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT10DI64.Search(const inBuff: TKDT10DI64_DynamicVecBuffer; var OutBuff: TKDT10DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT10DI64_DynamicVecBuffer;
  outBuffPtr : PKDT10DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT10DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT10DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DI64.Search(const inBuff: TKDT10DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT10DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT10DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT10DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT10DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT10DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT10DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT10DI64_Source));
end;

procedure TKDT10DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT10DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT10DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT10DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT10DI64.PrintNodeTree(const NodePtr: PKDT10DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT10DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT10DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT10DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT10DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT10DI64.KDT10DI64Vec(const s: string): TKDT10DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT10DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT10DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT10DI64.KDT10DI64Vec(const v: TKDT10DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT10DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT10DI64.KDT10DI64Pow(const v: TKDT10DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT10DI64.KDT10DI64Distance(const v1, v2: TKDT10DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT10DI64_Axis - 1 do
      Result := Result + KDT10DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT10DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT10DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT10DI64.Test;
var
  TKDT10DI64_Test    : TKDT10DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT10DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT10DI64_Test := TKDT10DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT10DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT10DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT10DI64_Axis - 1 do
        TKDT10DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT10DI64_Test.TestBuff), length(TKDT10DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT10DI64_Test.BuildKDTreeM(length(TKDT10DI64_Test.TestBuff), @TKDT10DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT10DI64_Test.BuildKDTreeM(length(TKDT10DI64_Test.TestBuff), TKDT10DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT10DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT10DI64_Test.TestBuff));
  TKDT10DI64_Test.Search(TKDT10DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT10DI64Distance(TKDT10DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT10DI64_Test.Clear;
  { kMean test }
  TKDT10DI64_Test.BuildKDTreeWithCluster(TKDT10DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT10DI64_Test.Search(TKDT10DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT10DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT10DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT10DI64_Test);
end;


function TKDT11DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT11DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT11DI64_Node;
  function SortCompare(const p1, p2: PKDT11DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT11DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT11DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT11DI64_SourceBuffer;
  dynBuff  : PKDT11DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT11DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT11DI64.GetData(const index: NativeInt): PKDT11DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT11DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT11DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT11DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT11DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT11DI64.StoreBuffPtr: PKDT11DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT11DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT11DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT11DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT11DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT11DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT11DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT11DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT11DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT11DI64.BuildKDTreeWithCluster(const inBuff: TKDT11DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT11DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT11DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT11DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT11DI64.BuildKDTreeWithCluster(const inBuff: TKDT11DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT11DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DI64_BuildCall);
var
  TempStoreBuff: TKDT11DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT11DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT11DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DI64_BuildMethod);
var
  TempStoreBuff: TKDT11DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT11DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT11DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT11DI64_BuildProc);
var
  TempStoreBuff: TKDT11DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT11DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT11DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT11DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT11DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT11DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT11DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT11DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT11DI64.Search(const Buff: TKDT11DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT11DI64_Node;

var
  NearestNeighbour: PKDT11DI64_Node;

  function FindParentNode(const BuffPtr: PKDT11DI64_Vec; NodePtr: PKDT11DI64_Node): PKDT11DI64_Node;
  var
    Next       : PKDT11DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT11DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT11DI64_Node; const BuffPtr: PKDT11DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT11DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT11DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT11DI64_Vec; const p1, p2: PKDT11DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT11DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT11DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT11DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT11DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT11DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT11DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT11DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT11DI64.Search(const Buff: TKDT11DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT11DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT11DI64.Search(const Buff: TKDT11DI64_Vec; var SearchedDistanceMin: Double): PKDT11DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT11DI64.Search(const Buff: TKDT11DI64_Vec): PKDT11DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT11DI64.Search(const inBuff: TKDT11DI64_DynamicVecBuffer; var OutBuff: TKDT11DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT11DI64_DynamicVecBuffer;
  outBuffPtr : PKDT11DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT11DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT11DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT11DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT11DI64.Search(const inBuff: TKDT11DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT11DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT11DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT11DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT11DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT11DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT11DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT11DI64_Source));
end;

procedure TKDT11DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT11DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT11DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT11DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT11DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT11DI64.PrintNodeTree(const NodePtr: PKDT11DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT11DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT11DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT11DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT11DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT11DI64.KDT11DI64Vec(const s: string): TKDT11DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT11DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT11DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT11DI64.KDT11DI64Vec(const v: TKDT11DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT11DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT11DI64.KDT11DI64Pow(const v: TKDT11DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT11DI64.KDT11DI64Distance(const v1, v2: TKDT11DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT11DI64_Axis - 1 do
      Result := Result + KDT11DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT11DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT11DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT11DI64.Test;
var
  TKDT11DI64_Test    : TKDT11DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT11DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT11DI64_Test := TKDT11DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT11DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT11DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT11DI64_Axis - 1 do
        TKDT11DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT11DI64_Test.TestBuff), length(TKDT11DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT11DI64_Test.BuildKDTreeM(length(TKDT11DI64_Test.TestBuff), @TKDT11DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT11DI64_Test.BuildKDTreeM(length(TKDT11DI64_Test.TestBuff), TKDT11DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT11DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT11DI64_Test.TestBuff));
  TKDT11DI64_Test.Search(TKDT11DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT11DI64Distance(TKDT11DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT11DI64_Test.Clear;
  { kMean test }
  TKDT11DI64_Test.BuildKDTreeWithCluster(TKDT11DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT11DI64_Test.Search(TKDT11DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT11DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT11DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT11DI64_Test);
end;


function TKDT12DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT12DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT12DI64_Node;
  function SortCompare(const p1, p2: PKDT12DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT12DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT12DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT12DI64_SourceBuffer;
  dynBuff  : PKDT12DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT12DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT12DI64.GetData(const index: NativeInt): PKDT12DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT12DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT12DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT12DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT12DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT12DI64.StoreBuffPtr: PKDT12DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT12DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT12DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT12DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT12DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT12DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT12DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT12DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT12DI64.BuildKDTreeWithCluster(const inBuff: TKDT12DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT12DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT12DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT12DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT12DI64.BuildKDTreeWithCluster(const inBuff: TKDT12DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI64_BuildCall);
var
  TempStoreBuff: TKDT12DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT12DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT12DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI64_BuildMethod);
var
  TempStoreBuff: TKDT12DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT12DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT12DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT12DI64_BuildProc);
var
  TempStoreBuff: TKDT12DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT12DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT12DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT12DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT12DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT12DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT12DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT12DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT12DI64.Search(const Buff: TKDT12DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT12DI64_Node;

var
  NearestNeighbour: PKDT12DI64_Node;

  function FindParentNode(const BuffPtr: PKDT12DI64_Vec; NodePtr: PKDT12DI64_Node): PKDT12DI64_Node;
  var
    Next       : PKDT12DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT12DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT12DI64_Node; const BuffPtr: PKDT12DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT12DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT12DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT12DI64_Vec; const p1, p2: PKDT12DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT12DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT12DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT12DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT12DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT12DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT12DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT12DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT12DI64.Search(const Buff: TKDT12DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT12DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT12DI64.Search(const Buff: TKDT12DI64_Vec; var SearchedDistanceMin: Double): PKDT12DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT12DI64.Search(const Buff: TKDT12DI64_Vec): PKDT12DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT12DI64.Search(const inBuff: TKDT12DI64_DynamicVecBuffer; var OutBuff: TKDT12DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT12DI64_DynamicVecBuffer;
  outBuffPtr : PKDT12DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT12DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT12DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DI64.Search(const inBuff: TKDT12DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT12DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT12DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT12DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT12DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT12DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT12DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT12DI64_Source));
end;

procedure TKDT12DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT12DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT12DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT12DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT12DI64.PrintNodeTree(const NodePtr: PKDT12DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT12DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT12DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT12DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT12DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT12DI64.KDT12DI64Vec(const s: string): TKDT12DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT12DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT12DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT12DI64.KDT12DI64Vec(const v: TKDT12DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT12DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT12DI64.KDT12DI64Pow(const v: TKDT12DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT12DI64.KDT12DI64Distance(const v1, v2: TKDT12DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT12DI64_Axis - 1 do
      Result := Result + KDT12DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT12DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT12DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT12DI64.Test;
var
  TKDT12DI64_Test    : TKDT12DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT12DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT12DI64_Test := TKDT12DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT12DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT12DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT12DI64_Axis - 1 do
        TKDT12DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT12DI64_Test.TestBuff), length(TKDT12DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT12DI64_Test.BuildKDTreeM(length(TKDT12DI64_Test.TestBuff), @TKDT12DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT12DI64_Test.BuildKDTreeM(length(TKDT12DI64_Test.TestBuff), TKDT12DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT12DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT12DI64_Test.TestBuff));
  TKDT12DI64_Test.Search(TKDT12DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT12DI64Distance(TKDT12DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT12DI64_Test.Clear;
  { kMean test }
  TKDT12DI64_Test.BuildKDTreeWithCluster(TKDT12DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT12DI64_Test.Search(TKDT12DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT12DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT12DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT12DI64_Test);
end;


function TKDT13DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT13DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT13DI64_Node;
  function SortCompare(const p1, p2: PKDT13DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT13DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT13DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT13DI64_SourceBuffer;
  dynBuff  : PKDT13DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT13DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT13DI64.GetData(const index: NativeInt): PKDT13DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT13DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT13DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT13DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT13DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT13DI64.StoreBuffPtr: PKDT13DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT13DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT13DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT13DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT13DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT13DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT13DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT13DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT13DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT13DI64.BuildKDTreeWithCluster(const inBuff: TKDT13DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT13DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT13DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT13DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT13DI64.BuildKDTreeWithCluster(const inBuff: TKDT13DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT13DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DI64_BuildCall);
var
  TempStoreBuff: TKDT13DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT13DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT13DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DI64_BuildMethod);
var
  TempStoreBuff: TKDT13DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT13DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT13DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT13DI64_BuildProc);
var
  TempStoreBuff: TKDT13DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT13DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT13DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT13DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT13DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT13DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT13DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT13DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT13DI64.Search(const Buff: TKDT13DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT13DI64_Node;

var
  NearestNeighbour: PKDT13DI64_Node;

  function FindParentNode(const BuffPtr: PKDT13DI64_Vec; NodePtr: PKDT13DI64_Node): PKDT13DI64_Node;
  var
    Next       : PKDT13DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT13DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT13DI64_Node; const BuffPtr: PKDT13DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT13DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT13DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT13DI64_Vec; const p1, p2: PKDT13DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT13DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT13DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT13DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT13DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT13DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT13DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT13DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT13DI64.Search(const Buff: TKDT13DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT13DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT13DI64.Search(const Buff: TKDT13DI64_Vec; var SearchedDistanceMin: Double): PKDT13DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT13DI64.Search(const Buff: TKDT13DI64_Vec): PKDT13DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT13DI64.Search(const inBuff: TKDT13DI64_DynamicVecBuffer; var OutBuff: TKDT13DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT13DI64_DynamicVecBuffer;
  outBuffPtr : PKDT13DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT13DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT13DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT13DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT13DI64.Search(const inBuff: TKDT13DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT13DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT13DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT13DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT13DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT13DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT13DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT13DI64_Source));
end;

procedure TKDT13DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT13DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT13DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT13DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT13DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT13DI64.PrintNodeTree(const NodePtr: PKDT13DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT13DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT13DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT13DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT13DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT13DI64.KDT13DI64Vec(const s: string): TKDT13DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT13DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT13DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT13DI64.KDT13DI64Vec(const v: TKDT13DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT13DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT13DI64.KDT13DI64Pow(const v: TKDT13DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT13DI64.KDT13DI64Distance(const v1, v2: TKDT13DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT13DI64_Axis - 1 do
      Result := Result + KDT13DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT13DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT13DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT13DI64.Test;
var
  TKDT13DI64_Test    : TKDT13DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT13DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT13DI64_Test := TKDT13DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT13DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT13DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT13DI64_Axis - 1 do
        TKDT13DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT13DI64_Test.TestBuff), length(TKDT13DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT13DI64_Test.BuildKDTreeM(length(TKDT13DI64_Test.TestBuff), @TKDT13DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT13DI64_Test.BuildKDTreeM(length(TKDT13DI64_Test.TestBuff), TKDT13DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT13DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT13DI64_Test.TestBuff));
  TKDT13DI64_Test.Search(TKDT13DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT13DI64Distance(TKDT13DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT13DI64_Test.Clear;
  { kMean test }
  TKDT13DI64_Test.BuildKDTreeWithCluster(TKDT13DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT13DI64_Test.Search(TKDT13DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT13DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT13DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT13DI64_Test);
end;


function TKDT14DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT14DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT14DI64_Node;
  function SortCompare(const p1, p2: PKDT14DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT14DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT14DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT14DI64_SourceBuffer;
  dynBuff  : PKDT14DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT14DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT14DI64.GetData(const index: NativeInt): PKDT14DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT14DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT14DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT14DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT14DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT14DI64.StoreBuffPtr: PKDT14DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT14DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT14DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT14DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT14DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT14DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT14DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT14DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT14DI64.BuildKDTreeWithCluster(const inBuff: TKDT14DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT14DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT14DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT14DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT14DI64.BuildKDTreeWithCluster(const inBuff: TKDT14DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI64_BuildCall);
var
  TempStoreBuff: TKDT14DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT14DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT14DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI64_BuildMethod);
var
  TempStoreBuff: TKDT14DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT14DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT14DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT14DI64_BuildProc);
var
  TempStoreBuff: TKDT14DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT14DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT14DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT14DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT14DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT14DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT14DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT14DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT14DI64.Search(const Buff: TKDT14DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT14DI64_Node;

var
  NearestNeighbour: PKDT14DI64_Node;

  function FindParentNode(const BuffPtr: PKDT14DI64_Vec; NodePtr: PKDT14DI64_Node): PKDT14DI64_Node;
  var
    Next       : PKDT14DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT14DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT14DI64_Node; const BuffPtr: PKDT14DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT14DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT14DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT14DI64_Vec; const p1, p2: PKDT14DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT14DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT14DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT14DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT14DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT14DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT14DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT14DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT14DI64.Search(const Buff: TKDT14DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT14DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT14DI64.Search(const Buff: TKDT14DI64_Vec; var SearchedDistanceMin: Double): PKDT14DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT14DI64.Search(const Buff: TKDT14DI64_Vec): PKDT14DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT14DI64.Search(const inBuff: TKDT14DI64_DynamicVecBuffer; var OutBuff: TKDT14DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT14DI64_DynamicVecBuffer;
  outBuffPtr : PKDT14DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT14DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT14DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DI64.Search(const inBuff: TKDT14DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT14DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT14DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT14DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT14DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT14DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT14DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT14DI64_Source));
end;

procedure TKDT14DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT14DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT14DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT14DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT14DI64.PrintNodeTree(const NodePtr: PKDT14DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT14DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT14DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT14DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT14DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT14DI64.KDT14DI64Vec(const s: string): TKDT14DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT14DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT14DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT14DI64.KDT14DI64Vec(const v: TKDT14DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT14DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT14DI64.KDT14DI64Pow(const v: TKDT14DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT14DI64.KDT14DI64Distance(const v1, v2: TKDT14DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT14DI64_Axis - 1 do
      Result := Result + KDT14DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT14DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT14DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT14DI64.Test;
var
  TKDT14DI64_Test    : TKDT14DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT14DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT14DI64_Test := TKDT14DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT14DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT14DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT14DI64_Axis - 1 do
        TKDT14DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT14DI64_Test.TestBuff), length(TKDT14DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT14DI64_Test.BuildKDTreeM(length(TKDT14DI64_Test.TestBuff), @TKDT14DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT14DI64_Test.BuildKDTreeM(length(TKDT14DI64_Test.TestBuff), TKDT14DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT14DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT14DI64_Test.TestBuff));
  TKDT14DI64_Test.Search(TKDT14DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT14DI64Distance(TKDT14DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT14DI64_Test.Clear;
  { kMean test }
  TKDT14DI64_Test.BuildKDTreeWithCluster(TKDT14DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT14DI64_Test.Search(TKDT14DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT14DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT14DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT14DI64_Test);
end;


function TKDT15DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT15DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT15DI64_Node;
  function SortCompare(const p1, p2: PKDT15DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT15DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT15DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT15DI64_SourceBuffer;
  dynBuff  : PKDT15DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT15DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT15DI64.GetData(const index: NativeInt): PKDT15DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT15DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT15DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT15DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT15DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT15DI64.StoreBuffPtr: PKDT15DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT15DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT15DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT15DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT15DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT15DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT15DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT15DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT15DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT15DI64.BuildKDTreeWithCluster(const inBuff: TKDT15DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT15DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT15DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT15DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT15DI64.BuildKDTreeWithCluster(const inBuff: TKDT15DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT15DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DI64_BuildCall);
var
  TempStoreBuff: TKDT15DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT15DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT15DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DI64_BuildMethod);
var
  TempStoreBuff: TKDT15DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT15DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT15DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT15DI64_BuildProc);
var
  TempStoreBuff: TKDT15DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT15DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT15DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT15DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT15DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT15DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT15DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT15DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT15DI64.Search(const Buff: TKDT15DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT15DI64_Node;

var
  NearestNeighbour: PKDT15DI64_Node;

  function FindParentNode(const BuffPtr: PKDT15DI64_Vec; NodePtr: PKDT15DI64_Node): PKDT15DI64_Node;
  var
    Next       : PKDT15DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT15DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT15DI64_Node; const BuffPtr: PKDT15DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT15DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT15DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT15DI64_Vec; const p1, p2: PKDT15DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT15DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT15DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT15DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT15DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT15DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT15DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT15DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT15DI64.Search(const Buff: TKDT15DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT15DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT15DI64.Search(const Buff: TKDT15DI64_Vec; var SearchedDistanceMin: Double): PKDT15DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT15DI64.Search(const Buff: TKDT15DI64_Vec): PKDT15DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT15DI64.Search(const inBuff: TKDT15DI64_DynamicVecBuffer; var OutBuff: TKDT15DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT15DI64_DynamicVecBuffer;
  outBuffPtr : PKDT15DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT15DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT15DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT15DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT15DI64.Search(const inBuff: TKDT15DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT15DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT15DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT15DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT15DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT15DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT15DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT15DI64_Source));
end;

procedure TKDT15DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT15DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT15DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT15DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT15DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT15DI64.PrintNodeTree(const NodePtr: PKDT15DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT15DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT15DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT15DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT15DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT15DI64.KDT15DI64Vec(const s: string): TKDT15DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT15DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT15DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT15DI64.KDT15DI64Vec(const v: TKDT15DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT15DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT15DI64.KDT15DI64Pow(const v: TKDT15DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT15DI64.KDT15DI64Distance(const v1, v2: TKDT15DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT15DI64_Axis - 1 do
      Result := Result + KDT15DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT15DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT15DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT15DI64.Test;
var
  TKDT15DI64_Test    : TKDT15DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT15DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT15DI64_Test := TKDT15DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT15DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT15DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT15DI64_Axis - 1 do
        TKDT15DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT15DI64_Test.TestBuff), length(TKDT15DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT15DI64_Test.BuildKDTreeM(length(TKDT15DI64_Test.TestBuff), @TKDT15DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT15DI64_Test.BuildKDTreeM(length(TKDT15DI64_Test.TestBuff), TKDT15DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT15DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT15DI64_Test.TestBuff));
  TKDT15DI64_Test.Search(TKDT15DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT15DI64Distance(TKDT15DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT15DI64_Test.Clear;
  { kMean test }
  TKDT15DI64_Test.BuildKDTreeWithCluster(TKDT15DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT15DI64_Test.Search(TKDT15DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT15DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT15DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT15DI64_Test);
end;


function TKDT16DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT16DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT16DI64_Node;
  function SortCompare(const p1, p2: PKDT16DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT16DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT16DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT16DI64_SourceBuffer;
  dynBuff  : PKDT16DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT16DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT16DI64.GetData(const index: NativeInt): PKDT16DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT16DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT16DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT16DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT16DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT16DI64.StoreBuffPtr: PKDT16DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT16DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT16DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT16DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT16DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT16DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT16DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT16DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT16DI64.BuildKDTreeWithCluster(const inBuff: TKDT16DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT16DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT16DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT16DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT16DI64.BuildKDTreeWithCluster(const inBuff: TKDT16DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI64_BuildCall);
var
  TempStoreBuff: TKDT16DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT16DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT16DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI64_BuildMethod);
var
  TempStoreBuff: TKDT16DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT16DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT16DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT16DI64_BuildProc);
var
  TempStoreBuff: TKDT16DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT16DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT16DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT16DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT16DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT16DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT16DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT16DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT16DI64.Search(const Buff: TKDT16DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT16DI64_Node;

var
  NearestNeighbour: PKDT16DI64_Node;

  function FindParentNode(const BuffPtr: PKDT16DI64_Vec; NodePtr: PKDT16DI64_Node): PKDT16DI64_Node;
  var
    Next       : PKDT16DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT16DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT16DI64_Node; const BuffPtr: PKDT16DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT16DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT16DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT16DI64_Vec; const p1, p2: PKDT16DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT16DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT16DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT16DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT16DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT16DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT16DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT16DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT16DI64.Search(const Buff: TKDT16DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT16DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT16DI64.Search(const Buff: TKDT16DI64_Vec; var SearchedDistanceMin: Double): PKDT16DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT16DI64.Search(const Buff: TKDT16DI64_Vec): PKDT16DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT16DI64.Search(const inBuff: TKDT16DI64_DynamicVecBuffer; var OutBuff: TKDT16DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT16DI64_DynamicVecBuffer;
  outBuffPtr : PKDT16DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT16DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT16DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DI64.Search(const inBuff: TKDT16DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT16DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT16DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT16DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT16DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT16DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT16DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT16DI64_Source));
end;

procedure TKDT16DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT16DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT16DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT16DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT16DI64.PrintNodeTree(const NodePtr: PKDT16DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT16DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT16DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT16DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT16DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT16DI64.KDT16DI64Vec(const s: string): TKDT16DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT16DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT16DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT16DI64.KDT16DI64Vec(const v: TKDT16DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT16DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT16DI64.KDT16DI64Pow(const v: TKDT16DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT16DI64.KDT16DI64Distance(const v1, v2: TKDT16DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT16DI64_Axis - 1 do
      Result := Result + KDT16DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT16DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT16DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT16DI64.Test;
var
  TKDT16DI64_Test    : TKDT16DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT16DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT16DI64_Test := TKDT16DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT16DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT16DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT16DI64_Axis - 1 do
        TKDT16DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT16DI64_Test.TestBuff), length(TKDT16DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT16DI64_Test.BuildKDTreeM(length(TKDT16DI64_Test.TestBuff), @TKDT16DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT16DI64_Test.BuildKDTreeM(length(TKDT16DI64_Test.TestBuff), TKDT16DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT16DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT16DI64_Test.TestBuff));
  TKDT16DI64_Test.Search(TKDT16DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT16DI64Distance(TKDT16DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT16DI64_Test.Clear;
  { kMean test }
  TKDT16DI64_Test.BuildKDTreeWithCluster(TKDT16DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT16DI64_Test.Search(TKDT16DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT16DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT16DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT16DI64_Test);
end;


function TKDT17DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT17DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT17DI64_Node;
  function SortCompare(const p1, p2: PKDT17DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT17DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT17DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT17DI64_SourceBuffer;
  dynBuff  : PKDT17DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT17DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT17DI64.GetData(const index: NativeInt): PKDT17DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT17DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT17DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT17DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT17DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT17DI64.StoreBuffPtr: PKDT17DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT17DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT17DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT17DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT17DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT17DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT17DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT17DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT17DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT17DI64.BuildKDTreeWithCluster(const inBuff: TKDT17DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT17DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT17DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT17DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT17DI64.BuildKDTreeWithCluster(const inBuff: TKDT17DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT17DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DI64_BuildCall);
var
  TempStoreBuff: TKDT17DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT17DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT17DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DI64_BuildMethod);
var
  TempStoreBuff: TKDT17DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT17DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT17DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT17DI64_BuildProc);
var
  TempStoreBuff: TKDT17DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT17DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT17DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT17DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT17DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT17DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT17DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT17DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT17DI64.Search(const Buff: TKDT17DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT17DI64_Node;

var
  NearestNeighbour: PKDT17DI64_Node;

  function FindParentNode(const BuffPtr: PKDT17DI64_Vec; NodePtr: PKDT17DI64_Node): PKDT17DI64_Node;
  var
    Next       : PKDT17DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT17DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT17DI64_Node; const BuffPtr: PKDT17DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT17DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT17DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT17DI64_Vec; const p1, p2: PKDT17DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT17DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT17DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT17DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT17DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT17DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT17DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT17DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT17DI64.Search(const Buff: TKDT17DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT17DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT17DI64.Search(const Buff: TKDT17DI64_Vec; var SearchedDistanceMin: Double): PKDT17DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT17DI64.Search(const Buff: TKDT17DI64_Vec): PKDT17DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT17DI64.Search(const inBuff: TKDT17DI64_DynamicVecBuffer; var OutBuff: TKDT17DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT17DI64_DynamicVecBuffer;
  outBuffPtr : PKDT17DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT17DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT17DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT17DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT17DI64.Search(const inBuff: TKDT17DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT17DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT17DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT17DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT17DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT17DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT17DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT17DI64_Source));
end;

procedure TKDT17DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT17DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT17DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT17DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT17DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT17DI64.PrintNodeTree(const NodePtr: PKDT17DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT17DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT17DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT17DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT17DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT17DI64.KDT17DI64Vec(const s: string): TKDT17DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT17DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT17DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT17DI64.KDT17DI64Vec(const v: TKDT17DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT17DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT17DI64.KDT17DI64Pow(const v: TKDT17DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT17DI64.KDT17DI64Distance(const v1, v2: TKDT17DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT17DI64_Axis - 1 do
      Result := Result + KDT17DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT17DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT17DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT17DI64.Test;
var
  TKDT17DI64_Test    : TKDT17DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT17DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT17DI64_Test := TKDT17DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT17DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT17DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT17DI64_Axis - 1 do
        TKDT17DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT17DI64_Test.TestBuff), length(TKDT17DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT17DI64_Test.BuildKDTreeM(length(TKDT17DI64_Test.TestBuff), @TKDT17DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT17DI64_Test.BuildKDTreeM(length(TKDT17DI64_Test.TestBuff), TKDT17DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT17DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT17DI64_Test.TestBuff));
  TKDT17DI64_Test.Search(TKDT17DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT17DI64Distance(TKDT17DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT17DI64_Test.Clear;
  { kMean test }
  TKDT17DI64_Test.BuildKDTreeWithCluster(TKDT17DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT17DI64_Test.Search(TKDT17DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT17DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT17DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT17DI64_Test);
end;


function TKDT18DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT18DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT18DI64_Node;
  function SortCompare(const p1, p2: PKDT18DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT18DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT18DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT18DI64_SourceBuffer;
  dynBuff  : PKDT18DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT18DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT18DI64.GetData(const index: NativeInt): PKDT18DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT18DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT18DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT18DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT18DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT18DI64.StoreBuffPtr: PKDT18DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT18DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT18DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT18DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT18DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT18DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT18DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT18DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT18DI64.BuildKDTreeWithCluster(const inBuff: TKDT18DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT18DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT18DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT18DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT18DI64.BuildKDTreeWithCluster(const inBuff: TKDT18DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI64_BuildCall);
var
  TempStoreBuff: TKDT18DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT18DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT18DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI64_BuildMethod);
var
  TempStoreBuff: TKDT18DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT18DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT18DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT18DI64_BuildProc);
var
  TempStoreBuff: TKDT18DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT18DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT18DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT18DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT18DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT18DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT18DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT18DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT18DI64.Search(const Buff: TKDT18DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT18DI64_Node;

var
  NearestNeighbour: PKDT18DI64_Node;

  function FindParentNode(const BuffPtr: PKDT18DI64_Vec; NodePtr: PKDT18DI64_Node): PKDT18DI64_Node;
  var
    Next       : PKDT18DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT18DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT18DI64_Node; const BuffPtr: PKDT18DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT18DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT18DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT18DI64_Vec; const p1, p2: PKDT18DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT18DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT18DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT18DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT18DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT18DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT18DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT18DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT18DI64.Search(const Buff: TKDT18DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT18DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT18DI64.Search(const Buff: TKDT18DI64_Vec; var SearchedDistanceMin: Double): PKDT18DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT18DI64.Search(const Buff: TKDT18DI64_Vec): PKDT18DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT18DI64.Search(const inBuff: TKDT18DI64_DynamicVecBuffer; var OutBuff: TKDT18DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT18DI64_DynamicVecBuffer;
  outBuffPtr : PKDT18DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT18DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT18DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DI64.Search(const inBuff: TKDT18DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT18DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT18DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT18DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT18DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT18DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT18DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT18DI64_Source));
end;

procedure TKDT18DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT18DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT18DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT18DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT18DI64.PrintNodeTree(const NodePtr: PKDT18DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT18DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT18DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT18DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT18DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT18DI64.KDT18DI64Vec(const s: string): TKDT18DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT18DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT18DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT18DI64.KDT18DI64Vec(const v: TKDT18DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT18DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT18DI64.KDT18DI64Pow(const v: TKDT18DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT18DI64.KDT18DI64Distance(const v1, v2: TKDT18DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT18DI64_Axis - 1 do
      Result := Result + KDT18DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT18DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT18DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT18DI64.Test;
var
  TKDT18DI64_Test    : TKDT18DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT18DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT18DI64_Test := TKDT18DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT18DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT18DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT18DI64_Axis - 1 do
        TKDT18DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT18DI64_Test.TestBuff), length(TKDT18DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT18DI64_Test.BuildKDTreeM(length(TKDT18DI64_Test.TestBuff), @TKDT18DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT18DI64_Test.BuildKDTreeM(length(TKDT18DI64_Test.TestBuff), TKDT18DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT18DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT18DI64_Test.TestBuff));
  TKDT18DI64_Test.Search(TKDT18DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT18DI64Distance(TKDT18DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT18DI64_Test.Clear;
  { kMean test }
  TKDT18DI64_Test.BuildKDTreeWithCluster(TKDT18DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT18DI64_Test.Search(TKDT18DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT18DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT18DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT18DI64_Test);
end;


function TKDT19DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT19DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT19DI64_Node;
  function SortCompare(const p1, p2: PKDT19DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT19DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT19DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT19DI64_SourceBuffer;
  dynBuff  : PKDT19DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT19DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT19DI64.GetData(const index: NativeInt): PKDT19DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT19DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT19DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT19DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT19DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT19DI64.StoreBuffPtr: PKDT19DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT19DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT19DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT19DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT19DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT19DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT19DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT19DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT19DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT19DI64.BuildKDTreeWithCluster(const inBuff: TKDT19DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT19DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT19DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT19DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT19DI64.BuildKDTreeWithCluster(const inBuff: TKDT19DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT19DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DI64_BuildCall);
var
  TempStoreBuff: TKDT19DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT19DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT19DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DI64_BuildMethod);
var
  TempStoreBuff: TKDT19DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT19DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT19DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT19DI64_BuildProc);
var
  TempStoreBuff: TKDT19DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT19DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT19DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT19DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT19DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT19DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT19DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT19DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT19DI64.Search(const Buff: TKDT19DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT19DI64_Node;

var
  NearestNeighbour: PKDT19DI64_Node;

  function FindParentNode(const BuffPtr: PKDT19DI64_Vec; NodePtr: PKDT19DI64_Node): PKDT19DI64_Node;
  var
    Next       : PKDT19DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT19DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT19DI64_Node; const BuffPtr: PKDT19DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT19DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT19DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT19DI64_Vec; const p1, p2: PKDT19DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT19DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT19DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT19DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT19DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT19DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT19DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT19DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT19DI64.Search(const Buff: TKDT19DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT19DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT19DI64.Search(const Buff: TKDT19DI64_Vec; var SearchedDistanceMin: Double): PKDT19DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT19DI64.Search(const Buff: TKDT19DI64_Vec): PKDT19DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT19DI64.Search(const inBuff: TKDT19DI64_DynamicVecBuffer; var OutBuff: TKDT19DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT19DI64_DynamicVecBuffer;
  outBuffPtr : PKDT19DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT19DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT19DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT19DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT19DI64.Search(const inBuff: TKDT19DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT19DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT19DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT19DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT19DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT19DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT19DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT19DI64_Source));
end;

procedure TKDT19DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT19DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT19DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT19DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT19DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT19DI64.PrintNodeTree(const NodePtr: PKDT19DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT19DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT19DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT19DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT19DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT19DI64.KDT19DI64Vec(const s: string): TKDT19DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT19DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT19DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT19DI64.KDT19DI64Vec(const v: TKDT19DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT19DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT19DI64.KDT19DI64Pow(const v: TKDT19DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT19DI64.KDT19DI64Distance(const v1, v2: TKDT19DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT19DI64_Axis - 1 do
      Result := Result + KDT19DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT19DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT19DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT19DI64.Test;
var
  TKDT19DI64_Test    : TKDT19DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT19DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT19DI64_Test := TKDT19DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT19DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT19DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT19DI64_Axis - 1 do
        TKDT19DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT19DI64_Test.TestBuff), length(TKDT19DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT19DI64_Test.BuildKDTreeM(length(TKDT19DI64_Test.TestBuff), @TKDT19DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT19DI64_Test.BuildKDTreeM(length(TKDT19DI64_Test.TestBuff), TKDT19DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT19DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT19DI64_Test.TestBuff));
  TKDT19DI64_Test.Search(TKDT19DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT19DI64Distance(TKDT19DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT19DI64_Test.Clear;
  { kMean test }
  TKDT19DI64_Test.BuildKDTreeWithCluster(TKDT19DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT19DI64_Test.Search(TKDT19DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT19DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT19DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT19DI64_Test);
end;


function TKDT20DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT20DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT20DI64_Node;
  function SortCompare(const p1, p2: PKDT20DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT20DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT20DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT20DI64_SourceBuffer;
  dynBuff  : PKDT20DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT20DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT20DI64.GetData(const index: NativeInt): PKDT20DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT20DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT20DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT20DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT20DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT20DI64.StoreBuffPtr: PKDT20DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT20DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT20DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT20DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT20DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT20DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT20DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT20DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT20DI64.BuildKDTreeWithCluster(const inBuff: TKDT20DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT20DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT20DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT20DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT20DI64.BuildKDTreeWithCluster(const inBuff: TKDT20DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI64_BuildCall);
var
  TempStoreBuff: TKDT20DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT20DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT20DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI64_BuildMethod);
var
  TempStoreBuff: TKDT20DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT20DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT20DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT20DI64_BuildProc);
var
  TempStoreBuff: TKDT20DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT20DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT20DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT20DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT20DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT20DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT20DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT20DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT20DI64.Search(const Buff: TKDT20DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT20DI64_Node;

var
  NearestNeighbour: PKDT20DI64_Node;

  function FindParentNode(const BuffPtr: PKDT20DI64_Vec; NodePtr: PKDT20DI64_Node): PKDT20DI64_Node;
  var
    Next       : PKDT20DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT20DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT20DI64_Node; const BuffPtr: PKDT20DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT20DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT20DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT20DI64_Vec; const p1, p2: PKDT20DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT20DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT20DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT20DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT20DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT20DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT20DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT20DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT20DI64.Search(const Buff: TKDT20DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT20DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT20DI64.Search(const Buff: TKDT20DI64_Vec; var SearchedDistanceMin: Double): PKDT20DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT20DI64.Search(const Buff: TKDT20DI64_Vec): PKDT20DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT20DI64.Search(const inBuff: TKDT20DI64_DynamicVecBuffer; var OutBuff: TKDT20DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT20DI64_DynamicVecBuffer;
  outBuffPtr : PKDT20DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT20DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT20DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DI64.Search(const inBuff: TKDT20DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT20DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT20DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT20DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT20DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT20DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT20DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT20DI64_Source));
end;

procedure TKDT20DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT20DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT20DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT20DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT20DI64.PrintNodeTree(const NodePtr: PKDT20DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT20DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT20DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT20DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT20DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT20DI64.KDT20DI64Vec(const s: string): TKDT20DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT20DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT20DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT20DI64.KDT20DI64Vec(const v: TKDT20DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT20DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT20DI64.KDT20DI64Pow(const v: TKDT20DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT20DI64.KDT20DI64Distance(const v1, v2: TKDT20DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT20DI64_Axis - 1 do
      Result := Result + KDT20DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT20DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT20DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT20DI64.Test;
var
  TKDT20DI64_Test    : TKDT20DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT20DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT20DI64_Test := TKDT20DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT20DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT20DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT20DI64_Axis - 1 do
        TKDT20DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT20DI64_Test.TestBuff), length(TKDT20DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT20DI64_Test.BuildKDTreeM(length(TKDT20DI64_Test.TestBuff), @TKDT20DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT20DI64_Test.BuildKDTreeM(length(TKDT20DI64_Test.TestBuff), TKDT20DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT20DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT20DI64_Test.TestBuff));
  TKDT20DI64_Test.Search(TKDT20DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT20DI64Distance(TKDT20DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT20DI64_Test.Clear;
  { kMean test }
  TKDT20DI64_Test.BuildKDTreeWithCluster(TKDT20DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT20DI64_Test.Search(TKDT20DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT20DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT20DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT20DI64_Test);
end;


function TKDT21DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT21DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT21DI64_Node;
  function SortCompare(const p1, p2: PKDT21DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT21DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT21DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT21DI64_SourceBuffer;
  dynBuff  : PKDT21DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT21DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT21DI64.GetData(const index: NativeInt): PKDT21DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT21DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT21DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT21DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT21DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT21DI64.StoreBuffPtr: PKDT21DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT21DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT21DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT21DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT21DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT21DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT21DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT21DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT21DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT21DI64.BuildKDTreeWithCluster(const inBuff: TKDT21DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT21DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT21DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT21DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT21DI64.BuildKDTreeWithCluster(const inBuff: TKDT21DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT21DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DI64_BuildCall);
var
  TempStoreBuff: TKDT21DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT21DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT21DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DI64_BuildMethod);
var
  TempStoreBuff: TKDT21DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT21DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT21DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT21DI64_BuildProc);
var
  TempStoreBuff: TKDT21DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT21DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT21DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT21DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT21DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT21DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT21DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT21DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT21DI64.Search(const Buff: TKDT21DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT21DI64_Node;

var
  NearestNeighbour: PKDT21DI64_Node;

  function FindParentNode(const BuffPtr: PKDT21DI64_Vec; NodePtr: PKDT21DI64_Node): PKDT21DI64_Node;
  var
    Next       : PKDT21DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT21DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT21DI64_Node; const BuffPtr: PKDT21DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT21DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT21DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT21DI64_Vec; const p1, p2: PKDT21DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT21DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT21DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT21DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT21DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT21DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT21DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT21DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT21DI64.Search(const Buff: TKDT21DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT21DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT21DI64.Search(const Buff: TKDT21DI64_Vec; var SearchedDistanceMin: Double): PKDT21DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT21DI64.Search(const Buff: TKDT21DI64_Vec): PKDT21DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT21DI64.Search(const inBuff: TKDT21DI64_DynamicVecBuffer; var OutBuff: TKDT21DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT21DI64_DynamicVecBuffer;
  outBuffPtr : PKDT21DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT21DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT21DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT21DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT21DI64.Search(const inBuff: TKDT21DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT21DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT21DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT21DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT21DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT21DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT21DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT21DI64_Source));
end;

procedure TKDT21DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT21DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT21DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT21DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT21DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT21DI64.PrintNodeTree(const NodePtr: PKDT21DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT21DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT21DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT21DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT21DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT21DI64.KDT21DI64Vec(const s: string): TKDT21DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT21DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT21DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT21DI64.KDT21DI64Vec(const v: TKDT21DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT21DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT21DI64.KDT21DI64Pow(const v: TKDT21DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT21DI64.KDT21DI64Distance(const v1, v2: TKDT21DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT21DI64_Axis - 1 do
      Result := Result + KDT21DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT21DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT21DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT21DI64.Test;
var
  TKDT21DI64_Test    : TKDT21DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT21DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT21DI64_Test := TKDT21DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT21DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT21DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT21DI64_Axis - 1 do
        TKDT21DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT21DI64_Test.TestBuff), length(TKDT21DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT21DI64_Test.BuildKDTreeM(length(TKDT21DI64_Test.TestBuff), @TKDT21DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT21DI64_Test.BuildKDTreeM(length(TKDT21DI64_Test.TestBuff), TKDT21DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT21DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT21DI64_Test.TestBuff));
  TKDT21DI64_Test.Search(TKDT21DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT21DI64Distance(TKDT21DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT21DI64_Test.Clear;
  { kMean test }
  TKDT21DI64_Test.BuildKDTreeWithCluster(TKDT21DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT21DI64_Test.Search(TKDT21DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT21DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT21DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT21DI64_Test);
end;


function TKDT22DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT22DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT22DI64_Node;
  function SortCompare(const p1, p2: PKDT22DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT22DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT22DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT22DI64_SourceBuffer;
  dynBuff  : PKDT22DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT22DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT22DI64.GetData(const index: NativeInt): PKDT22DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT22DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT22DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT22DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT22DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT22DI64.StoreBuffPtr: PKDT22DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT22DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT22DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT22DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT22DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT22DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT22DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT22DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT22DI64.BuildKDTreeWithCluster(const inBuff: TKDT22DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT22DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT22DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT22DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT22DI64.BuildKDTreeWithCluster(const inBuff: TKDT22DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI64_BuildCall);
var
  TempStoreBuff: TKDT22DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT22DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT22DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI64_BuildMethod);
var
  TempStoreBuff: TKDT22DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT22DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT22DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT22DI64_BuildProc);
var
  TempStoreBuff: TKDT22DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT22DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT22DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT22DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT22DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT22DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT22DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT22DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT22DI64.Search(const Buff: TKDT22DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT22DI64_Node;

var
  NearestNeighbour: PKDT22DI64_Node;

  function FindParentNode(const BuffPtr: PKDT22DI64_Vec; NodePtr: PKDT22DI64_Node): PKDT22DI64_Node;
  var
    Next       : PKDT22DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT22DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT22DI64_Node; const BuffPtr: PKDT22DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT22DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT22DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT22DI64_Vec; const p1, p2: PKDT22DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT22DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT22DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT22DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT22DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT22DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT22DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT22DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT22DI64.Search(const Buff: TKDT22DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT22DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT22DI64.Search(const Buff: TKDT22DI64_Vec; var SearchedDistanceMin: Double): PKDT22DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT22DI64.Search(const Buff: TKDT22DI64_Vec): PKDT22DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT22DI64.Search(const inBuff: TKDT22DI64_DynamicVecBuffer; var OutBuff: TKDT22DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT22DI64_DynamicVecBuffer;
  outBuffPtr : PKDT22DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT22DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT22DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DI64.Search(const inBuff: TKDT22DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT22DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT22DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT22DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT22DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT22DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT22DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT22DI64_Source));
end;

procedure TKDT22DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT22DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT22DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT22DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT22DI64.PrintNodeTree(const NodePtr: PKDT22DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT22DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT22DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT22DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT22DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT22DI64.KDT22DI64Vec(const s: string): TKDT22DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT22DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT22DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT22DI64.KDT22DI64Vec(const v: TKDT22DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT22DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT22DI64.KDT22DI64Pow(const v: TKDT22DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT22DI64.KDT22DI64Distance(const v1, v2: TKDT22DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT22DI64_Axis - 1 do
      Result := Result + KDT22DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT22DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT22DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT22DI64.Test;
var
  TKDT22DI64_Test    : TKDT22DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT22DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT22DI64_Test := TKDT22DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT22DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT22DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT22DI64_Axis - 1 do
        TKDT22DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT22DI64_Test.TestBuff), length(TKDT22DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT22DI64_Test.BuildKDTreeM(length(TKDT22DI64_Test.TestBuff), @TKDT22DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT22DI64_Test.BuildKDTreeM(length(TKDT22DI64_Test.TestBuff), TKDT22DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT22DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT22DI64_Test.TestBuff));
  TKDT22DI64_Test.Search(TKDT22DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT22DI64Distance(TKDT22DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT22DI64_Test.Clear;
  { kMean test }
  TKDT22DI64_Test.BuildKDTreeWithCluster(TKDT22DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT22DI64_Test.Search(TKDT22DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT22DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT22DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT22DI64_Test);
end;


function TKDT23DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT23DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT23DI64_Node;
  function SortCompare(const p1, p2: PKDT23DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT23DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT23DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT23DI64_SourceBuffer;
  dynBuff  : PKDT23DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT23DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT23DI64.GetData(const index: NativeInt): PKDT23DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT23DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT23DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT23DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT23DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT23DI64.StoreBuffPtr: PKDT23DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT23DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT23DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT23DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT23DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT23DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT23DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT23DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT23DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT23DI64.BuildKDTreeWithCluster(const inBuff: TKDT23DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT23DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT23DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT23DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT23DI64.BuildKDTreeWithCluster(const inBuff: TKDT23DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT23DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DI64_BuildCall);
var
  TempStoreBuff: TKDT23DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT23DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT23DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DI64_BuildMethod);
var
  TempStoreBuff: TKDT23DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT23DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT23DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT23DI64_BuildProc);
var
  TempStoreBuff: TKDT23DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT23DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT23DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT23DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT23DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT23DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT23DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT23DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT23DI64.Search(const Buff: TKDT23DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT23DI64_Node;

var
  NearestNeighbour: PKDT23DI64_Node;

  function FindParentNode(const BuffPtr: PKDT23DI64_Vec; NodePtr: PKDT23DI64_Node): PKDT23DI64_Node;
  var
    Next       : PKDT23DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT23DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT23DI64_Node; const BuffPtr: PKDT23DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT23DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT23DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT23DI64_Vec; const p1, p2: PKDT23DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT23DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT23DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT23DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT23DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT23DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT23DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT23DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT23DI64.Search(const Buff: TKDT23DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT23DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT23DI64.Search(const Buff: TKDT23DI64_Vec; var SearchedDistanceMin: Double): PKDT23DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT23DI64.Search(const Buff: TKDT23DI64_Vec): PKDT23DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT23DI64.Search(const inBuff: TKDT23DI64_DynamicVecBuffer; var OutBuff: TKDT23DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT23DI64_DynamicVecBuffer;
  outBuffPtr : PKDT23DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT23DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT23DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT23DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT23DI64.Search(const inBuff: TKDT23DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT23DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT23DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT23DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT23DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT23DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT23DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT23DI64_Source));
end;

procedure TKDT23DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT23DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT23DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT23DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT23DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT23DI64.PrintNodeTree(const NodePtr: PKDT23DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT23DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT23DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT23DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT23DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT23DI64.KDT23DI64Vec(const s: string): TKDT23DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT23DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT23DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT23DI64.KDT23DI64Vec(const v: TKDT23DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT23DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT23DI64.KDT23DI64Pow(const v: TKDT23DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT23DI64.KDT23DI64Distance(const v1, v2: TKDT23DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT23DI64_Axis - 1 do
      Result := Result + KDT23DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT23DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT23DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT23DI64.Test;
var
  TKDT23DI64_Test    : TKDT23DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT23DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT23DI64_Test := TKDT23DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT23DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT23DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT23DI64_Axis - 1 do
        TKDT23DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT23DI64_Test.TestBuff), length(TKDT23DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT23DI64_Test.BuildKDTreeM(length(TKDT23DI64_Test.TestBuff), @TKDT23DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT23DI64_Test.BuildKDTreeM(length(TKDT23DI64_Test.TestBuff), TKDT23DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT23DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT23DI64_Test.TestBuff));
  TKDT23DI64_Test.Search(TKDT23DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT23DI64Distance(TKDT23DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT23DI64_Test.Clear;
  { kMean test }
  TKDT23DI64_Test.BuildKDTreeWithCluster(TKDT23DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT23DI64_Test.Search(TKDT23DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT23DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT23DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT23DI64_Test);
end;


function TKDT24DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT24DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT24DI64_Node;
  function SortCompare(const p1, p2: PKDT24DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT24DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT24DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT24DI64_SourceBuffer;
  dynBuff  : PKDT24DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT24DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT24DI64.GetData(const index: NativeInt): PKDT24DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT24DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT24DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT24DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT24DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT24DI64.StoreBuffPtr: PKDT24DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT24DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT24DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT24DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT24DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT24DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT24DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT24DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT24DI64.BuildKDTreeWithCluster(const inBuff: TKDT24DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT24DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT24DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT24DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT24DI64.BuildKDTreeWithCluster(const inBuff: TKDT24DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI64_BuildCall);
var
  TempStoreBuff: TKDT24DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT24DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT24DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI64_BuildMethod);
var
  TempStoreBuff: TKDT24DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT24DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT24DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT24DI64_BuildProc);
var
  TempStoreBuff: TKDT24DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT24DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT24DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT24DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT24DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT24DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT24DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT24DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT24DI64.Search(const Buff: TKDT24DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT24DI64_Node;

var
  NearestNeighbour: PKDT24DI64_Node;

  function FindParentNode(const BuffPtr: PKDT24DI64_Vec; NodePtr: PKDT24DI64_Node): PKDT24DI64_Node;
  var
    Next       : PKDT24DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT24DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT24DI64_Node; const BuffPtr: PKDT24DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT24DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT24DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT24DI64_Vec; const p1, p2: PKDT24DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT24DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT24DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT24DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT24DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT24DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT24DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT24DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT24DI64.Search(const Buff: TKDT24DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT24DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT24DI64.Search(const Buff: TKDT24DI64_Vec; var SearchedDistanceMin: Double): PKDT24DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT24DI64.Search(const Buff: TKDT24DI64_Vec): PKDT24DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT24DI64.Search(const inBuff: TKDT24DI64_DynamicVecBuffer; var OutBuff: TKDT24DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT24DI64_DynamicVecBuffer;
  outBuffPtr : PKDT24DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT24DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT24DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DI64.Search(const inBuff: TKDT24DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT24DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT24DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT24DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT24DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT24DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT24DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT24DI64_Source));
end;

procedure TKDT24DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT24DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT24DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT24DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT24DI64.PrintNodeTree(const NodePtr: PKDT24DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT24DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT24DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT24DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT24DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT24DI64.KDT24DI64Vec(const s: string): TKDT24DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT24DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT24DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT24DI64.KDT24DI64Vec(const v: TKDT24DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT24DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT24DI64.KDT24DI64Pow(const v: TKDT24DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT24DI64.KDT24DI64Distance(const v1, v2: TKDT24DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT24DI64_Axis - 1 do
      Result := Result + KDT24DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT24DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT24DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT24DI64.Test;
var
  TKDT24DI64_Test    : TKDT24DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT24DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT24DI64_Test := TKDT24DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT24DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT24DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT24DI64_Axis - 1 do
        TKDT24DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT24DI64_Test.TestBuff), length(TKDT24DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT24DI64_Test.BuildKDTreeM(length(TKDT24DI64_Test.TestBuff), @TKDT24DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT24DI64_Test.BuildKDTreeM(length(TKDT24DI64_Test.TestBuff), TKDT24DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT24DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT24DI64_Test.TestBuff));
  TKDT24DI64_Test.Search(TKDT24DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT24DI64Distance(TKDT24DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT24DI64_Test.Clear;
  { kMean test }
  TKDT24DI64_Test.BuildKDTreeWithCluster(TKDT24DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT24DI64_Test.Search(TKDT24DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT24DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT24DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT24DI64_Test);
end;


function TKDT25DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT25DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT25DI64_Node;
  function SortCompare(const p1, p2: PKDT25DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT25DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT25DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT25DI64_SourceBuffer;
  dynBuff  : PKDT25DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT25DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT25DI64.GetData(const index: NativeInt): PKDT25DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT25DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT25DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT25DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT25DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT25DI64.StoreBuffPtr: PKDT25DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT25DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT25DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT25DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT25DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT25DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT25DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT25DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT25DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT25DI64.BuildKDTreeWithCluster(const inBuff: TKDT25DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT25DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT25DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT25DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT25DI64.BuildKDTreeWithCluster(const inBuff: TKDT25DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT25DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DI64_BuildCall);
var
  TempStoreBuff: TKDT25DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT25DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT25DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT25DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT25DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT25DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DI64_BuildMethod);
var
  TempStoreBuff: TKDT25DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT25DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT25DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT25DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT25DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT25DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT25DI64_BuildProc);
var
  TempStoreBuff: TKDT25DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT25DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT25DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT25DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT25DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT25DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT25DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT25DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT25DI64.Search(const Buff: TKDT25DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT25DI64_Node;

var
  NearestNeighbour: PKDT25DI64_Node;

  function FindParentNode(const BuffPtr: PKDT25DI64_Vec; NodePtr: PKDT25DI64_Node): PKDT25DI64_Node;
  var
    Next       : PKDT25DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT25DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT25DI64_Node; const BuffPtr: PKDT25DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT25DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT25DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT25DI64_Vec; const p1, p2: PKDT25DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT25DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT25DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT25DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT25DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT25DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT25DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT25DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT25DI64.Search(const Buff: TKDT25DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT25DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT25DI64.Search(const Buff: TKDT25DI64_Vec; var SearchedDistanceMin: Double): PKDT25DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT25DI64.Search(const Buff: TKDT25DI64_Vec): PKDT25DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT25DI64.Search(const inBuff: TKDT25DI64_DynamicVecBuffer; var OutBuff: TKDT25DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT25DI64_DynamicVecBuffer;
  outBuffPtr : PKDT25DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT25DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT25DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT25DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT25DI64.Search(const inBuff: TKDT25DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT25DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT25DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT25DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT25DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT25DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT25DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT25DI64_Source));
end;

procedure TKDT25DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT25DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT25DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT25DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT25DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT25DI64.PrintNodeTree(const NodePtr: PKDT25DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT25DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT25DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT25DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT25DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT25DI64.KDT25DI64Vec(const s: string): TKDT25DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT25DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT25DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT25DI64.KDT25DI64Vec(const v: TKDT25DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT25DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT25DI64.KDT25DI64Pow(const v: TKDT25DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT25DI64.KDT25DI64Distance(const v1, v2: TKDT25DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT25DI64_Axis - 1 do
      Result := Result + KDT25DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT25DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT25DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT25DI64.Test;
var
  TKDT25DI64_Test    : TKDT25DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT25DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT25DI64_Test := TKDT25DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT25DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT25DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT25DI64_Axis - 1 do
        TKDT25DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT25DI64_Test.TestBuff), length(TKDT25DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT25DI64_Test.BuildKDTreeM(length(TKDT25DI64_Test.TestBuff), @TKDT25DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT25DI64_Test.BuildKDTreeM(length(TKDT25DI64_Test.TestBuff), TKDT25DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT25DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT25DI64_Test.TestBuff));
  TKDT25DI64_Test.Search(TKDT25DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT25DI64Distance(TKDT25DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT25DI64_Test.Clear;
  { kMean test }
  TKDT25DI64_Test.BuildKDTreeWithCluster(TKDT25DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT25DI64_Test.Search(TKDT25DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT25DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT25DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT25DI64_Test);
end;


function TKDT26DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT26DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT26DI64_Node;
  function SortCompare(const p1, p2: PKDT26DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT26DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT26DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT26DI64_SourceBuffer;
  dynBuff  : PKDT26DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT26DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT26DI64.GetData(const index: NativeInt): PKDT26DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT26DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT26DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT26DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT26DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT26DI64.StoreBuffPtr: PKDT26DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT26DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT26DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT26DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT26DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT26DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT26DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT26DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT26DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT26DI64.BuildKDTreeWithCluster(const inBuff: TKDT26DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT26DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT26DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT26DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT26DI64.BuildKDTreeWithCluster(const inBuff: TKDT26DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT26DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DI64_BuildCall);
var
  TempStoreBuff: TKDT26DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT26DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT26DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT26DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT26DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT26DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DI64_BuildMethod);
var
  TempStoreBuff: TKDT26DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT26DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT26DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT26DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT26DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT26DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT26DI64_BuildProc);
var
  TempStoreBuff: TKDT26DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT26DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT26DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT26DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT26DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT26DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT26DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT26DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT26DI64.Search(const Buff: TKDT26DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT26DI64_Node;

var
  NearestNeighbour: PKDT26DI64_Node;

  function FindParentNode(const BuffPtr: PKDT26DI64_Vec; NodePtr: PKDT26DI64_Node): PKDT26DI64_Node;
  var
    Next       : PKDT26DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT26DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT26DI64_Node; const BuffPtr: PKDT26DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT26DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT26DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT26DI64_Vec; const p1, p2: PKDT26DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT26DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT26DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT26DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT26DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT26DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT26DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT26DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT26DI64.Search(const Buff: TKDT26DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT26DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT26DI64.Search(const Buff: TKDT26DI64_Vec; var SearchedDistanceMin: Double): PKDT26DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT26DI64.Search(const Buff: TKDT26DI64_Vec): PKDT26DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT26DI64.Search(const inBuff: TKDT26DI64_DynamicVecBuffer; var OutBuff: TKDT26DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT26DI64_DynamicVecBuffer;
  outBuffPtr : PKDT26DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT26DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT26DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT26DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT26DI64.Search(const inBuff: TKDT26DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT26DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT26DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT26DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT26DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT26DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT26DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT26DI64_Source));
end;

procedure TKDT26DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT26DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT26DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT26DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT26DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT26DI64.PrintNodeTree(const NodePtr: PKDT26DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT26DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT26DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT26DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT26DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT26DI64.KDT26DI64Vec(const s: string): TKDT26DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT26DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT26DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT26DI64.KDT26DI64Vec(const v: TKDT26DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT26DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT26DI64.KDT26DI64Pow(const v: TKDT26DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT26DI64.KDT26DI64Distance(const v1, v2: TKDT26DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT26DI64_Axis - 1 do
      Result := Result + KDT26DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT26DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT26DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT26DI64.Test;
var
  TKDT26DI64_Test    : TKDT26DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT26DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT26DI64_Test := TKDT26DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT26DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT26DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT26DI64_Axis - 1 do
        TKDT26DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT26DI64_Test.TestBuff), length(TKDT26DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT26DI64_Test.BuildKDTreeM(length(TKDT26DI64_Test.TestBuff), @TKDT26DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT26DI64_Test.BuildKDTreeM(length(TKDT26DI64_Test.TestBuff), TKDT26DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT26DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT26DI64_Test.TestBuff));
  TKDT26DI64_Test.Search(TKDT26DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT26DI64Distance(TKDT26DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT26DI64_Test.Clear;
  { kMean test }
  TKDT26DI64_Test.BuildKDTreeWithCluster(TKDT26DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT26DI64_Test.Search(TKDT26DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT26DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT26DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT26DI64_Test);
end;


function TKDT27DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT27DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT27DI64_Node;
  function SortCompare(const p1, p2: PKDT27DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT27DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT27DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT27DI64_SourceBuffer;
  dynBuff  : PKDT27DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT27DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT27DI64.GetData(const index: NativeInt): PKDT27DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT27DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT27DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT27DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT27DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT27DI64.StoreBuffPtr: PKDT27DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT27DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT27DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT27DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT27DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT27DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT27DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT27DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT27DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT27DI64.BuildKDTreeWithCluster(const inBuff: TKDT27DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT27DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT27DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT27DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT27DI64.BuildKDTreeWithCluster(const inBuff: TKDT27DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT27DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DI64_BuildCall);
var
  TempStoreBuff: TKDT27DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT27DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT27DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT27DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT27DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT27DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DI64_BuildMethod);
var
  TempStoreBuff: TKDT27DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT27DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT27DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT27DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT27DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT27DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT27DI64_BuildProc);
var
  TempStoreBuff: TKDT27DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT27DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT27DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT27DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT27DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT27DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT27DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT27DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT27DI64.Search(const Buff: TKDT27DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT27DI64_Node;

var
  NearestNeighbour: PKDT27DI64_Node;

  function FindParentNode(const BuffPtr: PKDT27DI64_Vec; NodePtr: PKDT27DI64_Node): PKDT27DI64_Node;
  var
    Next       : PKDT27DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT27DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT27DI64_Node; const BuffPtr: PKDT27DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT27DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT27DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT27DI64_Vec; const p1, p2: PKDT27DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT27DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT27DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT27DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT27DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT27DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT27DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT27DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT27DI64.Search(const Buff: TKDT27DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT27DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT27DI64.Search(const Buff: TKDT27DI64_Vec; var SearchedDistanceMin: Double): PKDT27DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT27DI64.Search(const Buff: TKDT27DI64_Vec): PKDT27DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT27DI64.Search(const inBuff: TKDT27DI64_DynamicVecBuffer; var OutBuff: TKDT27DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT27DI64_DynamicVecBuffer;
  outBuffPtr : PKDT27DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT27DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT27DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT27DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT27DI64.Search(const inBuff: TKDT27DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT27DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT27DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT27DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT27DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT27DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT27DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT27DI64_Source));
end;

procedure TKDT27DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT27DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT27DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT27DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT27DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT27DI64.PrintNodeTree(const NodePtr: PKDT27DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT27DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT27DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT27DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT27DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT27DI64.KDT27DI64Vec(const s: string): TKDT27DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT27DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT27DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT27DI64.KDT27DI64Vec(const v: TKDT27DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT27DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT27DI64.KDT27DI64Pow(const v: TKDT27DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT27DI64.KDT27DI64Distance(const v1, v2: TKDT27DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT27DI64_Axis - 1 do
      Result := Result + KDT27DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT27DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT27DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT27DI64.Test;
var
  TKDT27DI64_Test    : TKDT27DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT27DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT27DI64_Test := TKDT27DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT27DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT27DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT27DI64_Axis - 1 do
        TKDT27DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT27DI64_Test.TestBuff), length(TKDT27DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT27DI64_Test.BuildKDTreeM(length(TKDT27DI64_Test.TestBuff), @TKDT27DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT27DI64_Test.BuildKDTreeM(length(TKDT27DI64_Test.TestBuff), TKDT27DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT27DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT27DI64_Test.TestBuff));
  TKDT27DI64_Test.Search(TKDT27DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT27DI64Distance(TKDT27DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT27DI64_Test.Clear;
  { kMean test }
  TKDT27DI64_Test.BuildKDTreeWithCluster(TKDT27DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT27DI64_Test.Search(TKDT27DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT27DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT27DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT27DI64_Test);
end;


function TKDT28DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT28DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT28DI64_Node;
  function SortCompare(const p1, p2: PKDT28DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT28DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT28DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT28DI64_SourceBuffer;
  dynBuff  : PKDT28DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT28DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT28DI64.GetData(const index: NativeInt): PKDT28DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT28DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT28DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT28DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT28DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT28DI64.StoreBuffPtr: PKDT28DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT28DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT28DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT28DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT28DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT28DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT28DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT28DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT28DI64.BuildKDTreeWithCluster(const inBuff: TKDT28DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT28DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT28DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT28DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT28DI64.BuildKDTreeWithCluster(const inBuff: TKDT28DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI64_BuildCall);
var
  TempStoreBuff: TKDT28DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT28DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT28DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT28DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT28DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI64_BuildMethod);
var
  TempStoreBuff: TKDT28DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT28DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT28DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT28DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT28DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT28DI64_BuildProc);
var
  TempStoreBuff: TKDT28DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT28DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT28DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT28DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT28DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT28DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT28DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT28DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT28DI64.Search(const Buff: TKDT28DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT28DI64_Node;

var
  NearestNeighbour: PKDT28DI64_Node;

  function FindParentNode(const BuffPtr: PKDT28DI64_Vec; NodePtr: PKDT28DI64_Node): PKDT28DI64_Node;
  var
    Next       : PKDT28DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT28DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT28DI64_Node; const BuffPtr: PKDT28DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT28DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT28DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT28DI64_Vec; const p1, p2: PKDT28DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT28DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT28DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT28DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT28DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT28DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT28DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT28DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT28DI64.Search(const Buff: TKDT28DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT28DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT28DI64.Search(const Buff: TKDT28DI64_Vec; var SearchedDistanceMin: Double): PKDT28DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT28DI64.Search(const Buff: TKDT28DI64_Vec): PKDT28DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT28DI64.Search(const inBuff: TKDT28DI64_DynamicVecBuffer; var OutBuff: TKDT28DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT28DI64_DynamicVecBuffer;
  outBuffPtr : PKDT28DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT28DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT28DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT28DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT28DI64.Search(const inBuff: TKDT28DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT28DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT28DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT28DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT28DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT28DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT28DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT28DI64_Source));
end;

procedure TKDT28DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT28DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT28DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT28DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT28DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT28DI64.PrintNodeTree(const NodePtr: PKDT28DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT28DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT28DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT28DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT28DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT28DI64.KDT28DI64Vec(const s: string): TKDT28DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT28DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT28DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT28DI64.KDT28DI64Vec(const v: TKDT28DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT28DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT28DI64.KDT28DI64Pow(const v: TKDT28DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT28DI64.KDT28DI64Distance(const v1, v2: TKDT28DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT28DI64_Axis - 1 do
      Result := Result + KDT28DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT28DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT28DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT28DI64.Test;
var
  TKDT28DI64_Test    : TKDT28DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT28DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT28DI64_Test := TKDT28DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT28DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT28DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT28DI64_Axis - 1 do
        TKDT28DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT28DI64_Test.TestBuff), length(TKDT28DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT28DI64_Test.BuildKDTreeM(length(TKDT28DI64_Test.TestBuff), @TKDT28DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT28DI64_Test.BuildKDTreeM(length(TKDT28DI64_Test.TestBuff), TKDT28DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT28DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT28DI64_Test.TestBuff));
  TKDT28DI64_Test.Search(TKDT28DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT28DI64Distance(TKDT28DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT28DI64_Test.Clear;
  { kMean test }
  TKDT28DI64_Test.BuildKDTreeWithCluster(TKDT28DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT28DI64_Test.Search(TKDT28DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT28DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT28DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT28DI64_Test);
end;


function TKDT29DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT29DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT29DI64_Node;
  function SortCompare(const p1, p2: PKDT29DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT29DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT29DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT29DI64_SourceBuffer;
  dynBuff  : PKDT29DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT29DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT29DI64.GetData(const index: NativeInt): PKDT29DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT29DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT29DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT29DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT29DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT29DI64.StoreBuffPtr: PKDT29DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT29DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT29DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT29DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT29DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT29DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT29DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT29DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT29DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT29DI64.BuildKDTreeWithCluster(const inBuff: TKDT29DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT29DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT29DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT29DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT29DI64.BuildKDTreeWithCluster(const inBuff: TKDT29DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT29DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DI64_BuildCall);
var
  TempStoreBuff: TKDT29DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT29DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT29DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT29DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT29DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT29DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DI64_BuildMethod);
var
  TempStoreBuff: TKDT29DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT29DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT29DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT29DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT29DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT29DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT29DI64_BuildProc);
var
  TempStoreBuff: TKDT29DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT29DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT29DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT29DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT29DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT29DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT29DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT29DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT29DI64.Search(const Buff: TKDT29DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT29DI64_Node;

var
  NearestNeighbour: PKDT29DI64_Node;

  function FindParentNode(const BuffPtr: PKDT29DI64_Vec; NodePtr: PKDT29DI64_Node): PKDT29DI64_Node;
  var
    Next       : PKDT29DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT29DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT29DI64_Node; const BuffPtr: PKDT29DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT29DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT29DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT29DI64_Vec; const p1, p2: PKDT29DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT29DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT29DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT29DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT29DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT29DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT29DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT29DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT29DI64.Search(const Buff: TKDT29DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT29DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT29DI64.Search(const Buff: TKDT29DI64_Vec; var SearchedDistanceMin: Double): PKDT29DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT29DI64.Search(const Buff: TKDT29DI64_Vec): PKDT29DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT29DI64.Search(const inBuff: TKDT29DI64_DynamicVecBuffer; var OutBuff: TKDT29DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT29DI64_DynamicVecBuffer;
  outBuffPtr : PKDT29DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT29DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT29DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT29DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT29DI64.Search(const inBuff: TKDT29DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT29DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT29DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT29DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT29DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT29DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT29DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT29DI64_Source));
end;

procedure TKDT29DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT29DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT29DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT29DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT29DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT29DI64.PrintNodeTree(const NodePtr: PKDT29DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT29DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT29DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT29DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT29DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT29DI64.KDT29DI64Vec(const s: string): TKDT29DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT29DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT29DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT29DI64.KDT29DI64Vec(const v: TKDT29DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT29DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT29DI64.KDT29DI64Pow(const v: TKDT29DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT29DI64.KDT29DI64Distance(const v1, v2: TKDT29DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT29DI64_Axis - 1 do
      Result := Result + KDT29DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT29DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT29DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT29DI64.Test;
var
  TKDT29DI64_Test    : TKDT29DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT29DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT29DI64_Test := TKDT29DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT29DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT29DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT29DI64_Axis - 1 do
        TKDT29DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT29DI64_Test.TestBuff), length(TKDT29DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT29DI64_Test.BuildKDTreeM(length(TKDT29DI64_Test.TestBuff), @TKDT29DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT29DI64_Test.BuildKDTreeM(length(TKDT29DI64_Test.TestBuff), TKDT29DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT29DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT29DI64_Test.TestBuff));
  TKDT29DI64_Test.Search(TKDT29DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT29DI64Distance(TKDT29DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT29DI64_Test.Clear;
  { kMean test }
  TKDT29DI64_Test.BuildKDTreeWithCluster(TKDT29DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT29DI64_Test.Search(TKDT29DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT29DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT29DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT29DI64_Test);
end;


function TKDT30DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT30DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT30DI64_Node;
  function SortCompare(const p1, p2: PKDT30DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT30DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT30DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT30DI64_SourceBuffer;
  dynBuff  : PKDT30DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT30DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT30DI64.GetData(const index: NativeInt): PKDT30DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT30DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT30DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT30DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT30DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT30DI64.StoreBuffPtr: PKDT30DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT30DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT30DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT30DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT30DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT30DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT30DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT30DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT30DI64.BuildKDTreeWithCluster(const inBuff: TKDT30DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT30DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT30DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT30DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT30DI64.BuildKDTreeWithCluster(const inBuff: TKDT30DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI64_BuildCall);
var
  TempStoreBuff: TKDT30DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT30DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT30DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT30DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT30DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI64_BuildMethod);
var
  TempStoreBuff: TKDT30DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT30DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT30DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT30DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT30DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT30DI64_BuildProc);
var
  TempStoreBuff: TKDT30DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT30DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT30DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT30DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT30DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT30DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT30DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT30DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT30DI64.Search(const Buff: TKDT30DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT30DI64_Node;

var
  NearestNeighbour: PKDT30DI64_Node;

  function FindParentNode(const BuffPtr: PKDT30DI64_Vec; NodePtr: PKDT30DI64_Node): PKDT30DI64_Node;
  var
    Next       : PKDT30DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT30DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT30DI64_Node; const BuffPtr: PKDT30DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT30DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT30DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT30DI64_Vec; const p1, p2: PKDT30DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT30DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT30DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT30DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT30DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT30DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT30DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT30DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT30DI64.Search(const Buff: TKDT30DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT30DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT30DI64.Search(const Buff: TKDT30DI64_Vec; var SearchedDistanceMin: Double): PKDT30DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT30DI64.Search(const Buff: TKDT30DI64_Vec): PKDT30DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT30DI64.Search(const inBuff: TKDT30DI64_DynamicVecBuffer; var OutBuff: TKDT30DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT30DI64_DynamicVecBuffer;
  outBuffPtr : PKDT30DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT30DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT30DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT30DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT30DI64.Search(const inBuff: TKDT30DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT30DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT30DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT30DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT30DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT30DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT30DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT30DI64_Source));
end;

procedure TKDT30DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT30DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT30DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT30DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT30DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT30DI64.PrintNodeTree(const NodePtr: PKDT30DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT30DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT30DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT30DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT30DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT30DI64.KDT30DI64Vec(const s: string): TKDT30DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT30DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT30DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT30DI64.KDT30DI64Vec(const v: TKDT30DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT30DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT30DI64.KDT30DI64Pow(const v: TKDT30DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT30DI64.KDT30DI64Distance(const v1, v2: TKDT30DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT30DI64_Axis - 1 do
      Result := Result + KDT30DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT30DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT30DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT30DI64.Test;
var
  TKDT30DI64_Test    : TKDT30DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT30DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT30DI64_Test := TKDT30DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT30DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT30DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT30DI64_Axis - 1 do
        TKDT30DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT30DI64_Test.TestBuff), length(TKDT30DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT30DI64_Test.BuildKDTreeM(length(TKDT30DI64_Test.TestBuff), @TKDT30DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT30DI64_Test.BuildKDTreeM(length(TKDT30DI64_Test.TestBuff), TKDT30DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT30DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT30DI64_Test.TestBuff));
  TKDT30DI64_Test.Search(TKDT30DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT30DI64Distance(TKDT30DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT30DI64_Test.Clear;
  { kMean test }
  TKDT30DI64_Test.BuildKDTreeWithCluster(TKDT30DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT30DI64_Test.Search(TKDT30DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT30DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT30DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT30DI64_Test);
end;


function TKDT31DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT31DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT31DI64_Node;
  function SortCompare(const p1, p2: PKDT31DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT31DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT31DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT31DI64_SourceBuffer;
  dynBuff  : PKDT31DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT31DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT31DI64.GetData(const index: NativeInt): PKDT31DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT31DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT31DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT31DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT31DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT31DI64.StoreBuffPtr: PKDT31DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT31DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT31DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT31DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT31DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT31DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT31DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT31DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT31DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT31DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT31DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT31DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT31DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT31DI64.BuildKDTreeWithCluster(const inBuff: TKDT31DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT31DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT31DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT31DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT31DI64.BuildKDTreeWithCluster(const inBuff: TKDT31DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT31DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT31DI64_BuildCall);
var
  TempStoreBuff: TKDT31DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT31DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT31DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT31DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT31DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT31DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT31DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT31DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT31DI64_BuildMethod);
var
  TempStoreBuff: TKDT31DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT31DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT31DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT31DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT31DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT31DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT31DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT31DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT31DI64_BuildProc);
var
  TempStoreBuff: TKDT31DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT31DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT31DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT31DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT31DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT31DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT31DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT31DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT31DI64.Search(const Buff: TKDT31DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT31DI64_Node;

var
  NearestNeighbour: PKDT31DI64_Node;

  function FindParentNode(const BuffPtr: PKDT31DI64_Vec; NodePtr: PKDT31DI64_Node): PKDT31DI64_Node;
  var
    Next       : PKDT31DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT31DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT31DI64_Node; const BuffPtr: PKDT31DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT31DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT31DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT31DI64_Vec; const p1, p2: PKDT31DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT31DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT31DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT31DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT31DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT31DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT31DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT31DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT31DI64.Search(const Buff: TKDT31DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT31DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT31DI64.Search(const Buff: TKDT31DI64_Vec; var SearchedDistanceMin: Double): PKDT31DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT31DI64.Search(const Buff: TKDT31DI64_Vec): PKDT31DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT31DI64.Search(const inBuff: TKDT31DI64_DynamicVecBuffer; var OutBuff: TKDT31DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT31DI64_DynamicVecBuffer;
  outBuffPtr : PKDT31DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT31DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT31DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT31DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT31DI64.Search(const inBuff: TKDT31DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT31DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT31DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT31DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT31DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT31DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT31DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT31DI64_Source));
end;

procedure TKDT31DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT31DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT31DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT31DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT31DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT31DI64.PrintNodeTree(const NodePtr: PKDT31DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT31DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT31DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT31DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT31DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT31DI64.KDT31DI64Vec(const s: string): TKDT31DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT31DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT31DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT31DI64.KDT31DI64Vec(const v: TKDT31DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT31DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT31DI64.KDT31DI64Pow(const v: TKDT31DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT31DI64.KDT31DI64Distance(const v1, v2: TKDT31DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT31DI64_Axis - 1 do
      Result := Result + KDT31DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT31DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT31DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT31DI64.Test;
var
  TKDT31DI64_Test    : TKDT31DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT31DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT31DI64_Test := TKDT31DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT31DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT31DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT31DI64_Axis - 1 do
        TKDT31DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT31DI64_Test.TestBuff), length(TKDT31DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT31DI64_Test.BuildKDTreeM(length(TKDT31DI64_Test.TestBuff), @TKDT31DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT31DI64_Test.BuildKDTreeM(length(TKDT31DI64_Test.TestBuff), TKDT31DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT31DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT31DI64_Test.TestBuff));
  TKDT31DI64_Test.Search(TKDT31DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT31DI64Distance(TKDT31DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT31DI64_Test.Clear;
  { kMean test }
  TKDT31DI64_Test.BuildKDTreeWithCluster(TKDT31DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT31DI64_Test.Search(TKDT31DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT31DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT31DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT31DI64_Test);
end;


function TKDT32DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT32DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT32DI64_Node;
  function SortCompare(const p1, p2: PKDT32DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT32DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT32DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT32DI64_SourceBuffer;
  dynBuff  : PKDT32DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT32DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT32DI64.GetData(const index: NativeInt): PKDT32DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT32DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT32DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT32DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT32DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT32DI64.StoreBuffPtr: PKDT32DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT32DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT32DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT32DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT32DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT32DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT32DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT32DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT32DI64.BuildKDTreeWithCluster(const inBuff: TKDT32DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT32DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT32DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT32DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT32DI64.BuildKDTreeWithCluster(const inBuff: TKDT32DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI64_BuildCall);
var
  TempStoreBuff: TKDT32DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT32DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT32DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT32DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT32DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI64_BuildMethod);
var
  TempStoreBuff: TKDT32DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT32DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT32DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT32DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT32DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT32DI64_BuildProc);
var
  TempStoreBuff: TKDT32DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT32DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT32DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT32DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT32DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT32DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT32DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT32DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT32DI64.Search(const Buff: TKDT32DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT32DI64_Node;

var
  NearestNeighbour: PKDT32DI64_Node;

  function FindParentNode(const BuffPtr: PKDT32DI64_Vec; NodePtr: PKDT32DI64_Node): PKDT32DI64_Node;
  var
    Next       : PKDT32DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT32DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT32DI64_Node; const BuffPtr: PKDT32DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT32DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT32DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT32DI64_Vec; const p1, p2: PKDT32DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT32DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT32DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT32DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT32DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT32DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT32DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT32DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT32DI64.Search(const Buff: TKDT32DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT32DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT32DI64.Search(const Buff: TKDT32DI64_Vec; var SearchedDistanceMin: Double): PKDT32DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT32DI64.Search(const Buff: TKDT32DI64_Vec): PKDT32DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT32DI64.Search(const inBuff: TKDT32DI64_DynamicVecBuffer; var OutBuff: TKDT32DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT32DI64_DynamicVecBuffer;
  outBuffPtr : PKDT32DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT32DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT32DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT32DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT32DI64.Search(const inBuff: TKDT32DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT32DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT32DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT32DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT32DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT32DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT32DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT32DI64_Source));
end;

procedure TKDT32DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT32DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT32DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT32DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT32DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT32DI64.PrintNodeTree(const NodePtr: PKDT32DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT32DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT32DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT32DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT32DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT32DI64.KDT32DI64Vec(const s: string): TKDT32DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT32DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT32DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT32DI64.KDT32DI64Vec(const v: TKDT32DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT32DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT32DI64.KDT32DI64Pow(const v: TKDT32DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT32DI64.KDT32DI64Distance(const v1, v2: TKDT32DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT32DI64_Axis - 1 do
      Result := Result + KDT32DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT32DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT32DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT32DI64.Test;
var
  TKDT32DI64_Test    : TKDT32DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT32DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT32DI64_Test := TKDT32DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT32DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT32DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT32DI64_Axis - 1 do
        TKDT32DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT32DI64_Test.TestBuff), length(TKDT32DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT32DI64_Test.BuildKDTreeM(length(TKDT32DI64_Test.TestBuff), @TKDT32DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT32DI64_Test.BuildKDTreeM(length(TKDT32DI64_Test.TestBuff), TKDT32DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT32DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT32DI64_Test.TestBuff));
  TKDT32DI64_Test.Search(TKDT32DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT32DI64Distance(TKDT32DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT32DI64_Test.Clear;
  { kMean test }
  TKDT32DI64_Test.BuildKDTreeWithCluster(TKDT32DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT32DI64_Test.Search(TKDT32DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT32DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT32DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT32DI64_Test);
end;


function TKDT33DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT33DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT33DI64_Node;
  function SortCompare(const p1, p2: PKDT33DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT33DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT33DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT33DI64_SourceBuffer;
  dynBuff  : PKDT33DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT33DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT33DI64.GetData(const index: NativeInt): PKDT33DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT33DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT33DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT33DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT33DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT33DI64.StoreBuffPtr: PKDT33DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT33DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT33DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT33DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT33DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT33DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT33DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT33DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT33DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT33DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT33DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT33DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT33DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT33DI64.BuildKDTreeWithCluster(const inBuff: TKDT33DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT33DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT33DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT33DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT33DI64.BuildKDTreeWithCluster(const inBuff: TKDT33DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT33DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT33DI64_BuildCall);
var
  TempStoreBuff: TKDT33DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT33DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT33DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT33DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT33DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT33DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT33DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT33DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT33DI64_BuildMethod);
var
  TempStoreBuff: TKDT33DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT33DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT33DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT33DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT33DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT33DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT33DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT33DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT33DI64_BuildProc);
var
  TempStoreBuff: TKDT33DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT33DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT33DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT33DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT33DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT33DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT33DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT33DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT33DI64.Search(const Buff: TKDT33DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT33DI64_Node;

var
  NearestNeighbour: PKDT33DI64_Node;

  function FindParentNode(const BuffPtr: PKDT33DI64_Vec; NodePtr: PKDT33DI64_Node): PKDT33DI64_Node;
  var
    Next       : PKDT33DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT33DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT33DI64_Node; const BuffPtr: PKDT33DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT33DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT33DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT33DI64_Vec; const p1, p2: PKDT33DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT33DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT33DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT33DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT33DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT33DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT33DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT33DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT33DI64.Search(const Buff: TKDT33DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT33DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT33DI64.Search(const Buff: TKDT33DI64_Vec; var SearchedDistanceMin: Double): PKDT33DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT33DI64.Search(const Buff: TKDT33DI64_Vec): PKDT33DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT33DI64.Search(const inBuff: TKDT33DI64_DynamicVecBuffer; var OutBuff: TKDT33DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT33DI64_DynamicVecBuffer;
  outBuffPtr : PKDT33DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT33DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT33DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT33DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT33DI64.Search(const inBuff: TKDT33DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT33DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT33DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT33DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT33DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT33DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT33DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT33DI64_Source));
end;

procedure TKDT33DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT33DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT33DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT33DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT33DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT33DI64.PrintNodeTree(const NodePtr: PKDT33DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT33DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT33DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT33DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT33DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT33DI64.KDT33DI64Vec(const s: string): TKDT33DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT33DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT33DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT33DI64.KDT33DI64Vec(const v: TKDT33DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT33DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT33DI64.KDT33DI64Pow(const v: TKDT33DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT33DI64.KDT33DI64Distance(const v1, v2: TKDT33DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT33DI64_Axis - 1 do
      Result := Result + KDT33DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT33DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT33DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT33DI64.Test;
var
  TKDT33DI64_Test    : TKDT33DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT33DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT33DI64_Test := TKDT33DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT33DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT33DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT33DI64_Axis - 1 do
        TKDT33DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT33DI64_Test.TestBuff), length(TKDT33DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT33DI64_Test.BuildKDTreeM(length(TKDT33DI64_Test.TestBuff), @TKDT33DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT33DI64_Test.BuildKDTreeM(length(TKDT33DI64_Test.TestBuff), TKDT33DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT33DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT33DI64_Test.TestBuff));
  TKDT33DI64_Test.Search(TKDT33DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT33DI64Distance(TKDT33DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT33DI64_Test.Clear;
  { kMean test }
  TKDT33DI64_Test.BuildKDTreeWithCluster(TKDT33DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT33DI64_Test.Search(TKDT33DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT33DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT33DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT33DI64_Test);
end;


function TKDT34DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT34DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT34DI64_Node;
  function SortCompare(const p1, p2: PKDT34DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT34DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT34DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT34DI64_SourceBuffer;
  dynBuff  : PKDT34DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT34DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT34DI64.GetData(const index: NativeInt): PKDT34DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT34DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT34DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT34DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT34DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT34DI64.StoreBuffPtr: PKDT34DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT34DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT34DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT34DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT34DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT34DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT34DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT34DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT34DI64.BuildKDTreeWithCluster(const inBuff: TKDT34DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT34DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT34DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT34DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT34DI64.BuildKDTreeWithCluster(const inBuff: TKDT34DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI64_BuildCall);
var
  TempStoreBuff: TKDT34DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT34DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT34DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT34DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT34DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI64_BuildMethod);
var
  TempStoreBuff: TKDT34DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT34DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT34DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT34DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT34DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT34DI64_BuildProc);
var
  TempStoreBuff: TKDT34DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT34DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT34DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT34DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT34DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT34DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT34DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT34DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT34DI64.Search(const Buff: TKDT34DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT34DI64_Node;

var
  NearestNeighbour: PKDT34DI64_Node;

  function FindParentNode(const BuffPtr: PKDT34DI64_Vec; NodePtr: PKDT34DI64_Node): PKDT34DI64_Node;
  var
    Next       : PKDT34DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT34DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT34DI64_Node; const BuffPtr: PKDT34DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT34DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT34DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT34DI64_Vec; const p1, p2: PKDT34DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT34DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT34DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT34DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT34DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT34DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT34DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT34DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT34DI64.Search(const Buff: TKDT34DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT34DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT34DI64.Search(const Buff: TKDT34DI64_Vec; var SearchedDistanceMin: Double): PKDT34DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT34DI64.Search(const Buff: TKDT34DI64_Vec): PKDT34DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT34DI64.Search(const inBuff: TKDT34DI64_DynamicVecBuffer; var OutBuff: TKDT34DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT34DI64_DynamicVecBuffer;
  outBuffPtr : PKDT34DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT34DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT34DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT34DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT34DI64.Search(const inBuff: TKDT34DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT34DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT34DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT34DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT34DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT34DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT34DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT34DI64_Source));
end;

procedure TKDT34DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT34DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT34DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT34DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT34DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT34DI64.PrintNodeTree(const NodePtr: PKDT34DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT34DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT34DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT34DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT34DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT34DI64.KDT34DI64Vec(const s: string): TKDT34DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT34DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT34DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT34DI64.KDT34DI64Vec(const v: TKDT34DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT34DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT34DI64.KDT34DI64Pow(const v: TKDT34DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT34DI64.KDT34DI64Distance(const v1, v2: TKDT34DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT34DI64_Axis - 1 do
      Result := Result + KDT34DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT34DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT34DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT34DI64.Test;
var
  TKDT34DI64_Test    : TKDT34DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT34DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT34DI64_Test := TKDT34DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT34DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT34DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT34DI64_Axis - 1 do
        TKDT34DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT34DI64_Test.TestBuff), length(TKDT34DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT34DI64_Test.BuildKDTreeM(length(TKDT34DI64_Test.TestBuff), @TKDT34DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT34DI64_Test.BuildKDTreeM(length(TKDT34DI64_Test.TestBuff), TKDT34DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT34DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT34DI64_Test.TestBuff));
  TKDT34DI64_Test.Search(TKDT34DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT34DI64Distance(TKDT34DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT34DI64_Test.Clear;
  { kMean test }
  TKDT34DI64_Test.BuildKDTreeWithCluster(TKDT34DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT34DI64_Test.Search(TKDT34DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT34DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT34DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT34DI64_Test);
end;


function TKDT35DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT35DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT35DI64_Node;
  function SortCompare(const p1, p2: PKDT35DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT35DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT35DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT35DI64_SourceBuffer;
  dynBuff  : PKDT35DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT35DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT35DI64.GetData(const index: NativeInt): PKDT35DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT35DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT35DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT35DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT35DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT35DI64.StoreBuffPtr: PKDT35DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT35DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT35DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT35DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT35DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT35DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT35DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT35DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT35DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT35DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT35DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT35DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT35DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT35DI64.BuildKDTreeWithCluster(const inBuff: TKDT35DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT35DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT35DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT35DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT35DI64.BuildKDTreeWithCluster(const inBuff: TKDT35DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT35DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT35DI64_BuildCall);
var
  TempStoreBuff: TKDT35DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT35DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT35DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT35DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT35DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT35DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT35DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT35DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT35DI64_BuildMethod);
var
  TempStoreBuff: TKDT35DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT35DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT35DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT35DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT35DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT35DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT35DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT35DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT35DI64_BuildProc);
var
  TempStoreBuff: TKDT35DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT35DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT35DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT35DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT35DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT35DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT35DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT35DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT35DI64.Search(const Buff: TKDT35DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT35DI64_Node;

var
  NearestNeighbour: PKDT35DI64_Node;

  function FindParentNode(const BuffPtr: PKDT35DI64_Vec; NodePtr: PKDT35DI64_Node): PKDT35DI64_Node;
  var
    Next       : PKDT35DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT35DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT35DI64_Node; const BuffPtr: PKDT35DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT35DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT35DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT35DI64_Vec; const p1, p2: PKDT35DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT35DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT35DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT35DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT35DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT35DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT35DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT35DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT35DI64.Search(const Buff: TKDT35DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT35DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT35DI64.Search(const Buff: TKDT35DI64_Vec; var SearchedDistanceMin: Double): PKDT35DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT35DI64.Search(const Buff: TKDT35DI64_Vec): PKDT35DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT35DI64.Search(const inBuff: TKDT35DI64_DynamicVecBuffer; var OutBuff: TKDT35DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT35DI64_DynamicVecBuffer;
  outBuffPtr : PKDT35DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT35DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT35DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT35DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT35DI64.Search(const inBuff: TKDT35DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT35DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT35DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT35DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT35DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT35DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT35DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT35DI64_Source));
end;

procedure TKDT35DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT35DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT35DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT35DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT35DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT35DI64.PrintNodeTree(const NodePtr: PKDT35DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT35DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT35DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT35DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT35DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT35DI64.KDT35DI64Vec(const s: string): TKDT35DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT35DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT35DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT35DI64.KDT35DI64Vec(const v: TKDT35DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT35DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT35DI64.KDT35DI64Pow(const v: TKDT35DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT35DI64.KDT35DI64Distance(const v1, v2: TKDT35DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT35DI64_Axis - 1 do
      Result := Result + KDT35DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT35DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT35DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT35DI64.Test;
var
  TKDT35DI64_Test    : TKDT35DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT35DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT35DI64_Test := TKDT35DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT35DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT35DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT35DI64_Axis - 1 do
        TKDT35DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT35DI64_Test.TestBuff), length(TKDT35DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT35DI64_Test.BuildKDTreeM(length(TKDT35DI64_Test.TestBuff), @TKDT35DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT35DI64_Test.BuildKDTreeM(length(TKDT35DI64_Test.TestBuff), TKDT35DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT35DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT35DI64_Test.TestBuff));
  TKDT35DI64_Test.Search(TKDT35DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT35DI64Distance(TKDT35DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT35DI64_Test.Clear;
  { kMean test }
  TKDT35DI64_Test.BuildKDTreeWithCluster(TKDT35DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT35DI64_Test.Search(TKDT35DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT35DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT35DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT35DI64_Test);
end;


function TKDT36DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT36DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT36DI64_Node;
  function SortCompare(const p1, p2: PKDT36DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT36DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT36DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT36DI64_SourceBuffer;
  dynBuff  : PKDT36DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT36DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT36DI64.GetData(const index: NativeInt): PKDT36DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT36DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT36DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT36DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT36DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT36DI64.StoreBuffPtr: PKDT36DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT36DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT36DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT36DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT36DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT36DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT36DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT36DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT36DI64.BuildKDTreeWithCluster(const inBuff: TKDT36DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT36DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT36DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT36DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT36DI64.BuildKDTreeWithCluster(const inBuff: TKDT36DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI64_BuildCall);
var
  TempStoreBuff: TKDT36DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT36DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT36DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT36DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT36DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI64_BuildMethod);
var
  TempStoreBuff: TKDT36DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT36DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT36DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT36DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT36DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT36DI64_BuildProc);
var
  TempStoreBuff: TKDT36DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT36DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT36DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT36DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT36DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT36DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT36DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT36DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT36DI64.Search(const Buff: TKDT36DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT36DI64_Node;

var
  NearestNeighbour: PKDT36DI64_Node;

  function FindParentNode(const BuffPtr: PKDT36DI64_Vec; NodePtr: PKDT36DI64_Node): PKDT36DI64_Node;
  var
    Next       : PKDT36DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT36DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT36DI64_Node; const BuffPtr: PKDT36DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT36DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT36DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT36DI64_Vec; const p1, p2: PKDT36DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT36DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT36DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT36DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT36DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT36DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT36DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT36DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT36DI64.Search(const Buff: TKDT36DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT36DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT36DI64.Search(const Buff: TKDT36DI64_Vec; var SearchedDistanceMin: Double): PKDT36DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT36DI64.Search(const Buff: TKDT36DI64_Vec): PKDT36DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT36DI64.Search(const inBuff: TKDT36DI64_DynamicVecBuffer; var OutBuff: TKDT36DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT36DI64_DynamicVecBuffer;
  outBuffPtr : PKDT36DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT36DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT36DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT36DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT36DI64.Search(const inBuff: TKDT36DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT36DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT36DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT36DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT36DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT36DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT36DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT36DI64_Source));
end;

procedure TKDT36DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT36DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT36DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT36DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT36DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT36DI64.PrintNodeTree(const NodePtr: PKDT36DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT36DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT36DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT36DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT36DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT36DI64.KDT36DI64Vec(const s: string): TKDT36DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT36DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT36DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT36DI64.KDT36DI64Vec(const v: TKDT36DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT36DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT36DI64.KDT36DI64Pow(const v: TKDT36DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT36DI64.KDT36DI64Distance(const v1, v2: TKDT36DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT36DI64_Axis - 1 do
      Result := Result + KDT36DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT36DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT36DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT36DI64.Test;
var
  TKDT36DI64_Test    : TKDT36DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT36DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT36DI64_Test := TKDT36DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT36DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT36DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT36DI64_Axis - 1 do
        TKDT36DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT36DI64_Test.TestBuff), length(TKDT36DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT36DI64_Test.BuildKDTreeM(length(TKDT36DI64_Test.TestBuff), @TKDT36DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT36DI64_Test.BuildKDTreeM(length(TKDT36DI64_Test.TestBuff), TKDT36DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT36DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT36DI64_Test.TestBuff));
  TKDT36DI64_Test.Search(TKDT36DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT36DI64Distance(TKDT36DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT36DI64_Test.Clear;
  { kMean test }
  TKDT36DI64_Test.BuildKDTreeWithCluster(TKDT36DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT36DI64_Test.Search(TKDT36DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT36DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT36DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT36DI64_Test);
end;


function TKDT37DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT37DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT37DI64_Node;
  function SortCompare(const p1, p2: PKDT37DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT37DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT37DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT37DI64_SourceBuffer;
  dynBuff  : PKDT37DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT37DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT37DI64.GetData(const index: NativeInt): PKDT37DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT37DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT37DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT37DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT37DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT37DI64.StoreBuffPtr: PKDT37DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT37DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT37DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT37DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT37DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT37DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT37DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT37DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT37DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT37DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT37DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT37DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT37DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT37DI64.BuildKDTreeWithCluster(const inBuff: TKDT37DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT37DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT37DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT37DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT37DI64.BuildKDTreeWithCluster(const inBuff: TKDT37DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT37DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT37DI64_BuildCall);
var
  TempStoreBuff: TKDT37DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT37DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT37DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT37DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT37DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT37DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT37DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT37DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT37DI64_BuildMethod);
var
  TempStoreBuff: TKDT37DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT37DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT37DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT37DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT37DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT37DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT37DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT37DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT37DI64_BuildProc);
var
  TempStoreBuff: TKDT37DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT37DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT37DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT37DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT37DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT37DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT37DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT37DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT37DI64.Search(const Buff: TKDT37DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT37DI64_Node;

var
  NearestNeighbour: PKDT37DI64_Node;

  function FindParentNode(const BuffPtr: PKDT37DI64_Vec; NodePtr: PKDT37DI64_Node): PKDT37DI64_Node;
  var
    Next       : PKDT37DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT37DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT37DI64_Node; const BuffPtr: PKDT37DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT37DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT37DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT37DI64_Vec; const p1, p2: PKDT37DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT37DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT37DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT37DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT37DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT37DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT37DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT37DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT37DI64.Search(const Buff: TKDT37DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT37DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT37DI64.Search(const Buff: TKDT37DI64_Vec; var SearchedDistanceMin: Double): PKDT37DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT37DI64.Search(const Buff: TKDT37DI64_Vec): PKDT37DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT37DI64.Search(const inBuff: TKDT37DI64_DynamicVecBuffer; var OutBuff: TKDT37DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT37DI64_DynamicVecBuffer;
  outBuffPtr : PKDT37DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT37DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT37DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT37DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT37DI64.Search(const inBuff: TKDT37DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT37DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT37DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT37DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT37DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT37DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT37DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT37DI64_Source));
end;

procedure TKDT37DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT37DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT37DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT37DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT37DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT37DI64.PrintNodeTree(const NodePtr: PKDT37DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT37DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT37DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT37DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT37DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT37DI64.KDT37DI64Vec(const s: string): TKDT37DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT37DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT37DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT37DI64.KDT37DI64Vec(const v: TKDT37DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT37DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT37DI64.KDT37DI64Pow(const v: TKDT37DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT37DI64.KDT37DI64Distance(const v1, v2: TKDT37DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT37DI64_Axis - 1 do
      Result := Result + KDT37DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT37DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT37DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT37DI64.Test;
var
  TKDT37DI64_Test    : TKDT37DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT37DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT37DI64_Test := TKDT37DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT37DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT37DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT37DI64_Axis - 1 do
        TKDT37DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT37DI64_Test.TestBuff), length(TKDT37DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT37DI64_Test.BuildKDTreeM(length(TKDT37DI64_Test.TestBuff), @TKDT37DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT37DI64_Test.BuildKDTreeM(length(TKDT37DI64_Test.TestBuff), TKDT37DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT37DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT37DI64_Test.TestBuff));
  TKDT37DI64_Test.Search(TKDT37DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT37DI64Distance(TKDT37DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT37DI64_Test.Clear;
  { kMean test }
  TKDT37DI64_Test.BuildKDTreeWithCluster(TKDT37DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT37DI64_Test.Search(TKDT37DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT37DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT37DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT37DI64_Test);
end;


function TKDT38DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT38DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT38DI64_Node;
  function SortCompare(const p1, p2: PKDT38DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT38DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT38DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT38DI64_SourceBuffer;
  dynBuff  : PKDT38DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT38DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT38DI64.GetData(const index: NativeInt): PKDT38DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT38DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT38DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT38DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT38DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT38DI64.StoreBuffPtr: PKDT38DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT38DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT38DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT38DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT38DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT38DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT38DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT38DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT38DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT38DI64.BuildKDTreeWithCluster(const inBuff: TKDT38DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT38DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT38DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT38DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT38DI64.BuildKDTreeWithCluster(const inBuff: TKDT38DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT38DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DI64_BuildCall);
var
  TempStoreBuff: TKDT38DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT38DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT38DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT38DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT38DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT38DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DI64_BuildMethod);
var
  TempStoreBuff: TKDT38DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT38DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT38DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT38DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT38DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT38DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT38DI64_BuildProc);
var
  TempStoreBuff: TKDT38DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT38DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT38DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT38DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT38DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT38DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT38DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT38DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT38DI64.Search(const Buff: TKDT38DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT38DI64_Node;

var
  NearestNeighbour: PKDT38DI64_Node;

  function FindParentNode(const BuffPtr: PKDT38DI64_Vec; NodePtr: PKDT38DI64_Node): PKDT38DI64_Node;
  var
    Next       : PKDT38DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT38DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT38DI64_Node; const BuffPtr: PKDT38DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT38DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT38DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT38DI64_Vec; const p1, p2: PKDT38DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT38DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT38DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT38DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT38DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT38DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT38DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT38DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT38DI64.Search(const Buff: TKDT38DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT38DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT38DI64.Search(const Buff: TKDT38DI64_Vec; var SearchedDistanceMin: Double): PKDT38DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT38DI64.Search(const Buff: TKDT38DI64_Vec): PKDT38DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT38DI64.Search(const inBuff: TKDT38DI64_DynamicVecBuffer; var OutBuff: TKDT38DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT38DI64_DynamicVecBuffer;
  outBuffPtr : PKDT38DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT38DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT38DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT38DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT38DI64.Search(const inBuff: TKDT38DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT38DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT38DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT38DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT38DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT38DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT38DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT38DI64_Source));
end;

procedure TKDT38DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT38DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT38DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT38DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT38DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT38DI64.PrintNodeTree(const NodePtr: PKDT38DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT38DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT38DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT38DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT38DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT38DI64.KDT38DI64Vec(const s: string): TKDT38DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT38DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT38DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT38DI64.KDT38DI64Vec(const v: TKDT38DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT38DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT38DI64.KDT38DI64Pow(const v: TKDT38DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT38DI64.KDT38DI64Distance(const v1, v2: TKDT38DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT38DI64_Axis - 1 do
      Result := Result + KDT38DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT38DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT38DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT38DI64.Test;
var
  TKDT38DI64_Test    : TKDT38DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT38DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT38DI64_Test := TKDT38DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT38DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT38DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT38DI64_Axis - 1 do
        TKDT38DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT38DI64_Test.TestBuff), length(TKDT38DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT38DI64_Test.BuildKDTreeM(length(TKDT38DI64_Test.TestBuff), @TKDT38DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT38DI64_Test.BuildKDTreeM(length(TKDT38DI64_Test.TestBuff), TKDT38DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT38DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT38DI64_Test.TestBuff));
  TKDT38DI64_Test.Search(TKDT38DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT38DI64Distance(TKDT38DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT38DI64_Test.Clear;
  { kMean test }
  TKDT38DI64_Test.BuildKDTreeWithCluster(TKDT38DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT38DI64_Test.Search(TKDT38DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT38DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT38DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT38DI64_Test);
end;


function TKDT39DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT39DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT39DI64_Node;
  function SortCompare(const p1, p2: PKDT39DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT39DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT39DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT39DI64_SourceBuffer;
  dynBuff  : PKDT39DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT39DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT39DI64.GetData(const index: NativeInt): PKDT39DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT39DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT39DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT39DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT39DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT39DI64.StoreBuffPtr: PKDT39DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT39DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT39DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT39DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT39DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT39DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT39DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT39DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT39DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT39DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT39DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT39DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT39DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT39DI64.BuildKDTreeWithCluster(const inBuff: TKDT39DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT39DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT39DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT39DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT39DI64.BuildKDTreeWithCluster(const inBuff: TKDT39DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT39DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT39DI64_BuildCall);
var
  TempStoreBuff: TKDT39DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT39DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT39DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT39DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT39DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT39DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT39DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT39DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT39DI64_BuildMethod);
var
  TempStoreBuff: TKDT39DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT39DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT39DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT39DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT39DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT39DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT39DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT39DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT39DI64_BuildProc);
var
  TempStoreBuff: TKDT39DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT39DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT39DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT39DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT39DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT39DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT39DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT39DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT39DI64.Search(const Buff: TKDT39DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT39DI64_Node;

var
  NearestNeighbour: PKDT39DI64_Node;

  function FindParentNode(const BuffPtr: PKDT39DI64_Vec; NodePtr: PKDT39DI64_Node): PKDT39DI64_Node;
  var
    Next       : PKDT39DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT39DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT39DI64_Node; const BuffPtr: PKDT39DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT39DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT39DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT39DI64_Vec; const p1, p2: PKDT39DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT39DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT39DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT39DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT39DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT39DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT39DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT39DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT39DI64.Search(const Buff: TKDT39DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT39DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT39DI64.Search(const Buff: TKDT39DI64_Vec; var SearchedDistanceMin: Double): PKDT39DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT39DI64.Search(const Buff: TKDT39DI64_Vec): PKDT39DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT39DI64.Search(const inBuff: TKDT39DI64_DynamicVecBuffer; var OutBuff: TKDT39DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT39DI64_DynamicVecBuffer;
  outBuffPtr : PKDT39DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT39DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT39DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT39DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT39DI64.Search(const inBuff: TKDT39DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT39DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT39DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT39DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT39DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT39DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT39DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT39DI64_Source));
end;

procedure TKDT39DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT39DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT39DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT39DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT39DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT39DI64.PrintNodeTree(const NodePtr: PKDT39DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT39DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT39DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT39DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT39DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT39DI64.KDT39DI64Vec(const s: string): TKDT39DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT39DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT39DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT39DI64.KDT39DI64Vec(const v: TKDT39DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT39DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT39DI64.KDT39DI64Pow(const v: TKDT39DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT39DI64.KDT39DI64Distance(const v1, v2: TKDT39DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT39DI64_Axis - 1 do
      Result := Result + KDT39DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT39DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT39DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT39DI64.Test;
var
  TKDT39DI64_Test    : TKDT39DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT39DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT39DI64_Test := TKDT39DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT39DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT39DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT39DI64_Axis - 1 do
        TKDT39DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT39DI64_Test.TestBuff), length(TKDT39DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT39DI64_Test.BuildKDTreeM(length(TKDT39DI64_Test.TestBuff), @TKDT39DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT39DI64_Test.BuildKDTreeM(length(TKDT39DI64_Test.TestBuff), TKDT39DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT39DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT39DI64_Test.TestBuff));
  TKDT39DI64_Test.Search(TKDT39DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT39DI64Distance(TKDT39DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT39DI64_Test.Clear;
  { kMean test }
  TKDT39DI64_Test.BuildKDTreeWithCluster(TKDT39DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT39DI64_Test.Search(TKDT39DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT39DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT39DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT39DI64_Test);
end;


function TKDT40DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT40DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT40DI64_Node;
  function SortCompare(const p1, p2: PKDT40DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT40DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT40DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT40DI64_SourceBuffer;
  dynBuff  : PKDT40DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT40DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT40DI64.GetData(const index: NativeInt): PKDT40DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT40DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT40DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT40DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT40DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT40DI64.StoreBuffPtr: PKDT40DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT40DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT40DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT40DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT40DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT40DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT40DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT40DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT40DI64.BuildKDTreeWithCluster(const inBuff: TKDT40DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT40DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT40DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT40DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT40DI64.BuildKDTreeWithCluster(const inBuff: TKDT40DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI64_BuildCall);
var
  TempStoreBuff: TKDT40DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT40DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT40DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT40DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT40DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI64_BuildMethod);
var
  TempStoreBuff: TKDT40DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT40DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT40DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT40DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT40DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT40DI64_BuildProc);
var
  TempStoreBuff: TKDT40DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT40DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT40DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT40DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT40DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT40DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT40DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT40DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT40DI64.Search(const Buff: TKDT40DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT40DI64_Node;

var
  NearestNeighbour: PKDT40DI64_Node;

  function FindParentNode(const BuffPtr: PKDT40DI64_Vec; NodePtr: PKDT40DI64_Node): PKDT40DI64_Node;
  var
    Next       : PKDT40DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT40DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT40DI64_Node; const BuffPtr: PKDT40DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT40DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT40DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT40DI64_Vec; const p1, p2: PKDT40DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT40DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT40DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT40DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT40DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT40DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT40DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT40DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT40DI64.Search(const Buff: TKDT40DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT40DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT40DI64.Search(const Buff: TKDT40DI64_Vec; var SearchedDistanceMin: Double): PKDT40DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT40DI64.Search(const Buff: TKDT40DI64_Vec): PKDT40DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT40DI64.Search(const inBuff: TKDT40DI64_DynamicVecBuffer; var OutBuff: TKDT40DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT40DI64_DynamicVecBuffer;
  outBuffPtr : PKDT40DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT40DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT40DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT40DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT40DI64.Search(const inBuff: TKDT40DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT40DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT40DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT40DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT40DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT40DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT40DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT40DI64_Source));
end;

procedure TKDT40DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT40DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT40DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT40DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT40DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT40DI64.PrintNodeTree(const NodePtr: PKDT40DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT40DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT40DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT40DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT40DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT40DI64.KDT40DI64Vec(const s: string): TKDT40DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT40DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT40DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT40DI64.KDT40DI64Vec(const v: TKDT40DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT40DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT40DI64.KDT40DI64Pow(const v: TKDT40DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT40DI64.KDT40DI64Distance(const v1, v2: TKDT40DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT40DI64_Axis - 1 do
      Result := Result + KDT40DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT40DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT40DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT40DI64.Test;
var
  TKDT40DI64_Test    : TKDT40DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT40DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT40DI64_Test := TKDT40DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT40DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT40DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT40DI64_Axis - 1 do
        TKDT40DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT40DI64_Test.TestBuff), length(TKDT40DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT40DI64_Test.BuildKDTreeM(length(TKDT40DI64_Test.TestBuff), @TKDT40DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT40DI64_Test.BuildKDTreeM(length(TKDT40DI64_Test.TestBuff), TKDT40DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT40DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT40DI64_Test.TestBuff));
  TKDT40DI64_Test.Search(TKDT40DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT40DI64Distance(TKDT40DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT40DI64_Test.Clear;
  { kMean test }
  TKDT40DI64_Test.BuildKDTreeWithCluster(TKDT40DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT40DI64_Test.Search(TKDT40DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT40DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT40DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT40DI64_Test);
end;


function TKDT41DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT41DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT41DI64_Node;
  function SortCompare(const p1, p2: PKDT41DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT41DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT41DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT41DI64_SourceBuffer;
  dynBuff  : PKDT41DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT41DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT41DI64.GetData(const index: NativeInt): PKDT41DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT41DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT41DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT41DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT41DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT41DI64.StoreBuffPtr: PKDT41DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT41DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT41DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT41DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT41DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT41DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT41DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT41DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT41DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT41DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT41DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT41DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT41DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT41DI64.BuildKDTreeWithCluster(const inBuff: TKDT41DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT41DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT41DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT41DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT41DI64.BuildKDTreeWithCluster(const inBuff: TKDT41DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT41DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT41DI64_BuildCall);
var
  TempStoreBuff: TKDT41DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT41DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT41DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT41DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT41DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT41DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT41DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT41DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT41DI64_BuildMethod);
var
  TempStoreBuff: TKDT41DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT41DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT41DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT41DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT41DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT41DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT41DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT41DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT41DI64_BuildProc);
var
  TempStoreBuff: TKDT41DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT41DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT41DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT41DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT41DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT41DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT41DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT41DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT41DI64.Search(const Buff: TKDT41DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT41DI64_Node;

var
  NearestNeighbour: PKDT41DI64_Node;

  function FindParentNode(const BuffPtr: PKDT41DI64_Vec; NodePtr: PKDT41DI64_Node): PKDT41DI64_Node;
  var
    Next       : PKDT41DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT41DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT41DI64_Node; const BuffPtr: PKDT41DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT41DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT41DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT41DI64_Vec; const p1, p2: PKDT41DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT41DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT41DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT41DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT41DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT41DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT41DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT41DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT41DI64.Search(const Buff: TKDT41DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT41DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT41DI64.Search(const Buff: TKDT41DI64_Vec; var SearchedDistanceMin: Double): PKDT41DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT41DI64.Search(const Buff: TKDT41DI64_Vec): PKDT41DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT41DI64.Search(const inBuff: TKDT41DI64_DynamicVecBuffer; var OutBuff: TKDT41DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT41DI64_DynamicVecBuffer;
  outBuffPtr : PKDT41DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT41DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT41DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT41DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT41DI64.Search(const inBuff: TKDT41DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT41DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT41DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT41DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT41DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT41DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT41DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT41DI64_Source));
end;

procedure TKDT41DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT41DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT41DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT41DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT41DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT41DI64.PrintNodeTree(const NodePtr: PKDT41DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT41DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT41DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT41DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT41DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT41DI64.KDT41DI64Vec(const s: string): TKDT41DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT41DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT41DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT41DI64.KDT41DI64Vec(const v: TKDT41DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT41DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT41DI64.KDT41DI64Pow(const v: TKDT41DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT41DI64.KDT41DI64Distance(const v1, v2: TKDT41DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT41DI64_Axis - 1 do
      Result := Result + KDT41DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT41DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT41DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT41DI64.Test;
var
  TKDT41DI64_Test    : TKDT41DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT41DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT41DI64_Test := TKDT41DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT41DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT41DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT41DI64_Axis - 1 do
        TKDT41DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT41DI64_Test.TestBuff), length(TKDT41DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT41DI64_Test.BuildKDTreeM(length(TKDT41DI64_Test.TestBuff), @TKDT41DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT41DI64_Test.BuildKDTreeM(length(TKDT41DI64_Test.TestBuff), TKDT41DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT41DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT41DI64_Test.TestBuff));
  TKDT41DI64_Test.Search(TKDT41DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT41DI64Distance(TKDT41DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT41DI64_Test.Clear;
  { kMean test }
  TKDT41DI64_Test.BuildKDTreeWithCluster(TKDT41DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT41DI64_Test.Search(TKDT41DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT41DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT41DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT41DI64_Test);
end;


function TKDT42DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT42DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT42DI64_Node;
  function SortCompare(const p1, p2: PKDT42DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT42DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT42DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT42DI64_SourceBuffer;
  dynBuff  : PKDT42DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT42DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT42DI64.GetData(const index: NativeInt): PKDT42DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT42DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT42DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT42DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT42DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT42DI64.StoreBuffPtr: PKDT42DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT42DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT42DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT42DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT42DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT42DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT42DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT42DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT42DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT42DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT42DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT42DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT42DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT42DI64.BuildKDTreeWithCluster(const inBuff: TKDT42DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT42DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT42DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT42DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT42DI64.BuildKDTreeWithCluster(const inBuff: TKDT42DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT42DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT42DI64_BuildCall);
var
  TempStoreBuff: TKDT42DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT42DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT42DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT42DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT42DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT42DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT42DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT42DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT42DI64_BuildMethod);
var
  TempStoreBuff: TKDT42DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT42DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT42DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT42DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT42DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT42DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT42DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT42DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT42DI64_BuildProc);
var
  TempStoreBuff: TKDT42DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT42DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT42DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT42DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT42DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT42DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT42DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT42DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT42DI64.Search(const Buff: TKDT42DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT42DI64_Node;

var
  NearestNeighbour: PKDT42DI64_Node;

  function FindParentNode(const BuffPtr: PKDT42DI64_Vec; NodePtr: PKDT42DI64_Node): PKDT42DI64_Node;
  var
    Next       : PKDT42DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT42DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT42DI64_Node; const BuffPtr: PKDT42DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT42DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT42DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT42DI64_Vec; const p1, p2: PKDT42DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT42DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT42DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT42DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT42DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT42DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT42DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT42DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT42DI64.Search(const Buff: TKDT42DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT42DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT42DI64.Search(const Buff: TKDT42DI64_Vec; var SearchedDistanceMin: Double): PKDT42DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT42DI64.Search(const Buff: TKDT42DI64_Vec): PKDT42DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT42DI64.Search(const inBuff: TKDT42DI64_DynamicVecBuffer; var OutBuff: TKDT42DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT42DI64_DynamicVecBuffer;
  outBuffPtr : PKDT42DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT42DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT42DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT42DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT42DI64.Search(const inBuff: TKDT42DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT42DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT42DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT42DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT42DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT42DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT42DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT42DI64_Source));
end;

procedure TKDT42DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT42DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT42DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT42DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT42DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT42DI64.PrintNodeTree(const NodePtr: PKDT42DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT42DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT42DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT42DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT42DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT42DI64.KDT42DI64Vec(const s: string): TKDT42DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT42DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT42DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT42DI64.KDT42DI64Vec(const v: TKDT42DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT42DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT42DI64.KDT42DI64Pow(const v: TKDT42DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT42DI64.KDT42DI64Distance(const v1, v2: TKDT42DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT42DI64_Axis - 1 do
      Result := Result + KDT42DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT42DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT42DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT42DI64.Test;
var
  TKDT42DI64_Test    : TKDT42DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT42DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT42DI64_Test := TKDT42DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT42DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT42DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT42DI64_Axis - 1 do
        TKDT42DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT42DI64_Test.TestBuff), length(TKDT42DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT42DI64_Test.BuildKDTreeM(length(TKDT42DI64_Test.TestBuff), @TKDT42DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT42DI64_Test.BuildKDTreeM(length(TKDT42DI64_Test.TestBuff), TKDT42DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT42DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT42DI64_Test.TestBuff));
  TKDT42DI64_Test.Search(TKDT42DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT42DI64Distance(TKDT42DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT42DI64_Test.Clear;
  { kMean test }
  TKDT42DI64_Test.BuildKDTreeWithCluster(TKDT42DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT42DI64_Test.Search(TKDT42DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT42DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT42DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT42DI64_Test);
end;


function TKDT43DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT43DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT43DI64_Node;
  function SortCompare(const p1, p2: PKDT43DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT43DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT43DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT43DI64_SourceBuffer;
  dynBuff  : PKDT43DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT43DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT43DI64.GetData(const index: NativeInt): PKDT43DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT43DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT43DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT43DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT43DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT43DI64.StoreBuffPtr: PKDT43DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT43DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT43DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT43DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT43DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT43DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT43DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT43DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT43DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT43DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT43DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT43DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT43DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT43DI64.BuildKDTreeWithCluster(const inBuff: TKDT43DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT43DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT43DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT43DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT43DI64.BuildKDTreeWithCluster(const inBuff: TKDT43DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT43DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT43DI64_BuildCall);
var
  TempStoreBuff: TKDT43DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT43DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT43DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT43DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT43DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT43DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT43DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT43DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT43DI64_BuildMethod);
var
  TempStoreBuff: TKDT43DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT43DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT43DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT43DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT43DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT43DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT43DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT43DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT43DI64_BuildProc);
var
  TempStoreBuff: TKDT43DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT43DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT43DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT43DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT43DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT43DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT43DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT43DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT43DI64.Search(const Buff: TKDT43DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT43DI64_Node;

var
  NearestNeighbour: PKDT43DI64_Node;

  function FindParentNode(const BuffPtr: PKDT43DI64_Vec; NodePtr: PKDT43DI64_Node): PKDT43DI64_Node;
  var
    Next       : PKDT43DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT43DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT43DI64_Node; const BuffPtr: PKDT43DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT43DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT43DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT43DI64_Vec; const p1, p2: PKDT43DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT43DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT43DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT43DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT43DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT43DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT43DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT43DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT43DI64.Search(const Buff: TKDT43DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT43DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT43DI64.Search(const Buff: TKDT43DI64_Vec; var SearchedDistanceMin: Double): PKDT43DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT43DI64.Search(const Buff: TKDT43DI64_Vec): PKDT43DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT43DI64.Search(const inBuff: TKDT43DI64_DynamicVecBuffer; var OutBuff: TKDT43DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT43DI64_DynamicVecBuffer;
  outBuffPtr : PKDT43DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT43DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT43DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT43DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT43DI64.Search(const inBuff: TKDT43DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT43DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT43DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT43DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT43DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT43DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT43DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT43DI64_Source));
end;

procedure TKDT43DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT43DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT43DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT43DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT43DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT43DI64.PrintNodeTree(const NodePtr: PKDT43DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT43DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT43DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT43DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT43DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT43DI64.KDT43DI64Vec(const s: string): TKDT43DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT43DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT43DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT43DI64.KDT43DI64Vec(const v: TKDT43DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT43DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT43DI64.KDT43DI64Pow(const v: TKDT43DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT43DI64.KDT43DI64Distance(const v1, v2: TKDT43DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT43DI64_Axis - 1 do
      Result := Result + KDT43DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT43DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT43DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT43DI64.Test;
var
  TKDT43DI64_Test    : TKDT43DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT43DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT43DI64_Test := TKDT43DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT43DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT43DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT43DI64_Axis - 1 do
        TKDT43DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT43DI64_Test.TestBuff), length(TKDT43DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT43DI64_Test.BuildKDTreeM(length(TKDT43DI64_Test.TestBuff), @TKDT43DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT43DI64_Test.BuildKDTreeM(length(TKDT43DI64_Test.TestBuff), TKDT43DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT43DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT43DI64_Test.TestBuff));
  TKDT43DI64_Test.Search(TKDT43DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT43DI64Distance(TKDT43DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT43DI64_Test.Clear;
  { kMean test }
  TKDT43DI64_Test.BuildKDTreeWithCluster(TKDT43DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT43DI64_Test.Search(TKDT43DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT43DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT43DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT43DI64_Test);
end;


function TKDT44DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT44DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT44DI64_Node;
  function SortCompare(const p1, p2: PKDT44DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT44DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT44DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT44DI64_SourceBuffer;
  dynBuff  : PKDT44DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT44DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT44DI64.GetData(const index: NativeInt): PKDT44DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT44DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT44DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT44DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT44DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT44DI64.StoreBuffPtr: PKDT44DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT44DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT44DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT44DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT44DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT44DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT44DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT44DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT44DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT44DI64.BuildKDTreeWithCluster(const inBuff: TKDT44DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT44DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT44DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT44DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT44DI64.BuildKDTreeWithCluster(const inBuff: TKDT44DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT44DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DI64_BuildCall);
var
  TempStoreBuff: TKDT44DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT44DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT44DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT44DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT44DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT44DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DI64_BuildMethod);
var
  TempStoreBuff: TKDT44DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT44DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT44DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT44DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT44DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT44DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT44DI64_BuildProc);
var
  TempStoreBuff: TKDT44DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT44DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT44DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT44DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT44DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT44DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT44DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT44DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT44DI64.Search(const Buff: TKDT44DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT44DI64_Node;

var
  NearestNeighbour: PKDT44DI64_Node;

  function FindParentNode(const BuffPtr: PKDT44DI64_Vec; NodePtr: PKDT44DI64_Node): PKDT44DI64_Node;
  var
    Next       : PKDT44DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT44DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT44DI64_Node; const BuffPtr: PKDT44DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT44DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT44DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT44DI64_Vec; const p1, p2: PKDT44DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT44DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT44DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT44DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT44DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT44DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT44DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT44DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT44DI64.Search(const Buff: TKDT44DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT44DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT44DI64.Search(const Buff: TKDT44DI64_Vec; var SearchedDistanceMin: Double): PKDT44DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT44DI64.Search(const Buff: TKDT44DI64_Vec): PKDT44DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT44DI64.Search(const inBuff: TKDT44DI64_DynamicVecBuffer; var OutBuff: TKDT44DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT44DI64_DynamicVecBuffer;
  outBuffPtr : PKDT44DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT44DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT44DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT44DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT44DI64.Search(const inBuff: TKDT44DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT44DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT44DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT44DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT44DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT44DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT44DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT44DI64_Source));
end;

procedure TKDT44DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT44DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT44DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT44DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT44DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT44DI64.PrintNodeTree(const NodePtr: PKDT44DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT44DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT44DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT44DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT44DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT44DI64.KDT44DI64Vec(const s: string): TKDT44DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT44DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT44DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT44DI64.KDT44DI64Vec(const v: TKDT44DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT44DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT44DI64.KDT44DI64Pow(const v: TKDT44DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT44DI64.KDT44DI64Distance(const v1, v2: TKDT44DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT44DI64_Axis - 1 do
      Result := Result + KDT44DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT44DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT44DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT44DI64.Test;
var
  TKDT44DI64_Test    : TKDT44DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT44DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT44DI64_Test := TKDT44DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT44DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT44DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT44DI64_Axis - 1 do
        TKDT44DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT44DI64_Test.TestBuff), length(TKDT44DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT44DI64_Test.BuildKDTreeM(length(TKDT44DI64_Test.TestBuff), @TKDT44DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT44DI64_Test.BuildKDTreeM(length(TKDT44DI64_Test.TestBuff), TKDT44DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT44DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT44DI64_Test.TestBuff));
  TKDT44DI64_Test.Search(TKDT44DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT44DI64Distance(TKDT44DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT44DI64_Test.Clear;
  { kMean test }
  TKDT44DI64_Test.BuildKDTreeWithCluster(TKDT44DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT44DI64_Test.Search(TKDT44DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT44DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT44DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT44DI64_Test);
end;


function TKDT45DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT45DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT45DI64_Node;
  function SortCompare(const p1, p2: PKDT45DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT45DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT45DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT45DI64_SourceBuffer;
  dynBuff  : PKDT45DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT45DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT45DI64.GetData(const index: NativeInt): PKDT45DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT45DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT45DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT45DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT45DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT45DI64.StoreBuffPtr: PKDT45DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT45DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT45DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT45DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT45DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT45DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT45DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT45DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT45DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT45DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT45DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT45DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT45DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT45DI64.BuildKDTreeWithCluster(const inBuff: TKDT45DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT45DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT45DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT45DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT45DI64.BuildKDTreeWithCluster(const inBuff: TKDT45DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT45DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT45DI64_BuildCall);
var
  TempStoreBuff: TKDT45DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT45DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT45DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT45DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT45DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT45DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT45DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT45DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT45DI64_BuildMethod);
var
  TempStoreBuff: TKDT45DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT45DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT45DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT45DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT45DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT45DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT45DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT45DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT45DI64_BuildProc);
var
  TempStoreBuff: TKDT45DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT45DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT45DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT45DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT45DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT45DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT45DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT45DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT45DI64.Search(const Buff: TKDT45DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT45DI64_Node;

var
  NearestNeighbour: PKDT45DI64_Node;

  function FindParentNode(const BuffPtr: PKDT45DI64_Vec; NodePtr: PKDT45DI64_Node): PKDT45DI64_Node;
  var
    Next       : PKDT45DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT45DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT45DI64_Node; const BuffPtr: PKDT45DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT45DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT45DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT45DI64_Vec; const p1, p2: PKDT45DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT45DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT45DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT45DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT45DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT45DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT45DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT45DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT45DI64.Search(const Buff: TKDT45DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT45DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT45DI64.Search(const Buff: TKDT45DI64_Vec; var SearchedDistanceMin: Double): PKDT45DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT45DI64.Search(const Buff: TKDT45DI64_Vec): PKDT45DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT45DI64.Search(const inBuff: TKDT45DI64_DynamicVecBuffer; var OutBuff: TKDT45DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT45DI64_DynamicVecBuffer;
  outBuffPtr : PKDT45DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT45DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT45DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT45DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT45DI64.Search(const inBuff: TKDT45DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT45DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT45DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT45DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT45DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT45DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT45DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT45DI64_Source));
end;

procedure TKDT45DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT45DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT45DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT45DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT45DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT45DI64.PrintNodeTree(const NodePtr: PKDT45DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT45DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT45DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT45DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT45DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT45DI64.KDT45DI64Vec(const s: string): TKDT45DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT45DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT45DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT45DI64.KDT45DI64Vec(const v: TKDT45DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT45DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT45DI64.KDT45DI64Pow(const v: TKDT45DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT45DI64.KDT45DI64Distance(const v1, v2: TKDT45DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT45DI64_Axis - 1 do
      Result := Result + KDT45DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT45DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT45DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT45DI64.Test;
var
  TKDT45DI64_Test    : TKDT45DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT45DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT45DI64_Test := TKDT45DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT45DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT45DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT45DI64_Axis - 1 do
        TKDT45DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT45DI64_Test.TestBuff), length(TKDT45DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT45DI64_Test.BuildKDTreeM(length(TKDT45DI64_Test.TestBuff), @TKDT45DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT45DI64_Test.BuildKDTreeM(length(TKDT45DI64_Test.TestBuff), TKDT45DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT45DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT45DI64_Test.TestBuff));
  TKDT45DI64_Test.Search(TKDT45DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT45DI64Distance(TKDT45DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT45DI64_Test.Clear;
  { kMean test }
  TKDT45DI64_Test.BuildKDTreeWithCluster(TKDT45DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT45DI64_Test.Search(TKDT45DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT45DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT45DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT45DI64_Test);
end;


function TKDT46DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT46DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT46DI64_Node;
  function SortCompare(const p1, p2: PKDT46DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT46DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT46DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT46DI64_SourceBuffer;
  dynBuff  : PKDT46DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT46DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT46DI64.GetData(const index: NativeInt): PKDT46DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT46DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT46DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT46DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT46DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT46DI64.StoreBuffPtr: PKDT46DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT46DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT46DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT46DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT46DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT46DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT46DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT46DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT46DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT46DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT46DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT46DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT46DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT46DI64.BuildKDTreeWithCluster(const inBuff: TKDT46DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT46DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT46DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT46DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT46DI64.BuildKDTreeWithCluster(const inBuff: TKDT46DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT46DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT46DI64_BuildCall);
var
  TempStoreBuff: TKDT46DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT46DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT46DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT46DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT46DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT46DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT46DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT46DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT46DI64_BuildMethod);
var
  TempStoreBuff: TKDT46DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT46DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT46DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT46DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT46DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT46DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT46DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT46DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT46DI64_BuildProc);
var
  TempStoreBuff: TKDT46DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT46DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT46DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT46DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT46DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT46DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT46DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT46DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT46DI64.Search(const Buff: TKDT46DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT46DI64_Node;

var
  NearestNeighbour: PKDT46DI64_Node;

  function FindParentNode(const BuffPtr: PKDT46DI64_Vec; NodePtr: PKDT46DI64_Node): PKDT46DI64_Node;
  var
    Next       : PKDT46DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT46DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT46DI64_Node; const BuffPtr: PKDT46DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT46DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT46DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT46DI64_Vec; const p1, p2: PKDT46DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT46DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT46DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT46DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT46DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT46DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT46DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT46DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT46DI64.Search(const Buff: TKDT46DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT46DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT46DI64.Search(const Buff: TKDT46DI64_Vec; var SearchedDistanceMin: Double): PKDT46DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT46DI64.Search(const Buff: TKDT46DI64_Vec): PKDT46DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT46DI64.Search(const inBuff: TKDT46DI64_DynamicVecBuffer; var OutBuff: TKDT46DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT46DI64_DynamicVecBuffer;
  outBuffPtr : PKDT46DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT46DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT46DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT46DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT46DI64.Search(const inBuff: TKDT46DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT46DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT46DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT46DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT46DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT46DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT46DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT46DI64_Source));
end;

procedure TKDT46DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT46DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT46DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT46DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT46DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT46DI64.PrintNodeTree(const NodePtr: PKDT46DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT46DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT46DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT46DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT46DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT46DI64.KDT46DI64Vec(const s: string): TKDT46DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT46DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT46DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT46DI64.KDT46DI64Vec(const v: TKDT46DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT46DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT46DI64.KDT46DI64Pow(const v: TKDT46DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT46DI64.KDT46DI64Distance(const v1, v2: TKDT46DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT46DI64_Axis - 1 do
      Result := Result + KDT46DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT46DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT46DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT46DI64.Test;
var
  TKDT46DI64_Test    : TKDT46DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT46DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT46DI64_Test := TKDT46DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT46DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT46DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT46DI64_Axis - 1 do
        TKDT46DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT46DI64_Test.TestBuff), length(TKDT46DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT46DI64_Test.BuildKDTreeM(length(TKDT46DI64_Test.TestBuff), @TKDT46DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT46DI64_Test.BuildKDTreeM(length(TKDT46DI64_Test.TestBuff), TKDT46DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT46DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT46DI64_Test.TestBuff));
  TKDT46DI64_Test.Search(TKDT46DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT46DI64Distance(TKDT46DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT46DI64_Test.Clear;
  { kMean test }
  TKDT46DI64_Test.BuildKDTreeWithCluster(TKDT46DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT46DI64_Test.Search(TKDT46DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT46DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT46DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT46DI64_Test);
end;


function TKDT47DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT47DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT47DI64_Node;
  function SortCompare(const p1, p2: PKDT47DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT47DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT47DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT47DI64_SourceBuffer;
  dynBuff  : PKDT47DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT47DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT47DI64.GetData(const index: NativeInt): PKDT47DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT47DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT47DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT47DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT47DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT47DI64.StoreBuffPtr: PKDT47DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT47DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT47DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT47DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT47DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT47DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT47DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT47DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT47DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT47DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT47DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT47DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT47DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT47DI64.BuildKDTreeWithCluster(const inBuff: TKDT47DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT47DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT47DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT47DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT47DI64.BuildKDTreeWithCluster(const inBuff: TKDT47DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT47DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT47DI64_BuildCall);
var
  TempStoreBuff: TKDT47DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT47DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT47DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT47DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT47DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT47DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT47DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT47DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT47DI64_BuildMethod);
var
  TempStoreBuff: TKDT47DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT47DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT47DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT47DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT47DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT47DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT47DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT47DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT47DI64_BuildProc);
var
  TempStoreBuff: TKDT47DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT47DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT47DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT47DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT47DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT47DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT47DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT47DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT47DI64.Search(const Buff: TKDT47DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT47DI64_Node;

var
  NearestNeighbour: PKDT47DI64_Node;

  function FindParentNode(const BuffPtr: PKDT47DI64_Vec; NodePtr: PKDT47DI64_Node): PKDT47DI64_Node;
  var
    Next       : PKDT47DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT47DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT47DI64_Node; const BuffPtr: PKDT47DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT47DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT47DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT47DI64_Vec; const p1, p2: PKDT47DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT47DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT47DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT47DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT47DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT47DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT47DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT47DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT47DI64.Search(const Buff: TKDT47DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT47DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT47DI64.Search(const Buff: TKDT47DI64_Vec; var SearchedDistanceMin: Double): PKDT47DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT47DI64.Search(const Buff: TKDT47DI64_Vec): PKDT47DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT47DI64.Search(const inBuff: TKDT47DI64_DynamicVecBuffer; var OutBuff: TKDT47DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT47DI64_DynamicVecBuffer;
  outBuffPtr : PKDT47DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT47DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT47DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT47DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT47DI64.Search(const inBuff: TKDT47DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT47DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT47DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT47DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT47DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT47DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT47DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT47DI64_Source));
end;

procedure TKDT47DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT47DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT47DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT47DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT47DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT47DI64.PrintNodeTree(const NodePtr: PKDT47DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT47DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT47DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT47DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT47DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT47DI64.KDT47DI64Vec(const s: string): TKDT47DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT47DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT47DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT47DI64.KDT47DI64Vec(const v: TKDT47DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT47DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT47DI64.KDT47DI64Pow(const v: TKDT47DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT47DI64.KDT47DI64Distance(const v1, v2: TKDT47DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT47DI64_Axis - 1 do
      Result := Result + KDT47DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT47DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT47DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT47DI64.Test;
var
  TKDT47DI64_Test    : TKDT47DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT47DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT47DI64_Test := TKDT47DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT47DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT47DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT47DI64_Axis - 1 do
        TKDT47DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT47DI64_Test.TestBuff), length(TKDT47DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT47DI64_Test.BuildKDTreeM(length(TKDT47DI64_Test.TestBuff), @TKDT47DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT47DI64_Test.BuildKDTreeM(length(TKDT47DI64_Test.TestBuff), TKDT47DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT47DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT47DI64_Test.TestBuff));
  TKDT47DI64_Test.Search(TKDT47DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT47DI64Distance(TKDT47DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT47DI64_Test.Clear;
  { kMean test }
  TKDT47DI64_Test.BuildKDTreeWithCluster(TKDT47DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT47DI64_Test.Search(TKDT47DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT47DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT47DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT47DI64_Test);
end;


function TKDT48DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT48DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT48DI64_Node;
  function SortCompare(const p1, p2: PKDT48DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT48DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT48DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT48DI64_SourceBuffer;
  dynBuff  : PKDT48DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT48DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT48DI64.GetData(const index: NativeInt): PKDT48DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT48DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT48DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT48DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT48DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT48DI64.StoreBuffPtr: PKDT48DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT48DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT48DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT48DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT48DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT48DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT48DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT48DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT48DI64.BuildKDTreeWithCluster(const inBuff: TKDT48DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT48DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT48DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT48DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT48DI64.BuildKDTreeWithCluster(const inBuff: TKDT48DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI64_BuildCall);
var
  TempStoreBuff: TKDT48DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT48DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT48DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI64_BuildMethod);
var
  TempStoreBuff: TKDT48DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT48DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT48DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT48DI64_BuildProc);
var
  TempStoreBuff: TKDT48DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT48DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT48DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT48DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT48DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT48DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT48DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT48DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT48DI64.Search(const Buff: TKDT48DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT48DI64_Node;

var
  NearestNeighbour: PKDT48DI64_Node;

  function FindParentNode(const BuffPtr: PKDT48DI64_Vec; NodePtr: PKDT48DI64_Node): PKDT48DI64_Node;
  var
    Next       : PKDT48DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT48DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT48DI64_Node; const BuffPtr: PKDT48DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT48DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT48DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT48DI64_Vec; const p1, p2: PKDT48DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT48DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT48DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT48DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT48DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT48DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT48DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT48DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT48DI64.Search(const Buff: TKDT48DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT48DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT48DI64.Search(const Buff: TKDT48DI64_Vec; var SearchedDistanceMin: Double): PKDT48DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT48DI64.Search(const Buff: TKDT48DI64_Vec): PKDT48DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT48DI64.Search(const inBuff: TKDT48DI64_DynamicVecBuffer; var OutBuff: TKDT48DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT48DI64_DynamicVecBuffer;
  outBuffPtr : PKDT48DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT48DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT48DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DI64.Search(const inBuff: TKDT48DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT48DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT48DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT48DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT48DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT48DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT48DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT48DI64_Source));
end;

procedure TKDT48DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT48DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT48DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT48DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT48DI64.PrintNodeTree(const NodePtr: PKDT48DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT48DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT48DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT48DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT48DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT48DI64.KDT48DI64Vec(const s: string): TKDT48DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT48DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT48DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT48DI64.KDT48DI64Vec(const v: TKDT48DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT48DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT48DI64.KDT48DI64Pow(const v: TKDT48DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT48DI64.KDT48DI64Distance(const v1, v2: TKDT48DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT48DI64_Axis - 1 do
      Result := Result + KDT48DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT48DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT48DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT48DI64.Test;
var
  TKDT48DI64_Test    : TKDT48DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT48DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT48DI64_Test := TKDT48DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT48DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT48DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT48DI64_Axis - 1 do
        TKDT48DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT48DI64_Test.TestBuff), length(TKDT48DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT48DI64_Test.BuildKDTreeM(length(TKDT48DI64_Test.TestBuff), @TKDT48DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT48DI64_Test.BuildKDTreeM(length(TKDT48DI64_Test.TestBuff), TKDT48DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT48DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT48DI64_Test.TestBuff));
  TKDT48DI64_Test.Search(TKDT48DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT48DI64Distance(TKDT48DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT48DI64_Test.Clear;
  { kMean test }
  TKDT48DI64_Test.BuildKDTreeWithCluster(TKDT48DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT48DI64_Test.Search(TKDT48DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT48DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT48DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT48DI64_Test);
end;


function TKDT49DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT49DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT49DI64_Node;
  function SortCompare(const p1, p2: PKDT49DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT49DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT49DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT49DI64_SourceBuffer;
  dynBuff  : PKDT49DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT49DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT49DI64.GetData(const index: NativeInt): PKDT49DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT49DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT49DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT49DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT49DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT49DI64.StoreBuffPtr: PKDT49DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT49DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT49DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT49DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT49DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT49DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT49DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT49DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT49DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT49DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT49DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT49DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT49DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT49DI64.BuildKDTreeWithCluster(const inBuff: TKDT49DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT49DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT49DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT49DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT49DI64.BuildKDTreeWithCluster(const inBuff: TKDT49DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT49DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT49DI64_BuildCall);
var
  TempStoreBuff: TKDT49DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT49DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT49DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT49DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT49DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT49DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT49DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT49DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT49DI64_BuildMethod);
var
  TempStoreBuff: TKDT49DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT49DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT49DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT49DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT49DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT49DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT49DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT49DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT49DI64_BuildProc);
var
  TempStoreBuff: TKDT49DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT49DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT49DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT49DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT49DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT49DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT49DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT49DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT49DI64.Search(const Buff: TKDT49DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT49DI64_Node;

var
  NearestNeighbour: PKDT49DI64_Node;

  function FindParentNode(const BuffPtr: PKDT49DI64_Vec; NodePtr: PKDT49DI64_Node): PKDT49DI64_Node;
  var
    Next       : PKDT49DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT49DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT49DI64_Node; const BuffPtr: PKDT49DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT49DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT49DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT49DI64_Vec; const p1, p2: PKDT49DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT49DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT49DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT49DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT49DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT49DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT49DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT49DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT49DI64.Search(const Buff: TKDT49DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT49DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT49DI64.Search(const Buff: TKDT49DI64_Vec; var SearchedDistanceMin: Double): PKDT49DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT49DI64.Search(const Buff: TKDT49DI64_Vec): PKDT49DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT49DI64.Search(const inBuff: TKDT49DI64_DynamicVecBuffer; var OutBuff: TKDT49DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT49DI64_DynamicVecBuffer;
  outBuffPtr : PKDT49DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT49DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT49DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT49DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT49DI64.Search(const inBuff: TKDT49DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT49DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT49DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT49DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT49DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT49DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT49DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT49DI64_Source));
end;

procedure TKDT49DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT49DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT49DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT49DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT49DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT49DI64.PrintNodeTree(const NodePtr: PKDT49DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT49DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT49DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT49DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT49DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT49DI64.KDT49DI64Vec(const s: string): TKDT49DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT49DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT49DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT49DI64.KDT49DI64Vec(const v: TKDT49DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT49DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT49DI64.KDT49DI64Pow(const v: TKDT49DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT49DI64.KDT49DI64Distance(const v1, v2: TKDT49DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT49DI64_Axis - 1 do
      Result := Result + KDT49DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT49DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT49DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT49DI64.Test;
var
  TKDT49DI64_Test    : TKDT49DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT49DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT49DI64_Test := TKDT49DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT49DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT49DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT49DI64_Axis - 1 do
        TKDT49DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT49DI64_Test.TestBuff), length(TKDT49DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT49DI64_Test.BuildKDTreeM(length(TKDT49DI64_Test.TestBuff), @TKDT49DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT49DI64_Test.BuildKDTreeM(length(TKDT49DI64_Test.TestBuff), TKDT49DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT49DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT49DI64_Test.TestBuff));
  TKDT49DI64_Test.Search(TKDT49DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT49DI64Distance(TKDT49DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT49DI64_Test.Clear;
  { kMean test }
  TKDT49DI64_Test.BuildKDTreeWithCluster(TKDT49DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT49DI64_Test.Search(TKDT49DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT49DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT49DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT49DI64_Test);
end;


function TKDT50DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT50DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT50DI64_Node;
  function SortCompare(const p1, p2: PKDT50DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT50DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT50DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT50DI64_SourceBuffer;
  dynBuff  : PKDT50DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT50DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT50DI64.GetData(const index: NativeInt): PKDT50DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT50DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT50DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT50DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT50DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT50DI64.StoreBuffPtr: PKDT50DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT50DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT50DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT50DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT50DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT50DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT50DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT50DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT50DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT50DI64.BuildKDTreeWithCluster(const inBuff: TKDT50DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT50DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT50DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT50DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT50DI64.BuildKDTreeWithCluster(const inBuff: TKDT50DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT50DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DI64_BuildCall);
var
  TempStoreBuff: TKDT50DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT50DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT50DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT50DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT50DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT50DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DI64_BuildMethod);
var
  TempStoreBuff: TKDT50DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT50DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT50DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT50DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT50DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT50DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT50DI64_BuildProc);
var
  TempStoreBuff: TKDT50DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT50DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT50DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT50DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT50DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT50DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT50DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT50DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT50DI64.Search(const Buff: TKDT50DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT50DI64_Node;

var
  NearestNeighbour: PKDT50DI64_Node;

  function FindParentNode(const BuffPtr: PKDT50DI64_Vec; NodePtr: PKDT50DI64_Node): PKDT50DI64_Node;
  var
    Next       : PKDT50DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT50DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT50DI64_Node; const BuffPtr: PKDT50DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT50DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT50DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT50DI64_Vec; const p1, p2: PKDT50DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT50DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT50DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT50DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT50DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT50DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT50DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT50DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT50DI64.Search(const Buff: TKDT50DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT50DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT50DI64.Search(const Buff: TKDT50DI64_Vec; var SearchedDistanceMin: Double): PKDT50DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT50DI64.Search(const Buff: TKDT50DI64_Vec): PKDT50DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT50DI64.Search(const inBuff: TKDT50DI64_DynamicVecBuffer; var OutBuff: TKDT50DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT50DI64_DynamicVecBuffer;
  outBuffPtr : PKDT50DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT50DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT50DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT50DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT50DI64.Search(const inBuff: TKDT50DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT50DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT50DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT50DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT50DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT50DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT50DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT50DI64_Source));
end;

procedure TKDT50DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT50DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT50DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT50DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT50DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT50DI64.PrintNodeTree(const NodePtr: PKDT50DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT50DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT50DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT50DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT50DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT50DI64.KDT50DI64Vec(const s: string): TKDT50DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT50DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT50DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT50DI64.KDT50DI64Vec(const v: TKDT50DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT50DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT50DI64.KDT50DI64Pow(const v: TKDT50DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT50DI64.KDT50DI64Distance(const v1, v2: TKDT50DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT50DI64_Axis - 1 do
      Result := Result + KDT50DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT50DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT50DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT50DI64.Test;
var
  TKDT50DI64_Test    : TKDT50DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT50DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT50DI64_Test := TKDT50DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT50DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT50DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT50DI64_Axis - 1 do
        TKDT50DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT50DI64_Test.TestBuff), length(TKDT50DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT50DI64_Test.BuildKDTreeM(length(TKDT50DI64_Test.TestBuff), @TKDT50DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT50DI64_Test.BuildKDTreeM(length(TKDT50DI64_Test.TestBuff), TKDT50DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT50DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT50DI64_Test.TestBuff));
  TKDT50DI64_Test.Search(TKDT50DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT50DI64Distance(TKDT50DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT50DI64_Test.Clear;
  { kMean test }
  TKDT50DI64_Test.BuildKDTreeWithCluster(TKDT50DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT50DI64_Test.Search(TKDT50DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT50DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT50DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT50DI64_Test);
end;


function TKDT51DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT51DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT51DI64_Node;
  function SortCompare(const p1, p2: PKDT51DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT51DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT51DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT51DI64_SourceBuffer;
  dynBuff  : PKDT51DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT51DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT51DI64.GetData(const index: NativeInt): PKDT51DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT51DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT51DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT51DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT51DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT51DI64.StoreBuffPtr: PKDT51DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT51DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT51DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT51DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT51DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT51DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT51DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT51DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT51DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT51DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT51DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT51DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT51DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT51DI64.BuildKDTreeWithCluster(const inBuff: TKDT51DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT51DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT51DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT51DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT51DI64.BuildKDTreeWithCluster(const inBuff: TKDT51DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT51DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT51DI64_BuildCall);
var
  TempStoreBuff: TKDT51DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT51DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT51DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT51DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT51DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT51DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT51DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT51DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT51DI64_BuildMethod);
var
  TempStoreBuff: TKDT51DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT51DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT51DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT51DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT51DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT51DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT51DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT51DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT51DI64_BuildProc);
var
  TempStoreBuff: TKDT51DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT51DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT51DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT51DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT51DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT51DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT51DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT51DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT51DI64.Search(const Buff: TKDT51DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT51DI64_Node;

var
  NearestNeighbour: PKDT51DI64_Node;

  function FindParentNode(const BuffPtr: PKDT51DI64_Vec; NodePtr: PKDT51DI64_Node): PKDT51DI64_Node;
  var
    Next       : PKDT51DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT51DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT51DI64_Node; const BuffPtr: PKDT51DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT51DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT51DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT51DI64_Vec; const p1, p2: PKDT51DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT51DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT51DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT51DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT51DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT51DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT51DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT51DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT51DI64.Search(const Buff: TKDT51DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT51DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT51DI64.Search(const Buff: TKDT51DI64_Vec; var SearchedDistanceMin: Double): PKDT51DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT51DI64.Search(const Buff: TKDT51DI64_Vec): PKDT51DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT51DI64.Search(const inBuff: TKDT51DI64_DynamicVecBuffer; var OutBuff: TKDT51DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT51DI64_DynamicVecBuffer;
  outBuffPtr : PKDT51DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT51DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT51DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT51DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT51DI64.Search(const inBuff: TKDT51DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT51DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT51DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT51DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT51DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT51DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT51DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT51DI64_Source));
end;

procedure TKDT51DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT51DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT51DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT51DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT51DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT51DI64.PrintNodeTree(const NodePtr: PKDT51DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT51DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT51DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT51DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT51DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT51DI64.KDT51DI64Vec(const s: string): TKDT51DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT51DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT51DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT51DI64.KDT51DI64Vec(const v: TKDT51DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT51DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT51DI64.KDT51DI64Pow(const v: TKDT51DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT51DI64.KDT51DI64Distance(const v1, v2: TKDT51DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT51DI64_Axis - 1 do
      Result := Result + KDT51DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT51DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT51DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT51DI64.Test;
var
  TKDT51DI64_Test    : TKDT51DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT51DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT51DI64_Test := TKDT51DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT51DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT51DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT51DI64_Axis - 1 do
        TKDT51DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT51DI64_Test.TestBuff), length(TKDT51DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT51DI64_Test.BuildKDTreeM(length(TKDT51DI64_Test.TestBuff), @TKDT51DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT51DI64_Test.BuildKDTreeM(length(TKDT51DI64_Test.TestBuff), TKDT51DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT51DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT51DI64_Test.TestBuff));
  TKDT51DI64_Test.Search(TKDT51DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT51DI64Distance(TKDT51DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT51DI64_Test.Clear;
  { kMean test }
  TKDT51DI64_Test.BuildKDTreeWithCluster(TKDT51DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT51DI64_Test.Search(TKDT51DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT51DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT51DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT51DI64_Test);
end;


function TKDT52DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT52DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT52DI64_Node;
  function SortCompare(const p1, p2: PKDT52DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT52DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT52DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT52DI64_SourceBuffer;
  dynBuff  : PKDT52DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT52DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT52DI64.GetData(const index: NativeInt): PKDT52DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT52DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT52DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT52DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT52DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT52DI64.StoreBuffPtr: PKDT52DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT52DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT52DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT52DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT52DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT52DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT52DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT52DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT52DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT52DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT52DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT52DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT52DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT52DI64.BuildKDTreeWithCluster(const inBuff: TKDT52DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT52DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT52DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT52DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT52DI64.BuildKDTreeWithCluster(const inBuff: TKDT52DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT52DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT52DI64_BuildCall);
var
  TempStoreBuff: TKDT52DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT52DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT52DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT52DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT52DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT52DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT52DI64_BuildMethod);
var
  TempStoreBuff: TKDT52DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT52DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT52DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT52DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT52DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT52DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT52DI64_BuildProc);
var
  TempStoreBuff: TKDT52DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT52DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT52DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT52DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT52DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT52DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT52DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT52DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT52DI64.Search(const Buff: TKDT52DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT52DI64_Node;

var
  NearestNeighbour: PKDT52DI64_Node;

  function FindParentNode(const BuffPtr: PKDT52DI64_Vec; NodePtr: PKDT52DI64_Node): PKDT52DI64_Node;
  var
    Next       : PKDT52DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT52DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT52DI64_Node; const BuffPtr: PKDT52DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT52DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT52DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT52DI64_Vec; const p1, p2: PKDT52DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT52DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT52DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT52DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT52DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT52DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT52DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT52DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT52DI64.Search(const Buff: TKDT52DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT52DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT52DI64.Search(const Buff: TKDT52DI64_Vec; var SearchedDistanceMin: Double): PKDT52DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT52DI64.Search(const Buff: TKDT52DI64_Vec): PKDT52DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT52DI64.Search(const inBuff: TKDT52DI64_DynamicVecBuffer; var OutBuff: TKDT52DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT52DI64_DynamicVecBuffer;
  outBuffPtr : PKDT52DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT52DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT52DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT52DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT52DI64.Search(const inBuff: TKDT52DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT52DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT52DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT52DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT52DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT52DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT52DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT52DI64_Source));
end;

procedure TKDT52DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT52DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT52DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT52DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT52DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT52DI64.PrintNodeTree(const NodePtr: PKDT52DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT52DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT52DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT52DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT52DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT52DI64.KDT52DI64Vec(const s: string): TKDT52DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT52DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT52DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT52DI64.KDT52DI64Vec(const v: TKDT52DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT52DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT52DI64.KDT52DI64Pow(const v: TKDT52DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT52DI64.KDT52DI64Distance(const v1, v2: TKDT52DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT52DI64_Axis - 1 do
      Result := Result + KDT52DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT52DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT52DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT52DI64.Test;
var
  TKDT52DI64_Test    : TKDT52DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT52DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT52DI64_Test := TKDT52DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT52DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT52DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT52DI64_Axis - 1 do
        TKDT52DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT52DI64_Test.TestBuff), length(TKDT52DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT52DI64_Test.BuildKDTreeM(length(TKDT52DI64_Test.TestBuff), @TKDT52DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT52DI64_Test.BuildKDTreeM(length(TKDT52DI64_Test.TestBuff), TKDT52DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT52DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT52DI64_Test.TestBuff));
  TKDT52DI64_Test.Search(TKDT52DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT52DI64Distance(TKDT52DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT52DI64_Test.Clear;
  { kMean test }
  TKDT52DI64_Test.BuildKDTreeWithCluster(TKDT52DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT52DI64_Test.Search(TKDT52DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT52DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT52DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT52DI64_Test);
end;


function TKDT53DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT53DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT53DI64_Node;
  function SortCompare(const p1, p2: PKDT53DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT53DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT53DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT53DI64_SourceBuffer;
  dynBuff  : PKDT53DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT53DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT53DI64.GetData(const index: NativeInt): PKDT53DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT53DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT53DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT53DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT53DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT53DI64.StoreBuffPtr: PKDT53DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT53DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT53DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT53DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT53DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT53DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT53DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT53DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT53DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT53DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT53DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT53DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT53DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT53DI64.BuildKDTreeWithCluster(const inBuff: TKDT53DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT53DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT53DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT53DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT53DI64.BuildKDTreeWithCluster(const inBuff: TKDT53DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT53DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT53DI64_BuildCall);
var
  TempStoreBuff: TKDT53DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT53DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT53DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT53DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT53DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT53DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT53DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT53DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT53DI64_BuildMethod);
var
  TempStoreBuff: TKDT53DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT53DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT53DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT53DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT53DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT53DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT53DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT53DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT53DI64_BuildProc);
var
  TempStoreBuff: TKDT53DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT53DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT53DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT53DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT53DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT53DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT53DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT53DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT53DI64.Search(const Buff: TKDT53DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT53DI64_Node;

var
  NearestNeighbour: PKDT53DI64_Node;

  function FindParentNode(const BuffPtr: PKDT53DI64_Vec; NodePtr: PKDT53DI64_Node): PKDT53DI64_Node;
  var
    Next       : PKDT53DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT53DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT53DI64_Node; const BuffPtr: PKDT53DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT53DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT53DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT53DI64_Vec; const p1, p2: PKDT53DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT53DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT53DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT53DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT53DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT53DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT53DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT53DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT53DI64.Search(const Buff: TKDT53DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT53DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT53DI64.Search(const Buff: TKDT53DI64_Vec; var SearchedDistanceMin: Double): PKDT53DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT53DI64.Search(const Buff: TKDT53DI64_Vec): PKDT53DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT53DI64.Search(const inBuff: TKDT53DI64_DynamicVecBuffer; var OutBuff: TKDT53DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT53DI64_DynamicVecBuffer;
  outBuffPtr : PKDT53DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT53DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT53DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT53DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT53DI64.Search(const inBuff: TKDT53DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT53DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT53DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT53DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT53DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT53DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT53DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT53DI64_Source));
end;

procedure TKDT53DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT53DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT53DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT53DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT53DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT53DI64.PrintNodeTree(const NodePtr: PKDT53DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT53DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT53DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT53DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT53DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT53DI64.KDT53DI64Vec(const s: string): TKDT53DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT53DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT53DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT53DI64.KDT53DI64Vec(const v: TKDT53DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT53DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT53DI64.KDT53DI64Pow(const v: TKDT53DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT53DI64.KDT53DI64Distance(const v1, v2: TKDT53DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT53DI64_Axis - 1 do
      Result := Result + KDT53DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT53DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT53DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT53DI64.Test;
var
  TKDT53DI64_Test    : TKDT53DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT53DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT53DI64_Test := TKDT53DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT53DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT53DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT53DI64_Axis - 1 do
        TKDT53DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT53DI64_Test.TestBuff), length(TKDT53DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT53DI64_Test.BuildKDTreeM(length(TKDT53DI64_Test.TestBuff), @TKDT53DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT53DI64_Test.BuildKDTreeM(length(TKDT53DI64_Test.TestBuff), TKDT53DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT53DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT53DI64_Test.TestBuff));
  TKDT53DI64_Test.Search(TKDT53DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT53DI64Distance(TKDT53DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT53DI64_Test.Clear;
  { kMean test }
  TKDT53DI64_Test.BuildKDTreeWithCluster(TKDT53DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT53DI64_Test.Search(TKDT53DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT53DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT53DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT53DI64_Test);
end;


function TKDT54DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT54DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT54DI64_Node;
  function SortCompare(const p1, p2: PKDT54DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT54DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT54DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT54DI64_SourceBuffer;
  dynBuff  : PKDT54DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT54DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT54DI64.GetData(const index: NativeInt): PKDT54DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT54DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT54DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT54DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT54DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT54DI64.StoreBuffPtr: PKDT54DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT54DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT54DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT54DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT54DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT54DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT54DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT54DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT54DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT54DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT54DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT54DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT54DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT54DI64.BuildKDTreeWithCluster(const inBuff: TKDT54DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT54DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT54DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT54DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT54DI64.BuildKDTreeWithCluster(const inBuff: TKDT54DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT54DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT54DI64_BuildCall);
var
  TempStoreBuff: TKDT54DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT54DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT54DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT54DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT54DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT54DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT54DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT54DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT54DI64_BuildMethod);
var
  TempStoreBuff: TKDT54DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT54DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT54DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT54DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT54DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT54DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT54DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT54DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT54DI64_BuildProc);
var
  TempStoreBuff: TKDT54DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT54DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT54DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT54DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT54DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT54DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT54DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT54DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT54DI64.Search(const Buff: TKDT54DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT54DI64_Node;

var
  NearestNeighbour: PKDT54DI64_Node;

  function FindParentNode(const BuffPtr: PKDT54DI64_Vec; NodePtr: PKDT54DI64_Node): PKDT54DI64_Node;
  var
    Next       : PKDT54DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT54DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT54DI64_Node; const BuffPtr: PKDT54DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT54DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT54DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT54DI64_Vec; const p1, p2: PKDT54DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT54DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT54DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT54DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT54DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT54DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT54DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT54DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT54DI64.Search(const Buff: TKDT54DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT54DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT54DI64.Search(const Buff: TKDT54DI64_Vec; var SearchedDistanceMin: Double): PKDT54DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT54DI64.Search(const Buff: TKDT54DI64_Vec): PKDT54DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT54DI64.Search(const inBuff: TKDT54DI64_DynamicVecBuffer; var OutBuff: TKDT54DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT54DI64_DynamicVecBuffer;
  outBuffPtr : PKDT54DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT54DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT54DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT54DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT54DI64.Search(const inBuff: TKDT54DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT54DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT54DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT54DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT54DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT54DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT54DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT54DI64_Source));
end;

procedure TKDT54DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT54DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT54DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT54DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT54DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT54DI64.PrintNodeTree(const NodePtr: PKDT54DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT54DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT54DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT54DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT54DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT54DI64.KDT54DI64Vec(const s: string): TKDT54DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT54DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT54DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT54DI64.KDT54DI64Vec(const v: TKDT54DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT54DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT54DI64.KDT54DI64Pow(const v: TKDT54DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT54DI64.KDT54DI64Distance(const v1, v2: TKDT54DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT54DI64_Axis - 1 do
      Result := Result + KDT54DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT54DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT54DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT54DI64.Test;
var
  TKDT54DI64_Test    : TKDT54DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT54DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT54DI64_Test := TKDT54DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT54DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT54DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT54DI64_Axis - 1 do
        TKDT54DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT54DI64_Test.TestBuff), length(TKDT54DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT54DI64_Test.BuildKDTreeM(length(TKDT54DI64_Test.TestBuff), @TKDT54DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT54DI64_Test.BuildKDTreeM(length(TKDT54DI64_Test.TestBuff), TKDT54DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT54DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT54DI64_Test.TestBuff));
  TKDT54DI64_Test.Search(TKDT54DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT54DI64Distance(TKDT54DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT54DI64_Test.Clear;
  { kMean test }
  TKDT54DI64_Test.BuildKDTreeWithCluster(TKDT54DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT54DI64_Test.Search(TKDT54DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT54DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT54DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT54DI64_Test);
end;


function TKDT55DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT55DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT55DI64_Node;
  function SortCompare(const p1, p2: PKDT55DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT55DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT55DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT55DI64_SourceBuffer;
  dynBuff  : PKDT55DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT55DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT55DI64.GetData(const index: NativeInt): PKDT55DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT55DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT55DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT55DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT55DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT55DI64.StoreBuffPtr: PKDT55DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT55DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT55DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT55DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT55DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT55DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT55DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT55DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT55DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT55DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT55DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT55DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT55DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT55DI64.BuildKDTreeWithCluster(const inBuff: TKDT55DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT55DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT55DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT55DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT55DI64.BuildKDTreeWithCluster(const inBuff: TKDT55DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT55DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT55DI64_BuildCall);
var
  TempStoreBuff: TKDT55DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT55DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT55DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT55DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT55DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT55DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT55DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT55DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT55DI64_BuildMethod);
var
  TempStoreBuff: TKDT55DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT55DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT55DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT55DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT55DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT55DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT55DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT55DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT55DI64_BuildProc);
var
  TempStoreBuff: TKDT55DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT55DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT55DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT55DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT55DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT55DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT55DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT55DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT55DI64.Search(const Buff: TKDT55DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT55DI64_Node;

var
  NearestNeighbour: PKDT55DI64_Node;

  function FindParentNode(const BuffPtr: PKDT55DI64_Vec; NodePtr: PKDT55DI64_Node): PKDT55DI64_Node;
  var
    Next       : PKDT55DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT55DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT55DI64_Node; const BuffPtr: PKDT55DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT55DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT55DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT55DI64_Vec; const p1, p2: PKDT55DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT55DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT55DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT55DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT55DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT55DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT55DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT55DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT55DI64.Search(const Buff: TKDT55DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT55DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT55DI64.Search(const Buff: TKDT55DI64_Vec; var SearchedDistanceMin: Double): PKDT55DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT55DI64.Search(const Buff: TKDT55DI64_Vec): PKDT55DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT55DI64.Search(const inBuff: TKDT55DI64_DynamicVecBuffer; var OutBuff: TKDT55DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT55DI64_DynamicVecBuffer;
  outBuffPtr : PKDT55DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT55DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT55DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT55DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT55DI64.Search(const inBuff: TKDT55DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT55DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT55DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT55DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT55DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT55DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT55DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT55DI64_Source));
end;

procedure TKDT55DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT55DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT55DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT55DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT55DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT55DI64.PrintNodeTree(const NodePtr: PKDT55DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT55DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT55DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT55DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT55DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT55DI64.KDT55DI64Vec(const s: string): TKDT55DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT55DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT55DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT55DI64.KDT55DI64Vec(const v: TKDT55DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT55DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT55DI64.KDT55DI64Pow(const v: TKDT55DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT55DI64.KDT55DI64Distance(const v1, v2: TKDT55DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT55DI64_Axis - 1 do
      Result := Result + KDT55DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT55DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT55DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT55DI64.Test;
var
  TKDT55DI64_Test    : TKDT55DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT55DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT55DI64_Test := TKDT55DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT55DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT55DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT55DI64_Axis - 1 do
        TKDT55DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT55DI64_Test.TestBuff), length(TKDT55DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT55DI64_Test.BuildKDTreeM(length(TKDT55DI64_Test.TestBuff), @TKDT55DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT55DI64_Test.BuildKDTreeM(length(TKDT55DI64_Test.TestBuff), TKDT55DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT55DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT55DI64_Test.TestBuff));
  TKDT55DI64_Test.Search(TKDT55DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT55DI64Distance(TKDT55DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT55DI64_Test.Clear;
  { kMean test }
  TKDT55DI64_Test.BuildKDTreeWithCluster(TKDT55DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT55DI64_Test.Search(TKDT55DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT55DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT55DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT55DI64_Test);
end;


function TKDT56DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT56DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT56DI64_Node;
  function SortCompare(const p1, p2: PKDT56DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT56DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT56DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT56DI64_SourceBuffer;
  dynBuff  : PKDT56DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT56DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT56DI64.GetData(const index: NativeInt): PKDT56DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT56DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT56DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT56DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT56DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT56DI64.StoreBuffPtr: PKDT56DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT56DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT56DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT56DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT56DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT56DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT56DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT56DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT56DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT56DI64.BuildKDTreeWithCluster(const inBuff: TKDT56DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT56DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT56DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT56DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT56DI64.BuildKDTreeWithCluster(const inBuff: TKDT56DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT56DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DI64_BuildCall);
var
  TempStoreBuff: TKDT56DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT56DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT56DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT56DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT56DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT56DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DI64_BuildMethod);
var
  TempStoreBuff: TKDT56DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT56DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT56DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT56DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT56DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT56DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT56DI64_BuildProc);
var
  TempStoreBuff: TKDT56DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT56DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT56DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT56DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT56DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT56DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT56DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT56DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT56DI64.Search(const Buff: TKDT56DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT56DI64_Node;

var
  NearestNeighbour: PKDT56DI64_Node;

  function FindParentNode(const BuffPtr: PKDT56DI64_Vec; NodePtr: PKDT56DI64_Node): PKDT56DI64_Node;
  var
    Next       : PKDT56DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT56DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT56DI64_Node; const BuffPtr: PKDT56DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT56DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT56DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT56DI64_Vec; const p1, p2: PKDT56DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT56DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT56DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT56DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT56DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT56DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT56DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT56DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT56DI64.Search(const Buff: TKDT56DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT56DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT56DI64.Search(const Buff: TKDT56DI64_Vec; var SearchedDistanceMin: Double): PKDT56DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT56DI64.Search(const Buff: TKDT56DI64_Vec): PKDT56DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT56DI64.Search(const inBuff: TKDT56DI64_DynamicVecBuffer; var OutBuff: TKDT56DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT56DI64_DynamicVecBuffer;
  outBuffPtr : PKDT56DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT56DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT56DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT56DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT56DI64.Search(const inBuff: TKDT56DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT56DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT56DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT56DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT56DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT56DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT56DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT56DI64_Source));
end;

procedure TKDT56DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT56DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT56DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT56DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT56DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT56DI64.PrintNodeTree(const NodePtr: PKDT56DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT56DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT56DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT56DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT56DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT56DI64.KDT56DI64Vec(const s: string): TKDT56DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT56DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT56DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT56DI64.KDT56DI64Vec(const v: TKDT56DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT56DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT56DI64.KDT56DI64Pow(const v: TKDT56DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT56DI64.KDT56DI64Distance(const v1, v2: TKDT56DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT56DI64_Axis - 1 do
      Result := Result + KDT56DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT56DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT56DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT56DI64.Test;
var
  TKDT56DI64_Test    : TKDT56DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT56DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT56DI64_Test := TKDT56DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT56DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT56DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT56DI64_Axis - 1 do
        TKDT56DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT56DI64_Test.TestBuff), length(TKDT56DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT56DI64_Test.BuildKDTreeM(length(TKDT56DI64_Test.TestBuff), @TKDT56DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT56DI64_Test.BuildKDTreeM(length(TKDT56DI64_Test.TestBuff), TKDT56DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT56DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT56DI64_Test.TestBuff));
  TKDT56DI64_Test.Search(TKDT56DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT56DI64Distance(TKDT56DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT56DI64_Test.Clear;
  { kMean test }
  TKDT56DI64_Test.BuildKDTreeWithCluster(TKDT56DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT56DI64_Test.Search(TKDT56DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT56DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT56DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT56DI64_Test);
end;


function TKDT57DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT57DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT57DI64_Node;
  function SortCompare(const p1, p2: PKDT57DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT57DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT57DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT57DI64_SourceBuffer;
  dynBuff  : PKDT57DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT57DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT57DI64.GetData(const index: NativeInt): PKDT57DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT57DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT57DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT57DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT57DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT57DI64.StoreBuffPtr: PKDT57DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT57DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT57DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT57DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT57DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT57DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT57DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT57DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT57DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT57DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT57DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT57DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT57DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT57DI64.BuildKDTreeWithCluster(const inBuff: TKDT57DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT57DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT57DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT57DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT57DI64.BuildKDTreeWithCluster(const inBuff: TKDT57DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT57DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT57DI64_BuildCall);
var
  TempStoreBuff: TKDT57DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT57DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT57DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT57DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT57DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT57DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT57DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT57DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT57DI64_BuildMethod);
var
  TempStoreBuff: TKDT57DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT57DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT57DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT57DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT57DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT57DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT57DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT57DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT57DI64_BuildProc);
var
  TempStoreBuff: TKDT57DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT57DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT57DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT57DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT57DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT57DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT57DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT57DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT57DI64.Search(const Buff: TKDT57DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT57DI64_Node;

var
  NearestNeighbour: PKDT57DI64_Node;

  function FindParentNode(const BuffPtr: PKDT57DI64_Vec; NodePtr: PKDT57DI64_Node): PKDT57DI64_Node;
  var
    Next       : PKDT57DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT57DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT57DI64_Node; const BuffPtr: PKDT57DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT57DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT57DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT57DI64_Vec; const p1, p2: PKDT57DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT57DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT57DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT57DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT57DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT57DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT57DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT57DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT57DI64.Search(const Buff: TKDT57DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT57DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT57DI64.Search(const Buff: TKDT57DI64_Vec; var SearchedDistanceMin: Double): PKDT57DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT57DI64.Search(const Buff: TKDT57DI64_Vec): PKDT57DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT57DI64.Search(const inBuff: TKDT57DI64_DynamicVecBuffer; var OutBuff: TKDT57DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT57DI64_DynamicVecBuffer;
  outBuffPtr : PKDT57DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT57DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT57DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT57DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT57DI64.Search(const inBuff: TKDT57DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT57DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT57DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT57DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT57DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT57DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT57DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT57DI64_Source));
end;

procedure TKDT57DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT57DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT57DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT57DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT57DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT57DI64.PrintNodeTree(const NodePtr: PKDT57DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT57DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT57DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT57DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT57DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT57DI64.KDT57DI64Vec(const s: string): TKDT57DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT57DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT57DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT57DI64.KDT57DI64Vec(const v: TKDT57DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT57DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT57DI64.KDT57DI64Pow(const v: TKDT57DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT57DI64.KDT57DI64Distance(const v1, v2: TKDT57DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT57DI64_Axis - 1 do
      Result := Result + KDT57DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT57DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT57DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT57DI64.Test;
var
  TKDT57DI64_Test    : TKDT57DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT57DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT57DI64_Test := TKDT57DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT57DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT57DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT57DI64_Axis - 1 do
        TKDT57DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT57DI64_Test.TestBuff), length(TKDT57DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT57DI64_Test.BuildKDTreeM(length(TKDT57DI64_Test.TestBuff), @TKDT57DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT57DI64_Test.BuildKDTreeM(length(TKDT57DI64_Test.TestBuff), TKDT57DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT57DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT57DI64_Test.TestBuff));
  TKDT57DI64_Test.Search(TKDT57DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT57DI64Distance(TKDT57DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT57DI64_Test.Clear;
  { kMean test }
  TKDT57DI64_Test.BuildKDTreeWithCluster(TKDT57DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT57DI64_Test.Search(TKDT57DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT57DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT57DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT57DI64_Test);
end;


function TKDT58DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT58DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT58DI64_Node;
  function SortCompare(const p1, p2: PKDT58DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT58DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT58DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT58DI64_SourceBuffer;
  dynBuff  : PKDT58DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT58DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT58DI64.GetData(const index: NativeInt): PKDT58DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT58DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT58DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT58DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT58DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT58DI64.StoreBuffPtr: PKDT58DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT58DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT58DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT58DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT58DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT58DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT58DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT58DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT58DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT58DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT58DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT58DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT58DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT58DI64.BuildKDTreeWithCluster(const inBuff: TKDT58DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT58DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT58DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT58DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT58DI64.BuildKDTreeWithCluster(const inBuff: TKDT58DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT58DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT58DI64_BuildCall);
var
  TempStoreBuff: TKDT58DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT58DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT58DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT58DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT58DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT58DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT58DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT58DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT58DI64_BuildMethod);
var
  TempStoreBuff: TKDT58DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT58DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT58DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT58DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT58DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT58DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT58DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT58DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT58DI64_BuildProc);
var
  TempStoreBuff: TKDT58DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT58DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT58DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT58DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT58DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT58DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT58DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT58DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT58DI64.Search(const Buff: TKDT58DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT58DI64_Node;

var
  NearestNeighbour: PKDT58DI64_Node;

  function FindParentNode(const BuffPtr: PKDT58DI64_Vec; NodePtr: PKDT58DI64_Node): PKDT58DI64_Node;
  var
    Next       : PKDT58DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT58DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT58DI64_Node; const BuffPtr: PKDT58DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT58DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT58DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT58DI64_Vec; const p1, p2: PKDT58DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT58DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT58DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT58DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT58DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT58DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT58DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT58DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT58DI64.Search(const Buff: TKDT58DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT58DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT58DI64.Search(const Buff: TKDT58DI64_Vec; var SearchedDistanceMin: Double): PKDT58DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT58DI64.Search(const Buff: TKDT58DI64_Vec): PKDT58DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT58DI64.Search(const inBuff: TKDT58DI64_DynamicVecBuffer; var OutBuff: TKDT58DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT58DI64_DynamicVecBuffer;
  outBuffPtr : PKDT58DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT58DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT58DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT58DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT58DI64.Search(const inBuff: TKDT58DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT58DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT58DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT58DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT58DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT58DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT58DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT58DI64_Source));
end;

procedure TKDT58DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT58DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT58DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT58DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT58DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT58DI64.PrintNodeTree(const NodePtr: PKDT58DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT58DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT58DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT58DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT58DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT58DI64.KDT58DI64Vec(const s: string): TKDT58DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT58DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT58DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT58DI64.KDT58DI64Vec(const v: TKDT58DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT58DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT58DI64.KDT58DI64Pow(const v: TKDT58DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT58DI64.KDT58DI64Distance(const v1, v2: TKDT58DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT58DI64_Axis - 1 do
      Result := Result + KDT58DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT58DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT58DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT58DI64.Test;
var
  TKDT58DI64_Test    : TKDT58DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT58DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT58DI64_Test := TKDT58DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT58DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT58DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT58DI64_Axis - 1 do
        TKDT58DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT58DI64_Test.TestBuff), length(TKDT58DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT58DI64_Test.BuildKDTreeM(length(TKDT58DI64_Test.TestBuff), @TKDT58DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT58DI64_Test.BuildKDTreeM(length(TKDT58DI64_Test.TestBuff), TKDT58DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT58DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT58DI64_Test.TestBuff));
  TKDT58DI64_Test.Search(TKDT58DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT58DI64Distance(TKDT58DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT58DI64_Test.Clear;
  { kMean test }
  TKDT58DI64_Test.BuildKDTreeWithCluster(TKDT58DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT58DI64_Test.Search(TKDT58DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT58DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT58DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT58DI64_Test);
end;


function TKDT59DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT59DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT59DI64_Node;
  function SortCompare(const p1, p2: PKDT59DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT59DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT59DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT59DI64_SourceBuffer;
  dynBuff  : PKDT59DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT59DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT59DI64.GetData(const index: NativeInt): PKDT59DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT59DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT59DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT59DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT59DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT59DI64.StoreBuffPtr: PKDT59DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT59DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT59DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT59DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT59DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT59DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT59DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT59DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT59DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT59DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT59DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT59DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT59DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT59DI64.BuildKDTreeWithCluster(const inBuff: TKDT59DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT59DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT59DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT59DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT59DI64.BuildKDTreeWithCluster(const inBuff: TKDT59DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT59DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT59DI64_BuildCall);
var
  TempStoreBuff: TKDT59DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT59DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT59DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT59DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT59DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT59DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT59DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT59DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT59DI64_BuildMethod);
var
  TempStoreBuff: TKDT59DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT59DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT59DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT59DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT59DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT59DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT59DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT59DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT59DI64_BuildProc);
var
  TempStoreBuff: TKDT59DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT59DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT59DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT59DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT59DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT59DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT59DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT59DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT59DI64.Search(const Buff: TKDT59DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT59DI64_Node;

var
  NearestNeighbour: PKDT59DI64_Node;

  function FindParentNode(const BuffPtr: PKDT59DI64_Vec; NodePtr: PKDT59DI64_Node): PKDT59DI64_Node;
  var
    Next       : PKDT59DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT59DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT59DI64_Node; const BuffPtr: PKDT59DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT59DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT59DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT59DI64_Vec; const p1, p2: PKDT59DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT59DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT59DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT59DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT59DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT59DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT59DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT59DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT59DI64.Search(const Buff: TKDT59DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT59DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT59DI64.Search(const Buff: TKDT59DI64_Vec; var SearchedDistanceMin: Double): PKDT59DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT59DI64.Search(const Buff: TKDT59DI64_Vec): PKDT59DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT59DI64.Search(const inBuff: TKDT59DI64_DynamicVecBuffer; var OutBuff: TKDT59DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT59DI64_DynamicVecBuffer;
  outBuffPtr : PKDT59DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT59DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT59DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT59DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT59DI64.Search(const inBuff: TKDT59DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT59DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT59DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT59DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT59DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT59DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT59DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT59DI64_Source));
end;

procedure TKDT59DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT59DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT59DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT59DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT59DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT59DI64.PrintNodeTree(const NodePtr: PKDT59DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT59DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT59DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT59DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT59DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT59DI64.KDT59DI64Vec(const s: string): TKDT59DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT59DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT59DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT59DI64.KDT59DI64Vec(const v: TKDT59DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT59DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT59DI64.KDT59DI64Pow(const v: TKDT59DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT59DI64.KDT59DI64Distance(const v1, v2: TKDT59DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT59DI64_Axis - 1 do
      Result := Result + KDT59DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT59DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT59DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT59DI64.Test;
var
  TKDT59DI64_Test    : TKDT59DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT59DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT59DI64_Test := TKDT59DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT59DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT59DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT59DI64_Axis - 1 do
        TKDT59DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT59DI64_Test.TestBuff), length(TKDT59DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT59DI64_Test.BuildKDTreeM(length(TKDT59DI64_Test.TestBuff), @TKDT59DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT59DI64_Test.BuildKDTreeM(length(TKDT59DI64_Test.TestBuff), TKDT59DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT59DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT59DI64_Test.TestBuff));
  TKDT59DI64_Test.Search(TKDT59DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT59DI64Distance(TKDT59DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT59DI64_Test.Clear;
  { kMean test }
  TKDT59DI64_Test.BuildKDTreeWithCluster(TKDT59DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT59DI64_Test.Search(TKDT59DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT59DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT59DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT59DI64_Test);
end;


function TKDT60DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT60DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT60DI64_Node;
  function SortCompare(const p1, p2: PKDT60DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT60DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT60DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT60DI64_SourceBuffer;
  dynBuff  : PKDT60DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT60DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT60DI64.GetData(const index: NativeInt): PKDT60DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT60DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT60DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT60DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT60DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT60DI64.StoreBuffPtr: PKDT60DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT60DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT60DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT60DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT60DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT60DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT60DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT60DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT60DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT60DI64.BuildKDTreeWithCluster(const inBuff: TKDT60DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT60DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT60DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT60DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT60DI64.BuildKDTreeWithCluster(const inBuff: TKDT60DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT60DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DI64_BuildCall);
var
  TempStoreBuff: TKDT60DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT60DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT60DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT60DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT60DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT60DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DI64_BuildMethod);
var
  TempStoreBuff: TKDT60DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT60DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT60DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT60DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT60DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT60DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT60DI64_BuildProc);
var
  TempStoreBuff: TKDT60DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT60DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT60DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT60DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT60DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT60DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT60DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT60DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT60DI64.Search(const Buff: TKDT60DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT60DI64_Node;

var
  NearestNeighbour: PKDT60DI64_Node;

  function FindParentNode(const BuffPtr: PKDT60DI64_Vec; NodePtr: PKDT60DI64_Node): PKDT60DI64_Node;
  var
    Next       : PKDT60DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT60DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT60DI64_Node; const BuffPtr: PKDT60DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT60DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT60DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT60DI64_Vec; const p1, p2: PKDT60DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT60DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT60DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT60DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT60DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT60DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT60DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT60DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT60DI64.Search(const Buff: TKDT60DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT60DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT60DI64.Search(const Buff: TKDT60DI64_Vec; var SearchedDistanceMin: Double): PKDT60DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT60DI64.Search(const Buff: TKDT60DI64_Vec): PKDT60DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT60DI64.Search(const inBuff: TKDT60DI64_DynamicVecBuffer; var OutBuff: TKDT60DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT60DI64_DynamicVecBuffer;
  outBuffPtr : PKDT60DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT60DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT60DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT60DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT60DI64.Search(const inBuff: TKDT60DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT60DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT60DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT60DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT60DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT60DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT60DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT60DI64_Source));
end;

procedure TKDT60DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT60DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT60DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT60DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT60DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT60DI64.PrintNodeTree(const NodePtr: PKDT60DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT60DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT60DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT60DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT60DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT60DI64.KDT60DI64Vec(const s: string): TKDT60DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT60DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT60DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT60DI64.KDT60DI64Vec(const v: TKDT60DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT60DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT60DI64.KDT60DI64Pow(const v: TKDT60DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT60DI64.KDT60DI64Distance(const v1, v2: TKDT60DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT60DI64_Axis - 1 do
      Result := Result + KDT60DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT60DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT60DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT60DI64.Test;
var
  TKDT60DI64_Test    : TKDT60DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT60DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT60DI64_Test := TKDT60DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT60DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT60DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT60DI64_Axis - 1 do
        TKDT60DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT60DI64_Test.TestBuff), length(TKDT60DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT60DI64_Test.BuildKDTreeM(length(TKDT60DI64_Test.TestBuff), @TKDT60DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT60DI64_Test.BuildKDTreeM(length(TKDT60DI64_Test.TestBuff), TKDT60DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT60DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT60DI64_Test.TestBuff));
  TKDT60DI64_Test.Search(TKDT60DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT60DI64Distance(TKDT60DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT60DI64_Test.Clear;
  { kMean test }
  TKDT60DI64_Test.BuildKDTreeWithCluster(TKDT60DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT60DI64_Test.Search(TKDT60DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT60DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT60DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT60DI64_Test);
end;


function TKDT61DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT61DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT61DI64_Node;
  function SortCompare(const p1, p2: PKDT61DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT61DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT61DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT61DI64_SourceBuffer;
  dynBuff  : PKDT61DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT61DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT61DI64.GetData(const index: NativeInt): PKDT61DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT61DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT61DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT61DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT61DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT61DI64.StoreBuffPtr: PKDT61DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT61DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT61DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT61DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT61DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT61DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT61DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT61DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT61DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT61DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT61DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT61DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT61DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT61DI64.BuildKDTreeWithCluster(const inBuff: TKDT61DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT61DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT61DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT61DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT61DI64.BuildKDTreeWithCluster(const inBuff: TKDT61DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT61DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT61DI64_BuildCall);
var
  TempStoreBuff: TKDT61DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT61DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT61DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT61DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT61DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT61DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT61DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT61DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT61DI64_BuildMethod);
var
  TempStoreBuff: TKDT61DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT61DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT61DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT61DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT61DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT61DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT61DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT61DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT61DI64_BuildProc);
var
  TempStoreBuff: TKDT61DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT61DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT61DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT61DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT61DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT61DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT61DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT61DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT61DI64.Search(const Buff: TKDT61DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT61DI64_Node;

var
  NearestNeighbour: PKDT61DI64_Node;

  function FindParentNode(const BuffPtr: PKDT61DI64_Vec; NodePtr: PKDT61DI64_Node): PKDT61DI64_Node;
  var
    Next       : PKDT61DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT61DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT61DI64_Node; const BuffPtr: PKDT61DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT61DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT61DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT61DI64_Vec; const p1, p2: PKDT61DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT61DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT61DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT61DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT61DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT61DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT61DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT61DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT61DI64.Search(const Buff: TKDT61DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT61DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT61DI64.Search(const Buff: TKDT61DI64_Vec; var SearchedDistanceMin: Double): PKDT61DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT61DI64.Search(const Buff: TKDT61DI64_Vec): PKDT61DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT61DI64.Search(const inBuff: TKDT61DI64_DynamicVecBuffer; var OutBuff: TKDT61DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT61DI64_DynamicVecBuffer;
  outBuffPtr : PKDT61DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT61DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT61DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT61DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT61DI64.Search(const inBuff: TKDT61DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT61DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT61DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT61DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT61DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT61DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT61DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT61DI64_Source));
end;

procedure TKDT61DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT61DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT61DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT61DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT61DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT61DI64.PrintNodeTree(const NodePtr: PKDT61DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT61DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT61DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT61DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT61DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT61DI64.KDT61DI64Vec(const s: string): TKDT61DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT61DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT61DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT61DI64.KDT61DI64Vec(const v: TKDT61DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT61DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT61DI64.KDT61DI64Pow(const v: TKDT61DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT61DI64.KDT61DI64Distance(const v1, v2: TKDT61DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT61DI64_Axis - 1 do
      Result := Result + KDT61DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT61DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT61DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT61DI64.Test;
var
  TKDT61DI64_Test    : TKDT61DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT61DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT61DI64_Test := TKDT61DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT61DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT61DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT61DI64_Axis - 1 do
        TKDT61DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT61DI64_Test.TestBuff), length(TKDT61DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT61DI64_Test.BuildKDTreeM(length(TKDT61DI64_Test.TestBuff), @TKDT61DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT61DI64_Test.BuildKDTreeM(length(TKDT61DI64_Test.TestBuff), TKDT61DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT61DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT61DI64_Test.TestBuff));
  TKDT61DI64_Test.Search(TKDT61DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT61DI64Distance(TKDT61DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT61DI64_Test.Clear;
  { kMean test }
  TKDT61DI64_Test.BuildKDTreeWithCluster(TKDT61DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT61DI64_Test.Search(TKDT61DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT61DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT61DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT61DI64_Test);
end;


function TKDT62DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT62DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT62DI64_Node;
  function SortCompare(const p1, p2: PKDT62DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT62DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT62DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT62DI64_SourceBuffer;
  dynBuff  : PKDT62DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT62DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT62DI64.GetData(const index: NativeInt): PKDT62DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT62DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT62DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT62DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT62DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT62DI64.StoreBuffPtr: PKDT62DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT62DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT62DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT62DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT62DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT62DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT62DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT62DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT62DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT62DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT62DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT62DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT62DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT62DI64.BuildKDTreeWithCluster(const inBuff: TKDT62DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT62DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT62DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT62DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT62DI64.BuildKDTreeWithCluster(const inBuff: TKDT62DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT62DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT62DI64_BuildCall);
var
  TempStoreBuff: TKDT62DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT62DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT62DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT62DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT62DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT62DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT62DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT62DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT62DI64_BuildMethod);
var
  TempStoreBuff: TKDT62DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT62DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT62DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT62DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT62DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT62DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT62DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT62DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT62DI64_BuildProc);
var
  TempStoreBuff: TKDT62DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT62DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT62DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT62DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT62DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT62DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT62DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT62DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT62DI64.Search(const Buff: TKDT62DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT62DI64_Node;

var
  NearestNeighbour: PKDT62DI64_Node;

  function FindParentNode(const BuffPtr: PKDT62DI64_Vec; NodePtr: PKDT62DI64_Node): PKDT62DI64_Node;
  var
    Next       : PKDT62DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT62DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT62DI64_Node; const BuffPtr: PKDT62DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT62DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT62DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT62DI64_Vec; const p1, p2: PKDT62DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT62DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT62DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT62DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT62DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT62DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT62DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT62DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT62DI64.Search(const Buff: TKDT62DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT62DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT62DI64.Search(const Buff: TKDT62DI64_Vec; var SearchedDistanceMin: Double): PKDT62DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT62DI64.Search(const Buff: TKDT62DI64_Vec): PKDT62DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT62DI64.Search(const inBuff: TKDT62DI64_DynamicVecBuffer; var OutBuff: TKDT62DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT62DI64_DynamicVecBuffer;
  outBuffPtr : PKDT62DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT62DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT62DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT62DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT62DI64.Search(const inBuff: TKDT62DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT62DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT62DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT62DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT62DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT62DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT62DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT62DI64_Source));
end;

procedure TKDT62DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT62DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT62DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT62DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT62DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT62DI64.PrintNodeTree(const NodePtr: PKDT62DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT62DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT62DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT62DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT62DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT62DI64.KDT62DI64Vec(const s: string): TKDT62DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT62DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT62DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT62DI64.KDT62DI64Vec(const v: TKDT62DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT62DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT62DI64.KDT62DI64Pow(const v: TKDT62DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT62DI64.KDT62DI64Distance(const v1, v2: TKDT62DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT62DI64_Axis - 1 do
      Result := Result + KDT62DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT62DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT62DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT62DI64.Test;
var
  TKDT62DI64_Test    : TKDT62DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT62DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT62DI64_Test := TKDT62DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT62DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT62DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT62DI64_Axis - 1 do
        TKDT62DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT62DI64_Test.TestBuff), length(TKDT62DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT62DI64_Test.BuildKDTreeM(length(TKDT62DI64_Test.TestBuff), @TKDT62DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT62DI64_Test.BuildKDTreeM(length(TKDT62DI64_Test.TestBuff), TKDT62DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT62DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT62DI64_Test.TestBuff));
  TKDT62DI64_Test.Search(TKDT62DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT62DI64Distance(TKDT62DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT62DI64_Test.Clear;
  { kMean test }
  TKDT62DI64_Test.BuildKDTreeWithCluster(TKDT62DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT62DI64_Test.Search(TKDT62DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT62DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT62DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT62DI64_Test);
end;


function TKDT63DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT63DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT63DI64_Node;
  function SortCompare(const p1, p2: PKDT63DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT63DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT63DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT63DI64_SourceBuffer;
  dynBuff  : PKDT63DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT63DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT63DI64.GetData(const index: NativeInt): PKDT63DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT63DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT63DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT63DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT63DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT63DI64.StoreBuffPtr: PKDT63DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT63DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT63DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT63DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT63DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT63DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT63DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT63DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT63DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT63DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT63DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT63DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT63DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT63DI64.BuildKDTreeWithCluster(const inBuff: TKDT63DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT63DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT63DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT63DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT63DI64.BuildKDTreeWithCluster(const inBuff: TKDT63DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT63DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT63DI64_BuildCall);
var
  TempStoreBuff: TKDT63DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT63DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT63DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT63DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT63DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT63DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT63DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT63DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT63DI64_BuildMethod);
var
  TempStoreBuff: TKDT63DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT63DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT63DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT63DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT63DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT63DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT63DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT63DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT63DI64_BuildProc);
var
  TempStoreBuff: TKDT63DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT63DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT63DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT63DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT63DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT63DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT63DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT63DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT63DI64.Search(const Buff: TKDT63DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT63DI64_Node;

var
  NearestNeighbour: PKDT63DI64_Node;

  function FindParentNode(const BuffPtr: PKDT63DI64_Vec; NodePtr: PKDT63DI64_Node): PKDT63DI64_Node;
  var
    Next       : PKDT63DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT63DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT63DI64_Node; const BuffPtr: PKDT63DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT63DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT63DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT63DI64_Vec; const p1, p2: PKDT63DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT63DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT63DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT63DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT63DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT63DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT63DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT63DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT63DI64.Search(const Buff: TKDT63DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT63DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT63DI64.Search(const Buff: TKDT63DI64_Vec; var SearchedDistanceMin: Double): PKDT63DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT63DI64.Search(const Buff: TKDT63DI64_Vec): PKDT63DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT63DI64.Search(const inBuff: TKDT63DI64_DynamicVecBuffer; var OutBuff: TKDT63DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT63DI64_DynamicVecBuffer;
  outBuffPtr : PKDT63DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT63DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT63DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT63DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT63DI64.Search(const inBuff: TKDT63DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT63DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT63DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT63DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT63DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT63DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT63DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT63DI64_Source));
end;

procedure TKDT63DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT63DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT63DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT63DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT63DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT63DI64.PrintNodeTree(const NodePtr: PKDT63DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT63DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT63DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT63DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT63DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT63DI64.KDT63DI64Vec(const s: string): TKDT63DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT63DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT63DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT63DI64.KDT63DI64Vec(const v: TKDT63DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT63DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT63DI64.KDT63DI64Pow(const v: TKDT63DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT63DI64.KDT63DI64Distance(const v1, v2: TKDT63DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT63DI64_Axis - 1 do
      Result := Result + KDT63DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT63DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT63DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT63DI64.Test;
var
  TKDT63DI64_Test    : TKDT63DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT63DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT63DI64_Test := TKDT63DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT63DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT63DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT63DI64_Axis - 1 do
        TKDT63DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT63DI64_Test.TestBuff), length(TKDT63DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT63DI64_Test.BuildKDTreeM(length(TKDT63DI64_Test.TestBuff), @TKDT63DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT63DI64_Test.BuildKDTreeM(length(TKDT63DI64_Test.TestBuff), TKDT63DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT63DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT63DI64_Test.TestBuff));
  TKDT63DI64_Test.Search(TKDT63DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT63DI64Distance(TKDT63DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT63DI64_Test.Clear;
  { kMean test }
  TKDT63DI64_Test.BuildKDTreeWithCluster(TKDT63DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT63DI64_Test.Search(TKDT63DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT63DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT63DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT63DI64_Test);
end;


function TKDT64DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT64DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT64DI64_Node;
  function SortCompare(const p1, p2: PKDT64DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT64DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT64DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT64DI64_SourceBuffer;
  dynBuff  : PKDT64DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT64DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT64DI64.GetData(const index: NativeInt): PKDT64DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT64DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT64DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT64DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT64DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT64DI64.StoreBuffPtr: PKDT64DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT64DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT64DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT64DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT64DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT64DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT64DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT64DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT64DI64.BuildKDTreeWithCluster(const inBuff: TKDT64DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT64DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT64DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT64DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT64DI64.BuildKDTreeWithCluster(const inBuff: TKDT64DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI64_BuildCall);
var
  TempStoreBuff: TKDT64DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT64DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT64DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI64_BuildMethod);
var
  TempStoreBuff: TKDT64DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT64DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT64DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT64DI64_BuildProc);
var
  TempStoreBuff: TKDT64DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT64DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT64DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT64DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT64DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT64DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT64DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT64DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT64DI64.Search(const Buff: TKDT64DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT64DI64_Node;

var
  NearestNeighbour: PKDT64DI64_Node;

  function FindParentNode(const BuffPtr: PKDT64DI64_Vec; NodePtr: PKDT64DI64_Node): PKDT64DI64_Node;
  var
    Next       : PKDT64DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT64DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT64DI64_Node; const BuffPtr: PKDT64DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT64DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT64DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT64DI64_Vec; const p1, p2: PKDT64DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT64DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT64DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT64DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT64DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT64DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT64DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT64DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT64DI64.Search(const Buff: TKDT64DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT64DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT64DI64.Search(const Buff: TKDT64DI64_Vec; var SearchedDistanceMin: Double): PKDT64DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT64DI64.Search(const Buff: TKDT64DI64_Vec): PKDT64DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT64DI64.Search(const inBuff: TKDT64DI64_DynamicVecBuffer; var OutBuff: TKDT64DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT64DI64_DynamicVecBuffer;
  outBuffPtr : PKDT64DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT64DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT64DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DI64.Search(const inBuff: TKDT64DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT64DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT64DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT64DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT64DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT64DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT64DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT64DI64_Source));
end;

procedure TKDT64DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT64DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT64DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT64DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT64DI64.PrintNodeTree(const NodePtr: PKDT64DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT64DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT64DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT64DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT64DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT64DI64.KDT64DI64Vec(const s: string): TKDT64DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT64DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT64DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT64DI64.KDT64DI64Vec(const v: TKDT64DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT64DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT64DI64.KDT64DI64Pow(const v: TKDT64DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT64DI64.KDT64DI64Distance(const v1, v2: TKDT64DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT64DI64_Axis - 1 do
      Result := Result + KDT64DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT64DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT64DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT64DI64.Test;
var
  TKDT64DI64_Test    : TKDT64DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT64DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT64DI64_Test := TKDT64DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT64DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT64DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT64DI64_Axis - 1 do
        TKDT64DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT64DI64_Test.TestBuff), length(TKDT64DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT64DI64_Test.BuildKDTreeM(length(TKDT64DI64_Test.TestBuff), @TKDT64DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT64DI64_Test.BuildKDTreeM(length(TKDT64DI64_Test.TestBuff), TKDT64DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT64DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT64DI64_Test.TestBuff));
  TKDT64DI64_Test.Search(TKDT64DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT64DI64Distance(TKDT64DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT64DI64_Test.Clear;
  { kMean test }
  TKDT64DI64_Test.BuildKDTreeWithCluster(TKDT64DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT64DI64_Test.Search(TKDT64DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT64DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT64DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT64DI64_Test);
end;


function TKDT72DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT72DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT72DI64_Node;
  function SortCompare(const p1, p2: PKDT72DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT72DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT72DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT72DI64_SourceBuffer;
  dynBuff  : PKDT72DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT72DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT72DI64.GetData(const index: NativeInt): PKDT72DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT72DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT72DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT72DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT72DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT72DI64.StoreBuffPtr: PKDT72DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT72DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT72DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT72DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT72DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT72DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT72DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT72DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT72DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT72DI64.BuildKDTreeWithCluster(const inBuff: TKDT72DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT72DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT72DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT72DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT72DI64.BuildKDTreeWithCluster(const inBuff: TKDT72DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT72DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DI64_BuildCall);
var
  TempStoreBuff: TKDT72DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT72DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT72DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT72DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT72DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT72DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DI64_BuildMethod);
var
  TempStoreBuff: TKDT72DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT72DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT72DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT72DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT72DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT72DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT72DI64_BuildProc);
var
  TempStoreBuff: TKDT72DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT72DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT72DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT72DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT72DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT72DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT72DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT72DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT72DI64.Search(const Buff: TKDT72DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT72DI64_Node;

var
  NearestNeighbour: PKDT72DI64_Node;

  function FindParentNode(const BuffPtr: PKDT72DI64_Vec; NodePtr: PKDT72DI64_Node): PKDT72DI64_Node;
  var
    Next       : PKDT72DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT72DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT72DI64_Node; const BuffPtr: PKDT72DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT72DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT72DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT72DI64_Vec; const p1, p2: PKDT72DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT72DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT72DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT72DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT72DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT72DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT72DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT72DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT72DI64.Search(const Buff: TKDT72DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT72DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT72DI64.Search(const Buff: TKDT72DI64_Vec; var SearchedDistanceMin: Double): PKDT72DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT72DI64.Search(const Buff: TKDT72DI64_Vec): PKDT72DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT72DI64.Search(const inBuff: TKDT72DI64_DynamicVecBuffer; var OutBuff: TKDT72DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT72DI64_DynamicVecBuffer;
  outBuffPtr : PKDT72DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT72DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT72DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT72DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT72DI64.Search(const inBuff: TKDT72DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT72DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT72DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT72DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT72DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT72DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT72DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT72DI64_Source));
end;

procedure TKDT72DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT72DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT72DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT72DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT72DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT72DI64.PrintNodeTree(const NodePtr: PKDT72DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT72DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT72DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT72DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT72DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT72DI64.KDT72DI64Vec(const s: string): TKDT72DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT72DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT72DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT72DI64.KDT72DI64Vec(const v: TKDT72DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT72DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT72DI64.KDT72DI64Pow(const v: TKDT72DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT72DI64.KDT72DI64Distance(const v1, v2: TKDT72DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT72DI64_Axis - 1 do
      Result := Result + KDT72DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT72DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT72DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT72DI64.Test;
var
  TKDT72DI64_Test    : TKDT72DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT72DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT72DI64_Test := TKDT72DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT72DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT72DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT72DI64_Axis - 1 do
        TKDT72DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT72DI64_Test.TestBuff), length(TKDT72DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT72DI64_Test.BuildKDTreeM(length(TKDT72DI64_Test.TestBuff), @TKDT72DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT72DI64_Test.BuildKDTreeM(length(TKDT72DI64_Test.TestBuff), TKDT72DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT72DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT72DI64_Test.TestBuff));
  TKDT72DI64_Test.Search(TKDT72DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT72DI64Distance(TKDT72DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT72DI64_Test.Clear;
  { kMean test }
  TKDT72DI64_Test.BuildKDTreeWithCluster(TKDT72DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT72DI64_Test.Search(TKDT72DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT72DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT72DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT72DI64_Test);
end;


function TKDT84DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT84DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT84DI64_Node;
  function SortCompare(const p1, p2: PKDT84DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT84DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT84DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT84DI64_SourceBuffer;
  dynBuff  : PKDT84DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT84DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT84DI64.GetData(const index: NativeInt): PKDT84DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT84DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT84DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT84DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT84DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT84DI64.StoreBuffPtr: PKDT84DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT84DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT84DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT84DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT84DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT84DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT84DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT84DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT84DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT84DI64.BuildKDTreeWithCluster(const inBuff: TKDT84DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT84DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT84DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT84DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT84DI64.BuildKDTreeWithCluster(const inBuff: TKDT84DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT84DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DI64_BuildCall);
var
  TempStoreBuff: TKDT84DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT84DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT84DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT84DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT84DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT84DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DI64_BuildMethod);
var
  TempStoreBuff: TKDT84DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT84DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT84DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT84DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT84DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT84DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT84DI64_BuildProc);
var
  TempStoreBuff: TKDT84DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT84DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT84DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT84DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT84DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT84DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT84DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT84DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT84DI64.Search(const Buff: TKDT84DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT84DI64_Node;

var
  NearestNeighbour: PKDT84DI64_Node;

  function FindParentNode(const BuffPtr: PKDT84DI64_Vec; NodePtr: PKDT84DI64_Node): PKDT84DI64_Node;
  var
    Next       : PKDT84DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT84DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT84DI64_Node; const BuffPtr: PKDT84DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT84DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT84DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT84DI64_Vec; const p1, p2: PKDT84DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT84DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT84DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT84DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT84DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT84DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT84DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT84DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT84DI64.Search(const Buff: TKDT84DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT84DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT84DI64.Search(const Buff: TKDT84DI64_Vec; var SearchedDistanceMin: Double): PKDT84DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT84DI64.Search(const Buff: TKDT84DI64_Vec): PKDT84DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT84DI64.Search(const inBuff: TKDT84DI64_DynamicVecBuffer; var OutBuff: TKDT84DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT84DI64_DynamicVecBuffer;
  outBuffPtr : PKDT84DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT84DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT84DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT84DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT84DI64.Search(const inBuff: TKDT84DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT84DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT84DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT84DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT84DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT84DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT84DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT84DI64_Source));
end;

procedure TKDT84DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT84DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT84DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT84DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT84DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT84DI64.PrintNodeTree(const NodePtr: PKDT84DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT84DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT84DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT84DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT84DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT84DI64.KDT84DI64Vec(const s: string): TKDT84DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT84DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT84DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT84DI64.KDT84DI64Vec(const v: TKDT84DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT84DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT84DI64.KDT84DI64Pow(const v: TKDT84DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT84DI64.KDT84DI64Distance(const v1, v2: TKDT84DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT84DI64_Axis - 1 do
      Result := Result + KDT84DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT84DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT84DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT84DI64.Test;
var
  TKDT84DI64_Test    : TKDT84DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT84DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT84DI64_Test := TKDT84DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT84DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT84DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT84DI64_Axis - 1 do
        TKDT84DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT84DI64_Test.TestBuff), length(TKDT84DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT84DI64_Test.BuildKDTreeM(length(TKDT84DI64_Test.TestBuff), @TKDT84DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT84DI64_Test.BuildKDTreeM(length(TKDT84DI64_Test.TestBuff), TKDT84DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT84DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT84DI64_Test.TestBuff));
  TKDT84DI64_Test.Search(TKDT84DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT84DI64Distance(TKDT84DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT84DI64_Test.Clear;
  { kMean test }
  TKDT84DI64_Test.BuildKDTreeWithCluster(TKDT84DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT84DI64_Test.Search(TKDT84DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT84DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT84DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT84DI64_Test);
end;


function TKDT96DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT96DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT96DI64_Node;
  function SortCompare(const p1, p2: PKDT96DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT96DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT96DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT96DI64_SourceBuffer;
  dynBuff  : PKDT96DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT96DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT96DI64.GetData(const index: NativeInt): PKDT96DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT96DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT96DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT96DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT96DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT96DI64.StoreBuffPtr: PKDT96DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT96DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT96DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT96DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT96DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT96DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT96DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT96DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT96DI64.BuildKDTreeWithCluster(const inBuff: TKDT96DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT96DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT96DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT96DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT96DI64.BuildKDTreeWithCluster(const inBuff: TKDT96DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI64_BuildCall);
var
  TempStoreBuff: TKDT96DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT96DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT96DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI64_BuildMethod);
var
  TempStoreBuff: TKDT96DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT96DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT96DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT96DI64_BuildProc);
var
  TempStoreBuff: TKDT96DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT96DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT96DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT96DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT96DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT96DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT96DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT96DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT96DI64.Search(const Buff: TKDT96DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT96DI64_Node;

var
  NearestNeighbour: PKDT96DI64_Node;

  function FindParentNode(const BuffPtr: PKDT96DI64_Vec; NodePtr: PKDT96DI64_Node): PKDT96DI64_Node;
  var
    Next       : PKDT96DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT96DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT96DI64_Node; const BuffPtr: PKDT96DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT96DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT96DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT96DI64_Vec; const p1, p2: PKDT96DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT96DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT96DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT96DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT96DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT96DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT96DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT96DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT96DI64.Search(const Buff: TKDT96DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT96DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT96DI64.Search(const Buff: TKDT96DI64_Vec; var SearchedDistanceMin: Double): PKDT96DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT96DI64.Search(const Buff: TKDT96DI64_Vec): PKDT96DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT96DI64.Search(const inBuff: TKDT96DI64_DynamicVecBuffer; var OutBuff: TKDT96DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT96DI64_DynamicVecBuffer;
  outBuffPtr : PKDT96DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT96DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT96DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DI64.Search(const inBuff: TKDT96DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT96DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT96DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT96DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT96DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT96DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT96DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT96DI64_Source));
end;

procedure TKDT96DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT96DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT96DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT96DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT96DI64.PrintNodeTree(const NodePtr: PKDT96DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT96DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT96DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT96DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT96DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT96DI64.KDT96DI64Vec(const s: string): TKDT96DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT96DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT96DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT96DI64.KDT96DI64Vec(const v: TKDT96DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT96DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT96DI64.KDT96DI64Pow(const v: TKDT96DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT96DI64.KDT96DI64Distance(const v1, v2: TKDT96DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT96DI64_Axis - 1 do
      Result := Result + KDT96DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT96DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT96DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT96DI64.Test;
var
  TKDT96DI64_Test    : TKDT96DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT96DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT96DI64_Test := TKDT96DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT96DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT96DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT96DI64_Axis - 1 do
        TKDT96DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT96DI64_Test.TestBuff), length(TKDT96DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT96DI64_Test.BuildKDTreeM(length(TKDT96DI64_Test.TestBuff), @TKDT96DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT96DI64_Test.BuildKDTreeM(length(TKDT96DI64_Test.TestBuff), TKDT96DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT96DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT96DI64_Test.TestBuff));
  TKDT96DI64_Test.Search(TKDT96DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT96DI64Distance(TKDT96DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT96DI64_Test.Clear;
  { kMean test }
  TKDT96DI64_Test.BuildKDTreeWithCluster(TKDT96DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT96DI64_Test.Search(TKDT96DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT96DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT96DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT96DI64_Test);
end;


function TKDT128DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT128DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT128DI64_Node;
  function SortCompare(const p1, p2: PKDT128DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT128DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT128DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT128DI64_SourceBuffer;
  dynBuff  : PKDT128DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT128DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT128DI64.GetData(const index: NativeInt): PKDT128DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT128DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT128DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT128DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT128DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT128DI64.StoreBuffPtr: PKDT128DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT128DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT128DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT128DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT128DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT128DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT128DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT128DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT128DI64.BuildKDTreeWithCluster(const inBuff: TKDT128DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT128DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT128DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT128DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT128DI64.BuildKDTreeWithCluster(const inBuff: TKDT128DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI64_BuildCall);
var
  TempStoreBuff: TKDT128DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT128DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT128DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI64_BuildMethod);
var
  TempStoreBuff: TKDT128DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT128DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT128DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT128DI64_BuildProc);
var
  TempStoreBuff: TKDT128DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT128DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT128DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT128DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT128DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT128DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT128DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT128DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT128DI64.Search(const Buff: TKDT128DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT128DI64_Node;

var
  NearestNeighbour: PKDT128DI64_Node;

  function FindParentNode(const BuffPtr: PKDT128DI64_Vec; NodePtr: PKDT128DI64_Node): PKDT128DI64_Node;
  var
    Next       : PKDT128DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT128DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT128DI64_Node; const BuffPtr: PKDT128DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT128DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT128DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT128DI64_Vec; const p1, p2: PKDT128DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT128DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT128DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT128DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT128DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT128DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT128DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT128DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT128DI64.Search(const Buff: TKDT128DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT128DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT128DI64.Search(const Buff: TKDT128DI64_Vec; var SearchedDistanceMin: Double): PKDT128DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT128DI64.Search(const Buff: TKDT128DI64_Vec): PKDT128DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT128DI64.Search(const inBuff: TKDT128DI64_DynamicVecBuffer; var OutBuff: TKDT128DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT128DI64_DynamicVecBuffer;
  outBuffPtr : PKDT128DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT128DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT128DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DI64.Search(const inBuff: TKDT128DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT128DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT128DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT128DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT128DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT128DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT128DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT128DI64_Source));
end;

procedure TKDT128DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT128DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT128DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT128DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT128DI64.PrintNodeTree(const NodePtr: PKDT128DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT128DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT128DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT128DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT128DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT128DI64.KDT128DI64Vec(const s: string): TKDT128DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT128DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT128DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT128DI64.KDT128DI64Vec(const v: TKDT128DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT128DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT128DI64.KDT128DI64Pow(const v: TKDT128DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT128DI64.KDT128DI64Distance(const v1, v2: TKDT128DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT128DI64_Axis - 1 do
      Result := Result + KDT128DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT128DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT128DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT128DI64.Test;
var
  TKDT128DI64_Test    : TKDT128DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT128DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT128DI64_Test := TKDT128DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT128DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT128DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT128DI64_Axis - 1 do
        TKDT128DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT128DI64_Test.TestBuff), length(TKDT128DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT128DI64_Test.BuildKDTreeM(length(TKDT128DI64_Test.TestBuff), @TKDT128DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT128DI64_Test.BuildKDTreeM(length(TKDT128DI64_Test.TestBuff), TKDT128DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT128DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT128DI64_Test.TestBuff));
  TKDT128DI64_Test.Search(TKDT128DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT128DI64Distance(TKDT128DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT128DI64_Test.Clear;
  { kMean test }
  TKDT128DI64_Test.BuildKDTreeWithCluster(TKDT128DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT128DI64_Test.Search(TKDT128DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT128DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT128DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT128DI64_Test);
end;


function TKDT140DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT140DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT140DI64_Node;
  function SortCompare(const p1, p2: PKDT140DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT140DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT140DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT140DI64_SourceBuffer;
  dynBuff  : PKDT140DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT140DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT140DI64.GetData(const index: NativeInt): PKDT140DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT140DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT140DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT140DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT140DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT140DI64.StoreBuffPtr: PKDT140DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT140DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT140DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT140DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT140DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT140DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT140DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT140DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT140DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT140DI64.BuildKDTreeWithCluster(const inBuff: TKDT140DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT140DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT140DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT140DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT140DI64.BuildKDTreeWithCluster(const inBuff: TKDT140DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT140DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DI64_BuildCall);
var
  TempStoreBuff: TKDT140DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT140DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT140DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT140DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT140DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT140DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DI64_BuildMethod);
var
  TempStoreBuff: TKDT140DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT140DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT140DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT140DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT140DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT140DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT140DI64_BuildProc);
var
  TempStoreBuff: TKDT140DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT140DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT140DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT140DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT140DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT140DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT140DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT140DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT140DI64.Search(const Buff: TKDT140DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT140DI64_Node;

var
  NearestNeighbour: PKDT140DI64_Node;

  function FindParentNode(const BuffPtr: PKDT140DI64_Vec; NodePtr: PKDT140DI64_Node): PKDT140DI64_Node;
  var
    Next       : PKDT140DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT140DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT140DI64_Node; const BuffPtr: PKDT140DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT140DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT140DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT140DI64_Vec; const p1, p2: PKDT140DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT140DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT140DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT140DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT140DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT140DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT140DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT140DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT140DI64.Search(const Buff: TKDT140DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT140DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT140DI64.Search(const Buff: TKDT140DI64_Vec; var SearchedDistanceMin: Double): PKDT140DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT140DI64.Search(const Buff: TKDT140DI64_Vec): PKDT140DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT140DI64.Search(const inBuff: TKDT140DI64_DynamicVecBuffer; var OutBuff: TKDT140DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT140DI64_DynamicVecBuffer;
  outBuffPtr : PKDT140DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT140DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT140DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT140DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT140DI64.Search(const inBuff: TKDT140DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT140DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT140DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT140DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT140DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT140DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT140DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT140DI64_Source));
end;

procedure TKDT140DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT140DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT140DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT140DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT140DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT140DI64.PrintNodeTree(const NodePtr: PKDT140DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT140DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT140DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT140DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT140DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT140DI64.KDT140DI64Vec(const s: string): TKDT140DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT140DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT140DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT140DI64.KDT140DI64Vec(const v: TKDT140DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT140DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT140DI64.KDT140DI64Pow(const v: TKDT140DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT140DI64.KDT140DI64Distance(const v1, v2: TKDT140DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT140DI64_Axis - 1 do
      Result := Result + KDT140DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT140DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT140DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT140DI64.Test;
var
  TKDT140DI64_Test    : TKDT140DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT140DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT140DI64_Test := TKDT140DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT140DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT140DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT140DI64_Axis - 1 do
        TKDT140DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT140DI64_Test.TestBuff), length(TKDT140DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT140DI64_Test.BuildKDTreeM(length(TKDT140DI64_Test.TestBuff), @TKDT140DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT140DI64_Test.BuildKDTreeM(length(TKDT140DI64_Test.TestBuff), TKDT140DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT140DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT140DI64_Test.TestBuff));
  TKDT140DI64_Test.Search(TKDT140DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT140DI64Distance(TKDT140DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT140DI64_Test.Clear;
  { kMean test }
  TKDT140DI64_Test.BuildKDTreeWithCluster(TKDT140DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT140DI64_Test.Search(TKDT140DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT140DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT140DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT140DI64_Test);
end;


function TKDT160DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT160DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT160DI64_Node;
  function SortCompare(const p1, p2: PKDT160DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT160DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT160DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT160DI64_SourceBuffer;
  dynBuff  : PKDT160DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT160DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT160DI64.GetData(const index: NativeInt): PKDT160DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT160DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT160DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT160DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT160DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT160DI64.StoreBuffPtr: PKDT160DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT160DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT160DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT160DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT160DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT160DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT160DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT160DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT160DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT160DI64.BuildKDTreeWithCluster(const inBuff: TKDT160DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT160DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT160DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT160DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT160DI64.BuildKDTreeWithCluster(const inBuff: TKDT160DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT160DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DI64_BuildCall);
var
  TempStoreBuff: TKDT160DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT160DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT160DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT160DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT160DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT160DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DI64_BuildMethod);
var
  TempStoreBuff: TKDT160DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT160DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT160DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT160DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT160DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT160DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT160DI64_BuildProc);
var
  TempStoreBuff: TKDT160DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT160DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT160DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT160DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT160DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT160DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT160DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT160DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT160DI64.Search(const Buff: TKDT160DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT160DI64_Node;

var
  NearestNeighbour: PKDT160DI64_Node;

  function FindParentNode(const BuffPtr: PKDT160DI64_Vec; NodePtr: PKDT160DI64_Node): PKDT160DI64_Node;
  var
    Next       : PKDT160DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT160DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT160DI64_Node; const BuffPtr: PKDT160DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT160DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT160DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT160DI64_Vec; const p1, p2: PKDT160DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT160DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT160DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT160DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT160DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT160DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT160DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT160DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT160DI64.Search(const Buff: TKDT160DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT160DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT160DI64.Search(const Buff: TKDT160DI64_Vec; var SearchedDistanceMin: Double): PKDT160DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT160DI64.Search(const Buff: TKDT160DI64_Vec): PKDT160DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT160DI64.Search(const inBuff: TKDT160DI64_DynamicVecBuffer; var OutBuff: TKDT160DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT160DI64_DynamicVecBuffer;
  outBuffPtr : PKDT160DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT160DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT160DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT160DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT160DI64.Search(const inBuff: TKDT160DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT160DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT160DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT160DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT160DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT160DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT160DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT160DI64_Source));
end;

procedure TKDT160DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT160DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT160DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT160DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT160DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT160DI64.PrintNodeTree(const NodePtr: PKDT160DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT160DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT160DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT160DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT160DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT160DI64.KDT160DI64Vec(const s: string): TKDT160DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT160DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT160DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT160DI64.KDT160DI64Vec(const v: TKDT160DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT160DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT160DI64.KDT160DI64Pow(const v: TKDT160DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT160DI64.KDT160DI64Distance(const v1, v2: TKDT160DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT160DI64_Axis - 1 do
      Result := Result + KDT160DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT160DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT160DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT160DI64.Test;
var
  TKDT160DI64_Test    : TKDT160DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT160DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT160DI64_Test := TKDT160DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT160DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT160DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT160DI64_Axis - 1 do
        TKDT160DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT160DI64_Test.TestBuff), length(TKDT160DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT160DI64_Test.BuildKDTreeM(length(TKDT160DI64_Test.TestBuff), @TKDT160DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT160DI64_Test.BuildKDTreeM(length(TKDT160DI64_Test.TestBuff), TKDT160DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT160DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT160DI64_Test.TestBuff));
  TKDT160DI64_Test.Search(TKDT160DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT160DI64Distance(TKDT160DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT160DI64_Test.Clear;
  { kMean test }
  TKDT160DI64_Test.BuildKDTreeWithCluster(TKDT160DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT160DI64_Test.Search(TKDT160DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT160DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT160DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT160DI64_Test);
end;


function TKDT196DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT196DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT196DI64_Node;
  function SortCompare(const p1, p2: PKDT196DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT196DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT196DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT196DI64_SourceBuffer;
  dynBuff  : PKDT196DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT196DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT196DI64.GetData(const index: NativeInt): PKDT196DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT196DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT196DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT196DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT196DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT196DI64.StoreBuffPtr: PKDT196DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT196DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT196DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT196DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT196DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT196DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT196DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT196DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT196DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT196DI64.BuildKDTreeWithCluster(const inBuff: TKDT196DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT196DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT196DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT196DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT196DI64.BuildKDTreeWithCluster(const inBuff: TKDT196DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT196DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DI64_BuildCall);
var
  TempStoreBuff: TKDT196DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT196DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT196DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT196DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT196DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT196DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DI64_BuildMethod);
var
  TempStoreBuff: TKDT196DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT196DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT196DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT196DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT196DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT196DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT196DI64_BuildProc);
var
  TempStoreBuff: TKDT196DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT196DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT196DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT196DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT196DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT196DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT196DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT196DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT196DI64.Search(const Buff: TKDT196DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT196DI64_Node;

var
  NearestNeighbour: PKDT196DI64_Node;

  function FindParentNode(const BuffPtr: PKDT196DI64_Vec; NodePtr: PKDT196DI64_Node): PKDT196DI64_Node;
  var
    Next       : PKDT196DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT196DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT196DI64_Node; const BuffPtr: PKDT196DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT196DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT196DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT196DI64_Vec; const p1, p2: PKDT196DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT196DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT196DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT196DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT196DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT196DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT196DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT196DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT196DI64.Search(const Buff: TKDT196DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT196DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT196DI64.Search(const Buff: TKDT196DI64_Vec; var SearchedDistanceMin: Double): PKDT196DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT196DI64.Search(const Buff: TKDT196DI64_Vec): PKDT196DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT196DI64.Search(const inBuff: TKDT196DI64_DynamicVecBuffer; var OutBuff: TKDT196DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT196DI64_DynamicVecBuffer;
  outBuffPtr : PKDT196DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT196DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT196DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT196DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT196DI64.Search(const inBuff: TKDT196DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT196DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT196DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT196DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT196DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT196DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT196DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT196DI64_Source));
end;

procedure TKDT196DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT196DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT196DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT196DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT196DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT196DI64.PrintNodeTree(const NodePtr: PKDT196DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT196DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT196DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT196DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT196DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT196DI64.KDT196DI64Vec(const s: string): TKDT196DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT196DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT196DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT196DI64.KDT196DI64Vec(const v: TKDT196DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT196DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT196DI64.KDT196DI64Pow(const v: TKDT196DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT196DI64.KDT196DI64Distance(const v1, v2: TKDT196DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT196DI64_Axis - 1 do
      Result := Result + KDT196DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT196DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT196DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT196DI64.Test;
var
  TKDT196DI64_Test    : TKDT196DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT196DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT196DI64_Test := TKDT196DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT196DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT196DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT196DI64_Axis - 1 do
        TKDT196DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT196DI64_Test.TestBuff), length(TKDT196DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT196DI64_Test.BuildKDTreeM(length(TKDT196DI64_Test.TestBuff), @TKDT196DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT196DI64_Test.BuildKDTreeM(length(TKDT196DI64_Test.TestBuff), TKDT196DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT196DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT196DI64_Test.TestBuff));
  TKDT196DI64_Test.Search(TKDT196DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT196DI64Distance(TKDT196DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT196DI64_Test.Clear;
  { kMean test }
  TKDT196DI64_Test.BuildKDTreeWithCluster(TKDT196DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT196DI64_Test.Search(TKDT196DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT196DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT196DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT196DI64_Test);
end;


function TKDT256DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT256DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT256DI64_Node;
  function SortCompare(const p1, p2: PKDT256DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT256DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT256DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT256DI64_SourceBuffer;
  dynBuff  : PKDT256DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT256DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT256DI64.GetData(const index: NativeInt): PKDT256DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT256DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT256DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT256DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT256DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT256DI64.StoreBuffPtr: PKDT256DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT256DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT256DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT256DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT256DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT256DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT256DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT256DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT256DI64.BuildKDTreeWithCluster(const inBuff: TKDT256DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT256DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT256DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT256DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT256DI64.BuildKDTreeWithCluster(const inBuff: TKDT256DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI64_BuildCall);
var
  TempStoreBuff: TKDT256DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT256DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT256DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI64_BuildMethod);
var
  TempStoreBuff: TKDT256DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT256DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT256DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT256DI64_BuildProc);
var
  TempStoreBuff: TKDT256DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT256DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT256DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT256DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT256DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT256DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT256DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT256DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT256DI64.Search(const Buff: TKDT256DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT256DI64_Node;

var
  NearestNeighbour: PKDT256DI64_Node;

  function FindParentNode(const BuffPtr: PKDT256DI64_Vec; NodePtr: PKDT256DI64_Node): PKDT256DI64_Node;
  var
    Next       : PKDT256DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT256DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT256DI64_Node; const BuffPtr: PKDT256DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT256DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT256DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT256DI64_Vec; const p1, p2: PKDT256DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT256DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT256DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT256DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT256DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT256DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT256DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT256DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT256DI64.Search(const Buff: TKDT256DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT256DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT256DI64.Search(const Buff: TKDT256DI64_Vec; var SearchedDistanceMin: Double): PKDT256DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT256DI64.Search(const Buff: TKDT256DI64_Vec): PKDT256DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT256DI64.Search(const inBuff: TKDT256DI64_DynamicVecBuffer; var OutBuff: TKDT256DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT256DI64_DynamicVecBuffer;
  outBuffPtr : PKDT256DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT256DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT256DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DI64.Search(const inBuff: TKDT256DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT256DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT256DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT256DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT256DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT256DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT256DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT256DI64_Source));
end;

procedure TKDT256DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT256DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT256DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT256DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT256DI64.PrintNodeTree(const NodePtr: PKDT256DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT256DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT256DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT256DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT256DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT256DI64.KDT256DI64Vec(const s: string): TKDT256DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT256DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT256DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT256DI64.KDT256DI64Vec(const v: TKDT256DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT256DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT256DI64.KDT256DI64Pow(const v: TKDT256DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT256DI64.KDT256DI64Distance(const v1, v2: TKDT256DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT256DI64_Axis - 1 do
      Result := Result + KDT256DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT256DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT256DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT256DI64.Test;
var
  TKDT256DI64_Test    : TKDT256DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT256DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT256DI64_Test := TKDT256DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT256DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT256DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT256DI64_Axis - 1 do
        TKDT256DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT256DI64_Test.TestBuff), length(TKDT256DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT256DI64_Test.BuildKDTreeM(length(TKDT256DI64_Test.TestBuff), @TKDT256DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT256DI64_Test.BuildKDTreeM(length(TKDT256DI64_Test.TestBuff), TKDT256DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT256DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT256DI64_Test.TestBuff));
  TKDT256DI64_Test.Search(TKDT256DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT256DI64Distance(TKDT256DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT256DI64_Test.Clear;
  { kMean test }
  TKDT256DI64_Test.BuildKDTreeWithCluster(TKDT256DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT256DI64_Test.Search(TKDT256DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT256DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT256DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT256DI64_Test);
end;


function TKDT272DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT272DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT272DI64_Node;
  function SortCompare(const p1, p2: PKDT272DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT272DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT272DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT272DI64_SourceBuffer;
  dynBuff  : PKDT272DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT272DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT272DI64.GetData(const index: NativeInt): PKDT272DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT272DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT272DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT272DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT272DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT272DI64.StoreBuffPtr: PKDT272DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT272DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT272DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT272DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT272DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT272DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT272DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT272DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT272DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT272DI64.BuildKDTreeWithCluster(const inBuff: TKDT272DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT272DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT272DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT272DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT272DI64.BuildKDTreeWithCluster(const inBuff: TKDT272DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT272DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DI64_BuildCall);
var
  TempStoreBuff: TKDT272DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT272DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT272DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT272DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT272DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT272DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DI64_BuildMethod);
var
  TempStoreBuff: TKDT272DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT272DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT272DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT272DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT272DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT272DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT272DI64_BuildProc);
var
  TempStoreBuff: TKDT272DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT272DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT272DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT272DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT272DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT272DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT272DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT272DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT272DI64.Search(const Buff: TKDT272DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT272DI64_Node;

var
  NearestNeighbour: PKDT272DI64_Node;

  function FindParentNode(const BuffPtr: PKDT272DI64_Vec; NodePtr: PKDT272DI64_Node): PKDT272DI64_Node;
  var
    Next       : PKDT272DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT272DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT272DI64_Node; const BuffPtr: PKDT272DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT272DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT272DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT272DI64_Vec; const p1, p2: PKDT272DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT272DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT272DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT272DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT272DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT272DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT272DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT272DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT272DI64.Search(const Buff: TKDT272DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT272DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT272DI64.Search(const Buff: TKDT272DI64_Vec; var SearchedDistanceMin: Double): PKDT272DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT272DI64.Search(const Buff: TKDT272DI64_Vec): PKDT272DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT272DI64.Search(const inBuff: TKDT272DI64_DynamicVecBuffer; var OutBuff: TKDT272DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT272DI64_DynamicVecBuffer;
  outBuffPtr : PKDT272DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT272DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT272DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT272DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT272DI64.Search(const inBuff: TKDT272DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT272DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT272DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT272DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT272DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT272DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT272DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT272DI64_Source));
end;

procedure TKDT272DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT272DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT272DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT272DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT272DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT272DI64.PrintNodeTree(const NodePtr: PKDT272DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT272DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT272DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT272DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT272DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT272DI64.KDT272DI64Vec(const s: string): TKDT272DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT272DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT272DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT272DI64.KDT272DI64Vec(const v: TKDT272DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT272DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT272DI64.KDT272DI64Pow(const v: TKDT272DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT272DI64.KDT272DI64Distance(const v1, v2: TKDT272DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT272DI64_Axis - 1 do
      Result := Result + KDT272DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT272DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT272DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT272DI64.Test;
var
  TKDT272DI64_Test    : TKDT272DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT272DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT272DI64_Test := TKDT272DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT272DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT272DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT272DI64_Axis - 1 do
        TKDT272DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT272DI64_Test.TestBuff), length(TKDT272DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT272DI64_Test.BuildKDTreeM(length(TKDT272DI64_Test.TestBuff), @TKDT272DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT272DI64_Test.BuildKDTreeM(length(TKDT272DI64_Test.TestBuff), TKDT272DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT272DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT272DI64_Test.TestBuff));
  TKDT272DI64_Test.Search(TKDT272DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT272DI64Distance(TKDT272DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT272DI64_Test.Clear;
  { kMean test }
  TKDT272DI64_Test.BuildKDTreeWithCluster(TKDT272DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT272DI64_Test.Search(TKDT272DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT272DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT272DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT272DI64_Test);
end;


function TKDT288DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT288DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT288DI64_Node;
  function SortCompare(const p1, p2: PKDT288DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT288DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT288DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT288DI64_SourceBuffer;
  dynBuff  : PKDT288DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT288DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT288DI64.GetData(const index: NativeInt): PKDT288DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT288DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT288DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT288DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT288DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT288DI64.StoreBuffPtr: PKDT288DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT288DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT288DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT288DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT288DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT288DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT288DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT288DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT288DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT288DI64.BuildKDTreeWithCluster(const inBuff: TKDT288DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT288DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT288DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT288DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT288DI64.BuildKDTreeWithCluster(const inBuff: TKDT288DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT288DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DI64_BuildCall);
var
  TempStoreBuff: TKDT288DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT288DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT288DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT288DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT288DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT288DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DI64_BuildMethod);
var
  TempStoreBuff: TKDT288DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT288DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT288DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT288DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT288DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT288DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT288DI64_BuildProc);
var
  TempStoreBuff: TKDT288DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT288DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT288DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT288DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT288DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT288DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT288DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT288DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT288DI64.Search(const Buff: TKDT288DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT288DI64_Node;

var
  NearestNeighbour: PKDT288DI64_Node;

  function FindParentNode(const BuffPtr: PKDT288DI64_Vec; NodePtr: PKDT288DI64_Node): PKDT288DI64_Node;
  var
    Next       : PKDT288DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT288DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT288DI64_Node; const BuffPtr: PKDT288DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT288DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT288DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT288DI64_Vec; const p1, p2: PKDT288DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT288DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT288DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT288DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT288DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT288DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT288DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT288DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT288DI64.Search(const Buff: TKDT288DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT288DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT288DI64.Search(const Buff: TKDT288DI64_Vec; var SearchedDistanceMin: Double): PKDT288DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT288DI64.Search(const Buff: TKDT288DI64_Vec): PKDT288DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT288DI64.Search(const inBuff: TKDT288DI64_DynamicVecBuffer; var OutBuff: TKDT288DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT288DI64_DynamicVecBuffer;
  outBuffPtr : PKDT288DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT288DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT288DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT288DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT288DI64.Search(const inBuff: TKDT288DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT288DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT288DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT288DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT288DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT288DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT288DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT288DI64_Source));
end;

procedure TKDT288DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT288DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT288DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT288DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT288DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT288DI64.PrintNodeTree(const NodePtr: PKDT288DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT288DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT288DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT288DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT288DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT288DI64.KDT288DI64Vec(const s: string): TKDT288DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT288DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT288DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT288DI64.KDT288DI64Vec(const v: TKDT288DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT288DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT288DI64.KDT288DI64Pow(const v: TKDT288DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT288DI64.KDT288DI64Distance(const v1, v2: TKDT288DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT288DI64_Axis - 1 do
      Result := Result + KDT288DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT288DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT288DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT288DI64.Test;
var
  TKDT288DI64_Test    : TKDT288DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT288DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT288DI64_Test := TKDT288DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT288DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT288DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT288DI64_Axis - 1 do
        TKDT288DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT288DI64_Test.TestBuff), length(TKDT288DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT288DI64_Test.BuildKDTreeM(length(TKDT288DI64_Test.TestBuff), @TKDT288DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT288DI64_Test.BuildKDTreeM(length(TKDT288DI64_Test.TestBuff), TKDT288DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT288DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT288DI64_Test.TestBuff));
  TKDT288DI64_Test.Search(TKDT288DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT288DI64Distance(TKDT288DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT288DI64_Test.Clear;
  { kMean test }
  TKDT288DI64_Test.BuildKDTreeWithCluster(TKDT288DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT288DI64_Test.Search(TKDT288DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT288DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT288DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT288DI64_Test);
end;


function TKDT372DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT372DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT372DI64_Node;
  function SortCompare(const p1, p2: PKDT372DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT372DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT372DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT372DI64_SourceBuffer;
  dynBuff  : PKDT372DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT372DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT372DI64.GetData(const index: NativeInt): PKDT372DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT372DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT372DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT372DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT372DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT372DI64.StoreBuffPtr: PKDT372DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT372DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT372DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT372DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT372DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT372DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT372DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT372DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT372DI64.BuildKDTreeWithCluster(const inBuff: TKDT372DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT372DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT372DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT372DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT372DI64.BuildKDTreeWithCluster(const inBuff: TKDT372DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI64_BuildCall);
var
  TempStoreBuff: TKDT372DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT372DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT372DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT372DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT372DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI64_BuildMethod);
var
  TempStoreBuff: TKDT372DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT372DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT372DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT372DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT372DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT372DI64_BuildProc);
var
  TempStoreBuff: TKDT372DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT372DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT372DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT372DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT372DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT372DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT372DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT372DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT372DI64.Search(const Buff: TKDT372DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT372DI64_Node;

var
  NearestNeighbour: PKDT372DI64_Node;

  function FindParentNode(const BuffPtr: PKDT372DI64_Vec; NodePtr: PKDT372DI64_Node): PKDT372DI64_Node;
  var
    Next       : PKDT372DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT372DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT372DI64_Node; const BuffPtr: PKDT372DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT372DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT372DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT372DI64_Vec; const p1, p2: PKDT372DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT372DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT372DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT372DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT372DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT372DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT372DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT372DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT372DI64.Search(const Buff: TKDT372DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT372DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT372DI64.Search(const Buff: TKDT372DI64_Vec; var SearchedDistanceMin: Double): PKDT372DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT372DI64.Search(const Buff: TKDT372DI64_Vec): PKDT372DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT372DI64.Search(const inBuff: TKDT372DI64_DynamicVecBuffer; var OutBuff: TKDT372DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT372DI64_DynamicVecBuffer;
  outBuffPtr : PKDT372DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT372DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT372DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT372DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT372DI64.Search(const inBuff: TKDT372DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT372DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT372DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT372DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT372DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT372DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT372DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT372DI64_Source));
end;

procedure TKDT372DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT372DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT372DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT372DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT372DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT372DI64.PrintNodeTree(const NodePtr: PKDT372DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT372DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT372DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT372DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT372DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT372DI64.KDT372DI64Vec(const s: string): TKDT372DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT372DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT372DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT372DI64.KDT372DI64Vec(const v: TKDT372DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT372DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT372DI64.KDT372DI64Pow(const v: TKDT372DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT372DI64.KDT372DI64Distance(const v1, v2: TKDT372DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT372DI64_Axis - 1 do
      Result := Result + KDT372DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT372DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT372DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT372DI64.Test;
var
  TKDT372DI64_Test    : TKDT372DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT372DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT372DI64_Test := TKDT372DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT372DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT372DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT372DI64_Axis - 1 do
        TKDT372DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT372DI64_Test.TestBuff), length(TKDT372DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT372DI64_Test.BuildKDTreeM(length(TKDT372DI64_Test.TestBuff), @TKDT372DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT372DI64_Test.BuildKDTreeM(length(TKDT372DI64_Test.TestBuff), TKDT372DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT372DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT372DI64_Test.TestBuff));
  TKDT372DI64_Test.Search(TKDT372DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT372DI64Distance(TKDT372DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT372DI64_Test.Clear;
  { kMean test }
  TKDT372DI64_Test.BuildKDTreeWithCluster(TKDT372DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT372DI64_Test.Search(TKDT372DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT372DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT372DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT372DI64_Test);
end;


function TKDT512DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT512DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT512DI64_Node;
  function SortCompare(const p1, p2: PKDT512DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT512DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT512DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT512DI64_SourceBuffer;
  dynBuff  : PKDT512DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT512DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT512DI64.GetData(const index: NativeInt): PKDT512DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT512DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT512DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT512DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT512DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT512DI64.StoreBuffPtr: PKDT512DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT512DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT512DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT512DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT512DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT512DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT512DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT512DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT512DI64.BuildKDTreeWithCluster(const inBuff: TKDT512DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT512DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT512DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT512DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT512DI64.BuildKDTreeWithCluster(const inBuff: TKDT512DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI64_BuildCall);
var
  TempStoreBuff: TKDT512DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT512DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT512DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI64_BuildMethod);
var
  TempStoreBuff: TKDT512DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT512DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT512DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT512DI64_BuildProc);
var
  TempStoreBuff: TKDT512DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT512DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT512DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT512DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT512DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT512DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT512DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT512DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT512DI64.Search(const Buff: TKDT512DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT512DI64_Node;

var
  NearestNeighbour: PKDT512DI64_Node;

  function FindParentNode(const BuffPtr: PKDT512DI64_Vec; NodePtr: PKDT512DI64_Node): PKDT512DI64_Node;
  var
    Next       : PKDT512DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT512DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT512DI64_Node; const BuffPtr: PKDT512DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT512DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT512DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT512DI64_Vec; const p1, p2: PKDT512DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT512DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT512DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT512DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT512DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT512DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT512DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT512DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT512DI64.Search(const Buff: TKDT512DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT512DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT512DI64.Search(const Buff: TKDT512DI64_Vec; var SearchedDistanceMin: Double): PKDT512DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT512DI64.Search(const Buff: TKDT512DI64_Vec): PKDT512DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT512DI64.Search(const inBuff: TKDT512DI64_DynamicVecBuffer; var OutBuff: TKDT512DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT512DI64_DynamicVecBuffer;
  outBuffPtr : PKDT512DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT512DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT512DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DI64.Search(const inBuff: TKDT512DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT512DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT512DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT512DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT512DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT512DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT512DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT512DI64_Source));
end;

procedure TKDT512DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT512DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT512DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT512DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT512DI64.PrintNodeTree(const NodePtr: PKDT512DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT512DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT512DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT512DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT512DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT512DI64.KDT512DI64Vec(const s: string): TKDT512DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT512DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT512DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT512DI64.KDT512DI64Vec(const v: TKDT512DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT512DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT512DI64.KDT512DI64Pow(const v: TKDT512DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT512DI64.KDT512DI64Distance(const v1, v2: TKDT512DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT512DI64_Axis - 1 do
      Result := Result + KDT512DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT512DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT512DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT512DI64.Test;
var
  TKDT512DI64_Test    : TKDT512DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT512DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT512DI64_Test := TKDT512DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT512DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT512DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT512DI64_Axis - 1 do
        TKDT512DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT512DI64_Test.TestBuff), length(TKDT512DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT512DI64_Test.BuildKDTreeM(length(TKDT512DI64_Test.TestBuff), @TKDT512DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT512DI64_Test.BuildKDTreeM(length(TKDT512DI64_Test.TestBuff), TKDT512DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT512DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT512DI64_Test.TestBuff));
  TKDT512DI64_Test.Search(TKDT512DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT512DI64Distance(TKDT512DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT512DI64_Test.Clear;
  { kMean test }
  TKDT512DI64_Test.BuildKDTreeWithCluster(TKDT512DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT512DI64_Test.Search(TKDT512DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT512DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT512DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT512DI64_Test);
end;


function TKDT576DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT576DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT576DI64_Node;
  function SortCompare(const p1, p2: PKDT576DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT576DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT576DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT576DI64_SourceBuffer;
  dynBuff  : PKDT576DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT576DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT576DI64.GetData(const index: NativeInt): PKDT576DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT576DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT576DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT576DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT576DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT576DI64.StoreBuffPtr: PKDT576DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT576DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT576DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT576DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT576DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT576DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT576DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT576DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT576DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT576DI64.BuildKDTreeWithCluster(const inBuff: TKDT576DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT576DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT576DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT576DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT576DI64.BuildKDTreeWithCluster(const inBuff: TKDT576DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT576DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DI64_BuildCall);
var
  TempStoreBuff: TKDT576DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT576DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT576DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT576DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT576DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT576DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DI64_BuildMethod);
var
  TempStoreBuff: TKDT576DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT576DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT576DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT576DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT576DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT576DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT576DI64_BuildProc);
var
  TempStoreBuff: TKDT576DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT576DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT576DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT576DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT576DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT576DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT576DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT576DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT576DI64.Search(const Buff: TKDT576DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT576DI64_Node;

var
  NearestNeighbour: PKDT576DI64_Node;

  function FindParentNode(const BuffPtr: PKDT576DI64_Vec; NodePtr: PKDT576DI64_Node): PKDT576DI64_Node;
  var
    Next       : PKDT576DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT576DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT576DI64_Node; const BuffPtr: PKDT576DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT576DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT576DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT576DI64_Vec; const p1, p2: PKDT576DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT576DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT576DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT576DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT576DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT576DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT576DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT576DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT576DI64.Search(const Buff: TKDT576DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT576DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT576DI64.Search(const Buff: TKDT576DI64_Vec; var SearchedDistanceMin: Double): PKDT576DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT576DI64.Search(const Buff: TKDT576DI64_Vec): PKDT576DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT576DI64.Search(const inBuff: TKDT576DI64_DynamicVecBuffer; var OutBuff: TKDT576DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT576DI64_DynamicVecBuffer;
  outBuffPtr : PKDT576DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT576DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT576DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT576DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT576DI64.Search(const inBuff: TKDT576DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT576DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT576DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT576DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT576DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT576DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT576DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT576DI64_Source));
end;

procedure TKDT576DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT576DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT576DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT576DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT576DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT576DI64.PrintNodeTree(const NodePtr: PKDT576DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT576DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT576DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT576DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT576DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT576DI64.KDT576DI64Vec(const s: string): TKDT576DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT576DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT576DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT576DI64.KDT576DI64Vec(const v: TKDT576DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT576DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT576DI64.KDT576DI64Pow(const v: TKDT576DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT576DI64.KDT576DI64Distance(const v1, v2: TKDT576DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT576DI64_Axis - 1 do
      Result := Result + KDT576DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT576DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT576DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT576DI64.Test;
var
  TKDT576DI64_Test    : TKDT576DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT576DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT576DI64_Test := TKDT576DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT576DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT576DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT576DI64_Axis - 1 do
        TKDT576DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT576DI64_Test.TestBuff), length(TKDT576DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT576DI64_Test.BuildKDTreeM(length(TKDT576DI64_Test.TestBuff), @TKDT576DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT576DI64_Test.BuildKDTreeM(length(TKDT576DI64_Test.TestBuff), TKDT576DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT576DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT576DI64_Test.TestBuff));
  TKDT576DI64_Test.Search(TKDT576DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT576DI64Distance(TKDT576DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT576DI64_Test.Clear;
  { kMean test }
  TKDT576DI64_Test.BuildKDTreeWithCluster(TKDT576DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT576DI64_Test.Search(TKDT576DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT576DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT576DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT576DI64_Test);
end;


function TKDT768DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT768DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT768DI64_Node;
  function SortCompare(const p1, p2: PKDT768DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT768DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT768DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT768DI64_SourceBuffer;
  dynBuff  : PKDT768DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT768DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT768DI64.GetData(const index: NativeInt): PKDT768DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT768DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT768DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT768DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT768DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT768DI64.StoreBuffPtr: PKDT768DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT768DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT768DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT768DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT768DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT768DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT768DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT768DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT768DI64.BuildKDTreeWithCluster(const inBuff: TKDT768DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT768DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT768DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT768DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT768DI64.BuildKDTreeWithCluster(const inBuff: TKDT768DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI64_BuildCall);
var
  TempStoreBuff: TKDT768DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT768DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT768DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT768DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT768DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI64_BuildMethod);
var
  TempStoreBuff: TKDT768DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT768DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT768DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT768DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT768DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT768DI64_BuildProc);
var
  TempStoreBuff: TKDT768DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT768DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT768DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT768DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT768DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT768DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT768DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT768DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT768DI64.Search(const Buff: TKDT768DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT768DI64_Node;

var
  NearestNeighbour: PKDT768DI64_Node;

  function FindParentNode(const BuffPtr: PKDT768DI64_Vec; NodePtr: PKDT768DI64_Node): PKDT768DI64_Node;
  var
    Next       : PKDT768DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT768DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT768DI64_Node; const BuffPtr: PKDT768DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT768DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT768DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT768DI64_Vec; const p1, p2: PKDT768DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT768DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT768DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT768DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT768DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT768DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT768DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT768DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT768DI64.Search(const Buff: TKDT768DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT768DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT768DI64.Search(const Buff: TKDT768DI64_Vec; var SearchedDistanceMin: Double): PKDT768DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT768DI64.Search(const Buff: TKDT768DI64_Vec): PKDT768DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT768DI64.Search(const inBuff: TKDT768DI64_DynamicVecBuffer; var OutBuff: TKDT768DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT768DI64_DynamicVecBuffer;
  outBuffPtr : PKDT768DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT768DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT768DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT768DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT768DI64.Search(const inBuff: TKDT768DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT768DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT768DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT768DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT768DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT768DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT768DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT768DI64_Source));
end;

procedure TKDT768DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT768DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT768DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT768DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT768DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT768DI64.PrintNodeTree(const NodePtr: PKDT768DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT768DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT768DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT768DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT768DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT768DI64.KDT768DI64Vec(const s: string): TKDT768DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT768DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT768DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT768DI64.KDT768DI64Vec(const v: TKDT768DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT768DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT768DI64.KDT768DI64Pow(const v: TKDT768DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT768DI64.KDT768DI64Distance(const v1, v2: TKDT768DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT768DI64_Axis - 1 do
      Result := Result + KDT768DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT768DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT768DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT768DI64.Test;
var
  TKDT768DI64_Test    : TKDT768DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT768DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT768DI64_Test := TKDT768DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT768DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT768DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT768DI64_Axis - 1 do
        TKDT768DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT768DI64_Test.TestBuff), length(TKDT768DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT768DI64_Test.BuildKDTreeM(length(TKDT768DI64_Test.TestBuff), @TKDT768DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT768DI64_Test.BuildKDTreeM(length(TKDT768DI64_Test.TestBuff), TKDT768DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT768DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT768DI64_Test.TestBuff));
  TKDT768DI64_Test.Search(TKDT768DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT768DI64Distance(TKDT768DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT768DI64_Test.Clear;
  { kMean test }
  TKDT768DI64_Test.BuildKDTreeWithCluster(TKDT768DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT768DI64_Test.Search(TKDT768DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT768DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT768DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT768DI64_Test);
end;


function TKDT1024DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1024DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1024DI64_Node;
  function SortCompare(const p1, p2: PKDT1024DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1024DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1024DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1024DI64_SourceBuffer;
  dynBuff  : PKDT1024DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1024DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1024DI64.GetData(const index: NativeInt): PKDT1024DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1024DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1024DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1024DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1024DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1024DI64.StoreBuffPtr: PKDT1024DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1024DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT1024DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1024DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT1024DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT1024DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1024DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1024DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1024DI64.BuildKDTreeWithCluster(const inBuff: TKDT1024DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1024DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1024DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1024DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1024DI64.BuildKDTreeWithCluster(const inBuff: TKDT1024DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI64_BuildCall);
var
  TempStoreBuff: TKDT1024DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1024DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1024DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI64_BuildMethod);
var
  TempStoreBuff: TKDT1024DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1024DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1024DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1024DI64_BuildProc);
var
  TempStoreBuff: TKDT1024DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1024DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1024DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1024DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1024DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1024DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1024DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1024DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1024DI64.Search(const Buff: TKDT1024DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1024DI64_Node;

var
  NearestNeighbour: PKDT1024DI64_Node;

  function FindParentNode(const BuffPtr: PKDT1024DI64_Vec; NodePtr: PKDT1024DI64_Node): PKDT1024DI64_Node;
  var
    Next       : PKDT1024DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1024DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1024DI64_Node; const BuffPtr: PKDT1024DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1024DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1024DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1024DI64_Vec; const p1, p2: PKDT1024DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1024DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1024DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1024DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1024DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1024DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1024DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1024DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT1024DI64.Search(const Buff: TKDT1024DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1024DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1024DI64.Search(const Buff: TKDT1024DI64_Vec; var SearchedDistanceMin: Double): PKDT1024DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1024DI64.Search(const Buff: TKDT1024DI64_Vec): PKDT1024DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1024DI64.Search(const inBuff: TKDT1024DI64_DynamicVecBuffer; var OutBuff: TKDT1024DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1024DI64_DynamicVecBuffer;
  outBuffPtr : PKDT1024DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1024DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1024DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DI64.Search(const inBuff: TKDT1024DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1024DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1024DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1024DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1024DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1024DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1024DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1024DI64_Source));
end;

procedure TKDT1024DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1024DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1024DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1024DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1024DI64.PrintNodeTree(const NodePtr: PKDT1024DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1024DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1024DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1024DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1024DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1024DI64.KDT1024DI64Vec(const s: string): TKDT1024DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1024DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1024DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1024DI64.KDT1024DI64Vec(const v: TKDT1024DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1024DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT1024DI64.KDT1024DI64Pow(const v: TKDT1024DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1024DI64.KDT1024DI64Distance(const v1, v2: TKDT1024DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1024DI64_Axis - 1 do
      Result := Result + KDT1024DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT1024DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1024DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1024DI64.Test;
var
  TKDT1024DI64_Test    : TKDT1024DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1024DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1024DI64_Test := TKDT1024DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1024DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT1024DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT1024DI64_Axis - 1 do
        TKDT1024DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1024DI64_Test.TestBuff), length(TKDT1024DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1024DI64_Test.BuildKDTreeM(length(TKDT1024DI64_Test.TestBuff), @TKDT1024DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1024DI64_Test.BuildKDTreeM(length(TKDT1024DI64_Test.TestBuff), TKDT1024DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1024DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1024DI64_Test.TestBuff));
  TKDT1024DI64_Test.Search(TKDT1024DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1024DI64Distance(TKDT1024DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1024DI64_Test.Clear;
  { kMean test }
  TKDT1024DI64_Test.BuildKDTreeWithCluster(TKDT1024DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1024DI64_Test.Search(TKDT1024DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1024DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1024DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1024DI64_Test);
end;


function TKDT1040DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1040DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1040DI64_Node;
  function SortCompare(const p1, p2: PKDT1040DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1040DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1040DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1040DI64_SourceBuffer;
  dynBuff  : PKDT1040DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1040DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1040DI64.GetData(const index: NativeInt): PKDT1040DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1040DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1040DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1040DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1040DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1040DI64.StoreBuffPtr: PKDT1040DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1040DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT1040DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1040DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT1040DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1040DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT1040DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1040DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1040DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1040DI64.BuildKDTreeWithCluster(const inBuff: TKDT1040DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1040DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1040DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1040DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1040DI64.BuildKDTreeWithCluster(const inBuff: TKDT1040DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1040DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DI64_BuildCall);
var
  TempStoreBuff: TKDT1040DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1040DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1040DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1040DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1040DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1040DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DI64_BuildMethod);
var
  TempStoreBuff: TKDT1040DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1040DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1040DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1040DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1040DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1040DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1040DI64_BuildProc);
var
  TempStoreBuff: TKDT1040DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1040DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1040DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1040DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1040DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1040DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1040DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1040DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1040DI64.Search(const Buff: TKDT1040DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1040DI64_Node;

var
  NearestNeighbour: PKDT1040DI64_Node;

  function FindParentNode(const BuffPtr: PKDT1040DI64_Vec; NodePtr: PKDT1040DI64_Node): PKDT1040DI64_Node;
  var
    Next       : PKDT1040DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1040DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1040DI64_Node; const BuffPtr: PKDT1040DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1040DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1040DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1040DI64_Vec; const p1, p2: PKDT1040DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1040DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1040DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1040DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1040DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1040DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1040DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1040DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT1040DI64.Search(const Buff: TKDT1040DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1040DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1040DI64.Search(const Buff: TKDT1040DI64_Vec; var SearchedDistanceMin: Double): PKDT1040DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1040DI64.Search(const Buff: TKDT1040DI64_Vec): PKDT1040DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1040DI64.Search(const inBuff: TKDT1040DI64_DynamicVecBuffer; var OutBuff: TKDT1040DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1040DI64_DynamicVecBuffer;
  outBuffPtr : PKDT1040DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1040DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1040DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1040DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1040DI64.Search(const inBuff: TKDT1040DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1040DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1040DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1040DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1040DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1040DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1040DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1040DI64_Source));
end;

procedure TKDT1040DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1040DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1040DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1040DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1040DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1040DI64.PrintNodeTree(const NodePtr: PKDT1040DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1040DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1040DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1040DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1040DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1040DI64.KDT1040DI64Vec(const s: string): TKDT1040DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1040DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1040DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1040DI64.KDT1040DI64Vec(const v: TKDT1040DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1040DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT1040DI64.KDT1040DI64Pow(const v: TKDT1040DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1040DI64.KDT1040DI64Distance(const v1, v2: TKDT1040DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1040DI64_Axis - 1 do
      Result := Result + KDT1040DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT1040DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1040DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1040DI64.Test;
var
  TKDT1040DI64_Test    : TKDT1040DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1040DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1040DI64_Test := TKDT1040DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1040DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT1040DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT1040DI64_Axis - 1 do
        TKDT1040DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1040DI64_Test.TestBuff), length(TKDT1040DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1040DI64_Test.BuildKDTreeM(length(TKDT1040DI64_Test.TestBuff), @TKDT1040DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1040DI64_Test.BuildKDTreeM(length(TKDT1040DI64_Test.TestBuff), TKDT1040DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1040DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1040DI64_Test.TestBuff));
  TKDT1040DI64_Test.Search(TKDT1040DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1040DI64Distance(TKDT1040DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1040DI64_Test.Clear;
  { kMean test }
  TKDT1040DI64_Test.BuildKDTreeWithCluster(TKDT1040DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1040DI64_Test.Search(TKDT1040DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1040DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1040DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1040DI64_Test);
end;


function TKDT1056DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1056DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1056DI64_Node;
  function SortCompare(const p1, p2: PKDT1056DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1056DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1056DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1056DI64_SourceBuffer;
  dynBuff  : PKDT1056DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1056DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1056DI64.GetData(const index: NativeInt): PKDT1056DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1056DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1056DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1056DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1056DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1056DI64.StoreBuffPtr: PKDT1056DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1056DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT1056DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1056DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT1056DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1056DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT1056DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1056DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1056DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1056DI64.BuildKDTreeWithCluster(const inBuff: TKDT1056DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1056DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1056DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1056DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1056DI64.BuildKDTreeWithCluster(const inBuff: TKDT1056DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1056DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DI64_BuildCall);
var
  TempStoreBuff: TKDT1056DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1056DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1056DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1056DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1056DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1056DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DI64_BuildMethod);
var
  TempStoreBuff: TKDT1056DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1056DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1056DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1056DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1056DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1056DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1056DI64_BuildProc);
var
  TempStoreBuff: TKDT1056DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1056DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1056DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1056DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1056DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1056DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1056DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1056DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1056DI64.Search(const Buff: TKDT1056DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1056DI64_Node;

var
  NearestNeighbour: PKDT1056DI64_Node;

  function FindParentNode(const BuffPtr: PKDT1056DI64_Vec; NodePtr: PKDT1056DI64_Node): PKDT1056DI64_Node;
  var
    Next       : PKDT1056DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1056DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1056DI64_Node; const BuffPtr: PKDT1056DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1056DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1056DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1056DI64_Vec; const p1, p2: PKDT1056DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1056DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1056DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1056DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1056DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1056DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1056DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1056DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT1056DI64.Search(const Buff: TKDT1056DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1056DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1056DI64.Search(const Buff: TKDT1056DI64_Vec; var SearchedDistanceMin: Double): PKDT1056DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1056DI64.Search(const Buff: TKDT1056DI64_Vec): PKDT1056DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1056DI64.Search(const inBuff: TKDT1056DI64_DynamicVecBuffer; var OutBuff: TKDT1056DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1056DI64_DynamicVecBuffer;
  outBuffPtr : PKDT1056DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1056DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1056DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1056DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1056DI64.Search(const inBuff: TKDT1056DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1056DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1056DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1056DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1056DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1056DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1056DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1056DI64_Source));
end;

procedure TKDT1056DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1056DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1056DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1056DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1056DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1056DI64.PrintNodeTree(const NodePtr: PKDT1056DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1056DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1056DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1056DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1056DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1056DI64.KDT1056DI64Vec(const s: string): TKDT1056DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1056DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1056DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1056DI64.KDT1056DI64Vec(const v: TKDT1056DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1056DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT1056DI64.KDT1056DI64Pow(const v: TKDT1056DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1056DI64.KDT1056DI64Distance(const v1, v2: TKDT1056DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1056DI64_Axis - 1 do
      Result := Result + KDT1056DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT1056DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1056DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1056DI64.Test;
var
  TKDT1056DI64_Test    : TKDT1056DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1056DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1056DI64_Test := TKDT1056DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1056DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT1056DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT1056DI64_Axis - 1 do
        TKDT1056DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1056DI64_Test.TestBuff), length(TKDT1056DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1056DI64_Test.BuildKDTreeM(length(TKDT1056DI64_Test.TestBuff), @TKDT1056DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1056DI64_Test.BuildKDTreeM(length(TKDT1056DI64_Test.TestBuff), TKDT1056DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1056DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1056DI64_Test.TestBuff));
  TKDT1056DI64_Test.Search(TKDT1056DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1056DI64Distance(TKDT1056DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1056DI64_Test.Clear;
  { kMean test }
  TKDT1056DI64_Test.BuildKDTreeWithCluster(TKDT1056DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1056DI64_Test.Search(TKDT1056DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1056DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1056DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1056DI64_Test);
end;


function TKDT1536DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1536DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1536DI64_Node;
  function SortCompare(const p1, p2: PKDT1536DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1536DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1536DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1536DI64_SourceBuffer;
  dynBuff  : PKDT1536DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1536DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1536DI64.GetData(const index: NativeInt): PKDT1536DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1536DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1536DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1536DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1536DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1536DI64.StoreBuffPtr: PKDT1536DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1536DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT1536DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1536DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT1536DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT1536DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1536DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1536DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1536DI64.BuildKDTreeWithCluster(const inBuff: TKDT1536DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1536DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1536DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1536DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1536DI64.BuildKDTreeWithCluster(const inBuff: TKDT1536DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI64_BuildCall);
var
  TempStoreBuff: TKDT1536DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1536DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1536DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1536DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1536DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI64_BuildMethod);
var
  TempStoreBuff: TKDT1536DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1536DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1536DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1536DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1536DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1536DI64_BuildProc);
var
  TempStoreBuff: TKDT1536DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1536DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1536DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1536DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1536DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1536DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1536DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1536DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1536DI64.Search(const Buff: TKDT1536DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1536DI64_Node;

var
  NearestNeighbour: PKDT1536DI64_Node;

  function FindParentNode(const BuffPtr: PKDT1536DI64_Vec; NodePtr: PKDT1536DI64_Node): PKDT1536DI64_Node;
  var
    Next       : PKDT1536DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1536DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1536DI64_Node; const BuffPtr: PKDT1536DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1536DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1536DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1536DI64_Vec; const p1, p2: PKDT1536DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1536DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1536DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1536DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1536DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1536DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1536DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1536DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT1536DI64.Search(const Buff: TKDT1536DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1536DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1536DI64.Search(const Buff: TKDT1536DI64_Vec; var SearchedDistanceMin: Double): PKDT1536DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1536DI64.Search(const Buff: TKDT1536DI64_Vec): PKDT1536DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1536DI64.Search(const inBuff: TKDT1536DI64_DynamicVecBuffer; var OutBuff: TKDT1536DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1536DI64_DynamicVecBuffer;
  outBuffPtr : PKDT1536DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1536DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1536DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1536DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1536DI64.Search(const inBuff: TKDT1536DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1536DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1536DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1536DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1536DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1536DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1536DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1536DI64_Source));
end;

procedure TKDT1536DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1536DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1536DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1536DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1536DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1536DI64.PrintNodeTree(const NodePtr: PKDT1536DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1536DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1536DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1536DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1536DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1536DI64.KDT1536DI64Vec(const s: string): TKDT1536DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1536DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1536DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1536DI64.KDT1536DI64Vec(const v: TKDT1536DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1536DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT1536DI64.KDT1536DI64Pow(const v: TKDT1536DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1536DI64.KDT1536DI64Distance(const v1, v2: TKDT1536DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1536DI64_Axis - 1 do
      Result := Result + KDT1536DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT1536DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1536DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1536DI64.Test;
var
  TKDT1536DI64_Test    : TKDT1536DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1536DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1536DI64_Test := TKDT1536DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1536DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT1536DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT1536DI64_Axis - 1 do
        TKDT1536DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1536DI64_Test.TestBuff), length(TKDT1536DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1536DI64_Test.BuildKDTreeM(length(TKDT1536DI64_Test.TestBuff), @TKDT1536DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1536DI64_Test.BuildKDTreeM(length(TKDT1536DI64_Test.TestBuff), TKDT1536DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1536DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1536DI64_Test.TestBuff));
  TKDT1536DI64_Test.Search(TKDT1536DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1536DI64Distance(TKDT1536DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1536DI64_Test.Clear;
  { kMean test }
  TKDT1536DI64_Test.BuildKDTreeWithCluster(TKDT1536DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1536DI64_Test.Search(TKDT1536DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1536DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1536DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1536DI64_Test);
end;


function TKDT1920DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1920DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1920DI64_Node;
  function SortCompare(const p1, p2: PKDT1920DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1920DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1920DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1920DI64_SourceBuffer;
  dynBuff  : PKDT1920DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1920DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1920DI64.GetData(const index: NativeInt): PKDT1920DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1920DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1920DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1920DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1920DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1920DI64.StoreBuffPtr: PKDT1920DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1920DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT1920DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1920DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT1920DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT1920DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1920DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1920DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1920DI64.BuildKDTreeWithCluster(const inBuff: TKDT1920DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1920DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1920DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1920DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1920DI64.BuildKDTreeWithCluster(const inBuff: TKDT1920DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI64_BuildCall);
var
  TempStoreBuff: TKDT1920DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1920DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1920DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1920DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1920DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI64_BuildMethod);
var
  TempStoreBuff: TKDT1920DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1920DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1920DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1920DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1920DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1920DI64_BuildProc);
var
  TempStoreBuff: TKDT1920DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1920DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1920DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1920DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1920DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1920DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1920DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1920DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1920DI64.Search(const Buff: TKDT1920DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1920DI64_Node;

var
  NearestNeighbour: PKDT1920DI64_Node;

  function FindParentNode(const BuffPtr: PKDT1920DI64_Vec; NodePtr: PKDT1920DI64_Node): PKDT1920DI64_Node;
  var
    Next       : PKDT1920DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1920DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1920DI64_Node; const BuffPtr: PKDT1920DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1920DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1920DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1920DI64_Vec; const p1, p2: PKDT1920DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1920DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1920DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1920DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1920DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1920DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1920DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1920DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT1920DI64.Search(const Buff: TKDT1920DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1920DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1920DI64.Search(const Buff: TKDT1920DI64_Vec; var SearchedDistanceMin: Double): PKDT1920DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1920DI64.Search(const Buff: TKDT1920DI64_Vec): PKDT1920DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1920DI64.Search(const inBuff: TKDT1920DI64_DynamicVecBuffer; var OutBuff: TKDT1920DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1920DI64_DynamicVecBuffer;
  outBuffPtr : PKDT1920DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1920DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1920DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1920DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1920DI64.Search(const inBuff: TKDT1920DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1920DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1920DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1920DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1920DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1920DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1920DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1920DI64_Source));
end;

procedure TKDT1920DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1920DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1920DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1920DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1920DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1920DI64.PrintNodeTree(const NodePtr: PKDT1920DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1920DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1920DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1920DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1920DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1920DI64.KDT1920DI64Vec(const s: string): TKDT1920DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1920DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1920DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1920DI64.KDT1920DI64Vec(const v: TKDT1920DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1920DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT1920DI64.KDT1920DI64Pow(const v: TKDT1920DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1920DI64.KDT1920DI64Distance(const v1, v2: TKDT1920DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1920DI64_Axis - 1 do
      Result := Result + KDT1920DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT1920DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1920DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1920DI64.Test;
var
  TKDT1920DI64_Test    : TKDT1920DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1920DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1920DI64_Test := TKDT1920DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1920DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT1920DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT1920DI64_Axis - 1 do
        TKDT1920DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1920DI64_Test.TestBuff), length(TKDT1920DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1920DI64_Test.BuildKDTreeM(length(TKDT1920DI64_Test.TestBuff), @TKDT1920DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1920DI64_Test.BuildKDTreeM(length(TKDT1920DI64_Test.TestBuff), TKDT1920DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1920DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1920DI64_Test.TestBuff));
  TKDT1920DI64_Test.Search(TKDT1920DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1920DI64Distance(TKDT1920DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1920DI64_Test.Clear;
  { kMean test }
  TKDT1920DI64_Test.BuildKDTreeWithCluster(TKDT1920DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1920DI64_Test.Search(TKDT1920DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1920DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1920DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1920DI64_Test);
end;


function TKDT1980DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT1980DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT1980DI64_Node;
  function SortCompare(const p1, p2: PKDT1980DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT1980DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT1980DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT1980DI64_SourceBuffer;
  dynBuff  : PKDT1980DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT1980DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT1980DI64.GetData(const index: NativeInt): PKDT1980DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT1980DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT1980DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT1980DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT1980DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT1980DI64.StoreBuffPtr: PKDT1980DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT1980DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT1980DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT1980DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT1980DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT1980DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT1980DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT1980DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT1980DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT1980DI64.BuildKDTreeWithCluster(const inBuff: TKDT1980DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT1980DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT1980DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT1980DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT1980DI64.BuildKDTreeWithCluster(const inBuff: TKDT1980DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT1980DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DI64_BuildCall);
var
  TempStoreBuff: TKDT1980DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1980DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1980DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1980DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1980DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT1980DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DI64_BuildMethod);
var
  TempStoreBuff: TKDT1980DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1980DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1980DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1980DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1980DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT1980DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT1980DI64_BuildProc);
var
  TempStoreBuff: TKDT1980DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT1980DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT1980DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT1980DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT1980DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT1980DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT1980DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT1980DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT1980DI64.Search(const Buff: TKDT1980DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT1980DI64_Node;

var
  NearestNeighbour: PKDT1980DI64_Node;

  function FindParentNode(const BuffPtr: PKDT1980DI64_Vec; NodePtr: PKDT1980DI64_Node): PKDT1980DI64_Node;
  var
    Next       : PKDT1980DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT1980DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT1980DI64_Node; const BuffPtr: PKDT1980DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT1980DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT1980DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT1980DI64_Vec; const p1, p2: PKDT1980DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT1980DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT1980DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT1980DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT1980DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT1980DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT1980DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT1980DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT1980DI64.Search(const Buff: TKDT1980DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT1980DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT1980DI64.Search(const Buff: TKDT1980DI64_Vec; var SearchedDistanceMin: Double): PKDT1980DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT1980DI64.Search(const Buff: TKDT1980DI64_Vec): PKDT1980DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT1980DI64.Search(const inBuff: TKDT1980DI64_DynamicVecBuffer; var OutBuff: TKDT1980DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1980DI64_DynamicVecBuffer;
  outBuffPtr : PKDT1980DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1980DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1980DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1980DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1980DI64.Search(const inBuff: TKDT1980DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT1980DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT1980DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT1980DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT1980DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT1980DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT1980DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT1980DI64_Source));
end;

procedure TKDT1980DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT1980DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT1980DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT1980DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1980DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT1980DI64.PrintNodeTree(const NodePtr: PKDT1980DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT1980DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT1980DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT1980DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT1980DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT1980DI64.KDT1980DI64Vec(const s: string): TKDT1980DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT1980DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT1980DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT1980DI64.KDT1980DI64Vec(const v: TKDT1980DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT1980DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT1980DI64.KDT1980DI64Pow(const v: TKDT1980DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT1980DI64.KDT1980DI64Distance(const v1, v2: TKDT1980DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT1980DI64_Axis - 1 do
      Result := Result + KDT1980DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT1980DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT1980DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT1980DI64.Test;
var
  TKDT1980DI64_Test    : TKDT1980DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT1980DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT1980DI64_Test := TKDT1980DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT1980DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT1980DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT1980DI64_Axis - 1 do
        TKDT1980DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT1980DI64_Test.TestBuff), length(TKDT1980DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT1980DI64_Test.BuildKDTreeM(length(TKDT1980DI64_Test.TestBuff), @TKDT1980DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT1980DI64_Test.BuildKDTreeM(length(TKDT1980DI64_Test.TestBuff), TKDT1980DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT1980DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT1980DI64_Test.TestBuff));
  TKDT1980DI64_Test.Search(TKDT1980DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT1980DI64Distance(TKDT1980DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT1980DI64_Test.Clear;
  { kMean test }
  TKDT1980DI64_Test.BuildKDTreeWithCluster(TKDT1980DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT1980DI64_Test.Search(TKDT1980DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT1980DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT1980DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT1980DI64_Test);
end;


function TKDT2048DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT2048DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT2048DI64_Node;
  function SortCompare(const p1, p2: PKDT2048DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT2048DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT2048DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT2048DI64_SourceBuffer;
  dynBuff  : PKDT2048DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT2048DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT2048DI64.GetData(const index: NativeInt): PKDT2048DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT2048DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT2048DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT2048DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT2048DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT2048DI64.StoreBuffPtr: PKDT2048DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT2048DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT2048DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT2048DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT2048DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT2048DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT2048DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT2048DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT2048DI64.BuildKDTreeWithCluster(const inBuff: TKDT2048DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT2048DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT2048DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT2048DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT2048DI64.BuildKDTreeWithCluster(const inBuff: TKDT2048DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI64_BuildCall);
var
  TempStoreBuff: TKDT2048DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2048DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2048DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2048DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT2048DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI64_BuildMethod);
var
  TempStoreBuff: TKDT2048DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2048DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2048DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2048DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT2048DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT2048DI64_BuildProc);
var
  TempStoreBuff: TKDT2048DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT2048DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT2048DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT2048DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT2048DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT2048DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT2048DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT2048DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT2048DI64.Search(const Buff: TKDT2048DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT2048DI64_Node;

var
  NearestNeighbour: PKDT2048DI64_Node;

  function FindParentNode(const BuffPtr: PKDT2048DI64_Vec; NodePtr: PKDT2048DI64_Node): PKDT2048DI64_Node;
  var
    Next       : PKDT2048DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT2048DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT2048DI64_Node; const BuffPtr: PKDT2048DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT2048DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT2048DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT2048DI64_Vec; const p1, p2: PKDT2048DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT2048DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT2048DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT2048DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT2048DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT2048DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT2048DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT2048DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT2048DI64.Search(const Buff: TKDT2048DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT2048DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT2048DI64.Search(const Buff: TKDT2048DI64_Vec; var SearchedDistanceMin: Double): PKDT2048DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT2048DI64.Search(const Buff: TKDT2048DI64_Vec): PKDT2048DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT2048DI64.Search(const inBuff: TKDT2048DI64_DynamicVecBuffer; var OutBuff: TKDT2048DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2048DI64_DynamicVecBuffer;
  outBuffPtr : PKDT2048DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2048DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2048DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2048DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2048DI64.Search(const inBuff: TKDT2048DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT2048DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT2048DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT2048DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT2048DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT2048DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT2048DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT2048DI64_Source));
end;

procedure TKDT2048DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT2048DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT2048DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT2048DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2048DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT2048DI64.PrintNodeTree(const NodePtr: PKDT2048DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT2048DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT2048DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT2048DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT2048DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT2048DI64.KDT2048DI64Vec(const s: string): TKDT2048DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT2048DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT2048DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT2048DI64.KDT2048DI64Vec(const v: TKDT2048DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT2048DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT2048DI64.KDT2048DI64Pow(const v: TKDT2048DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT2048DI64.KDT2048DI64Distance(const v1, v2: TKDT2048DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT2048DI64_Axis - 1 do
      Result := Result + KDT2048DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT2048DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT2048DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT2048DI64.Test;
var
  TKDT2048DI64_Test    : TKDT2048DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT2048DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT2048DI64_Test := TKDT2048DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT2048DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT2048DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT2048DI64_Axis - 1 do
        TKDT2048DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT2048DI64_Test.TestBuff), length(TKDT2048DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT2048DI64_Test.BuildKDTreeM(length(TKDT2048DI64_Test.TestBuff), @TKDT2048DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT2048DI64_Test.BuildKDTreeM(length(TKDT2048DI64_Test.TestBuff), TKDT2048DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT2048DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT2048DI64_Test.TestBuff));
  TKDT2048DI64_Test.Search(TKDT2048DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT2048DI64Distance(TKDT2048DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT2048DI64_Test.Clear;
  { kMean test }
  TKDT2048DI64_Test.BuildKDTreeWithCluster(TKDT2048DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT2048DI64_Test.Search(TKDT2048DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT2048DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT2048DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT2048DI64_Test);
end;


function TKDT3072DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3072DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3072DI64_Node;
  function SortCompare(const p1, p2: PKDT3072DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3072DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3072DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3072DI64_SourceBuffer;
  dynBuff  : PKDT3072DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3072DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3072DI64.GetData(const index: NativeInt): PKDT3072DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3072DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3072DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3072DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3072DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3072DI64.StoreBuffPtr: PKDT3072DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3072DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT3072DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3072DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT3072DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT3072DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3072DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3072DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3072DI64.BuildKDTreeWithCluster(const inBuff: TKDT3072DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3072DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3072DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3072DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3072DI64.BuildKDTreeWithCluster(const inBuff: TKDT3072DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI64_BuildCall);
var
  TempStoreBuff: TKDT3072DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3072DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3072DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3072DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3072DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI64_BuildMethod);
var
  TempStoreBuff: TKDT3072DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3072DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3072DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3072DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3072DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3072DI64_BuildProc);
var
  TempStoreBuff: TKDT3072DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3072DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3072DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3072DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3072DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3072DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3072DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3072DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3072DI64.Search(const Buff: TKDT3072DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3072DI64_Node;

var
  NearestNeighbour: PKDT3072DI64_Node;

  function FindParentNode(const BuffPtr: PKDT3072DI64_Vec; NodePtr: PKDT3072DI64_Node): PKDT3072DI64_Node;
  var
    Next       : PKDT3072DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3072DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3072DI64_Node; const BuffPtr: PKDT3072DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3072DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3072DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3072DI64_Vec; const p1, p2: PKDT3072DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3072DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3072DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3072DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3072DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3072DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3072DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3072DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT3072DI64.Search(const Buff: TKDT3072DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3072DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3072DI64.Search(const Buff: TKDT3072DI64_Vec; var SearchedDistanceMin: Double): PKDT3072DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3072DI64.Search(const Buff: TKDT3072DI64_Vec): PKDT3072DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3072DI64.Search(const inBuff: TKDT3072DI64_DynamicVecBuffer; var OutBuff: TKDT3072DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3072DI64_DynamicVecBuffer;
  outBuffPtr : PKDT3072DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3072DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3072DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3072DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3072DI64.Search(const inBuff: TKDT3072DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3072DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3072DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3072DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3072DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3072DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3072DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3072DI64_Source));
end;

procedure TKDT3072DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3072DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3072DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3072DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3072DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3072DI64.PrintNodeTree(const NodePtr: PKDT3072DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3072DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3072DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3072DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3072DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3072DI64.KDT3072DI64Vec(const s: string): TKDT3072DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3072DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3072DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3072DI64.KDT3072DI64Vec(const v: TKDT3072DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3072DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT3072DI64.KDT3072DI64Pow(const v: TKDT3072DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3072DI64.KDT3072DI64Distance(const v1, v2: TKDT3072DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3072DI64_Axis - 1 do
      Result := Result + KDT3072DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT3072DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3072DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3072DI64.Test;
var
  TKDT3072DI64_Test    : TKDT3072DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3072DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3072DI64_Test := TKDT3072DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3072DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT3072DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT3072DI64_Axis - 1 do
        TKDT3072DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT3072DI64_Test.TestBuff), length(TKDT3072DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3072DI64_Test.BuildKDTreeM(length(TKDT3072DI64_Test.TestBuff), @TKDT3072DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3072DI64_Test.BuildKDTreeM(length(TKDT3072DI64_Test.TestBuff), TKDT3072DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3072DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3072DI64_Test.TestBuff));
  TKDT3072DI64_Test.Search(TKDT3072DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3072DI64Distance(TKDT3072DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3072DI64_Test.Clear;
  { kMean test }
  TKDT3072DI64_Test.BuildKDTreeWithCluster(TKDT3072DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3072DI64_Test.Search(TKDT3072DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3072DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3072DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3072DI64_Test);
end;


function TKDT3088DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3088DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3088DI64_Node;
  function SortCompare(const p1, p2: PKDT3088DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3088DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3088DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3088DI64_SourceBuffer;
  dynBuff  : PKDT3088DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3088DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3088DI64.GetData(const index: NativeInt): PKDT3088DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3088DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3088DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3088DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3088DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3088DI64.StoreBuffPtr: PKDT3088DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3088DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT3088DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3088DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT3088DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3088DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT3088DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3088DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3088DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3088DI64.BuildKDTreeWithCluster(const inBuff: TKDT3088DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3088DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3088DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3088DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3088DI64.BuildKDTreeWithCluster(const inBuff: TKDT3088DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3088DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DI64_BuildCall);
var
  TempStoreBuff: TKDT3088DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3088DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3088DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3088DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3088DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3088DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DI64_BuildMethod);
var
  TempStoreBuff: TKDT3088DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3088DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3088DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3088DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3088DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3088DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3088DI64_BuildProc);
var
  TempStoreBuff: TKDT3088DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3088DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3088DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3088DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3088DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3088DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3088DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3088DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3088DI64.Search(const Buff: TKDT3088DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3088DI64_Node;

var
  NearestNeighbour: PKDT3088DI64_Node;

  function FindParentNode(const BuffPtr: PKDT3088DI64_Vec; NodePtr: PKDT3088DI64_Node): PKDT3088DI64_Node;
  var
    Next       : PKDT3088DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3088DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3088DI64_Node; const BuffPtr: PKDT3088DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3088DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3088DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3088DI64_Vec; const p1, p2: PKDT3088DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3088DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3088DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3088DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3088DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3088DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3088DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3088DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT3088DI64.Search(const Buff: TKDT3088DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3088DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3088DI64.Search(const Buff: TKDT3088DI64_Vec; var SearchedDistanceMin: Double): PKDT3088DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3088DI64.Search(const Buff: TKDT3088DI64_Vec): PKDT3088DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3088DI64.Search(const inBuff: TKDT3088DI64_DynamicVecBuffer; var OutBuff: TKDT3088DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3088DI64_DynamicVecBuffer;
  outBuffPtr : PKDT3088DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3088DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3088DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3088DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3088DI64.Search(const inBuff: TKDT3088DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3088DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3088DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3088DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3088DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3088DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3088DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3088DI64_Source));
end;

procedure TKDT3088DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3088DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3088DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3088DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3088DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3088DI64.PrintNodeTree(const NodePtr: PKDT3088DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3088DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3088DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3088DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3088DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3088DI64.KDT3088DI64Vec(const s: string): TKDT3088DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3088DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3088DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3088DI64.KDT3088DI64Vec(const v: TKDT3088DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3088DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT3088DI64.KDT3088DI64Pow(const v: TKDT3088DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3088DI64.KDT3088DI64Distance(const v1, v2: TKDT3088DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3088DI64_Axis - 1 do
      Result := Result + KDT3088DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT3088DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3088DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3088DI64.Test;
var
  TKDT3088DI64_Test    : TKDT3088DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3088DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3088DI64_Test := TKDT3088DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3088DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT3088DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT3088DI64_Axis - 1 do
        TKDT3088DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT3088DI64_Test.TestBuff), length(TKDT3088DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3088DI64_Test.BuildKDTreeM(length(TKDT3088DI64_Test.TestBuff), @TKDT3088DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3088DI64_Test.BuildKDTreeM(length(TKDT3088DI64_Test.TestBuff), TKDT3088DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3088DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3088DI64_Test.TestBuff));
  TKDT3088DI64_Test.Search(TKDT3088DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3088DI64Distance(TKDT3088DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3088DI64_Test.Clear;
  { kMean test }
  TKDT3088DI64_Test.BuildKDTreeWithCluster(TKDT3088DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3088DI64_Test.Search(TKDT3088DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3088DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3088DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3088DI64_Test);
end;


function TKDT3104DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT3104DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT3104DI64_Node;
  function SortCompare(const p1, p2: PKDT3104DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT3104DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT3104DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT3104DI64_SourceBuffer;
  dynBuff  : PKDT3104DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT3104DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT3104DI64.GetData(const index: NativeInt): PKDT3104DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT3104DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT3104DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT3104DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT3104DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT3104DI64.StoreBuffPtr: PKDT3104DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT3104DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT3104DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT3104DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT3104DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT3104DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT3104DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT3104DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT3104DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT3104DI64.BuildKDTreeWithCluster(const inBuff: TKDT3104DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT3104DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT3104DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT3104DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT3104DI64.BuildKDTreeWithCluster(const inBuff: TKDT3104DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT3104DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DI64_BuildCall);
var
  TempStoreBuff: TKDT3104DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3104DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3104DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3104DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3104DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT3104DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DI64_BuildMethod);
var
  TempStoreBuff: TKDT3104DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3104DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3104DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3104DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3104DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT3104DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT3104DI64_BuildProc);
var
  TempStoreBuff: TKDT3104DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT3104DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT3104DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT3104DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT3104DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT3104DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT3104DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT3104DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT3104DI64.Search(const Buff: TKDT3104DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT3104DI64_Node;

var
  NearestNeighbour: PKDT3104DI64_Node;

  function FindParentNode(const BuffPtr: PKDT3104DI64_Vec; NodePtr: PKDT3104DI64_Node): PKDT3104DI64_Node;
  var
    Next       : PKDT3104DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT3104DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT3104DI64_Node; const BuffPtr: PKDT3104DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT3104DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT3104DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT3104DI64_Vec; const p1, p2: PKDT3104DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT3104DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT3104DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT3104DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT3104DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT3104DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT3104DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT3104DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT3104DI64.Search(const Buff: TKDT3104DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT3104DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT3104DI64.Search(const Buff: TKDT3104DI64_Vec; var SearchedDistanceMin: Double): PKDT3104DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT3104DI64.Search(const Buff: TKDT3104DI64_Vec): PKDT3104DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT3104DI64.Search(const inBuff: TKDT3104DI64_DynamicVecBuffer; var OutBuff: TKDT3104DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3104DI64_DynamicVecBuffer;
  outBuffPtr : PKDT3104DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3104DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3104DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3104DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3104DI64.Search(const inBuff: TKDT3104DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT3104DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT3104DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT3104DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT3104DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT3104DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT3104DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT3104DI64_Source));
end;

procedure TKDT3104DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT3104DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT3104DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT3104DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3104DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT3104DI64.PrintNodeTree(const NodePtr: PKDT3104DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT3104DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT3104DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT3104DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT3104DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT3104DI64.KDT3104DI64Vec(const s: string): TKDT3104DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT3104DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT3104DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT3104DI64.KDT3104DI64Vec(const v: TKDT3104DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT3104DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT3104DI64.KDT3104DI64Pow(const v: TKDT3104DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT3104DI64.KDT3104DI64Distance(const v1, v2: TKDT3104DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT3104DI64_Axis - 1 do
      Result := Result + KDT3104DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT3104DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT3104DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT3104DI64.Test;
var
  TKDT3104DI64_Test    : TKDT3104DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT3104DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT3104DI64_Test := TKDT3104DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT3104DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT3104DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT3104DI64_Axis - 1 do
        TKDT3104DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT3104DI64_Test.TestBuff), length(TKDT3104DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT3104DI64_Test.BuildKDTreeM(length(TKDT3104DI64_Test.TestBuff), @TKDT3104DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT3104DI64_Test.BuildKDTreeM(length(TKDT3104DI64_Test.TestBuff), TKDT3104DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT3104DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT3104DI64_Test.TestBuff));
  TKDT3104DI64_Test.Search(TKDT3104DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT3104DI64Distance(TKDT3104DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT3104DI64_Test.Clear;
  { kMean test }
  TKDT3104DI64_Test.BuildKDTreeWithCluster(TKDT3104DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT3104DI64_Test.Search(TKDT3104DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT3104DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT3104DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT3104DI64_Test);
end;


function TKDT4096DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT4096DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT4096DI64_Node;
  function SortCompare(const p1, p2: PKDT4096DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT4096DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT4096DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT4096DI64_SourceBuffer;
  dynBuff  : PKDT4096DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT4096DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT4096DI64.GetData(const index: NativeInt): PKDT4096DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT4096DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT4096DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT4096DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT4096DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT4096DI64.StoreBuffPtr: PKDT4096DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT4096DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT4096DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT4096DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT4096DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT4096DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT4096DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT4096DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT4096DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT4096DI64.BuildKDTreeWithCluster(const inBuff: TKDT4096DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT4096DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT4096DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT4096DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT4096DI64.BuildKDTreeWithCluster(const inBuff: TKDT4096DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT4096DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DI64_BuildCall);
var
  TempStoreBuff: TKDT4096DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4096DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4096DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4096DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4096DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT4096DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DI64_BuildMethod);
var
  TempStoreBuff: TKDT4096DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4096DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4096DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4096DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4096DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT4096DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT4096DI64_BuildProc);
var
  TempStoreBuff: TKDT4096DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT4096DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT4096DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT4096DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT4096DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT4096DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT4096DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT4096DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT4096DI64.Search(const Buff: TKDT4096DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT4096DI64_Node;

var
  NearestNeighbour: PKDT4096DI64_Node;

  function FindParentNode(const BuffPtr: PKDT4096DI64_Vec; NodePtr: PKDT4096DI64_Node): PKDT4096DI64_Node;
  var
    Next       : PKDT4096DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT4096DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT4096DI64_Node; const BuffPtr: PKDT4096DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT4096DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT4096DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT4096DI64_Vec; const p1, p2: PKDT4096DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT4096DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT4096DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT4096DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT4096DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT4096DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT4096DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT4096DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT4096DI64.Search(const Buff: TKDT4096DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT4096DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT4096DI64.Search(const Buff: TKDT4096DI64_Vec; var SearchedDistanceMin: Double): PKDT4096DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT4096DI64.Search(const Buff: TKDT4096DI64_Vec): PKDT4096DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT4096DI64.Search(const inBuff: TKDT4096DI64_DynamicVecBuffer; var OutBuff: TKDT4096DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4096DI64_DynamicVecBuffer;
  outBuffPtr : PKDT4096DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4096DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4096DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4096DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4096DI64.Search(const inBuff: TKDT4096DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT4096DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT4096DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT4096DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT4096DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT4096DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT4096DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT4096DI64_Source));
end;

procedure TKDT4096DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT4096DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT4096DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT4096DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4096DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT4096DI64.PrintNodeTree(const NodePtr: PKDT4096DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT4096DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT4096DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT4096DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT4096DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT4096DI64.KDT4096DI64Vec(const s: string): TKDT4096DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT4096DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT4096DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT4096DI64.KDT4096DI64Vec(const v: TKDT4096DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT4096DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT4096DI64.KDT4096DI64Pow(const v: TKDT4096DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT4096DI64.KDT4096DI64Distance(const v1, v2: TKDT4096DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT4096DI64_Axis - 1 do
      Result := Result + KDT4096DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT4096DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT4096DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT4096DI64.Test;
var
  TKDT4096DI64_Test    : TKDT4096DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT4096DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT4096DI64_Test := TKDT4096DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT4096DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT4096DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT4096DI64_Axis - 1 do
        TKDT4096DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT4096DI64_Test.TestBuff), length(TKDT4096DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT4096DI64_Test.BuildKDTreeM(length(TKDT4096DI64_Test.TestBuff), @TKDT4096DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT4096DI64_Test.BuildKDTreeM(length(TKDT4096DI64_Test.TestBuff), TKDT4096DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT4096DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT4096DI64_Test.TestBuff));
  TKDT4096DI64_Test.Search(TKDT4096DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT4096DI64Distance(TKDT4096DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT4096DI64_Test.Clear;
  { kMean test }
  TKDT4096DI64_Test.BuildKDTreeWithCluster(TKDT4096DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT4096DI64_Test.Search(TKDT4096DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT4096DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT4096DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT4096DI64_Test);
end;


function TKDT8192DI64.InternalBuildKdTree(const KDSourceBufferPtr: PKDT8192DI64_SourceBuffer; const PlanCount, Depth: NativeInt): PKDT8192DI64_Node;
  function SortCompare(const p1, p2: PKDT8192DI64_Source; const Axis: NativeInt): ShortInt;
  begin
    if p1^.Buff[Axis] = p2^.Buff[Axis] then
      begin
        if p1^.index = p2^.index then
            Result := 0
        else if p1^.index < p2^.index then
            Result := -1
        else
            Result := 1;
      end
    else if p1^.Buff[Axis] < p2^.Buff[Axis] then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(const SortBuffer: PKDT8192DI64_SourceBuffer; l, r: NativeInt; const Axis: NativeInt);
  var
    i, j: NativeInt;
    p, t: PKDT8192DI64_Source;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer^[(l + r) shr 1];
      repeat
        while SortCompare(SortBuffer^[i], p, Axis) < 0 do
            inc(i);
        while SortCompare(SortBuffer^[j], p, Axis) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer^[i];
                SortBuffer^[i] := SortBuffer^[j];
                SortBuffer^[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, Axis);
      l := i;
    until i >= r;
  end;

var
  m        : NativeInt;
  Axis     : NativeInt;
  kdBuffPtr: PKDT8192DI64_SourceBuffer;
  dynBuff  : PKDT8192DI64yanmicSourceBuffer;
begin
  Result := nil;
  if PlanCount = 0 then
      Exit;

  if PlanCount = 1 then
    begin
      New(Result);
      Result^.Parent := nil;
      Result^.Right := nil;
      Result^.Left := nil;
      Result^.vec := KDSourceBufferPtr^[0];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);
    end
  else
    begin
      Axis := Depth mod KDT8192DI64_Axis;
      m := PlanCount div 2;

      kdBuffPtr := GetMemory(PlanCount * SizeOf(Pointer));
      CopyPtr(@KDSourceBufferPtr^[0], @kdBuffPtr^[0], PlanCount * SizeOf(Pointer));

      if PlanCount > 1 then
          InternalSort(@kdBuffPtr[0], 0, PlanCount - 1, Axis);

      New(Result);
      Result^.Parent := nil;
      Result^.vec := kdBuffPtr^[m];

      KDNodes[NodeCounter] := Result;
      inc(NodeCounter);

      Result^.Left := InternalBuildKdTree(@kdBuffPtr^[0], m, Depth + 1);
      if Result^.Left <> nil then
          Result^.Left^.Parent := Result;

      Result^.Right := InternalBuildKdTree(@kdBuffPtr^[m + 1], PlanCount - (m + 1), Depth + 1);
      if Result^.Right <> nil then
          Result^.Right^.Parent := Result;

      FreeMemory(kdBuffPtr);
    end;
end;

function TKDT8192DI64.GetData(const index: NativeInt): PKDT8192DI64_Source;
begin
  Result := @KDStoreBuff[index];
end;

constructor TKDT8192DI64.Create;
begin
  inherited Create;
  NodeCounter := 0;
  RootNode := nil;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  Clear;
end;

destructor TKDT8192DI64.Destroy;
begin
  Clear;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);
  inherited Destroy;
end;

procedure TKDT8192DI64.Clear;
var
  i: NativeInt;
begin
  i := 0;
  while i < length(KDNodes) do
    begin
      Dispose(PKDT8192DI64_Node(KDNodes[i]));
      inc(i);
    end;
  SetLength(KDNodes, 0);
  SetLength(KDStoreBuff, 0);
  SetLength(KDBuff, 0);

  NodeCounter := 0;
  RootNode := nil;
end;

function TKDT8192DI64.StoreBuffPtr: PKDT8192DI64yanmicStoreBuffer;
begin
  Result := @KDStoreBuff;
end;

procedure TKDT8192DI64.BuildKDTreeC(const PlanCount: NativeInt; const OnTrigger: TKDT8192DI64_BuildCall);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

procedure TKDT8192DI64.BuildKDTreeM(const PlanCount: NativeInt; const OnTrigger: TKDT8192DI64_BuildMethod);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;

{$IFNDEF FPC}


procedure TKDT8192DI64.BuildKDTreeP(const PlanCount: NativeInt; const OnTrigger: TKDT8192DI64_BuildProc);
var
  i, j         : NativeInt;
  TempStoreBuff: TKDT8192DI64yanmicStoreBuffer;
begin
  Clear;

  if PlanCount <= 0 then
      Exit;

  SetLength(KDStoreBuff, PlanCount);
  SetLength(KDBuff, PlanCount);
  SetLength(KDNodes, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      KDStoreBuff[i].index := i;
      FillPtrByte(@KDStoreBuff[i].Buff[0], SizeOf(TKDT8192DI64_Vec), 0);
      OnTrigger(i, KDStoreBuff[i]);
      inc(i);
    end;

  j := PlanCount;

  RootNode := InternalBuildKdTree(@KDBuff[0], j, 0);
end;
{$ENDIF}


{ k-means++ clusterization }
procedure TKDT8192DI64.BuildKDTreeWithCluster(const inBuff: TKDT8192DI64_DynamicVecBuffer; const k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray);
var
  Source: TKMFloat2DArray;
  KArray: TKMFloat2DArray;
  i, j  : NativeInt;
begin
  SetLength(Source, length(inBuff), KDT8192DI64_Axis);
  for i := 0 to length(inBuff) - 1 do
    for j := 0 to KDT8192DI64_Axis - 1 do
        Source[i, j] := inBuff[i, j];

  if KMeansCluster(Source, KDT8192DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      SetLength(KArray, 0);
    end;

  SetLength(Source, 0);
end;

procedure TKDT8192DI64.BuildKDTreeWithCluster(const inBuff: TKDT8192DI64_DynamicVecBuffer; const k, Restarts: NativeInt);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithCluster(inBuff, k, Restarts, OutIndex);
  SetLength(OutIndex, 0);
end;

procedure TKDT8192DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DI64_BuildCall);
var
  TempStoreBuff: TKDT8192DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8192DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8192DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8192DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8192DI64.BuildKDTreeWithClusterC(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DI64_BuildCall);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterC(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

procedure TKDT8192DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DI64_BuildMethod);
var
  TempStoreBuff: TKDT8192DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8192DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8192DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8192DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8192DI64.BuildKDTreeWithClusterM(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DI64_BuildMethod);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterM(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$IFNDEF FPC}


procedure TKDT8192DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; var OutIndex: TDynamicIndexArray; const OnTrigger: TKDT8192DI64_BuildProc);
var
  TempStoreBuff: TKDT8192DI64yanmicStoreBuffer;
  Source       : TKMFloat2DArray;
  KArray       : TKMFloat2DArray;
  i, j         : NativeInt;
begin
  Clear;
  SetLength(TempStoreBuff, PlanCount);

  i := 0;
  while i < PlanCount do
    begin
      TempStoreBuff[i].index := i;
      FillPtrByte(@TempStoreBuff[i].Buff[0], SizeOf(TKDT8192DI64_Vec), 0);
      OnTrigger(i, TempStoreBuff[i]);
      inc(i);
    end;

  SetLength(Source, length(TempStoreBuff), KDT8192DI64_Axis);
  for i := 0 to length(TempStoreBuff) - 1 do
    for j := 0 to KDT8192DI64_Axis - 1 do
        Source[i, j] := TempStoreBuff[i].Buff[j];

  if KMeansCluster(Source, KDT8192DI64_Axis, k, umlMax(Restarts, 1), KArray, OutIndex) = 1 then
    begin
      SetLength(KDStoreBuff, k);
      SetLength(KDBuff, k);
      SetLength(KDNodes, k);

      for i := 0 to k - 1 do
        begin
          KDBuff[i] := @KDStoreBuff[i];

          KDStoreBuff[i].index := i;
          for j := 0 to KDT8192DI64_Axis - 1 do
              KDStoreBuff[i].Buff[j] := KArray[j, i];
        end;

      RootNode := InternalBuildKdTree(@KDBuff[0], k, 0);

      for i := 0 to length(OutIndex) - 1 do
          OutIndex[i] := TempStoreBuff[OutIndex[i]].index;

      SetLength(KArray, 0);
    end;

  SetLength(TempStoreBuff, 0);
  SetLength(Source, 0);
end;

procedure TKDT8192DI64.BuildKDTreeWithClusterP(const PlanCount, k, Restarts: NativeInt; const OnTrigger: TKDT8192DI64_BuildProc);
var
  OutIndex: TDynamicIndexArray;
begin
  BuildKDTreeWithClusterP(PlanCount, k, Restarts, OutIndex, OnTrigger);
  SetLength(OutIndex, 0);
end;

{$ENDIF FPC}


function TKDT8192DI64.Search(const Buff: TKDT8192DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt; const NearestNodes: TCoreClassList): PKDT8192DI64_Node;

var
  NearestNeighbour: PKDT8192DI64_Node;

  function FindParentNode(const BuffPtr: PKDT8192DI64_Vec; NodePtr: PKDT8192DI64_Node): PKDT8192DI64_Node;
  var
    Next       : PKDT8192DI64_Node;
    Depth, Axis: NativeInt;
  begin
    Result := nil;
    Depth := 0;
    Next := NodePtr;
    while Next <> nil do
      begin
        Result := Next;
        Axis := Depth mod KDT8192DI64_Axis;
        if BuffPtr^[Axis] > Next^.vec^.Buff[Axis] then
            Next := Next^.Right
        else
            Next := Next^.Left;
        Depth := Depth + 1;
      end;
  end;

  procedure ScanSubtree(const NodePtr: PKDT8192DI64_Node; const BuffPtr: PKDT8192DI64_Vec; const Depth: NativeInt; const NearestNodes: TCoreClassList);
  var
    Dist: Double;
    Axis: NativeInt;
  begin
    if NodePtr = nil then
        Exit;

    inc(SearchedCounter);

    if NearestNodes <> nil then
        NearestNodes.Add(NodePtr);

    Dist := KDT8192DI64Distance(BuffPtr^, NodePtr^.vec^.Buff);
    if Dist < SearchedDistanceMin then
      begin
        SearchedDistanceMin := Dist;
        NearestNeighbour := NodePtr;
      end
    else if (Dist = SearchedDistanceMin) and (NodePtr^.vec^.index < NearestNeighbour^.vec^.index) then
        NearestNeighbour := NodePtr;

    Axis := Depth mod KDT8192DI64_Axis;
    Dist := NodePtr^.vec^.Buff[Axis] - BuffPtr^[Axis];

    if Dist * Dist > SearchedDistanceMin then
      begin
        if NodePtr^.vec^.Buff[Axis] > BuffPtr^[Axis] then
            ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes)
        else
            ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end
    else
      begin
        ScanSubtree(NodePtr^.Left, BuffPtr, Depth + 1, NearestNodes);
        ScanSubtree(NodePtr^.Right, BuffPtr, Depth + 1, NearestNodes);
      end;
  end;

  function SortCompare(const BuffPtr: PKDT8192DI64_Vec; const p1, p2: PKDT8192DI64_Node): ShortInt;
  var
    d1, d2: Double;
  begin
    d1 := KDT8192DI64Distance(BuffPtr^, p1^.vec^.Buff);
    d2 := KDT8192DI64Distance(BuffPtr^, p2^.vec^.Buff);
    if d1 = d2 then
      begin
        if p1^.vec^.index = p2^.vec^.index then
            Result := 0
        else if p1^.vec^.index < p2^.vec^.index then
            Result := -1
        else
            Result := 1;
      end
    else if d1 < d2 then
        Result := -1
    else
        Result := 1;
  end;

  procedure InternalSort(var SortBuffer: TCoreClassPointerList; l, r: NativeInt; const BuffPtr: PKDT8192DI64_Vec);
  var
    i, j: NativeInt;
    p, t: PKDT8192DI64_Node;
  begin
    repeat
      i := l;
      j := r;
      p := SortBuffer[(l + r) shr 1];
      repeat
        while SortCompare(BuffPtr, SortBuffer[i], p) < 0 do
            inc(i);
        while SortCompare(BuffPtr, SortBuffer[j], p) > 0 do
            Dec(j);
        if i <= j then
          begin
            if i <> j then
              begin
                t := SortBuffer[i];
                SortBuffer[i] := SortBuffer[j];
                SortBuffer[j] := t;
              end;
            inc(i);
            Dec(j);
          end;
      until i > j;
      if l < j then
          InternalSort(SortBuffer, l, j, BuffPtr);
      l := i;
    until i >= r;
  end;

var
  Parent: PKDT8192DI64_Node;
begin
  Result := nil;
  SearchedDistanceMin := 0;
  SearchedCounter := 0;
  NearestNeighbour := nil;
  if NearestNodes <> nil then
      NearestNodes.Clear;
  if RootNode = nil then
      Exit;
  if Count = 0 then
      Exit;

  Parent := FindParentNode(@Buff[0], RootNode);
  NearestNeighbour := Parent;

  SearchedDistanceMin := KDT8192DI64Distance(Buff, Parent^.vec^.Buff);

  ScanSubtree(RootNode, @Buff[0], 0, NearestNodes);
  if NearestNeighbour = nil then
      NearestNeighbour := RootNode;
  Result := NearestNeighbour;

  if NearestNodes <> nil then
    begin
      Result := NearestNeighbour;
      if NearestNodes.Count > 1 then
          InternalSort(NearestNodes.ListData^, 0, NearestNodes.Count - 1, @Buff[0]);

      if NearestNodes.Count > 0 then
          Result := PKDT8192DI64_Node(NearestNodes[0]);
    end;
end;

function TKDT8192DI64.Search(const Buff: TKDT8192DI64_Vec; var SearchedDistanceMin: Double; var SearchedCounter: NativeInt): PKDT8192DI64_Node;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter, nil);
end;

function TKDT8192DI64.Search(const Buff: TKDT8192DI64_Vec; var SearchedDistanceMin: Double): PKDT8192DI64_Node;
var
  SearchedCounter: NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

function TKDT8192DI64.Search(const Buff: TKDT8192DI64_Vec): PKDT8192DI64_Node;
var
  SearchedDistanceMin: Double;
  SearchedCounter    : NativeInt;
begin
  Result := Search(Buff, SearchedDistanceMin, SearchedCounter);
end;

procedure TKDT8192DI64.Search(const inBuff: TKDT8192DI64_DynamicVecBuffer; var OutBuff: TKDT8192DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8192DI64_DynamicVecBuffer;
  outBuffPtr : PKDT8192DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8192DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outBuffPtr^[Pass] := p^.vec^.Buff;
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outBuffPtr := @OutBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8192DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outBuffPtr^[Pass] := p^.vec^.Buff;
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8192DI64_Node;
begin
  if length(OutBuff) <> length(OutIndex) then
      Exit;
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutBuff[i] := p^.vec^.Buff;
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8192DI64.Search(const inBuff: TKDT8192DI64_DynamicVecBuffer; var OutIndex: TDynamicIndexArray);

{$IFDEF parallel}
var
  inBuffPtr  : PKDT8192DI64_DynamicVecBuffer;
  outIndexPtr: PDynamicIndexArray;

  {$IFDEF FPC}
  procedure FPC_ParallelFor(Pass: PtrInt; Data: Pointer; Item: TMultiThreadProcItem);
  var
    p: PKDT8192DI64_Node;
  begin
    p := Search(inBuffPtr^[Pass]);
    outIndexPtr^[Pass] := p^.vec^.index;
  end;
{$ENDIF FPC}


begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  inBuffPtr := @inBuff;
  outIndexPtr := @OutIndex;

  MHGlobalHookEnabled := False;
  try
    {$IFDEF FPC}
    ProcThreadPool.DoParallelLocalProc(@FPC_ParallelFor, 0, PtrInt(length(inBuff) - 1));
    {$ELSE FPC}
    TParallel.For(Int64(0), Int64(length(inBuff) - 1),
      procedure(Pass: Int64)
      var
        p: PKDT8192DI64_Node;
      begin
        p := Search(inBuffPtr^[Pass]);
        outIndexPtr^[Pass] := p^.vec^.index;
      end);
    {$ENDIF FPC}
  finally
      MHGlobalHookEnabled := True;
  end;
end;

{$ELSE parallel}


var
  i: NativeInt;
  p: PKDT8192DI64_Node;
begin
  if length(inBuff) <> length(OutIndex) then
      Exit;

  for i := 0 to length(inBuff) - 1 do
    begin
      p := Search(inBuff[i]);
      OutIndex[i] := p^.vec^.index;
    end;
end;
{$ENDIF parallel}


procedure TKDT8192DI64.SaveToStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
begin
  cnt := length(KDStoreBuff);
  st := SaveToken;
  id := KDT8192DI64_Axis;

  stream.Write(st, 4);
  stream.Write(id, 4);

  stream.Write(cnt, 8);
  stream.Write(KDStoreBuff[0], cnt * SizeOf(TKDT8192DI64_Source));
end;

procedure TKDT8192DI64.LoadFromStream(stream: TCoreClassStream);
var
  cnt   : Int64;
  st, id: Integer;
  i     : NativeInt;
begin
  Clear;

  stream.Read(st, 4);
  stream.Read(id, 4);

  if st <> SaveToken then
      RaiseInfo('kdtree token error!');
  if id <> KDT8192DI64_Axis then
      RaiseInfo('kdtree axis error!');

  stream.Read(cnt, 8);

  SetLength(KDStoreBuff, cnt);
  try
      stream.Read(KDStoreBuff[0], cnt * SizeOf(TKDT8192DI64_Source));
  except
    Clear;
    Exit;
  end;

  SetLength(KDBuff, cnt);
  SetLength(KDNodes, cnt);

  i := 0;
  while i < cnt do
    begin
      KDBuff[i] := @KDStoreBuff[i];
      inc(i);
    end;

  RootNode := InternalBuildKdTree(@KDBuff[0], cnt, 0);
end;

procedure TKDT8192DI64.SaveToFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  fs := TCoreClassFileStream.Create(fileName, fmCreate);
  try
      SaveToStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8192DI64.LoadFromFile(fileName: string);
var
  fs: TCoreClassFileStream;
begin
  try
      fs := TCoreClassFileStream.Create(fileName, fmOpenRead or fmShareDenyWrite);
  except
      Exit;
  end;

  try
      LoadFromStream(fs);
  finally
      DisposeObject(fs);
  end;
end;

procedure TKDT8192DI64.PrintNodeTree(const NodePtr: PKDT8192DI64_Node);
  procedure DoPrintNode(prefix: string; const p: PKDT8192DI64_Node);
  begin
    DoStatus('%s +%d (%s) ', [prefix, p^.vec^.index, KDT8192DI64Vec(p^.vec^.Buff)]);
    if p^.Left <> nil then
        DoPrintNode(prefix + ' |-----', p^.Left);
    if p^.Right <> nil then
        DoPrintNode(prefix + ' |-----', p^.Right);
  end;

begin
  DoPrintNode('', NodePtr);
end;

procedure TKDT8192DI64.PrintBuffer;
var
  i: NativeInt;
begin
  for i := 0 to length(KDStoreBuff) - 1 do
      DoStatus('%d: %s ', [KDStoreBuff[i].index, KDT8192DI64Vec(KDStoreBuff[i].Buff)]);
end;

class function TKDT8192DI64.KDT8192DI64Vec(const s: string): TKDT8192DI64_Vec;
var
  t          : TTextParsing;
  SplitOutput: TArrayPascalString;
  i, j       : NativeInt;
begin
  for i := 0 to KDT8192DI64_Axis - 1 do
      Result[i] := 0;

  t := TTextParsing.Create(s, tsText, nil);
  if t.SplitChar(1, ', ', '', SplitOutput) > 0 then
    begin
      j := 0;
      for i := 0 to length(SplitOutput) - 1 do
        if umlGetNumTextType(SplitOutput[i]) <> ntUnknow then
          begin
            Result[j] := umlStrToInt(SplitOutput[i], 0);
            inc(j);
            if j >= KDT8192DI64_Axis then
                break;
          end;
    end;
  DisposeObject(t);
end;

class function TKDT8192DI64.KDT8192DI64Vec(const v: TKDT8192DI64_Vec): string;
var
  i: NativeInt;
begin
  Result := '';
  for i := 0 to KDT8192DI64_Axis - 1 do
    begin
      if i > 0 then
          Result := Result + ',';
      Result := Result + umlIntToStr(v[i]);
    end;
end;

class function TKDT8192DI64.KDT8192DI64Pow(const v: TKDT8192DI64_VecType): Double;
begin
  Result := v * v;
end;

class function TKDT8192DI64.KDT8192DI64Distance(const v1, v2: TKDT8192DI64_Vec): Double;
var
  i: NativeInt;
begin
  Result := 0;
  for i := 0 to KDT8192DI64_Axis - 1 do
      Result := Result + KDT8192DI64Pow(v2[i] - v1[i]);
end;

procedure TKDT8192DI64.Test_BuildM(const IndexFor: NativeInt; var Source: TKDT8192DI64_Source);
begin
  Source.Buff := TestBuff[IndexFor];
end;

class procedure TKDT8192DI64.Test;
var
  TKDT8192DI64_Test    : TKDT8192DI64;
  t              : TTimeTick;
  i, j           : NativeInt;
  TestResultBuff : TKDT8192DI64_DynamicVecBuffer;
  TestResultIndex: TDynamicIndexArray;
  KMeanOutIndex  : TDynamicIndexArray;
  errored        : Boolean;
begin
  errored := False;
  DoStatusNoLn('test %s...', [ClassName]);
  t := GetTimeTick;

  TKDT8192DI64_Test := TKDT8192DI64.Create;

  DoStatusNoLn('...');
  SetLength(TKDT8192DI64_Test.TestBuff, 100);
  for i := 0 to length(TKDT8192DI64_Test.TestBuff) - 1 do
    for j := 0 to KDT8192DI64_Axis - 1 do
        TKDT8192DI64_Test.TestBuff[i][j] := umlRandomRange(-length(TKDT8192DI64_Test.TestBuff), length(TKDT8192DI64_Test.TestBuff));

  DoStatusNoLn('...');
  {$IFDEF FPC}
  TKDT8192DI64_Test.BuildKDTreeM(length(TKDT8192DI64_Test.TestBuff), @TKDT8192DI64_Test.Test_BuildM);
  {$ELSE FPC}
  TKDT8192DI64_Test.BuildKDTreeM(length(TKDT8192DI64_Test.TestBuff), TKDT8192DI64_Test.Test_BuildM);
  {$ENDIF FPC}
  { parallel search test }
  DoStatusNoLn('...');
  SetLength(TestResultBuff, length(TKDT8192DI64_Test.TestBuff));
  SetLength(TestResultIndex, length(TKDT8192DI64_Test.TestBuff));
  TKDT8192DI64_Test.Search(TKDT8192DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if KDT8192DI64Distance(TKDT8192DI64_Test.TestBuff[TestResultIndex[i]], TestResultBuff[TestResultIndex[i]]) <> 0 then
        errored := True;

  DoStatusNoLn('...');
  TKDT8192DI64_Test.Clear;
  { kMean test }
  TKDT8192DI64_Test.BuildKDTreeWithCluster(TKDT8192DI64_Test.TestBuff, 10, 1, KMeanOutIndex);
  { parallel search test }
  TKDT8192DI64_Test.Search(TKDT8192DI64_Test.TestBuff, TestResultBuff, TestResultIndex);

  for i := 0 to length(TestResultIndex) - 1 do
    if TestResultIndex[i] <> KMeanOutIndex[i] then
        errored := True;

  SetLength(TKDT8192DI64_Test.TestBuff, 0);
  SetLength(TestResultBuff, 0);
  SetLength(TestResultIndex, 0);
  SetLength(KMeanOutIndex, 0);
  TKDT8192DI64_Test.Clear;

  if errored then
      DoStatusNoLn('error!')
  else
      DoStatusNoLn('passed ok %dms', [GetTimeTick - t]);
  DoStatusNoLn;

  DisposeObject(TKDT8192DI64_Test);
end;


procedure Test_All;
begin
  TKDT1DI64.Test();
  TKDT2DI64.Test();
  TKDT3DI64.Test();
  TKDT4DI64.Test();
  TKDT5DI64.Test();
  TKDT6DI64.Test();
  TKDT7DI64.Test();
  TKDT8DI64.Test();
  TKDT9DI64.Test();
  TKDT10DI64.Test();
  TKDT11DI64.Test();
  TKDT12DI64.Test();
  TKDT13DI64.Test();
  TKDT14DI64.Test();
  TKDT15DI64.Test();
  TKDT16DI64.Test();
  TKDT17DI64.Test();
  TKDT18DI64.Test();
  TKDT19DI64.Test();
  TKDT20DI64.Test();
  TKDT21DI64.Test();
  TKDT22DI64.Test();
  TKDT23DI64.Test();
  TKDT24DI64.Test();
  TKDT25DI64.Test();
  TKDT26DI64.Test();
  TKDT27DI64.Test();
  TKDT28DI64.Test();
  TKDT29DI64.Test();
  TKDT30DI64.Test();
  TKDT31DI64.Test();
  TKDT32DI64.Test();
  TKDT33DI64.Test();
  TKDT34DI64.Test();
  TKDT35DI64.Test();
  TKDT36DI64.Test();
  TKDT37DI64.Test();
  TKDT38DI64.Test();
  TKDT39DI64.Test();
  TKDT40DI64.Test();
  TKDT41DI64.Test();
  TKDT42DI64.Test();
  TKDT43DI64.Test();
  TKDT44DI64.Test();
  TKDT45DI64.Test();
  TKDT46DI64.Test();
  TKDT47DI64.Test();
  TKDT48DI64.Test();
  TKDT49DI64.Test();
  TKDT50DI64.Test();
  TKDT51DI64.Test();
  TKDT52DI64.Test();
  TKDT53DI64.Test();
  TKDT54DI64.Test();
  TKDT55DI64.Test();
  TKDT56DI64.Test();
  TKDT57DI64.Test();
  TKDT58DI64.Test();
  TKDT59DI64.Test();
  TKDT60DI64.Test();
  TKDT61DI64.Test();
  TKDT62DI64.Test();
  TKDT63DI64.Test();
  TKDT64DI64.Test();
  TKDT72DI64.Test();
  TKDT84DI64.Test();
  TKDT96DI64.Test();
  TKDT128DI64.Test();
  TKDT140DI64.Test();
  TKDT160DI64.Test();
  TKDT196DI64.Test();
  TKDT256DI64.Test();
  TKDT272DI64.Test();
  TKDT288DI64.Test();
  TKDT372DI64.Test();
  TKDT512DI64.Test();
  TKDT576DI64.Test();
  TKDT768DI64.Test();
  TKDT1024DI64.Test();
  TKDT1040DI64.Test();
  TKDT1056DI64.Test();
  TKDT1536DI64.Test();
  TKDT1920DI64.Test();
  TKDT1980DI64.Test();
  TKDT2048DI64.Test();
  TKDT3072DI64.Test();
  TKDT3088DI64.Test();
  TKDT3104DI64.Test();
  TKDT4096DI64.Test();
  TKDT8192DI64.Test();
  DoStatus('All Test Finished');
end;





initialization

finalization

end.

